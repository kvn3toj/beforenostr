import { test, expect } from '@playwright/test';

/**
 * üé• Tests E2E: Flujo Completo de Videos Gamificados
 * 
 * Verifica el ciclo completo:
 * 1. Visualizaci√≥n de videos desde el Backend NestJS
 * 2. Navegaci√≥n a la p√°gina de reproducci√≥n √úPlay
 * 3. Interacci√≥n con preguntas gamificadas (si disponible)
 * 4. Persistencia de respuestas
 */

test.describe('üé¨ Videos Gamificados - Flujo E2E Completo', () => {
  
  test.beforeEach(async ({ page }) => {
    // Ir a la p√°gina principal con mock auth habilitado
    await page.goto('/');
    
    // Verificar que la aplicaci√≥n carga correctamente
    await page.waitForSelector('#root', { timeout: 10000 });
    await expect(page.locator('#root')).toBeVisible();
    
    // Verificar que el usuario mock est√° autenticado
    await expect(page.locator('[data-testid="dev-auth-banner"]')).toBeVisible();
    
    console.log('‚úÖ SuperApp cargada con mock auth');
  });

  test('üîç Parte 2: Verificar visualizaci√≥n de videos desde Backend', async ({ page }) => {
    console.log('üéØ Iniciando verificaci√≥n de videos desde Backend NestJS...');
    
    // Navegar a la p√°gina de √úPlay
    await page.click('a[href="/play"]');
    await page.waitForLoadState('networkidle');
    
    // Verificar que la p√°gina √úPlay se carga
    await expect(page.locator('h1, h2, h3')).toContainText(/√úPlay|Videos|Playlist/i);
    
    // Verificar que hay contenido de videos cargado desde el backend
    const videoElements = page.locator('[data-testid*="video"], .video-item, .video-card');
    await expect(videoElements).toHaveCount({ min: 1 });
    
    console.log('‚úÖ Videos cargados desde Backend NestJS');
    
    // Interceptar llamadas a la API para verificar que se est√°n haciendo
    page.on('response', response => {
      if (response.url().includes('/video-items') && response.status() === 200) {
        console.log('‚úÖ API call successful:', response.url());
      }
    });
    
    // Buscar un video espec√≠fico que sabemos que existe (del seed data)
    const targetVideoTitle = 'Introducci√≥n a la Gamificaci√≥n';
    const videoWithTitle = page.locator(`text=${targetVideoTitle}`).first();
    
    if (await videoWithTitle.isVisible()) {
      console.log(`‚úÖ Video encontrado: "${targetVideoTitle}"`);
      
      // Verificar metadatos del video
      const videoContainer = videoWithTitle.locator('..').locator('..');
      await expect(videoContainer).toContainText(/gamificaci√≥n/i);
      
      console.log('‚úÖ Metadatos del video verificados');
    } else {
      console.log('‚ÑπÔ∏è  Video espec√≠fico no encontrado, verificando contenido general');
      
      // Al menos verificar que hay contenido de video general
      await expect(page.locator('text=/video|play|gamif/i')).toHaveCount({ min: 1 });
    }
  });

  test('üéÆ Parte 3A: Simular interacci√≥n con preguntas (si disponible)', async ({ page }) => {
    console.log('üéØ Iniciando simulaci√≥n de interacci√≥n con preguntas...');
    
    // Navegar a √úPlay
    await page.click('a[href="/play"]');
    await page.waitForLoadState('networkidle');
    
    // Buscar elementos de video interactivos
    const playButtons = page.locator('button[data-testid*="play"], .play-button, [aria-label*="play"]');
    const interactiveElements = page.locator('[data-testid*="interactive"], .question, .quiz');
    
    if (await playButtons.first().isVisible()) {
      console.log('üé¨ Bot√≥n de reproducci√≥n encontrado');
      
      // Intentar hacer clic en un video para reproducir
      await playButtons.first().click();
      await page.waitForTimeout(2000); // Dar tiempo para que cargue
      
      // Buscar elementos de pregunta o interacci√≥n
      if (await interactiveElements.first().isVisible()) {
        console.log('‚úÖ Elementos interactivos encontrados');
        
        // Buscar opciones de respuesta
        const answerOptions = page.locator('button[data-testid*="answer"], .answer-option, input[type="radio"]');
        
        if (await answerOptions.first().isVisible()) {
          console.log('ü§î Opciones de respuesta encontradas, simulando respuesta...');
          
          // Seleccionar la primera opci√≥n
          await answerOptions.first().click();
          
          // Buscar bot√≥n de enviar respuesta
          const submitButton = page.locator('button:has-text("Enviar"), button:has-text("Responder"), [data-testid*="submit"]');
          
          if (await submitButton.isVisible()) {
            await submitButton.click();
            console.log('‚úÖ Respuesta enviada');
            
            // Verificar que hay alg√∫n feedback
            await expect(page.locator('text=/correcto|incorrecto|bien|mal/i')).toBeVisible({ timeout: 5000 });
            console.log('‚úÖ Feedback de respuesta recibido');
          }
        }
      }
    } else {
      console.log('‚ÑπÔ∏è  No se encontraron elementos de video interactivos en esta vista');
      
      // Verificar que al menos la p√°gina carg√≥ contenido relacionado con videos
      await expect(page.locator('text=/video|play|contenido/i')).toHaveCount({ min: 1 });
    }
  });

  test('üìä Parte 3B: Verificar persistencia de datos (llamadas API)', async ({ page }) => {
    console.log('üéØ Verificando persistencia de interacciones...');
    
    let apiCallsDetected = false;
    let responseData: any[] = [];
    
    // Interceptar llamadas a la API relacionadas con interacciones
    page.on('response', async response => {
      const url = response.url();
      
      if (url.includes('/video-items') || 
          url.includes('/interactions') || 
          url.includes('/answers') || 
          url.includes('/progress')) {
        
        apiCallsDetected = true;
        
        try {
          const data = await response.json();
          responseData.push({
            url: url,
            status: response.status(),
            method: response.request().method(),
            data: data
          });
          
          console.log(`‚úÖ API Call intercepted: ${response.request().method()} ${url} - Status: ${response.status()}`);
        } catch (error) {
          console.log(`‚ÑπÔ∏è  API response (non-JSON): ${response.request().method()} ${url} - Status: ${response.status()}`);
        }
      }
    });
    
    // Navegar a √úPlay para disparar llamadas API
    await page.click('a[href="/play"]');
    await page.waitForLoadState('networkidle');
    
    // Esperar un poco m√°s para que se completen las llamadas
    await page.waitForTimeout(3000);
    
    // Verificar que se detectaron llamadas API
    expect(apiCallsDetected).toBe(true);
    console.log('‚úÖ Llamadas API detectadas para datos de video');
    
    // Verificar que las llamadas fueron exitosas
    const successfulCalls = responseData.filter(call => call.status >= 200 && call.status < 300);
    expect(successfulCalls.length).toBeGreaterThan(0);
    
    console.log(`‚úÖ ${successfulCalls.length} llamadas API exitosas detectadas`);
    
    // Log datos para debugging
    responseData.forEach(call => {
      console.log(`üì° ${call.method} ${call.url} - ${call.status}`);
    });
  });

  test('üîÑ Parte 4: Verificar datos de anal√≠ticas (simulado)', async ({ page }) => {
    console.log('üéØ Verificando capacidad de obtener anal√≠ticas...');
    
    // Simular obtenci√≥n de anal√≠ticas haciendo una llamada directa a la API
    // (esto simular√≠a lo que har√≠a el Gamifier Admin)
    
    const analyticsEndpoints = [
      '/video-items',
      '/playlists', 
      '/analytics/videos',
      '/stats/videos'
    ];
    
    for (const endpoint of analyticsEndpoints) {
      try {
        console.log(`üîç Probando endpoint: ${endpoint}`);
        
        const response = await page.request.get(`http://localhost:3002${endpoint}`, {
          headers: {
            'Authorization': 'Bearer mock-jwt-token-for-testing-do-not-use-in-production'
          }
        });
        
        if (response.ok()) {
          const data = await response.json();
          console.log(`‚úÖ Endpoint ${endpoint} disponible - ${response.status()}`);
          
          // Verificar que hay datos
          if (Array.isArray(data) && data.length > 0) {
            console.log(`üìä Datos encontrados: ${data.length} elementos`);
          } else if (data.data && Array.isArray(data.data)) {
            console.log(`üìä Datos encontrados: ${data.data.length} elementos`);
          } else {
            console.log(`üìä Respuesta estructurada recibida`);
          }
        } else {
          console.log(`‚ö†Ô∏è  Endpoint ${endpoint} no disponible - ${response.status()}`);
        }
      } catch (error) {
        console.log(`‚ùå Error en endpoint ${endpoint}:`, error.message);
      }
    }
    
    // Al menos uno de los endpoints debe funcionar
    const basicResponse = await page.request.get('http://localhost:3002/video-items');
    expect(basicResponse.ok()).toBe(true);
    
    console.log('‚úÖ Capacidad de anal√≠ticas verificada');
  });

  test('üèÅ Resumen del Flujo E2E Completo', async ({ page }) => {
    console.log('üéØ Ejecutando resumen del flujo E2E completo...');
    
    const results = {
      backendConnection: false,
      contentVisualization: false,
      userInteraction: false,
      dataPersistence: false,
      analyticsCapability: false
    };
    
    try {
      // 1. Verificar conexi√≥n con backend
      const healthResponse = await page.request.get('http://localhost:3002/health');
      results.backendConnection = healthResponse.ok();
      
      // 2. Verificar visualizaci√≥n de contenido
      await page.goto('/play');
      await page.waitForLoadState('networkidle');
      const contentElements = page.locator('text=/video|play|contenido|gamif/i');
      results.contentVisualization = (await contentElements.count()) > 0;
      
      // 3. Verificar capacidad de interacci√≥n (presencia de elementos)
      const interactiveElements = page.locator('button, input, [data-testid]');
      results.userInteraction = (await interactiveElements.count()) > 0;
      
      // 4. Verificar persistencia de datos (API funcional)
      const apiResponse = await page.request.get('http://localhost:3002/video-items');
      results.dataPersistence = apiResponse.ok();
      
      // 5. Verificar capacidad de anal√≠ticas
      const analyticsResponse = await page.request.get('http://localhost:3002/playlists');
      results.analyticsCapability = analyticsResponse.ok();
      
    } catch (error) {
      console.error('Error en verificaci√≥n:', error);
    }
    
    // Mostrar resultados
    console.log('\nüèÜ RESUMEN FLUJO E2E DE VIDEOS GAMIFICADOS:');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log(`üîå Conexi√≥n Backend:        ${results.backendConnection ? '‚úÖ' : '‚ùå'}`);
    console.log(`üì∫ Visualizaci√≥n Contenido: ${results.contentVisualization ? '‚úÖ' : '‚ùå'}`);
    console.log(`üéÆ Interacci√≥n Usuario:     ${results.userInteraction ? '‚úÖ' : '‚ùå'}`);
    console.log(`üíæ Persistencia Datos:      ${results.dataPersistence ? '‚úÖ' : '‚ùå'}`);
    console.log(`üìä Capacidad Anal√≠ticas:    ${results.analyticsCapability ? '‚úÖ' : '‚ùå'}`);
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    
    // Verificar que al menos los componentes cr√≠ticos funcionan
    expect(results.backendConnection).toBe(true);
    expect(results.dataPersistence).toBe(true);
    
    console.log('üéâ Flujo E2E de videos gamificados verificado exitosamente!');
  });

}); 