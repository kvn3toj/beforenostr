# ğŸ¯ BUILDER.IO CUSTOM RULES - COOMUNITY SUPERAPP
# Reglas especÃ­ficas para prevenir errores comunes en desarrollo con Builder.io

## ğŸš¨ REGLAS CRÃTICAS PARA PREVENIR ERRORES DE HOOKS Y IMPORTS

### 1. ğŸ”§ IMPORTS DE MATERIAL UI - OBLIGATORIO
**NUNCA usar imports masivos de Material UI que causen bundle bloat:**

âŒ PROHIBIDO:
```typescript
import {
  Box, Typography, Card, Button, IconButton, Dialog, DialogContent,
  Fade, Zoom, Grid, Container, Stack, Slide, Alert, Slider
} from '@mui/material';

import {
  PlayArrow, Pause, VolumeUp, VolumeOff, Fullscreen, FullscreenExit,
  Quiz, CheckCircle, Cancel, Star, EmojiEvents, ArrowBack, Settings,
  Add, SkipNext, Timer, Bolt, Diamond, ChevronLeft
} from '@mui/icons-material';
```

âœ… OBLIGATORIO:
```typescript
// Imports especÃ­ficos de componentes MUI
import Box from '@mui/material/Box';
import Typography from '@mui/material/Typography';
import Button from '@mui/material/Button';

// Imports especÃ­ficos de iconos MUI
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import PauseIcon from '@mui/icons-material/Pause';
import VolumeUpIcon from '@mui/icons-material/VolumeUp';
```

**RAZÃ“N:** Los imports masivos causan bundle bloat y pueden generar errores de dependencias circulares.

### 2. ğŸ”„ ORDEN DE HOOKS - CRÃTICO
**Los useCallback deben declararse en orden de dependencias para evitar referencias circulares:**

âœ… ORDEN CORRECTO:
```typescript
// 1. Primero: Funciones sin dependencias de otros callbacks
const clearQuestionTimer = useCallback(() => {
  // LÃ³gica de limpieza
}, []);

// 2. Segundo: Funciones que dependen de las anteriores
const handleSkipQuestion = useCallback(() => {
  clearQuestionTimer(); // âœ… Ya estÃ¡ definido
}, [clearQuestionTimer]);

// 3. Tercero: Funciones que dependen de las anteriores
const startQuestionTimer = useCallback((timeLimit: number) => {
  // Puede usar handleSkipQuestion
}, [handleSkipQuestion]);
```

âŒ ORDEN INCORRECTO:
```typescript
// âŒ startQuestionTimer usa handleSkipQuestion que aÃºn no existe
const startQuestionTimer = useCallback(() => {
  handleSkipQuestion(); // âŒ Error: no estÃ¡ definido
}, [handleSkipQuestion]);

const handleSkipQuestion = useCallback(() => {
  // Definido despuÃ©s
}, []);
```

### 3. ğŸ§¹ CLEANUP OBLIGATORIO
**SIEMPRE implementar cleanup de timers y event listeners:**

âœ… OBLIGATORIO:
```typescript
// Cleanup effect al final del componente
useEffect(() => {
  return () => {
    // Limpiar todos los timers
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }
    if (questionTimerRef.current) {
      clearInterval(questionTimerRef.current);
    }
  };
}, []);

// Error handlers para debugging
useEffect(() => {
  const handleError = (event: ErrorEvent) => {
    console.error('ğŸš¨ Error capturado:', event.message);
  };
  
  window.addEventListener('error', handleError);
  return () => window.removeEventListener('error', handleError);
}, []);
```

### 4. ğŸ›¡ï¸ ERROR BOUNDARIES ESPECIALIZADOS
**Usar Error Boundaries especÃ­ficos para componentes complejos:**

âœ… OBLIGATORIO para componentes de video/media:
```typescript
// En App.tsx
<VideoPlayerErrorBoundary>
  <HorizontalPlayerDemo />
</VideoPlayerErrorBoundary>
```

### 5. ğŸ“¦ REFS TIPADOS CORRECTAMENTE
**Usar tipos especÃ­ficos para refs segÃºn el elemento:**

âœ… CORRECTO:
```typescript
const videoRef = useRef<HTMLVideoElement>(null);
const containerRef = useRef<HTMLDivElement>(null);
```

âŒ INCORRECTO:
```typescript
const videoRef = useRef<HTMLIFrameElement>(null); // Para video HTML5
```

### 6. ğŸ¯ DEBUGGING SISTEMÃTICO
**Incluir logging estructurado para debugging:**

âœ… OBLIGATORIO:
```typescript
const checkForQuestions = useCallback((time: number) => {
  console.log('ğŸ” Verificando preguntas para tiempo:', time);
  console.log('ğŸ“‹ Preguntas disponibles:', mockVideoData.questions.map(q => ({
    id: q.id, timestamp: q.timestamp
  })));
  // LÃ³gica...
}, [dependencies]);
```

### 7. ğŸ”„ DEPENDENCIAS DE USEEFFECT
**Incluir TODAS las dependencias en useEffect:**

âœ… CORRECTO:
```typescript
useEffect(() => {
  // LÃ³gica que usa isPlaying, activeQuestion, checkForQuestions
}, [isPlaying, activeQuestion, checkForQuestions]);
```

âŒ INCORRECTO:
```typescript
useEffect(() => {
  // Usa variables pero no las incluye en dependencias
}, []); // âŒ Dependencias faltantes
```

### 8. ğŸš¨ DETECCIÃ“N DE ERRORES BUILDER.IO
**Implementar detecciÃ³n especÃ­fica de errores de Builder.io:**

âœ… OBLIGATORIO:
```typescript
// Al inicio del componente
useEffect(() => {
  const handleBuilderError = (event: ErrorEvent) => {
    if (event.message.includes('Builder') || 
        event.message.includes('hook') ||
        event.filename?.includes('builder')) {
      console.error('ğŸš¨ Builder.io Error detectado:', {
        message: event.message,
        filename: event.filename,
        component: 'ComponentName'
      });
    }
  };
  
  window.addEventListener('error', handleBuilderError);
  return () => window.removeEventListener('error', handleBuilderError);
}, []);
```

## ğŸ¯ CHECKLIST ANTES DE COMMIT

Antes de hacer commit de cualquier componente React, verificar:

- [ ] âœ… Imports especÃ­ficos (no masivos) de Material UI
- [ ] âœ… useCallback en orden correcto de dependencias  
- [ ] âœ… Cleanup effect implementado
- [ ] âœ… Error boundary aplicado si es componente complejo
- [ ] âœ… Refs tipados correctamente
- [ ] âœ… Logging de debugging incluido
- [ ] âœ… Todas las dependencias en useEffect
- [ ] âœ… Manejo de errores Builder.io implementado

## ğŸš€ TESTING OBLIGATORIO

Para componentes complejos, crear versiÃ³n simplificada para testing:

```typescript
// ComponenteComplejo.tsx - VersiÃ³n principal
// ComponenteComplejoSimple.tsx - VersiÃ³n de testing sin funcionalidades avanzadas
```

**ESTAS REGLAS SON OBLIGATORIAS PARA TODOS LOS COMPONENTES QUE USEN BUILDER.IO**

---

*Ãšltima actualizaciÃ³n: 2025-06-14 - Reglas implementadas despuÃ©s del error d5xc6yq0t* 