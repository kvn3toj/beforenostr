
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Mundo
 * 
 */
export type Mundo = $Result.DefaultSelection<Prisma.$MundoPayload>
/**
 * Model Playlist
 * 
 */
export type Playlist = $Result.DefaultSelection<Prisma.$PlaylistPayload>
/**
 * Model VideoItem
 * 
 */
export type VideoItem = $Result.DefaultSelection<Prisma.$VideoItemPayload>
/**
 * Model Subtitle
 * 
 */
export type Subtitle = $Result.DefaultSelection<Prisma.$SubtitlePayload>
/**
 * Model Question
 * 
 */
export type Question = $Result.DefaultSelection<Prisma.$QuestionPayload>
/**
 * Model AnswerOption
 * 
 */
export type AnswerOption = $Result.DefaultSelection<Prisma.$AnswerOptionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model VideoPermissions
 * 
 */
export type VideoPermissions = $Result.DefaultSelection<Prisma.$VideoPermissionsPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model World
 * 
 */
export type World = $Result.DefaultSelection<Prisma.$WorldPayload>
/**
 * Model Stage
 * 
 */
export type Stage = $Result.DefaultSelection<Prisma.$StagePayload>
/**
 * Model Experience
 * 
 */
export type Experience = $Result.DefaultSelection<Prisma.$ExperiencePayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model GamifiedPlaylist
 * 
 */
export type GamifiedPlaylist = $Result.DefaultSelection<Prisma.$GamifiedPlaylistPayload>
/**
 * Model ActivityQuestion
 * 
 */
export type ActivityQuestion = $Result.DefaultSelection<Prisma.$ActivityQuestionPayload>
/**
 * Model UserAnswer
 * 
 */
export type UserAnswer = $Result.DefaultSelection<Prisma.$UserAnswerPayload>
/**
 * Model Token
 * 
 */
export type Token = $Result.DefaultSelection<Prisma.$TokenPayload>
/**
 * Model Merit
 * 
 */
export type Merit = $Result.DefaultSelection<Prisma.$MeritPayload>
/**
 * Model Wallet
 * 
 */
export type Wallet = $Result.DefaultSelection<Prisma.$WalletPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model UserGroup
 * 
 */
export type UserGroup = $Result.DefaultSelection<Prisma.$UserGroupPayload>
/**
 * Model Publication
 * 
 */
export type Publication = $Result.DefaultSelection<Prisma.$PublicationPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Like
 * 
 */
export type Like = $Result.DefaultSelection<Prisma.$LikePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model InvitationTemplate
 * 
 */
export type InvitationTemplate = $Result.DefaultSelection<Prisma.$InvitationTemplatePayload>
/**
 * Model GiftCard
 * 
 */
export type GiftCard = $Result.DefaultSelection<Prisma.$GiftCardPayload>
/**
 * Model UserInvitation
 * 
 */
export type UserInvitation = $Result.DefaultSelection<Prisma.$UserInvitationPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model Configuration
 * 
 */
export type Configuration = $Result.DefaultSelection<Prisma.$ConfigurationPayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model AnalyticsData
 * 
 */
export type AnalyticsData = $Result.DefaultSelection<Prisma.$AnalyticsDataPayload>
/**
 * Model Ranking
 * 
 */
export type Ranking = $Result.DefaultSelection<Prisma.$RankingPayload>
/**
 * Model Personality
 * 
 */
export type Personality = $Result.DefaultSelection<Prisma.$PersonalityPayload>
/**
 * Model UIComponentTemplate
 * 
 */
export type UIComponentTemplate = $Result.DefaultSelection<Prisma.$UIComponentTemplatePayload>
/**
 * Model ItemType
 * 
 */
export type ItemType = $Result.DefaultSelection<Prisma.$ItemTypePayload>
/**
 * Model ContentItem
 * 
 */
export type ContentItem = $Result.DefaultSelection<Prisma.$ContentItemPayload>
/**
 * Model Challenge
 * 
 */
export type Challenge = $Result.DefaultSelection<Prisma.$ChallengePayload>
/**
 * Model ChallengeReward
 * 
 */
export type ChallengeReward = $Result.DefaultSelection<Prisma.$ChallengeRewardPayload>
/**
 * Model UserChallenge
 * 
 */
export type UserChallenge = $Result.DefaultSelection<Prisma.$UserChallengePayload>
/**
 * Model MarketplaceItem
 * 
 */
export type MarketplaceItem = $Result.DefaultSelection<Prisma.$MarketplaceItemPayload>
/**
 * Model StudyRoom
 * 
 */
export type StudyRoom = $Result.DefaultSelection<Prisma.$StudyRoomPayload>
/**
 * Model StudyRoomParticipant
 * 
 */
export type StudyRoomParticipant = $Result.DefaultSelection<Prisma.$StudyRoomParticipantPayload>
/**
 * Model StudyRoomMessage
 * 
 */
export type StudyRoomMessage = $Result.DefaultSelection<Prisma.$StudyRoomMessagePayload>
/**
 * Model FeedbackReport
 * 
 */
export type FeedbackReport = $Result.DefaultSelection<Prisma.$FeedbackReportPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model MarketplaceMatch
 * 
 */
export type MarketplaceMatch = $Result.DefaultSelection<Prisma.$MarketplaceMatchPayload>
/**
 * Model MatchMessage
 * 
 */
export type MatchMessage = $Result.DefaultSelection<Prisma.$MatchMessagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const MarketplaceItemType: {
  PRODUCT: 'PRODUCT',
  SERVICE: 'SERVICE',
  EXPERIENCE: 'EXPERIENCE',
  SKILL_EXCHANGE: 'SKILL_EXCHANGE',
  DIGITAL_CONTENT: 'DIGITAL_CONTENT'
};

export type MarketplaceItemType = (typeof MarketplaceItemType)[keyof typeof MarketplaceItemType]


export const Currency: {
  LUKAS: 'LUKAS',
  USD: 'USD',
  EUR: 'EUR',
  BTC: 'BTC',
  ETH: 'ETH'
};

export type Currency = (typeof Currency)[keyof typeof Currency]


export const MarketplaceItemStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SOLD: 'SOLD',
  EXPIRED: 'EXPIRED',
  SUSPENDED: 'SUSPENDED'
};

export type MarketplaceItemStatus = (typeof MarketplaceItemStatus)[keyof typeof MarketplaceItemStatus]


export const StudyRoomStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  ENDED: 'ENDED'
};

export type StudyRoomStatus = (typeof StudyRoomStatus)[keyof typeof StudyRoomStatus]


export const FeedbackType: {
  BUG: 'BUG',
  IMPROVEMENT: 'IMPROVEMENT',
  MISSING_FEATURE: 'MISSING_FEATURE',
  PERFORMANCE: 'PERFORMANCE',
  UX_ISSUE: 'UX_ISSUE',
  CODE_ANALYSIS: 'CODE_ANALYSIS'
};

export type FeedbackType = (typeof FeedbackType)[keyof typeof FeedbackType]


export const FeedbackPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type FeedbackPriority = (typeof FeedbackPriority)[keyof typeof FeedbackPriority]


export const FeedbackStatus: {
  SUBMITTED: 'SUBMITTED',
  REVIEWING: 'REVIEWING',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  REJECTED: 'REJECTED',
  DUPLICATE: 'DUPLICATE'
};

export type FeedbackStatus = (typeof FeedbackStatus)[keyof typeof FeedbackStatus]


export const MatchStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

export type MatchStatus = (typeof MatchStatus)[keyof typeof MatchStatus]

}

export type MarketplaceItemType = $Enums.MarketplaceItemType

export const MarketplaceItemType: typeof $Enums.MarketplaceItemType

export type Currency = $Enums.Currency

export const Currency: typeof $Enums.Currency

export type MarketplaceItemStatus = $Enums.MarketplaceItemStatus

export const MarketplaceItemStatus: typeof $Enums.MarketplaceItemStatus

export type StudyRoomStatus = $Enums.StudyRoomStatus

export const StudyRoomStatus: typeof $Enums.StudyRoomStatus

export type FeedbackType = $Enums.FeedbackType

export const FeedbackType: typeof $Enums.FeedbackType

export type FeedbackPriority = $Enums.FeedbackPriority

export const FeedbackPriority: typeof $Enums.FeedbackPriority

export type FeedbackStatus = $Enums.FeedbackStatus

export const FeedbackStatus: typeof $Enums.FeedbackStatus

export type MatchStatus = $Enums.MatchStatus

export const MatchStatus: typeof $Enums.MatchStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Mundos
 * const mundos = await prisma.mundo.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Mundos
   * const mundos = await prisma.mundo.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.mundo`: Exposes CRUD operations for the **Mundo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mundos
    * const mundos = await prisma.mundo.findMany()
    * ```
    */
  get mundo(): Prisma.MundoDelegate<ExtArgs>;

  /**
   * `prisma.playlist`: Exposes CRUD operations for the **Playlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Playlists
    * const playlists = await prisma.playlist.findMany()
    * ```
    */
  get playlist(): Prisma.PlaylistDelegate<ExtArgs>;

  /**
   * `prisma.videoItem`: Exposes CRUD operations for the **VideoItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoItems
    * const videoItems = await prisma.videoItem.findMany()
    * ```
    */
  get videoItem(): Prisma.VideoItemDelegate<ExtArgs>;

  /**
   * `prisma.subtitle`: Exposes CRUD operations for the **Subtitle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subtitles
    * const subtitles = await prisma.subtitle.findMany()
    * ```
    */
  get subtitle(): Prisma.SubtitleDelegate<ExtArgs>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<ExtArgs>;

  /**
   * `prisma.answerOption`: Exposes CRUD operations for the **AnswerOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnswerOptions
    * const answerOptions = await prisma.answerOption.findMany()
    * ```
    */
  get answerOption(): Prisma.AnswerOptionDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs>;

  /**
   * `prisma.videoPermissions`: Exposes CRUD operations for the **VideoPermissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoPermissions
    * const videoPermissions = await prisma.videoPermissions.findMany()
    * ```
    */
  get videoPermissions(): Prisma.VideoPermissionsDelegate<ExtArgs>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs>;

  /**
   * `prisma.world`: Exposes CRUD operations for the **World** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Worlds
    * const worlds = await prisma.world.findMany()
    * ```
    */
  get world(): Prisma.WorldDelegate<ExtArgs>;

  /**
   * `prisma.stage`: Exposes CRUD operations for the **Stage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stages
    * const stages = await prisma.stage.findMany()
    * ```
    */
  get stage(): Prisma.StageDelegate<ExtArgs>;

  /**
   * `prisma.experience`: Exposes CRUD operations for the **Experience** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Experiences
    * const experiences = await prisma.experience.findMany()
    * ```
    */
  get experience(): Prisma.ExperienceDelegate<ExtArgs>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs>;

  /**
   * `prisma.gamifiedPlaylist`: Exposes CRUD operations for the **GamifiedPlaylist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GamifiedPlaylists
    * const gamifiedPlaylists = await prisma.gamifiedPlaylist.findMany()
    * ```
    */
  get gamifiedPlaylist(): Prisma.GamifiedPlaylistDelegate<ExtArgs>;

  /**
   * `prisma.activityQuestion`: Exposes CRUD operations for the **ActivityQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityQuestions
    * const activityQuestions = await prisma.activityQuestion.findMany()
    * ```
    */
  get activityQuestion(): Prisma.ActivityQuestionDelegate<ExtArgs>;

  /**
   * `prisma.userAnswer`: Exposes CRUD operations for the **UserAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAnswers
    * const userAnswers = await prisma.userAnswer.findMany()
    * ```
    */
  get userAnswer(): Prisma.UserAnswerDelegate<ExtArgs>;

  /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<ExtArgs>;

  /**
   * `prisma.merit`: Exposes CRUD operations for the **Merit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Merits
    * const merits = await prisma.merit.findMany()
    * ```
    */
  get merit(): Prisma.MeritDelegate<ExtArgs>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs>;

  /**
   * `prisma.userGroup`: Exposes CRUD operations for the **UserGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserGroups
    * const userGroups = await prisma.userGroup.findMany()
    * ```
    */
  get userGroup(): Prisma.UserGroupDelegate<ExtArgs>;

  /**
   * `prisma.publication`: Exposes CRUD operations for the **Publication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publications
    * const publications = await prisma.publication.findMany()
    * ```
    */
  get publication(): Prisma.PublicationDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.like`: Exposes CRUD operations for the **Like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.like.findMany()
    * ```
    */
  get like(): Prisma.LikeDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.invitationTemplate`: Exposes CRUD operations for the **InvitationTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvitationTemplates
    * const invitationTemplates = await prisma.invitationTemplate.findMany()
    * ```
    */
  get invitationTemplate(): Prisma.InvitationTemplateDelegate<ExtArgs>;

  /**
   * `prisma.giftCard`: Exposes CRUD operations for the **GiftCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GiftCards
    * const giftCards = await prisma.giftCard.findMany()
    * ```
    */
  get giftCard(): Prisma.GiftCardDelegate<ExtArgs>;

  /**
   * `prisma.userInvitation`: Exposes CRUD operations for the **UserInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserInvitations
    * const userInvitations = await prisma.userInvitation.findMany()
    * ```
    */
  get userInvitation(): Prisma.UserInvitationDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.configuration`: Exposes CRUD operations for the **Configuration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configurations
    * const configurations = await prisma.configuration.findMany()
    * ```
    */
  get configuration(): Prisma.ConfigurationDelegate<ExtArgs>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs>;

  /**
   * `prisma.analyticsData`: Exposes CRUD operations for the **AnalyticsData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsData
    * const analyticsData = await prisma.analyticsData.findMany()
    * ```
    */
  get analyticsData(): Prisma.AnalyticsDataDelegate<ExtArgs>;

  /**
   * `prisma.ranking`: Exposes CRUD operations for the **Ranking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rankings
    * const rankings = await prisma.ranking.findMany()
    * ```
    */
  get ranking(): Prisma.RankingDelegate<ExtArgs>;

  /**
   * `prisma.personality`: Exposes CRUD operations for the **Personality** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personalities
    * const personalities = await prisma.personality.findMany()
    * ```
    */
  get personality(): Prisma.PersonalityDelegate<ExtArgs>;

  /**
   * `prisma.uIComponentTemplate`: Exposes CRUD operations for the **UIComponentTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UIComponentTemplates
    * const uIComponentTemplates = await prisma.uIComponentTemplate.findMany()
    * ```
    */
  get uIComponentTemplate(): Prisma.UIComponentTemplateDelegate<ExtArgs>;

  /**
   * `prisma.itemType`: Exposes CRUD operations for the **ItemType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemTypes
    * const itemTypes = await prisma.itemType.findMany()
    * ```
    */
  get itemType(): Prisma.ItemTypeDelegate<ExtArgs>;

  /**
   * `prisma.contentItem`: Exposes CRUD operations for the **ContentItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentItems
    * const contentItems = await prisma.contentItem.findMany()
    * ```
    */
  get contentItem(): Prisma.ContentItemDelegate<ExtArgs>;

  /**
   * `prisma.challenge`: Exposes CRUD operations for the **Challenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Challenges
    * const challenges = await prisma.challenge.findMany()
    * ```
    */
  get challenge(): Prisma.ChallengeDelegate<ExtArgs>;

  /**
   * `prisma.challengeReward`: Exposes CRUD operations for the **ChallengeReward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeRewards
    * const challengeRewards = await prisma.challengeReward.findMany()
    * ```
    */
  get challengeReward(): Prisma.ChallengeRewardDelegate<ExtArgs>;

  /**
   * `prisma.userChallenge`: Exposes CRUD operations for the **UserChallenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserChallenges
    * const userChallenges = await prisma.userChallenge.findMany()
    * ```
    */
  get userChallenge(): Prisma.UserChallengeDelegate<ExtArgs>;

  /**
   * `prisma.marketplaceItem`: Exposes CRUD operations for the **MarketplaceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketplaceItems
    * const marketplaceItems = await prisma.marketplaceItem.findMany()
    * ```
    */
  get marketplaceItem(): Prisma.MarketplaceItemDelegate<ExtArgs>;

  /**
   * `prisma.studyRoom`: Exposes CRUD operations for the **StudyRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudyRooms
    * const studyRooms = await prisma.studyRoom.findMany()
    * ```
    */
  get studyRoom(): Prisma.StudyRoomDelegate<ExtArgs>;

  /**
   * `prisma.studyRoomParticipant`: Exposes CRUD operations for the **StudyRoomParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudyRoomParticipants
    * const studyRoomParticipants = await prisma.studyRoomParticipant.findMany()
    * ```
    */
  get studyRoomParticipant(): Prisma.StudyRoomParticipantDelegate<ExtArgs>;

  /**
   * `prisma.studyRoomMessage`: Exposes CRUD operations for the **StudyRoomMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudyRoomMessages
    * const studyRoomMessages = await prisma.studyRoomMessage.findMany()
    * ```
    */
  get studyRoomMessage(): Prisma.StudyRoomMessageDelegate<ExtArgs>;

  /**
   * `prisma.feedbackReport`: Exposes CRUD operations for the **FeedbackReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedbackReports
    * const feedbackReports = await prisma.feedbackReport.findMany()
    * ```
    */
  get feedbackReport(): Prisma.FeedbackReportDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs>;

  /**
   * `prisma.marketplaceMatch`: Exposes CRUD operations for the **MarketplaceMatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketplaceMatches
    * const marketplaceMatches = await prisma.marketplaceMatch.findMany()
    * ```
    */
  get marketplaceMatch(): Prisma.MarketplaceMatchDelegate<ExtArgs>;

  /**
   * `prisma.matchMessage`: Exposes CRUD operations for the **MatchMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchMessages
    * const matchMessages = await prisma.matchMessage.findMany()
    * ```
    */
  get matchMessage(): Prisma.MatchMessageDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Mundo: 'Mundo',
    Playlist: 'Playlist',
    VideoItem: 'VideoItem',
    Subtitle: 'Subtitle',
    Question: 'Question',
    AnswerOption: 'AnswerOption',
    User: 'User',
    Role: 'Role',
    UserRole: 'UserRole',
    Permission: 'Permission',
    VideoPermissions: 'VideoPermissions',
    RolePermission: 'RolePermission',
    World: 'World',
    Stage: 'Stage',
    Experience: 'Experience',
    Activity: 'Activity',
    GamifiedPlaylist: 'GamifiedPlaylist',
    ActivityQuestion: 'ActivityQuestion',
    UserAnswer: 'UserAnswer',
    Token: 'Token',
    Merit: 'Merit',
    Wallet: 'Wallet',
    Transaction: 'Transaction',
    Group: 'Group',
    UserGroup: 'UserGroup',
    Publication: 'Publication',
    Comment: 'Comment',
    Like: 'Like',
    Notification: 'Notification',
    InvitationTemplate: 'InvitationTemplate',
    GiftCard: 'GiftCard',
    UserInvitation: 'UserInvitation',
    Report: 'Report',
    Configuration: 'Configuration',
    Log: 'Log',
    AnalyticsData: 'AnalyticsData',
    Ranking: 'Ranking',
    Personality: 'Personality',
    UIComponentTemplate: 'UIComponentTemplate',
    ItemType: 'ItemType',
    ContentItem: 'ContentItem',
    Challenge: 'Challenge',
    ChallengeReward: 'ChallengeReward',
    UserChallenge: 'UserChallenge',
    MarketplaceItem: 'MarketplaceItem',
    StudyRoom: 'StudyRoom',
    StudyRoomParticipant: 'StudyRoomParticipant',
    StudyRoomMessage: 'StudyRoomMessage',
    FeedbackReport: 'FeedbackReport',
    Profile: 'Profile',
    Review: 'Review',
    MarketplaceMatch: 'MarketplaceMatch',
    MatchMessage: 'MatchMessage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "mundo" | "playlist" | "videoItem" | "subtitle" | "question" | "answerOption" | "user" | "role" | "userRole" | "permission" | "videoPermissions" | "rolePermission" | "world" | "stage" | "experience" | "activity" | "gamifiedPlaylist" | "activityQuestion" | "userAnswer" | "token" | "merit" | "wallet" | "transaction" | "group" | "userGroup" | "publication" | "comment" | "like" | "notification" | "invitationTemplate" | "giftCard" | "userInvitation" | "report" | "configuration" | "log" | "analyticsData" | "ranking" | "personality" | "uIComponentTemplate" | "itemType" | "contentItem" | "challenge" | "challengeReward" | "userChallenge" | "marketplaceItem" | "studyRoom" | "studyRoomParticipant" | "studyRoomMessage" | "feedbackReport" | "profile" | "review" | "marketplaceMatch" | "matchMessage"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Mundo: {
        payload: Prisma.$MundoPayload<ExtArgs>
        fields: Prisma.MundoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MundoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MundoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MundoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MundoPayload>
          }
          findFirst: {
            args: Prisma.MundoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MundoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MundoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MundoPayload>
          }
          findMany: {
            args: Prisma.MundoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MundoPayload>[]
          }
          create: {
            args: Prisma.MundoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MundoPayload>
          }
          createMany: {
            args: Prisma.MundoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MundoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MundoPayload>[]
          }
          delete: {
            args: Prisma.MundoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MundoPayload>
          }
          update: {
            args: Prisma.MundoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MundoPayload>
          }
          deleteMany: {
            args: Prisma.MundoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MundoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MundoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MundoPayload>
          }
          aggregate: {
            args: Prisma.MundoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMundo>
          }
          groupBy: {
            args: Prisma.MundoGroupByArgs<ExtArgs>
            result: $Utils.Optional<MundoGroupByOutputType>[]
          }
          count: {
            args: Prisma.MundoCountArgs<ExtArgs>
            result: $Utils.Optional<MundoCountAggregateOutputType> | number
          }
        }
      }
      Playlist: {
        payload: Prisma.$PlaylistPayload<ExtArgs>
        fields: Prisma.PlaylistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaylistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaylistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          findFirst: {
            args: Prisma.PlaylistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaylistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          findMany: {
            args: Prisma.PlaylistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>[]
          }
          create: {
            args: Prisma.PlaylistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          createMany: {
            args: Prisma.PlaylistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaylistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>[]
          }
          delete: {
            args: Prisma.PlaylistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          update: {
            args: Prisma.PlaylistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          deleteMany: {
            args: Prisma.PlaylistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaylistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlaylistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          aggregate: {
            args: Prisma.PlaylistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaylist>
          }
          groupBy: {
            args: Prisma.PlaylistGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaylistGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaylistCountArgs<ExtArgs>
            result: $Utils.Optional<PlaylistCountAggregateOutputType> | number
          }
        }
      }
      VideoItem: {
        payload: Prisma.$VideoItemPayload<ExtArgs>
        fields: Prisma.VideoItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoItemPayload>
          }
          findFirst: {
            args: Prisma.VideoItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoItemPayload>
          }
          findMany: {
            args: Prisma.VideoItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoItemPayload>[]
          }
          create: {
            args: Prisma.VideoItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoItemPayload>
          }
          createMany: {
            args: Prisma.VideoItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoItemPayload>[]
          }
          delete: {
            args: Prisma.VideoItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoItemPayload>
          }
          update: {
            args: Prisma.VideoItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoItemPayload>
          }
          deleteMany: {
            args: Prisma.VideoItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VideoItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoItemPayload>
          }
          aggregate: {
            args: Prisma.VideoItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoItem>
          }
          groupBy: {
            args: Prisma.VideoItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoItemCountArgs<ExtArgs>
            result: $Utils.Optional<VideoItemCountAggregateOutputType> | number
          }
        }
      }
      Subtitle: {
        payload: Prisma.$SubtitlePayload<ExtArgs>
        fields: Prisma.SubtitleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubtitleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubtitleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload>
          }
          findFirst: {
            args: Prisma.SubtitleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubtitleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload>
          }
          findMany: {
            args: Prisma.SubtitleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload>[]
          }
          create: {
            args: Prisma.SubtitleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload>
          }
          createMany: {
            args: Prisma.SubtitleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubtitleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload>[]
          }
          delete: {
            args: Prisma.SubtitleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload>
          }
          update: {
            args: Prisma.SubtitleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload>
          }
          deleteMany: {
            args: Prisma.SubtitleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubtitleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubtitleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitlePayload>
          }
          aggregate: {
            args: Prisma.SubtitleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubtitle>
          }
          groupBy: {
            args: Prisma.SubtitleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubtitleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubtitleCountArgs<ExtArgs>
            result: $Utils.Optional<SubtitleCountAggregateOutputType> | number
          }
        }
      }
      Question: {
        payload: Prisma.$QuestionPayload<ExtArgs>
        fields: Prisma.QuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findFirst: {
            args: Prisma.QuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findMany: {
            args: Prisma.QuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          create: {
            args: Prisma.QuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          createMany: {
            args: Prisma.QuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          delete: {
            args: Prisma.QuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          update: {
            args: Prisma.QuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.QuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      AnswerOption: {
        payload: Prisma.$AnswerOptionPayload<ExtArgs>
        fields: Prisma.AnswerOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnswerOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnswerOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload>
          }
          findFirst: {
            args: Prisma.AnswerOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnswerOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload>
          }
          findMany: {
            args: Prisma.AnswerOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload>[]
          }
          create: {
            args: Prisma.AnswerOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload>
          }
          createMany: {
            args: Prisma.AnswerOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnswerOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload>[]
          }
          delete: {
            args: Prisma.AnswerOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload>
          }
          update: {
            args: Prisma.AnswerOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload>
          }
          deleteMany: {
            args: Prisma.AnswerOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnswerOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnswerOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerOptionPayload>
          }
          aggregate: {
            args: Prisma.AnswerOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnswerOption>
          }
          groupBy: {
            args: Prisma.AnswerOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnswerOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnswerOptionCountArgs<ExtArgs>
            result: $Utils.Optional<AnswerOptionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      VideoPermissions: {
        payload: Prisma.$VideoPermissionsPayload<ExtArgs>
        fields: Prisma.VideoPermissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoPermissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPermissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoPermissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPermissionsPayload>
          }
          findFirst: {
            args: Prisma.VideoPermissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPermissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoPermissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPermissionsPayload>
          }
          findMany: {
            args: Prisma.VideoPermissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPermissionsPayload>[]
          }
          create: {
            args: Prisma.VideoPermissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPermissionsPayload>
          }
          createMany: {
            args: Prisma.VideoPermissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoPermissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPermissionsPayload>[]
          }
          delete: {
            args: Prisma.VideoPermissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPermissionsPayload>
          }
          update: {
            args: Prisma.VideoPermissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPermissionsPayload>
          }
          deleteMany: {
            args: Prisma.VideoPermissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoPermissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VideoPermissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPermissionsPayload>
          }
          aggregate: {
            args: Prisma.VideoPermissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoPermissions>
          }
          groupBy: {
            args: Prisma.VideoPermissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoPermissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoPermissionsCountArgs<ExtArgs>
            result: $Utils.Optional<VideoPermissionsCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      World: {
        payload: Prisma.$WorldPayload<ExtArgs>
        fields: Prisma.WorldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldPayload>
          }
          findFirst: {
            args: Prisma.WorldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldPayload>
          }
          findMany: {
            args: Prisma.WorldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldPayload>[]
          }
          create: {
            args: Prisma.WorldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldPayload>
          }
          createMany: {
            args: Prisma.WorldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldPayload>[]
          }
          delete: {
            args: Prisma.WorldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldPayload>
          }
          update: {
            args: Prisma.WorldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldPayload>
          }
          deleteMany: {
            args: Prisma.WorldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorldPayload>
          }
          aggregate: {
            args: Prisma.WorldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorld>
          }
          groupBy: {
            args: Prisma.WorldGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorldGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorldCountArgs<ExtArgs>
            result: $Utils.Optional<WorldCountAggregateOutputType> | number
          }
        }
      }
      Stage: {
        payload: Prisma.$StagePayload<ExtArgs>
        fields: Prisma.StageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          findFirst: {
            args: Prisma.StageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          findMany: {
            args: Prisma.StageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>[]
          }
          create: {
            args: Prisma.StageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          createMany: {
            args: Prisma.StageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>[]
          }
          delete: {
            args: Prisma.StageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          update: {
            args: Prisma.StageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          deleteMany: {
            args: Prisma.StageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          aggregate: {
            args: Prisma.StageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStage>
          }
          groupBy: {
            args: Prisma.StageGroupByArgs<ExtArgs>
            result: $Utils.Optional<StageGroupByOutputType>[]
          }
          count: {
            args: Prisma.StageCountArgs<ExtArgs>
            result: $Utils.Optional<StageCountAggregateOutputType> | number
          }
        }
      }
      Experience: {
        payload: Prisma.$ExperiencePayload<ExtArgs>
        fields: Prisma.ExperienceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExperienceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExperienceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          findFirst: {
            args: Prisma.ExperienceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExperienceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          findMany: {
            args: Prisma.ExperienceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>[]
          }
          create: {
            args: Prisma.ExperienceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          createMany: {
            args: Prisma.ExperienceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExperienceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>[]
          }
          delete: {
            args: Prisma.ExperienceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          update: {
            args: Prisma.ExperienceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          deleteMany: {
            args: Prisma.ExperienceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExperienceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExperienceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          aggregate: {
            args: Prisma.ExperienceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExperience>
          }
          groupBy: {
            args: Prisma.ExperienceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExperienceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExperienceCountArgs<ExtArgs>
            result: $Utils.Optional<ExperienceCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      GamifiedPlaylist: {
        payload: Prisma.$GamifiedPlaylistPayload<ExtArgs>
        fields: Prisma.GamifiedPlaylistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GamifiedPlaylistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamifiedPlaylistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GamifiedPlaylistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamifiedPlaylistPayload>
          }
          findFirst: {
            args: Prisma.GamifiedPlaylistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamifiedPlaylistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GamifiedPlaylistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamifiedPlaylistPayload>
          }
          findMany: {
            args: Prisma.GamifiedPlaylistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamifiedPlaylistPayload>[]
          }
          create: {
            args: Prisma.GamifiedPlaylistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamifiedPlaylistPayload>
          }
          createMany: {
            args: Prisma.GamifiedPlaylistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GamifiedPlaylistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamifiedPlaylistPayload>[]
          }
          delete: {
            args: Prisma.GamifiedPlaylistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamifiedPlaylistPayload>
          }
          update: {
            args: Prisma.GamifiedPlaylistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamifiedPlaylistPayload>
          }
          deleteMany: {
            args: Prisma.GamifiedPlaylistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GamifiedPlaylistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GamifiedPlaylistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamifiedPlaylistPayload>
          }
          aggregate: {
            args: Prisma.GamifiedPlaylistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGamifiedPlaylist>
          }
          groupBy: {
            args: Prisma.GamifiedPlaylistGroupByArgs<ExtArgs>
            result: $Utils.Optional<GamifiedPlaylistGroupByOutputType>[]
          }
          count: {
            args: Prisma.GamifiedPlaylistCountArgs<ExtArgs>
            result: $Utils.Optional<GamifiedPlaylistCountAggregateOutputType> | number
          }
        }
      }
      ActivityQuestion: {
        payload: Prisma.$ActivityQuestionPayload<ExtArgs>
        fields: Prisma.ActivityQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityQuestionPayload>
          }
          findFirst: {
            args: Prisma.ActivityQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityQuestionPayload>
          }
          findMany: {
            args: Prisma.ActivityQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityQuestionPayload>[]
          }
          create: {
            args: Prisma.ActivityQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityQuestionPayload>
          }
          createMany: {
            args: Prisma.ActivityQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityQuestionPayload>[]
          }
          delete: {
            args: Prisma.ActivityQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityQuestionPayload>
          }
          update: {
            args: Prisma.ActivityQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityQuestionPayload>
          }
          deleteMany: {
            args: Prisma.ActivityQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityQuestionPayload>
          }
          aggregate: {
            args: Prisma.ActivityQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityQuestion>
          }
          groupBy: {
            args: Prisma.ActivityQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityQuestionCountAggregateOutputType> | number
          }
        }
      }
      UserAnswer: {
        payload: Prisma.$UserAnswerPayload<ExtArgs>
        fields: Prisma.UserAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload>
          }
          findFirst: {
            args: Prisma.UserAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload>
          }
          findMany: {
            args: Prisma.UserAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload>[]
          }
          create: {
            args: Prisma.UserAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload>
          }
          createMany: {
            args: Prisma.UserAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload>[]
          }
          delete: {
            args: Prisma.UserAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload>
          }
          update: {
            args: Prisma.UserAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload>
          }
          deleteMany: {
            args: Prisma.UserAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAnswerPayload>
          }
          aggregate: {
            args: Prisma.UserAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAnswer>
          }
          groupBy: {
            args: Prisma.UserAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<UserAnswerCountAggregateOutputType> | number
          }
        }
      }
      Token: {
        payload: Prisma.$TokenPayload<ExtArgs>
        fields: Prisma.TokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findFirst: {
            args: Prisma.TokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findMany: {
            args: Prisma.TokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          create: {
            args: Prisma.TokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          createMany: {
            args: Prisma.TokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          delete: {
            args: Prisma.TokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          update: {
            args: Prisma.TokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          deleteMany: {
            args: Prisma.TokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          aggregate: {
            args: Prisma.TokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToken>
          }
          groupBy: {
            args: Prisma.TokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenCountArgs<ExtArgs>
            result: $Utils.Optional<TokenCountAggregateOutputType> | number
          }
        }
      }
      Merit: {
        payload: Prisma.$MeritPayload<ExtArgs>
        fields: Prisma.MeritFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeritFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeritPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeritFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeritPayload>
          }
          findFirst: {
            args: Prisma.MeritFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeritPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeritFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeritPayload>
          }
          findMany: {
            args: Prisma.MeritFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeritPayload>[]
          }
          create: {
            args: Prisma.MeritCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeritPayload>
          }
          createMany: {
            args: Prisma.MeritCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeritCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeritPayload>[]
          }
          delete: {
            args: Prisma.MeritDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeritPayload>
          }
          update: {
            args: Prisma.MeritUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeritPayload>
          }
          deleteMany: {
            args: Prisma.MeritDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeritUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MeritUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeritPayload>
          }
          aggregate: {
            args: Prisma.MeritAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMerit>
          }
          groupBy: {
            args: Prisma.MeritGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeritGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeritCountArgs<ExtArgs>
            result: $Utils.Optional<MeritCountAggregateOutputType> | number
          }
        }
      }
      Wallet: {
        payload: Prisma.$WalletPayload<ExtArgs>
        fields: Prisma.WalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findFirst: {
            args: Prisma.WalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findMany: {
            args: Prisma.WalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          create: {
            args: Prisma.WalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          createMany: {
            args: Prisma.WalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          delete: {
            args: Prisma.WalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          update: {
            args: Prisma.WalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          deleteMany: {
            args: Prisma.WalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.WalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      UserGroup: {
        payload: Prisma.$UserGroupPayload<ExtArgs>
        fields: Prisma.UserGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          findFirst: {
            args: Prisma.UserGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          findMany: {
            args: Prisma.UserGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>[]
          }
          create: {
            args: Prisma.UserGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          createMany: {
            args: Prisma.UserGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>[]
          }
          delete: {
            args: Prisma.UserGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          update: {
            args: Prisma.UserGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          deleteMany: {
            args: Prisma.UserGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          aggregate: {
            args: Prisma.UserGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserGroup>
          }
          groupBy: {
            args: Prisma.UserGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserGroupCountArgs<ExtArgs>
            result: $Utils.Optional<UserGroupCountAggregateOutputType> | number
          }
        }
      }
      Publication: {
        payload: Prisma.$PublicationPayload<ExtArgs>
        fields: Prisma.PublicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PublicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PublicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          findFirst: {
            args: Prisma.PublicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PublicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          findMany: {
            args: Prisma.PublicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>[]
          }
          create: {
            args: Prisma.PublicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          createMany: {
            args: Prisma.PublicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PublicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>[]
          }
          delete: {
            args: Prisma.PublicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          update: {
            args: Prisma.PublicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          deleteMany: {
            args: Prisma.PublicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PublicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PublicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          aggregate: {
            args: Prisma.PublicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublication>
          }
          groupBy: {
            args: Prisma.PublicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PublicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PublicationCountArgs<ExtArgs>
            result: $Utils.Optional<PublicationCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Like: {
        payload: Prisma.$LikePayload<ExtArgs>
        fields: Prisma.LikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findFirst: {
            args: Prisma.LikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findMany: {
            args: Prisma.LikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          create: {
            args: Prisma.LikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          createMany: {
            args: Prisma.LikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          delete: {
            args: Prisma.LikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          update: {
            args: Prisma.LikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          deleteMany: {
            args: Prisma.LikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          aggregate: {
            args: Prisma.LikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLike>
          }
          groupBy: {
            args: Prisma.LikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikeCountArgs<ExtArgs>
            result: $Utils.Optional<LikeCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      InvitationTemplate: {
        payload: Prisma.$InvitationTemplatePayload<ExtArgs>
        fields: Prisma.InvitationTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          findFirst: {
            args: Prisma.InvitationTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          findMany: {
            args: Prisma.InvitationTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>[]
          }
          create: {
            args: Prisma.InvitationTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          createMany: {
            args: Prisma.InvitationTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>[]
          }
          delete: {
            args: Prisma.InvitationTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          update: {
            args: Prisma.InvitationTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          deleteMany: {
            args: Prisma.InvitationTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvitationTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationTemplatePayload>
          }
          aggregate: {
            args: Prisma.InvitationTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitationTemplate>
          }
          groupBy: {
            args: Prisma.InvitationTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationTemplateCountAggregateOutputType> | number
          }
        }
      }
      GiftCard: {
        payload: Prisma.$GiftCardPayload<ExtArgs>
        fields: Prisma.GiftCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GiftCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GiftCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload>
          }
          findFirst: {
            args: Prisma.GiftCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GiftCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload>
          }
          findMany: {
            args: Prisma.GiftCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload>[]
          }
          create: {
            args: Prisma.GiftCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload>
          }
          createMany: {
            args: Prisma.GiftCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GiftCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload>[]
          }
          delete: {
            args: Prisma.GiftCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload>
          }
          update: {
            args: Prisma.GiftCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload>
          }
          deleteMany: {
            args: Prisma.GiftCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GiftCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GiftCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftCardPayload>
          }
          aggregate: {
            args: Prisma.GiftCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGiftCard>
          }
          groupBy: {
            args: Prisma.GiftCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<GiftCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.GiftCardCountArgs<ExtArgs>
            result: $Utils.Optional<GiftCardCountAggregateOutputType> | number
          }
        }
      }
      UserInvitation: {
        payload: Prisma.$UserInvitationPayload<ExtArgs>
        fields: Prisma.UserInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          findFirst: {
            args: Prisma.UserInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          findMany: {
            args: Prisma.UserInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>[]
          }
          create: {
            args: Prisma.UserInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          createMany: {
            args: Prisma.UserInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>[]
          }
          delete: {
            args: Prisma.UserInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          update: {
            args: Prisma.UserInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          deleteMany: {
            args: Prisma.UserInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          aggregate: {
            args: Prisma.UserInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserInvitation>
          }
          groupBy: {
            args: Prisma.UserInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<UserInvitationCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      Configuration: {
        payload: Prisma.$ConfigurationPayload<ExtArgs>
        fields: Prisma.ConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          findFirst: {
            args: Prisma.ConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          findMany: {
            args: Prisma.ConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>[]
          }
          create: {
            args: Prisma.ConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          createMany: {
            args: Prisma.ConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfigurationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>[]
          }
          delete: {
            args: Prisma.ConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          update: {
            args: Prisma.ConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.ConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          aggregate: {
            args: Prisma.ConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfiguration>
          }
          groupBy: {
            args: Prisma.ConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigurationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigurationCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsData: {
        payload: Prisma.$AnalyticsDataPayload<ExtArgs>
        fields: Prisma.AnalyticsDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDataPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDataPayload>
          }
          findMany: {
            args: Prisma.AnalyticsDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDataPayload>[]
          }
          create: {
            args: Prisma.AnalyticsDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDataPayload>
          }
          createMany: {
            args: Prisma.AnalyticsDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDataPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDataPayload>
          }
          update: {
            args: Prisma.AnalyticsDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDataPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnalyticsDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDataPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsData>
          }
          groupBy: {
            args: Prisma.AnalyticsDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsDataCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsDataCountAggregateOutputType> | number
          }
        }
      }
      Ranking: {
        payload: Prisma.$RankingPayload<ExtArgs>
        fields: Prisma.RankingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RankingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RankingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankingPayload>
          }
          findFirst: {
            args: Prisma.RankingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RankingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankingPayload>
          }
          findMany: {
            args: Prisma.RankingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankingPayload>[]
          }
          create: {
            args: Prisma.RankingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankingPayload>
          }
          createMany: {
            args: Prisma.RankingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RankingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankingPayload>[]
          }
          delete: {
            args: Prisma.RankingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankingPayload>
          }
          update: {
            args: Prisma.RankingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankingPayload>
          }
          deleteMany: {
            args: Prisma.RankingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RankingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RankingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankingPayload>
          }
          aggregate: {
            args: Prisma.RankingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRanking>
          }
          groupBy: {
            args: Prisma.RankingGroupByArgs<ExtArgs>
            result: $Utils.Optional<RankingGroupByOutputType>[]
          }
          count: {
            args: Prisma.RankingCountArgs<ExtArgs>
            result: $Utils.Optional<RankingCountAggregateOutputType> | number
          }
        }
      }
      Personality: {
        payload: Prisma.$PersonalityPayload<ExtArgs>
        fields: Prisma.PersonalityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonalityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonalityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityPayload>
          }
          findFirst: {
            args: Prisma.PersonalityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonalityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityPayload>
          }
          findMany: {
            args: Prisma.PersonalityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityPayload>[]
          }
          create: {
            args: Prisma.PersonalityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityPayload>
          }
          createMany: {
            args: Prisma.PersonalityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonalityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityPayload>[]
          }
          delete: {
            args: Prisma.PersonalityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityPayload>
          }
          update: {
            args: Prisma.PersonalityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityPayload>
          }
          deleteMany: {
            args: Prisma.PersonalityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonalityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonalityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalityPayload>
          }
          aggregate: {
            args: Prisma.PersonalityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonality>
          }
          groupBy: {
            args: Prisma.PersonalityGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonalityGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonalityCountArgs<ExtArgs>
            result: $Utils.Optional<PersonalityCountAggregateOutputType> | number
          }
        }
      }
      UIComponentTemplate: {
        payload: Prisma.$UIComponentTemplatePayload<ExtArgs>
        fields: Prisma.UIComponentTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UIComponentTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UIComponentTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UIComponentTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UIComponentTemplatePayload>
          }
          findFirst: {
            args: Prisma.UIComponentTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UIComponentTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UIComponentTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UIComponentTemplatePayload>
          }
          findMany: {
            args: Prisma.UIComponentTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UIComponentTemplatePayload>[]
          }
          create: {
            args: Prisma.UIComponentTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UIComponentTemplatePayload>
          }
          createMany: {
            args: Prisma.UIComponentTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UIComponentTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UIComponentTemplatePayload>[]
          }
          delete: {
            args: Prisma.UIComponentTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UIComponentTemplatePayload>
          }
          update: {
            args: Prisma.UIComponentTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UIComponentTemplatePayload>
          }
          deleteMany: {
            args: Prisma.UIComponentTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UIComponentTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UIComponentTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UIComponentTemplatePayload>
          }
          aggregate: {
            args: Prisma.UIComponentTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUIComponentTemplate>
          }
          groupBy: {
            args: Prisma.UIComponentTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<UIComponentTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.UIComponentTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<UIComponentTemplateCountAggregateOutputType> | number
          }
        }
      }
      ItemType: {
        payload: Prisma.$ItemTypePayload<ExtArgs>
        fields: Prisma.ItemTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          findFirst: {
            args: Prisma.ItemTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          findMany: {
            args: Prisma.ItemTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>[]
          }
          create: {
            args: Prisma.ItemTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          createMany: {
            args: Prisma.ItemTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>[]
          }
          delete: {
            args: Prisma.ItemTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          update: {
            args: Prisma.ItemTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          deleteMany: {
            args: Prisma.ItemTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItemTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemTypePayload>
          }
          aggregate: {
            args: Prisma.ItemTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemType>
          }
          groupBy: {
            args: Prisma.ItemTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ItemTypeCountAggregateOutputType> | number
          }
        }
      }
      ContentItem: {
        payload: Prisma.$ContentItemPayload<ExtArgs>
        fields: Prisma.ContentItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>
          }
          findFirst: {
            args: Prisma.ContentItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>
          }
          findMany: {
            args: Prisma.ContentItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>[]
          }
          create: {
            args: Prisma.ContentItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>
          }
          createMany: {
            args: Prisma.ContentItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>[]
          }
          delete: {
            args: Prisma.ContentItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>
          }
          update: {
            args: Prisma.ContentItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>
          }
          deleteMany: {
            args: Prisma.ContentItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContentItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentItemPayload>
          }
          aggregate: {
            args: Prisma.ContentItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentItem>
          }
          groupBy: {
            args: Prisma.ContentItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentItemCountArgs<ExtArgs>
            result: $Utils.Optional<ContentItemCountAggregateOutputType> | number
          }
        }
      }
      Challenge: {
        payload: Prisma.$ChallengePayload<ExtArgs>
        fields: Prisma.ChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findFirst: {
            args: Prisma.ChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findMany: {
            args: Prisma.ChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          create: {
            args: Prisma.ChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          createMany: {
            args: Prisma.ChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          delete: {
            args: Prisma.ChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          update: {
            args: Prisma.ChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          aggregate: {
            args: Prisma.ChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallenge>
          }
          groupBy: {
            args: Prisma.ChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeCountAggregateOutputType> | number
          }
        }
      }
      ChallengeReward: {
        payload: Prisma.$ChallengeRewardPayload<ExtArgs>
        fields: Prisma.ChallengeRewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeRewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeRewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRewardPayload>
          }
          findFirst: {
            args: Prisma.ChallengeRewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeRewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRewardPayload>
          }
          findMany: {
            args: Prisma.ChallengeRewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRewardPayload>[]
          }
          create: {
            args: Prisma.ChallengeRewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRewardPayload>
          }
          createMany: {
            args: Prisma.ChallengeRewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeRewardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRewardPayload>[]
          }
          delete: {
            args: Prisma.ChallengeRewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRewardPayload>
          }
          update: {
            args: Prisma.ChallengeRewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRewardPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeRewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeRewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChallengeRewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRewardPayload>
          }
          aggregate: {
            args: Prisma.ChallengeRewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeReward>
          }
          groupBy: {
            args: Prisma.ChallengeRewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeRewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeRewardCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeRewardCountAggregateOutputType> | number
          }
        }
      }
      UserChallenge: {
        payload: Prisma.$UserChallengePayload<ExtArgs>
        fields: Prisma.UserChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          findFirst: {
            args: Prisma.UserChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          findMany: {
            args: Prisma.UserChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>[]
          }
          create: {
            args: Prisma.UserChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          createMany: {
            args: Prisma.UserChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserChallengeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>[]
          }
          delete: {
            args: Prisma.UserChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          update: {
            args: Prisma.UserChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          deleteMany: {
            args: Prisma.UserChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengePayload>
          }
          aggregate: {
            args: Prisma.UserChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserChallenge>
          }
          groupBy: {
            args: Prisma.UserChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<UserChallengeCountAggregateOutputType> | number
          }
        }
      }
      MarketplaceItem: {
        payload: Prisma.$MarketplaceItemPayload<ExtArgs>
        fields: Prisma.MarketplaceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketplaceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketplaceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          findFirst: {
            args: Prisma.MarketplaceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketplaceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          findMany: {
            args: Prisma.MarketplaceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>[]
          }
          create: {
            args: Prisma.MarketplaceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          createMany: {
            args: Prisma.MarketplaceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketplaceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>[]
          }
          delete: {
            args: Prisma.MarketplaceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          update: {
            args: Prisma.MarketplaceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          deleteMany: {
            args: Prisma.MarketplaceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketplaceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketplaceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceItemPayload>
          }
          aggregate: {
            args: Prisma.MarketplaceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketplaceItem>
          }
          groupBy: {
            args: Prisma.MarketplaceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketplaceItemCountArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceItemCountAggregateOutputType> | number
          }
        }
      }
      StudyRoom: {
        payload: Prisma.$StudyRoomPayload<ExtArgs>
        fields: Prisma.StudyRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudyRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudyRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomPayload>
          }
          findFirst: {
            args: Prisma.StudyRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudyRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomPayload>
          }
          findMany: {
            args: Prisma.StudyRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomPayload>[]
          }
          create: {
            args: Prisma.StudyRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomPayload>
          }
          createMany: {
            args: Prisma.StudyRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudyRoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomPayload>[]
          }
          delete: {
            args: Prisma.StudyRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomPayload>
          }
          update: {
            args: Prisma.StudyRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomPayload>
          }
          deleteMany: {
            args: Prisma.StudyRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudyRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudyRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomPayload>
          }
          aggregate: {
            args: Prisma.StudyRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudyRoom>
          }
          groupBy: {
            args: Prisma.StudyRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudyRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudyRoomCountArgs<ExtArgs>
            result: $Utils.Optional<StudyRoomCountAggregateOutputType> | number
          }
        }
      }
      StudyRoomParticipant: {
        payload: Prisma.$StudyRoomParticipantPayload<ExtArgs>
        fields: Prisma.StudyRoomParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudyRoomParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudyRoomParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomParticipantPayload>
          }
          findFirst: {
            args: Prisma.StudyRoomParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudyRoomParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomParticipantPayload>
          }
          findMany: {
            args: Prisma.StudyRoomParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomParticipantPayload>[]
          }
          create: {
            args: Prisma.StudyRoomParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomParticipantPayload>
          }
          createMany: {
            args: Prisma.StudyRoomParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudyRoomParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomParticipantPayload>[]
          }
          delete: {
            args: Prisma.StudyRoomParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomParticipantPayload>
          }
          update: {
            args: Prisma.StudyRoomParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomParticipantPayload>
          }
          deleteMany: {
            args: Prisma.StudyRoomParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudyRoomParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudyRoomParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomParticipantPayload>
          }
          aggregate: {
            args: Prisma.StudyRoomParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudyRoomParticipant>
          }
          groupBy: {
            args: Prisma.StudyRoomParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudyRoomParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudyRoomParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<StudyRoomParticipantCountAggregateOutputType> | number
          }
        }
      }
      StudyRoomMessage: {
        payload: Prisma.$StudyRoomMessagePayload<ExtArgs>
        fields: Prisma.StudyRoomMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudyRoomMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudyRoomMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomMessagePayload>
          }
          findFirst: {
            args: Prisma.StudyRoomMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudyRoomMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomMessagePayload>
          }
          findMany: {
            args: Prisma.StudyRoomMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomMessagePayload>[]
          }
          create: {
            args: Prisma.StudyRoomMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomMessagePayload>
          }
          createMany: {
            args: Prisma.StudyRoomMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudyRoomMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomMessagePayload>[]
          }
          delete: {
            args: Prisma.StudyRoomMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomMessagePayload>
          }
          update: {
            args: Prisma.StudyRoomMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomMessagePayload>
          }
          deleteMany: {
            args: Prisma.StudyRoomMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudyRoomMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudyRoomMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyRoomMessagePayload>
          }
          aggregate: {
            args: Prisma.StudyRoomMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudyRoomMessage>
          }
          groupBy: {
            args: Prisma.StudyRoomMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudyRoomMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudyRoomMessageCountArgs<ExtArgs>
            result: $Utils.Optional<StudyRoomMessageCountAggregateOutputType> | number
          }
        }
      }
      FeedbackReport: {
        payload: Prisma.$FeedbackReportPayload<ExtArgs>
        fields: Prisma.FeedbackReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload>
          }
          findFirst: {
            args: Prisma.FeedbackReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload>
          }
          findMany: {
            args: Prisma.FeedbackReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload>[]
          }
          create: {
            args: Prisma.FeedbackReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload>
          }
          createMany: {
            args: Prisma.FeedbackReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedbackReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload>[]
          }
          delete: {
            args: Prisma.FeedbackReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload>
          }
          update: {
            args: Prisma.FeedbackReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload>
          }
          aggregate: {
            args: Prisma.FeedbackReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedbackReport>
          }
          groupBy: {
            args: Prisma.FeedbackReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackReportCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackReportCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      MarketplaceMatch: {
        payload: Prisma.$MarketplaceMatchPayload<ExtArgs>
        fields: Prisma.MarketplaceMatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketplaceMatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceMatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketplaceMatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceMatchPayload>
          }
          findFirst: {
            args: Prisma.MarketplaceMatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceMatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketplaceMatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceMatchPayload>
          }
          findMany: {
            args: Prisma.MarketplaceMatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceMatchPayload>[]
          }
          create: {
            args: Prisma.MarketplaceMatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceMatchPayload>
          }
          createMany: {
            args: Prisma.MarketplaceMatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketplaceMatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceMatchPayload>[]
          }
          delete: {
            args: Prisma.MarketplaceMatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceMatchPayload>
          }
          update: {
            args: Prisma.MarketplaceMatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceMatchPayload>
          }
          deleteMany: {
            args: Prisma.MarketplaceMatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketplaceMatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketplaceMatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceMatchPayload>
          }
          aggregate: {
            args: Prisma.MarketplaceMatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketplaceMatch>
          }
          groupBy: {
            args: Prisma.MarketplaceMatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceMatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketplaceMatchCountArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceMatchCountAggregateOutputType> | number
          }
        }
      }
      MatchMessage: {
        payload: Prisma.$MatchMessagePayload<ExtArgs>
        fields: Prisma.MatchMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMessagePayload>
          }
          findFirst: {
            args: Prisma.MatchMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMessagePayload>
          }
          findMany: {
            args: Prisma.MatchMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMessagePayload>[]
          }
          create: {
            args: Prisma.MatchMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMessagePayload>
          }
          createMany: {
            args: Prisma.MatchMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMessagePayload>[]
          }
          delete: {
            args: Prisma.MatchMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMessagePayload>
          }
          update: {
            args: Prisma.MatchMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMessagePayload>
          }
          deleteMany: {
            args: Prisma.MatchMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MatchMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchMessagePayload>
          }
          aggregate: {
            args: Prisma.MatchMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchMessage>
          }
          groupBy: {
            args: Prisma.MatchMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchMessageCountArgs<ExtArgs>
            result: $Utils.Optional<MatchMessageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MundoCountOutputType
   */

  export type MundoCountOutputType = {
    playlists: number
    worlds: number
  }

  export type MundoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlists?: boolean | MundoCountOutputTypeCountPlaylistsArgs
    worlds?: boolean | MundoCountOutputTypeCountWorldsArgs
  }

  // Custom InputTypes
  /**
   * MundoCountOutputType without action
   */
  export type MundoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MundoCountOutputType
     */
    select?: MundoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MundoCountOutputType without action
   */
  export type MundoCountOutputTypeCountPlaylistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistWhereInput
  }

  /**
   * MundoCountOutputType without action
   */
  export type MundoCountOutputTypeCountWorldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorldWhereInput
  }


  /**
   * Count Type PlaylistCountOutputType
   */

  export type PlaylistCountOutputType = {
    contentItems: number
    gamifiedPlaylists: number
    videoItems: number
  }

  export type PlaylistCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentItems?: boolean | PlaylistCountOutputTypeCountContentItemsArgs
    gamifiedPlaylists?: boolean | PlaylistCountOutputTypeCountGamifiedPlaylistsArgs
    videoItems?: boolean | PlaylistCountOutputTypeCountVideoItemsArgs
  }

  // Custom InputTypes
  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistCountOutputType
     */
    select?: PlaylistCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeCountContentItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentItemWhereInput
  }

  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeCountGamifiedPlaylistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GamifiedPlaylistWhereInput
  }

  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeCountVideoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoItemWhereInput
  }


  /**
   * Count Type VideoItemCountOutputType
   */

  export type VideoItemCountOutputType = {
    activities: number
    questions: number
    subtitles: number
    studyRooms: number
  }

  export type VideoItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | VideoItemCountOutputTypeCountActivitiesArgs
    questions?: boolean | VideoItemCountOutputTypeCountQuestionsArgs
    subtitles?: boolean | VideoItemCountOutputTypeCountSubtitlesArgs
    studyRooms?: boolean | VideoItemCountOutputTypeCountStudyRoomsArgs
  }

  // Custom InputTypes
  /**
   * VideoItemCountOutputType without action
   */
  export type VideoItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoItemCountOutputType
     */
    select?: VideoItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideoItemCountOutputType without action
   */
  export type VideoItemCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * VideoItemCountOutputType without action
   */
  export type VideoItemCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }

  /**
   * VideoItemCountOutputType without action
   */
  export type VideoItemCountOutputTypeCountSubtitlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtitleWhereInput
  }

  /**
   * VideoItemCountOutputType without action
   */
  export type VideoItemCountOutputTypeCountStudyRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyRoomWhereInput
  }


  /**
   * Count Type QuestionCountOutputType
   */

  export type QuestionCountOutputType = {
    answerOptions: number
    userAnswers: number
  }

  export type QuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answerOptions?: boolean | QuestionCountOutputTypeCountAnswerOptionsArgs
    userAnswers?: boolean | QuestionCountOutputTypeCountUserAnswersArgs
  }

  // Custom InputTypes
  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     */
    select?: QuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountAnswerOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerOptionWhereInput
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountUserAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAnswerWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdActivities: number
    comments: number
    likes: number
    createdExperiences: number
    invitationsSent: number
    ownedGroups: number
    createdInvitationTemplates: number
    merits: number
    notifications: number
    publications: number
    createdReports: number
    assignedPermissions: number
    tokens: number
    transactionsTo: number
    transactionsFrom: number
    createdTemplates: number
    userAnswers: number
    userChallenges: number
    userGroups: number
    invitationsReceived: number
    assignedRoles: number
    userRoles: number
    hostedStudyRooms: number
    studyRoomParticipants: number
    sentChatMessages: number
    videoPermissions: number
    createdWorlds: number
    marketplaceItems: number
    buyerMatches: number
    sellerMatches: number
    matchMessages: number
    feedbackReports: number
    adminFeedbackResponses: number
    reviews: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdActivities?: boolean | UserCountOutputTypeCountCreatedActivitiesArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    likes?: boolean | UserCountOutputTypeCountLikesArgs
    createdExperiences?: boolean | UserCountOutputTypeCountCreatedExperiencesArgs
    invitationsSent?: boolean | UserCountOutputTypeCountInvitationsSentArgs
    ownedGroups?: boolean | UserCountOutputTypeCountOwnedGroupsArgs
    createdInvitationTemplates?: boolean | UserCountOutputTypeCountCreatedInvitationTemplatesArgs
    merits?: boolean | UserCountOutputTypeCountMeritsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    publications?: boolean | UserCountOutputTypeCountPublicationsArgs
    createdReports?: boolean | UserCountOutputTypeCountCreatedReportsArgs
    assignedPermissions?: boolean | UserCountOutputTypeCountAssignedPermissionsArgs
    tokens?: boolean | UserCountOutputTypeCountTokensArgs
    transactionsTo?: boolean | UserCountOutputTypeCountTransactionsToArgs
    transactionsFrom?: boolean | UserCountOutputTypeCountTransactionsFromArgs
    createdTemplates?: boolean | UserCountOutputTypeCountCreatedTemplatesArgs
    userAnswers?: boolean | UserCountOutputTypeCountUserAnswersArgs
    userChallenges?: boolean | UserCountOutputTypeCountUserChallengesArgs
    userGroups?: boolean | UserCountOutputTypeCountUserGroupsArgs
    invitationsReceived?: boolean | UserCountOutputTypeCountInvitationsReceivedArgs
    assignedRoles?: boolean | UserCountOutputTypeCountAssignedRolesArgs
    userRoles?: boolean | UserCountOutputTypeCountUserRolesArgs
    hostedStudyRooms?: boolean | UserCountOutputTypeCountHostedStudyRoomsArgs
    studyRoomParticipants?: boolean | UserCountOutputTypeCountStudyRoomParticipantsArgs
    sentChatMessages?: boolean | UserCountOutputTypeCountSentChatMessagesArgs
    videoPermissions?: boolean | UserCountOutputTypeCountVideoPermissionsArgs
    createdWorlds?: boolean | UserCountOutputTypeCountCreatedWorldsArgs
    marketplaceItems?: boolean | UserCountOutputTypeCountMarketplaceItemsArgs
    buyerMatches?: boolean | UserCountOutputTypeCountBuyerMatchesArgs
    sellerMatches?: boolean | UserCountOutputTypeCountSellerMatchesArgs
    matchMessages?: boolean | UserCountOutputTypeCountMatchMessagesArgs
    feedbackReports?: boolean | UserCountOutputTypeCountFeedbackReportsArgs
    adminFeedbackResponses?: boolean | UserCountOutputTypeCountAdminFeedbackResponsesArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedExperiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExperienceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GiftCardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedInvitationTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMeritsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeritWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPublicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UIComponentTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAnswerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserChallengeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGroupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHostedStudyRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyRoomWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudyRoomParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyRoomParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentChatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyRoomMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVideoPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoPermissionsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedWorldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorldWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMarketplaceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBuyerMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceMatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSellerMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceMatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMatchMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbackReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminFeedbackResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    rolePermissions: number
    userRoles: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | RoleCountOutputTypeCountRolePermissionsArgs
    userRoles?: boolean | RoleCountOutputTypeCountUserRolesArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    rolePermissions: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | PermissionCountOutputTypeCountRolePermissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type WorldCountOutputType
   */

  export type WorldCountOutputType = {
    stages: number
  }

  export type WorldCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stages?: boolean | WorldCountOutputTypeCountStagesArgs
  }

  // Custom InputTypes
  /**
   * WorldCountOutputType without action
   */
  export type WorldCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorldCountOutputType
     */
    select?: WorldCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorldCountOutputType without action
   */
  export type WorldCountOutputTypeCountStagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageWhereInput
  }


  /**
   * Count Type StageCountOutputType
   */

  export type StageCountOutputType = {
    experiences: number
  }

  export type StageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiences?: boolean | StageCountOutputTypeCountExperiencesArgs
  }

  // Custom InputTypes
  /**
   * StageCountOutputType without action
   */
  export type StageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageCountOutputType
     */
    select?: StageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StageCountOutputType without action
   */
  export type StageCountOutputTypeCountExperiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExperienceWhereInput
  }


  /**
   * Count Type ExperienceCountOutputType
   */

  export type ExperienceCountOutputType = {
    activities: number
  }

  export type ExperienceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | ExperienceCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * ExperienceCountOutputType without action
   */
  export type ExperienceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExperienceCountOutputType
     */
    select?: ExperienceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExperienceCountOutputType without action
   */
  export type ExperienceCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }


  /**
   * Count Type ActivityCountOutputType
   */

  export type ActivityCountOutputType = {
    questions: number
    gamifiedPlaylists: number
  }

  export type ActivityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | ActivityCountOutputTypeCountQuestionsArgs
    gamifiedPlaylists?: boolean | ActivityCountOutputTypeCountGamifiedPlaylistsArgs
  }

  // Custom InputTypes
  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCountOutputType
     */
    select?: ActivityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityQuestionWhereInput
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountGamifiedPlaylistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GamifiedPlaylistWhereInput
  }


  /**
   * Count Type ActivityQuestionCountOutputType
   */

  export type ActivityQuestionCountOutputType = {
    userAnswers: number
  }

  export type ActivityQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAnswers?: boolean | ActivityQuestionCountOutputTypeCountUserAnswersArgs
  }

  // Custom InputTypes
  /**
   * ActivityQuestionCountOutputType without action
   */
  export type ActivityQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityQuestionCountOutputType
     */
    select?: ActivityQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityQuestionCountOutputType without action
   */
  export type ActivityQuestionCountOutputTypeCountUserAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAnswerWhereInput
  }


  /**
   * Count Type WalletCountOutputType
   */

  export type WalletCountOutputType = {
    transactionsTo: number
    transactionsFrom: number
  }

  export type WalletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactionsTo?: boolean | WalletCountOutputTypeCountTransactionsToArgs
    transactionsFrom?: boolean | WalletCountOutputTypeCountTransactionsFromArgs
  }

  // Custom InputTypes
  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletCountOutputType
     */
    select?: WalletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeCountTransactionsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeCountTransactionsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    userGroups: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userGroups?: boolean | GroupCountOutputTypeCountUserGroupsArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountUserGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGroupWhereInput
  }


  /**
   * Count Type PublicationCountOutputType
   */

  export type PublicationCountOutputType = {
    comments: number
    likes: number
  }

  export type PublicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PublicationCountOutputTypeCountCommentsArgs
    likes?: boolean | PublicationCountOutputTypeCountLikesArgs
  }

  // Custom InputTypes
  /**
   * PublicationCountOutputType without action
   */
  export type PublicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationCountOutputType
     */
    select?: PublicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PublicationCountOutputType without action
   */
  export type PublicationCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * PublicationCountOutputType without action
   */
  export type PublicationCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }


  /**
   * Count Type GiftCardCountOutputType
   */

  export type GiftCardCountOutputType = {
    userInvitations: number
  }

  export type GiftCardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userInvitations?: boolean | GiftCardCountOutputTypeCountUserInvitationsArgs
  }

  // Custom InputTypes
  /**
   * GiftCardCountOutputType without action
   */
  export type GiftCardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCardCountOutputType
     */
    select?: GiftCardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GiftCardCountOutputType without action
   */
  export type GiftCardCountOutputTypeCountUserInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInvitationWhereInput
  }


  /**
   * Count Type PersonalityCountOutputType
   */

  export type PersonalityCountOutputType = {
    users: number
  }

  export type PersonalityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | PersonalityCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * PersonalityCountOutputType without action
   */
  export type PersonalityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalityCountOutputType
     */
    select?: PersonalityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersonalityCountOutputType without action
   */
  export type PersonalityCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type ItemTypeCountOutputType
   */

  export type ItemTypeCountOutputType = {
    contentItems: number
  }

  export type ItemTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentItems?: boolean | ItemTypeCountOutputTypeCountContentItemsArgs
  }

  // Custom InputTypes
  /**
   * ItemTypeCountOutputType without action
   */
  export type ItemTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemTypeCountOutputType
     */
    select?: ItemTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemTypeCountOutputType without action
   */
  export type ItemTypeCountOutputTypeCountContentItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentItemWhereInput
  }


  /**
   * Count Type ChallengeCountOutputType
   */

  export type ChallengeCountOutputType = {
    rewards: number
    userChallenges: number
  }

  export type ChallengeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rewards?: boolean | ChallengeCountOutputTypeCountRewardsArgs
    userChallenges?: boolean | ChallengeCountOutputTypeCountUserChallengesArgs
  }

  // Custom InputTypes
  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeCountOutputType
     */
    select?: ChallengeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeRewardWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountUserChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserChallengeWhereInput
  }


  /**
   * Count Type MarketplaceItemCountOutputType
   */

  export type MarketplaceItemCountOutputType = {
    reviews: number
    matches: number
  }

  export type MarketplaceItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | MarketplaceItemCountOutputTypeCountReviewsArgs
    matches?: boolean | MarketplaceItemCountOutputTypeCountMatchesArgs
  }

  // Custom InputTypes
  /**
   * MarketplaceItemCountOutputType without action
   */
  export type MarketplaceItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItemCountOutputType
     */
    select?: MarketplaceItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MarketplaceItemCountOutputType without action
   */
  export type MarketplaceItemCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * MarketplaceItemCountOutputType without action
   */
  export type MarketplaceItemCountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceMatchWhereInput
  }


  /**
   * Count Type StudyRoomCountOutputType
   */

  export type StudyRoomCountOutputType = {
    participants: number
    messages: number
  }

  export type StudyRoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | StudyRoomCountOutputTypeCountParticipantsArgs
    messages?: boolean | StudyRoomCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * StudyRoomCountOutputType without action
   */
  export type StudyRoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomCountOutputType
     */
    select?: StudyRoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudyRoomCountOutputType without action
   */
  export type StudyRoomCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyRoomParticipantWhereInput
  }

  /**
   * StudyRoomCountOutputType without action
   */
  export type StudyRoomCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyRoomMessageWhereInput
  }


  /**
   * Count Type MarketplaceMatchCountOutputType
   */

  export type MarketplaceMatchCountOutputType = {
    messages: number
  }

  export type MarketplaceMatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | MarketplaceMatchCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * MarketplaceMatchCountOutputType without action
   */
  export type MarketplaceMatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceMatchCountOutputType
     */
    select?: MarketplaceMatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MarketplaceMatchCountOutputType without action
   */
  export type MarketplaceMatchCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchMessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Mundo
   */

  export type AggregateMundo = {
    _count: MundoCountAggregateOutputType | null
    _avg: MundoAvgAggregateOutputType | null
    _sum: MundoSumAggregateOutputType | null
    _min: MundoMinAggregateOutputType | null
    _max: MundoMaxAggregateOutputType | null
  }

  export type MundoAvgAggregateOutputType = {
    version: number | null
  }

  export type MundoSumAggregateOutputType = {
    version: number | null
  }

  export type MundoMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    version: number | null
  }

  export type MundoMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    version: number | null
  }

  export type MundoCountAggregateOutputType = {
    id: number
    name: number
    description: number
    imageUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    createdById: number
    version: number
    _all: number
  }


  export type MundoAvgAggregateInputType = {
    version?: true
  }

  export type MundoSumAggregateInputType = {
    version?: true
  }

  export type MundoMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    version?: true
  }

  export type MundoMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    version?: true
  }

  export type MundoCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    version?: true
    _all?: true
  }

  export type MundoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mundo to aggregate.
     */
    where?: MundoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mundos to fetch.
     */
    orderBy?: MundoOrderByWithRelationInput | MundoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MundoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mundos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mundos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mundos
    **/
    _count?: true | MundoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MundoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MundoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MundoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MundoMaxAggregateInputType
  }

  export type GetMundoAggregateType<T extends MundoAggregateArgs> = {
        [P in keyof T & keyof AggregateMundo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMundo[P]>
      : GetScalarType<T[P], AggregateMundo[P]>
  }




  export type MundoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MundoWhereInput
    orderBy?: MundoOrderByWithAggregationInput | MundoOrderByWithAggregationInput[]
    by: MundoScalarFieldEnum[] | MundoScalarFieldEnum
    having?: MundoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MundoCountAggregateInputType | true
    _avg?: MundoAvgAggregateInputType
    _sum?: MundoSumAggregateInputType
    _min?: MundoMinAggregateInputType
    _max?: MundoMaxAggregateInputType
  }

  export type MundoGroupByOutputType = {
    id: string
    name: string
    description: string | null
    imageUrl: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    version: number
    _count: MundoCountAggregateOutputType | null
    _avg: MundoAvgAggregateOutputType | null
    _sum: MundoSumAggregateOutputType | null
    _min: MundoMinAggregateOutputType | null
    _max: MundoMaxAggregateOutputType | null
  }

  type GetMundoGroupByPayload<T extends MundoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MundoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MundoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MundoGroupByOutputType[P]>
            : GetScalarType<T[P], MundoGroupByOutputType[P]>
        }
      >
    >


  export type MundoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    version?: boolean
    playlists?: boolean | Mundo$playlistsArgs<ExtArgs>
    worlds?: boolean | Mundo$worldsArgs<ExtArgs>
    _count?: boolean | MundoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mundo"]>

  export type MundoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    version?: boolean
  }, ExtArgs["result"]["mundo"]>

  export type MundoSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    version?: boolean
  }

  export type MundoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlists?: boolean | Mundo$playlistsArgs<ExtArgs>
    worlds?: boolean | Mundo$worldsArgs<ExtArgs>
    _count?: boolean | MundoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MundoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MundoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mundo"
    objects: {
      playlists: Prisma.$PlaylistPayload<ExtArgs>[]
      worlds: Prisma.$WorldPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      imageUrl: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      createdById: string | null
      version: number
    }, ExtArgs["result"]["mundo"]>
    composites: {}
  }

  type MundoGetPayload<S extends boolean | null | undefined | MundoDefaultArgs> = $Result.GetResult<Prisma.$MundoPayload, S>

  type MundoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MundoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MundoCountAggregateInputType | true
    }

  export interface MundoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mundo'], meta: { name: 'Mundo' } }
    /**
     * Find zero or one Mundo that matches the filter.
     * @param {MundoFindUniqueArgs} args - Arguments to find a Mundo
     * @example
     * // Get one Mundo
     * const mundo = await prisma.mundo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MundoFindUniqueArgs>(args: SelectSubset<T, MundoFindUniqueArgs<ExtArgs>>): Prisma__MundoClient<$Result.GetResult<Prisma.$MundoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mundo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MundoFindUniqueOrThrowArgs} args - Arguments to find a Mundo
     * @example
     * // Get one Mundo
     * const mundo = await prisma.mundo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MundoFindUniqueOrThrowArgs>(args: SelectSubset<T, MundoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MundoClient<$Result.GetResult<Prisma.$MundoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mundo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MundoFindFirstArgs} args - Arguments to find a Mundo
     * @example
     * // Get one Mundo
     * const mundo = await prisma.mundo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MundoFindFirstArgs>(args?: SelectSubset<T, MundoFindFirstArgs<ExtArgs>>): Prisma__MundoClient<$Result.GetResult<Prisma.$MundoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mundo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MundoFindFirstOrThrowArgs} args - Arguments to find a Mundo
     * @example
     * // Get one Mundo
     * const mundo = await prisma.mundo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MundoFindFirstOrThrowArgs>(args?: SelectSubset<T, MundoFindFirstOrThrowArgs<ExtArgs>>): Prisma__MundoClient<$Result.GetResult<Prisma.$MundoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mundos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MundoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mundos
     * const mundos = await prisma.mundo.findMany()
     * 
     * // Get first 10 Mundos
     * const mundos = await prisma.mundo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mundoWithIdOnly = await prisma.mundo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MundoFindManyArgs>(args?: SelectSubset<T, MundoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MundoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mundo.
     * @param {MundoCreateArgs} args - Arguments to create a Mundo.
     * @example
     * // Create one Mundo
     * const Mundo = await prisma.mundo.create({
     *   data: {
     *     // ... data to create a Mundo
     *   }
     * })
     * 
     */
    create<T extends MundoCreateArgs>(args: SelectSubset<T, MundoCreateArgs<ExtArgs>>): Prisma__MundoClient<$Result.GetResult<Prisma.$MundoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mundos.
     * @param {MundoCreateManyArgs} args - Arguments to create many Mundos.
     * @example
     * // Create many Mundos
     * const mundo = await prisma.mundo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MundoCreateManyArgs>(args?: SelectSubset<T, MundoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mundos and returns the data saved in the database.
     * @param {MundoCreateManyAndReturnArgs} args - Arguments to create many Mundos.
     * @example
     * // Create many Mundos
     * const mundo = await prisma.mundo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mundos and only return the `id`
     * const mundoWithIdOnly = await prisma.mundo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MundoCreateManyAndReturnArgs>(args?: SelectSubset<T, MundoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MundoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Mundo.
     * @param {MundoDeleteArgs} args - Arguments to delete one Mundo.
     * @example
     * // Delete one Mundo
     * const Mundo = await prisma.mundo.delete({
     *   where: {
     *     // ... filter to delete one Mundo
     *   }
     * })
     * 
     */
    delete<T extends MundoDeleteArgs>(args: SelectSubset<T, MundoDeleteArgs<ExtArgs>>): Prisma__MundoClient<$Result.GetResult<Prisma.$MundoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mundo.
     * @param {MundoUpdateArgs} args - Arguments to update one Mundo.
     * @example
     * // Update one Mundo
     * const mundo = await prisma.mundo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MundoUpdateArgs>(args: SelectSubset<T, MundoUpdateArgs<ExtArgs>>): Prisma__MundoClient<$Result.GetResult<Prisma.$MundoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mundos.
     * @param {MundoDeleteManyArgs} args - Arguments to filter Mundos to delete.
     * @example
     * // Delete a few Mundos
     * const { count } = await prisma.mundo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MundoDeleteManyArgs>(args?: SelectSubset<T, MundoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mundos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MundoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mundos
     * const mundo = await prisma.mundo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MundoUpdateManyArgs>(args: SelectSubset<T, MundoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mundo.
     * @param {MundoUpsertArgs} args - Arguments to update or create a Mundo.
     * @example
     * // Update or create a Mundo
     * const mundo = await prisma.mundo.upsert({
     *   create: {
     *     // ... data to create a Mundo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mundo we want to update
     *   }
     * })
     */
    upsert<T extends MundoUpsertArgs>(args: SelectSubset<T, MundoUpsertArgs<ExtArgs>>): Prisma__MundoClient<$Result.GetResult<Prisma.$MundoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Mundos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MundoCountArgs} args - Arguments to filter Mundos to count.
     * @example
     * // Count the number of Mundos
     * const count = await prisma.mundo.count({
     *   where: {
     *     // ... the filter for the Mundos we want to count
     *   }
     * })
    **/
    count<T extends MundoCountArgs>(
      args?: Subset<T, MundoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MundoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mundo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MundoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MundoAggregateArgs>(args: Subset<T, MundoAggregateArgs>): Prisma.PrismaPromise<GetMundoAggregateType<T>>

    /**
     * Group by Mundo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MundoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MundoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MundoGroupByArgs['orderBy'] }
        : { orderBy?: MundoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MundoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMundoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mundo model
   */
  readonly fields: MundoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mundo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MundoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playlists<T extends Mundo$playlistsArgs<ExtArgs> = {}>(args?: Subset<T, Mundo$playlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findMany"> | Null>
    worlds<T extends Mundo$worldsArgs<ExtArgs> = {}>(args?: Subset<T, Mundo$worldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorldPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mundo model
   */ 
  interface MundoFieldRefs {
    readonly id: FieldRef<"Mundo", 'String'>
    readonly name: FieldRef<"Mundo", 'String'>
    readonly description: FieldRef<"Mundo", 'String'>
    readonly imageUrl: FieldRef<"Mundo", 'String'>
    readonly isActive: FieldRef<"Mundo", 'Boolean'>
    readonly createdAt: FieldRef<"Mundo", 'DateTime'>
    readonly updatedAt: FieldRef<"Mundo", 'DateTime'>
    readonly createdById: FieldRef<"Mundo", 'String'>
    readonly version: FieldRef<"Mundo", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Mundo findUnique
   */
  export type MundoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mundo
     */
    select?: MundoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MundoInclude<ExtArgs> | null
    /**
     * Filter, which Mundo to fetch.
     */
    where: MundoWhereUniqueInput
  }

  /**
   * Mundo findUniqueOrThrow
   */
  export type MundoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mundo
     */
    select?: MundoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MundoInclude<ExtArgs> | null
    /**
     * Filter, which Mundo to fetch.
     */
    where: MundoWhereUniqueInput
  }

  /**
   * Mundo findFirst
   */
  export type MundoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mundo
     */
    select?: MundoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MundoInclude<ExtArgs> | null
    /**
     * Filter, which Mundo to fetch.
     */
    where?: MundoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mundos to fetch.
     */
    orderBy?: MundoOrderByWithRelationInput | MundoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mundos.
     */
    cursor?: MundoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mundos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mundos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mundos.
     */
    distinct?: MundoScalarFieldEnum | MundoScalarFieldEnum[]
  }

  /**
   * Mundo findFirstOrThrow
   */
  export type MundoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mundo
     */
    select?: MundoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MundoInclude<ExtArgs> | null
    /**
     * Filter, which Mundo to fetch.
     */
    where?: MundoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mundos to fetch.
     */
    orderBy?: MundoOrderByWithRelationInput | MundoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mundos.
     */
    cursor?: MundoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mundos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mundos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mundos.
     */
    distinct?: MundoScalarFieldEnum | MundoScalarFieldEnum[]
  }

  /**
   * Mundo findMany
   */
  export type MundoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mundo
     */
    select?: MundoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MundoInclude<ExtArgs> | null
    /**
     * Filter, which Mundos to fetch.
     */
    where?: MundoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mundos to fetch.
     */
    orderBy?: MundoOrderByWithRelationInput | MundoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mundos.
     */
    cursor?: MundoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mundos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mundos.
     */
    skip?: number
    distinct?: MundoScalarFieldEnum | MundoScalarFieldEnum[]
  }

  /**
   * Mundo create
   */
  export type MundoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mundo
     */
    select?: MundoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MundoInclude<ExtArgs> | null
    /**
     * The data needed to create a Mundo.
     */
    data: XOR<MundoCreateInput, MundoUncheckedCreateInput>
  }

  /**
   * Mundo createMany
   */
  export type MundoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mundos.
     */
    data: MundoCreateManyInput | MundoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mundo createManyAndReturn
   */
  export type MundoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mundo
     */
    select?: MundoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Mundos.
     */
    data: MundoCreateManyInput | MundoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mundo update
   */
  export type MundoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mundo
     */
    select?: MundoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MundoInclude<ExtArgs> | null
    /**
     * The data needed to update a Mundo.
     */
    data: XOR<MundoUpdateInput, MundoUncheckedUpdateInput>
    /**
     * Choose, which Mundo to update.
     */
    where: MundoWhereUniqueInput
  }

  /**
   * Mundo updateMany
   */
  export type MundoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mundos.
     */
    data: XOR<MundoUpdateManyMutationInput, MundoUncheckedUpdateManyInput>
    /**
     * Filter which Mundos to update
     */
    where?: MundoWhereInput
  }

  /**
   * Mundo upsert
   */
  export type MundoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mundo
     */
    select?: MundoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MundoInclude<ExtArgs> | null
    /**
     * The filter to search for the Mundo to update in case it exists.
     */
    where: MundoWhereUniqueInput
    /**
     * In case the Mundo found by the `where` argument doesn't exist, create a new Mundo with this data.
     */
    create: XOR<MundoCreateInput, MundoUncheckedCreateInput>
    /**
     * In case the Mundo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MundoUpdateInput, MundoUncheckedUpdateInput>
  }

  /**
   * Mundo delete
   */
  export type MundoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mundo
     */
    select?: MundoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MundoInclude<ExtArgs> | null
    /**
     * Filter which Mundo to delete.
     */
    where: MundoWhereUniqueInput
  }

  /**
   * Mundo deleteMany
   */
  export type MundoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mundos to delete
     */
    where?: MundoWhereInput
  }

  /**
   * Mundo.playlists
   */
  export type Mundo$playlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    where?: PlaylistWhereInput
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    cursor?: PlaylistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * Mundo.worlds
   */
  export type Mundo$worldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the World
     */
    select?: WorldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorldInclude<ExtArgs> | null
    where?: WorldWhereInput
    orderBy?: WorldOrderByWithRelationInput | WorldOrderByWithRelationInput[]
    cursor?: WorldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorldScalarFieldEnum | WorldScalarFieldEnum[]
  }

  /**
   * Mundo without action
   */
  export type MundoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mundo
     */
    select?: MundoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MundoInclude<ExtArgs> | null
  }


  /**
   * Model Playlist
   */

  export type AggregatePlaylist = {
    _count: PlaylistCountAggregateOutputType | null
    _avg: PlaylistAvgAggregateOutputType | null
    _sum: PlaylistSumAggregateOutputType | null
    _min: PlaylistMinAggregateOutputType | null
    _max: PlaylistMaxAggregateOutputType | null
  }

  export type PlaylistAvgAggregateOutputType = {
    orderInMundo: number | null
    version: number | null
  }

  export type PlaylistSumAggregateOutputType = {
    orderInMundo: number | null
    version: number | null
  }

  export type PlaylistMinAggregateOutputType = {
    id: string | null
    mundoId: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    orderInMundo: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    version: number | null
  }

  export type PlaylistMaxAggregateOutputType = {
    id: string | null
    mundoId: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    orderInMundo: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
    version: number | null
  }

  export type PlaylistCountAggregateOutputType = {
    id: number
    mundoId: number
    name: number
    description: number
    imageUrl: number
    orderInMundo: number
    isActive: number
    createdAt: number
    updatedAt: number
    createdById: number
    version: number
    _all: number
  }


  export type PlaylistAvgAggregateInputType = {
    orderInMundo?: true
    version?: true
  }

  export type PlaylistSumAggregateInputType = {
    orderInMundo?: true
    version?: true
  }

  export type PlaylistMinAggregateInputType = {
    id?: true
    mundoId?: true
    name?: true
    description?: true
    imageUrl?: true
    orderInMundo?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    version?: true
  }

  export type PlaylistMaxAggregateInputType = {
    id?: true
    mundoId?: true
    name?: true
    description?: true
    imageUrl?: true
    orderInMundo?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    version?: true
  }

  export type PlaylistCountAggregateInputType = {
    id?: true
    mundoId?: true
    name?: true
    description?: true
    imageUrl?: true
    orderInMundo?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    version?: true
    _all?: true
  }

  export type PlaylistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Playlist to aggregate.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Playlists
    **/
    _count?: true | PlaylistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaylistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaylistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaylistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaylistMaxAggregateInputType
  }

  export type GetPlaylistAggregateType<T extends PlaylistAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaylist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaylist[P]>
      : GetScalarType<T[P], AggregatePlaylist[P]>
  }




  export type PlaylistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistWhereInput
    orderBy?: PlaylistOrderByWithAggregationInput | PlaylistOrderByWithAggregationInput[]
    by: PlaylistScalarFieldEnum[] | PlaylistScalarFieldEnum
    having?: PlaylistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaylistCountAggregateInputType | true
    _avg?: PlaylistAvgAggregateInputType
    _sum?: PlaylistSumAggregateInputType
    _min?: PlaylistMinAggregateInputType
    _max?: PlaylistMaxAggregateInputType
  }

  export type PlaylistGroupByOutputType = {
    id: string
    mundoId: string
    name: string
    description: string | null
    imageUrl: string | null
    orderInMundo: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    version: number
    _count: PlaylistCountAggregateOutputType | null
    _avg: PlaylistAvgAggregateOutputType | null
    _sum: PlaylistSumAggregateOutputType | null
    _min: PlaylistMinAggregateOutputType | null
    _max: PlaylistMaxAggregateOutputType | null
  }

  type GetPlaylistGroupByPayload<T extends PlaylistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaylistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaylistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaylistGroupByOutputType[P]>
            : GetScalarType<T[P], PlaylistGroupByOutputType[P]>
        }
      >
    >


  export type PlaylistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mundoId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    orderInMundo?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    version?: boolean
    contentItems?: boolean | Playlist$contentItemsArgs<ExtArgs>
    gamifiedPlaylists?: boolean | Playlist$gamifiedPlaylistsArgs<ExtArgs>
    mundo?: boolean | MundoDefaultArgs<ExtArgs>
    videoItems?: boolean | Playlist$videoItemsArgs<ExtArgs>
    _count?: boolean | PlaylistCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playlist"]>

  export type PlaylistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mundoId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    orderInMundo?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    version?: boolean
    mundo?: boolean | MundoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playlist"]>

  export type PlaylistSelectScalar = {
    id?: boolean
    mundoId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    orderInMundo?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    version?: boolean
  }

  export type PlaylistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentItems?: boolean | Playlist$contentItemsArgs<ExtArgs>
    gamifiedPlaylists?: boolean | Playlist$gamifiedPlaylistsArgs<ExtArgs>
    mundo?: boolean | MundoDefaultArgs<ExtArgs>
    videoItems?: boolean | Playlist$videoItemsArgs<ExtArgs>
    _count?: boolean | PlaylistCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlaylistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mundo?: boolean | MundoDefaultArgs<ExtArgs>
  }

  export type $PlaylistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Playlist"
    objects: {
      contentItems: Prisma.$ContentItemPayload<ExtArgs>[]
      gamifiedPlaylists: Prisma.$GamifiedPlaylistPayload<ExtArgs>[]
      mundo: Prisma.$MundoPayload<ExtArgs>
      videoItems: Prisma.$VideoItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mundoId: string
      name: string
      description: string | null
      imageUrl: string | null
      orderInMundo: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      createdById: string | null
      version: number
    }, ExtArgs["result"]["playlist"]>
    composites: {}
  }

  type PlaylistGetPayload<S extends boolean | null | undefined | PlaylistDefaultArgs> = $Result.GetResult<Prisma.$PlaylistPayload, S>

  type PlaylistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlaylistFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlaylistCountAggregateInputType | true
    }

  export interface PlaylistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Playlist'], meta: { name: 'Playlist' } }
    /**
     * Find zero or one Playlist that matches the filter.
     * @param {PlaylistFindUniqueArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaylistFindUniqueArgs>(args: SelectSubset<T, PlaylistFindUniqueArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Playlist that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlaylistFindUniqueOrThrowArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaylistFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaylistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Playlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindFirstArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaylistFindFirstArgs>(args?: SelectSubset<T, PlaylistFindFirstArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Playlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindFirstOrThrowArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaylistFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaylistFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Playlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Playlists
     * const playlists = await prisma.playlist.findMany()
     * 
     * // Get first 10 Playlists
     * const playlists = await prisma.playlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playlistWithIdOnly = await prisma.playlist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaylistFindManyArgs>(args?: SelectSubset<T, PlaylistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Playlist.
     * @param {PlaylistCreateArgs} args - Arguments to create a Playlist.
     * @example
     * // Create one Playlist
     * const Playlist = await prisma.playlist.create({
     *   data: {
     *     // ... data to create a Playlist
     *   }
     * })
     * 
     */
    create<T extends PlaylistCreateArgs>(args: SelectSubset<T, PlaylistCreateArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Playlists.
     * @param {PlaylistCreateManyArgs} args - Arguments to create many Playlists.
     * @example
     * // Create many Playlists
     * const playlist = await prisma.playlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaylistCreateManyArgs>(args?: SelectSubset<T, PlaylistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Playlists and returns the data saved in the database.
     * @param {PlaylistCreateManyAndReturnArgs} args - Arguments to create many Playlists.
     * @example
     * // Create many Playlists
     * const playlist = await prisma.playlist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Playlists and only return the `id`
     * const playlistWithIdOnly = await prisma.playlist.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaylistCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaylistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Playlist.
     * @param {PlaylistDeleteArgs} args - Arguments to delete one Playlist.
     * @example
     * // Delete one Playlist
     * const Playlist = await prisma.playlist.delete({
     *   where: {
     *     // ... filter to delete one Playlist
     *   }
     * })
     * 
     */
    delete<T extends PlaylistDeleteArgs>(args: SelectSubset<T, PlaylistDeleteArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Playlist.
     * @param {PlaylistUpdateArgs} args - Arguments to update one Playlist.
     * @example
     * // Update one Playlist
     * const playlist = await prisma.playlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaylistUpdateArgs>(args: SelectSubset<T, PlaylistUpdateArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Playlists.
     * @param {PlaylistDeleteManyArgs} args - Arguments to filter Playlists to delete.
     * @example
     * // Delete a few Playlists
     * const { count } = await prisma.playlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaylistDeleteManyArgs>(args?: SelectSubset<T, PlaylistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Playlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Playlists
     * const playlist = await prisma.playlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaylistUpdateManyArgs>(args: SelectSubset<T, PlaylistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Playlist.
     * @param {PlaylistUpsertArgs} args - Arguments to update or create a Playlist.
     * @example
     * // Update or create a Playlist
     * const playlist = await prisma.playlist.upsert({
     *   create: {
     *     // ... data to create a Playlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Playlist we want to update
     *   }
     * })
     */
    upsert<T extends PlaylistUpsertArgs>(args: SelectSubset<T, PlaylistUpsertArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Playlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistCountArgs} args - Arguments to filter Playlists to count.
     * @example
     * // Count the number of Playlists
     * const count = await prisma.playlist.count({
     *   where: {
     *     // ... the filter for the Playlists we want to count
     *   }
     * })
    **/
    count<T extends PlaylistCountArgs>(
      args?: Subset<T, PlaylistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaylistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Playlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaylistAggregateArgs>(args: Subset<T, PlaylistAggregateArgs>): Prisma.PrismaPromise<GetPlaylistAggregateType<T>>

    /**
     * Group by Playlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaylistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaylistGroupByArgs['orderBy'] }
        : { orderBy?: PlaylistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaylistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaylistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Playlist model
   */
  readonly fields: PlaylistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Playlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaylistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contentItems<T extends Playlist$contentItemsArgs<ExtArgs> = {}>(args?: Subset<T, Playlist$contentItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findMany"> | Null>
    gamifiedPlaylists<T extends Playlist$gamifiedPlaylistsArgs<ExtArgs> = {}>(args?: Subset<T, Playlist$gamifiedPlaylistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamifiedPlaylistPayload<ExtArgs>, T, "findMany"> | Null>
    mundo<T extends MundoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MundoDefaultArgs<ExtArgs>>): Prisma__MundoClient<$Result.GetResult<Prisma.$MundoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    videoItems<T extends Playlist$videoItemsArgs<ExtArgs> = {}>(args?: Subset<T, Playlist$videoItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Playlist model
   */ 
  interface PlaylistFieldRefs {
    readonly id: FieldRef<"Playlist", 'String'>
    readonly mundoId: FieldRef<"Playlist", 'String'>
    readonly name: FieldRef<"Playlist", 'String'>
    readonly description: FieldRef<"Playlist", 'String'>
    readonly imageUrl: FieldRef<"Playlist", 'String'>
    readonly orderInMundo: FieldRef<"Playlist", 'Int'>
    readonly isActive: FieldRef<"Playlist", 'Boolean'>
    readonly createdAt: FieldRef<"Playlist", 'DateTime'>
    readonly updatedAt: FieldRef<"Playlist", 'DateTime'>
    readonly createdById: FieldRef<"Playlist", 'String'>
    readonly version: FieldRef<"Playlist", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Playlist findUnique
   */
  export type PlaylistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist findUniqueOrThrow
   */
  export type PlaylistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist findFirst
   */
  export type PlaylistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Playlists.
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Playlists.
     */
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * Playlist findFirstOrThrow
   */
  export type PlaylistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Playlists.
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Playlists.
     */
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * Playlist findMany
   */
  export type PlaylistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlists to fetch.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Playlists.
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * Playlist create
   */
  export type PlaylistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The data needed to create a Playlist.
     */
    data: XOR<PlaylistCreateInput, PlaylistUncheckedCreateInput>
  }

  /**
   * Playlist createMany
   */
  export type PlaylistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Playlists.
     */
    data: PlaylistCreateManyInput | PlaylistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Playlist createManyAndReturn
   */
  export type PlaylistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Playlists.
     */
    data: PlaylistCreateManyInput | PlaylistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Playlist update
   */
  export type PlaylistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The data needed to update a Playlist.
     */
    data: XOR<PlaylistUpdateInput, PlaylistUncheckedUpdateInput>
    /**
     * Choose, which Playlist to update.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist updateMany
   */
  export type PlaylistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Playlists.
     */
    data: XOR<PlaylistUpdateManyMutationInput, PlaylistUncheckedUpdateManyInput>
    /**
     * Filter which Playlists to update
     */
    where?: PlaylistWhereInput
  }

  /**
   * Playlist upsert
   */
  export type PlaylistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The filter to search for the Playlist to update in case it exists.
     */
    where: PlaylistWhereUniqueInput
    /**
     * In case the Playlist found by the `where` argument doesn't exist, create a new Playlist with this data.
     */
    create: XOR<PlaylistCreateInput, PlaylistUncheckedCreateInput>
    /**
     * In case the Playlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaylistUpdateInput, PlaylistUncheckedUpdateInput>
  }

  /**
   * Playlist delete
   */
  export type PlaylistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter which Playlist to delete.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist deleteMany
   */
  export type PlaylistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Playlists to delete
     */
    where?: PlaylistWhereInput
  }

  /**
   * Playlist.contentItems
   */
  export type Playlist$contentItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    where?: ContentItemWhereInput
    orderBy?: ContentItemOrderByWithRelationInput | ContentItemOrderByWithRelationInput[]
    cursor?: ContentItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentItemScalarFieldEnum | ContentItemScalarFieldEnum[]
  }

  /**
   * Playlist.gamifiedPlaylists
   */
  export type Playlist$gamifiedPlaylistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamifiedPlaylist
     */
    select?: GamifiedPlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamifiedPlaylistInclude<ExtArgs> | null
    where?: GamifiedPlaylistWhereInput
    orderBy?: GamifiedPlaylistOrderByWithRelationInput | GamifiedPlaylistOrderByWithRelationInput[]
    cursor?: GamifiedPlaylistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamifiedPlaylistScalarFieldEnum | GamifiedPlaylistScalarFieldEnum[]
  }

  /**
   * Playlist.videoItems
   */
  export type Playlist$videoItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoItem
     */
    select?: VideoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoItemInclude<ExtArgs> | null
    where?: VideoItemWhereInput
    orderBy?: VideoItemOrderByWithRelationInput | VideoItemOrderByWithRelationInput[]
    cursor?: VideoItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoItemScalarFieldEnum | VideoItemScalarFieldEnum[]
  }

  /**
   * Playlist without action
   */
  export type PlaylistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
  }


  /**
   * Model VideoItem
   */

  export type AggregateVideoItem = {
    _count: VideoItemCountAggregateOutputType | null
    _avg: VideoItemAvgAggregateOutputType | null
    _sum: VideoItemSumAggregateOutputType | null
    _min: VideoItemMinAggregateOutputType | null
    _max: VideoItemMaxAggregateOutputType | null
  }

  export type VideoItemAvgAggregateOutputType = {
    id: number | null
    order: number | null
    duration: number | null
  }

  export type VideoItemSumAggregateOutputType = {
    id: number | null
    order: number | null
    duration: number | null
  }

  export type VideoItemMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    content: string | null
    url: string | null
    platform: string | null
    externalId: string | null
    playlistId: string | null
    itemTypeId: string | null
    order: number | null
    isActive: boolean | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    duration: number | null
    categories: string | null
    language: string | null
    quality: string | null
    tags: string | null
    thumbnailUrl: string | null
  }

  export type VideoItemMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    content: string | null
    url: string | null
    platform: string | null
    externalId: string | null
    playlistId: string | null
    itemTypeId: string | null
    order: number | null
    isActive: boolean | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    duration: number | null
    categories: string | null
    language: string | null
    quality: string | null
    tags: string | null
    thumbnailUrl: string | null
  }

  export type VideoItemCountAggregateOutputType = {
    id: number
    title: number
    description: number
    content: number
    url: number
    platform: number
    externalId: number
    playlistId: number
    itemTypeId: number
    order: number
    isActive: number
    isDeleted: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    duration: number
    categories: number
    language: number
    quality: number
    tags: number
    thumbnailUrl: number
    _all: number
  }


  export type VideoItemAvgAggregateInputType = {
    id?: true
    order?: true
    duration?: true
  }

  export type VideoItemSumAggregateInputType = {
    id?: true
    order?: true
    duration?: true
  }

  export type VideoItemMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    url?: true
    platform?: true
    externalId?: true
    playlistId?: true
    itemTypeId?: true
    order?: true
    isActive?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    duration?: true
    categories?: true
    language?: true
    quality?: true
    tags?: true
    thumbnailUrl?: true
  }

  export type VideoItemMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    url?: true
    platform?: true
    externalId?: true
    playlistId?: true
    itemTypeId?: true
    order?: true
    isActive?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    duration?: true
    categories?: true
    language?: true
    quality?: true
    tags?: true
    thumbnailUrl?: true
  }

  export type VideoItemCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    url?: true
    platform?: true
    externalId?: true
    playlistId?: true
    itemTypeId?: true
    order?: true
    isActive?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    duration?: true
    categories?: true
    language?: true
    quality?: true
    tags?: true
    thumbnailUrl?: true
    _all?: true
  }

  export type VideoItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoItem to aggregate.
     */
    where?: VideoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoItems to fetch.
     */
    orderBy?: VideoItemOrderByWithRelationInput | VideoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoItems
    **/
    _count?: true | VideoItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoItemMaxAggregateInputType
  }

  export type GetVideoItemAggregateType<T extends VideoItemAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoItem[P]>
      : GetScalarType<T[P], AggregateVideoItem[P]>
  }




  export type VideoItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoItemWhereInput
    orderBy?: VideoItemOrderByWithAggregationInput | VideoItemOrderByWithAggregationInput[]
    by: VideoItemScalarFieldEnum[] | VideoItemScalarFieldEnum
    having?: VideoItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoItemCountAggregateInputType | true
    _avg?: VideoItemAvgAggregateInputType
    _sum?: VideoItemSumAggregateInputType
    _min?: VideoItemMinAggregateInputType
    _max?: VideoItemMaxAggregateInputType
  }

  export type VideoItemGroupByOutputType = {
    id: number
    title: string
    description: string | null
    content: string
    url: string | null
    platform: string
    externalId: string | null
    playlistId: string
    itemTypeId: string
    order: number
    isActive: boolean
    isDeleted: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    duration: number | null
    categories: string | null
    language: string | null
    quality: string | null
    tags: string | null
    thumbnailUrl: string | null
    _count: VideoItemCountAggregateOutputType | null
    _avg: VideoItemAvgAggregateOutputType | null
    _sum: VideoItemSumAggregateOutputType | null
    _min: VideoItemMinAggregateOutputType | null
    _max: VideoItemMaxAggregateOutputType | null
  }

  type GetVideoItemGroupByPayload<T extends VideoItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoItemGroupByOutputType[P]>
            : GetScalarType<T[P], VideoItemGroupByOutputType[P]>
        }
      >
    >


  export type VideoItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    url?: boolean
    platform?: boolean
    externalId?: boolean
    playlistId?: boolean
    itemTypeId?: boolean
    order?: boolean
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    duration?: boolean
    categories?: boolean
    language?: boolean
    quality?: boolean
    tags?: boolean
    thumbnailUrl?: boolean
    activities?: boolean | VideoItem$activitiesArgs<ExtArgs>
    questions?: boolean | VideoItem$questionsArgs<ExtArgs>
    subtitles?: boolean | VideoItem$subtitlesArgs<ExtArgs>
    studyRooms?: boolean | VideoItem$studyRoomsArgs<ExtArgs>
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
    permissions?: boolean | VideoItem$permissionsArgs<ExtArgs>
    _count?: boolean | VideoItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoItem"]>

  export type VideoItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    url?: boolean
    platform?: boolean
    externalId?: boolean
    playlistId?: boolean
    itemTypeId?: boolean
    order?: boolean
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    duration?: boolean
    categories?: boolean
    language?: boolean
    quality?: boolean
    tags?: boolean
    thumbnailUrl?: boolean
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoItem"]>

  export type VideoItemSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    url?: boolean
    platform?: boolean
    externalId?: boolean
    playlistId?: boolean
    itemTypeId?: boolean
    order?: boolean
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    duration?: boolean
    categories?: boolean
    language?: boolean
    quality?: boolean
    tags?: boolean
    thumbnailUrl?: boolean
  }

  export type VideoItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | VideoItem$activitiesArgs<ExtArgs>
    questions?: boolean | VideoItem$questionsArgs<ExtArgs>
    subtitles?: boolean | VideoItem$subtitlesArgs<ExtArgs>
    studyRooms?: boolean | VideoItem$studyRoomsArgs<ExtArgs>
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
    permissions?: boolean | VideoItem$permissionsArgs<ExtArgs>
    _count?: boolean | VideoItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VideoItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
  }

  export type $VideoItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoItem"
    objects: {
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      questions: Prisma.$QuestionPayload<ExtArgs>[]
      subtitles: Prisma.$SubtitlePayload<ExtArgs>[]
      studyRooms: Prisma.$StudyRoomPayload<ExtArgs>[]
      playlist: Prisma.$PlaylistPayload<ExtArgs>
      permissions: Prisma.$VideoPermissionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      content: string
      url: string | null
      platform: string
      externalId: string | null
      playlistId: string
      itemTypeId: string
      order: number
      isActive: boolean
      isDeleted: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
      duration: number | null
      categories: string | null
      language: string | null
      quality: string | null
      tags: string | null
      thumbnailUrl: string | null
    }, ExtArgs["result"]["videoItem"]>
    composites: {}
  }

  type VideoItemGetPayload<S extends boolean | null | undefined | VideoItemDefaultArgs> = $Result.GetResult<Prisma.$VideoItemPayload, S>

  type VideoItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VideoItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VideoItemCountAggregateInputType | true
    }

  export interface VideoItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoItem'], meta: { name: 'VideoItem' } }
    /**
     * Find zero or one VideoItem that matches the filter.
     * @param {VideoItemFindUniqueArgs} args - Arguments to find a VideoItem
     * @example
     * // Get one VideoItem
     * const videoItem = await prisma.videoItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoItemFindUniqueArgs>(args: SelectSubset<T, VideoItemFindUniqueArgs<ExtArgs>>): Prisma__VideoItemClient<$Result.GetResult<Prisma.$VideoItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VideoItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VideoItemFindUniqueOrThrowArgs} args - Arguments to find a VideoItem
     * @example
     * // Get one VideoItem
     * const videoItem = await prisma.videoItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoItemFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoItemClient<$Result.GetResult<Prisma.$VideoItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VideoItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoItemFindFirstArgs} args - Arguments to find a VideoItem
     * @example
     * // Get one VideoItem
     * const videoItem = await prisma.videoItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoItemFindFirstArgs>(args?: SelectSubset<T, VideoItemFindFirstArgs<ExtArgs>>): Prisma__VideoItemClient<$Result.GetResult<Prisma.$VideoItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VideoItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoItemFindFirstOrThrowArgs} args - Arguments to find a VideoItem
     * @example
     * // Get one VideoItem
     * const videoItem = await prisma.videoItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoItemFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoItemClient<$Result.GetResult<Prisma.$VideoItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VideoItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoItems
     * const videoItems = await prisma.videoItem.findMany()
     * 
     * // Get first 10 VideoItems
     * const videoItems = await prisma.videoItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoItemWithIdOnly = await prisma.videoItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoItemFindManyArgs>(args?: SelectSubset<T, VideoItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VideoItem.
     * @param {VideoItemCreateArgs} args - Arguments to create a VideoItem.
     * @example
     * // Create one VideoItem
     * const VideoItem = await prisma.videoItem.create({
     *   data: {
     *     // ... data to create a VideoItem
     *   }
     * })
     * 
     */
    create<T extends VideoItemCreateArgs>(args: SelectSubset<T, VideoItemCreateArgs<ExtArgs>>): Prisma__VideoItemClient<$Result.GetResult<Prisma.$VideoItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VideoItems.
     * @param {VideoItemCreateManyArgs} args - Arguments to create many VideoItems.
     * @example
     * // Create many VideoItems
     * const videoItem = await prisma.videoItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoItemCreateManyArgs>(args?: SelectSubset<T, VideoItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoItems and returns the data saved in the database.
     * @param {VideoItemCreateManyAndReturnArgs} args - Arguments to create many VideoItems.
     * @example
     * // Create many VideoItems
     * const videoItem = await prisma.videoItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoItems and only return the `id`
     * const videoItemWithIdOnly = await prisma.videoItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoItemCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VideoItem.
     * @param {VideoItemDeleteArgs} args - Arguments to delete one VideoItem.
     * @example
     * // Delete one VideoItem
     * const VideoItem = await prisma.videoItem.delete({
     *   where: {
     *     // ... filter to delete one VideoItem
     *   }
     * })
     * 
     */
    delete<T extends VideoItemDeleteArgs>(args: SelectSubset<T, VideoItemDeleteArgs<ExtArgs>>): Prisma__VideoItemClient<$Result.GetResult<Prisma.$VideoItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VideoItem.
     * @param {VideoItemUpdateArgs} args - Arguments to update one VideoItem.
     * @example
     * // Update one VideoItem
     * const videoItem = await prisma.videoItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoItemUpdateArgs>(args: SelectSubset<T, VideoItemUpdateArgs<ExtArgs>>): Prisma__VideoItemClient<$Result.GetResult<Prisma.$VideoItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VideoItems.
     * @param {VideoItemDeleteManyArgs} args - Arguments to filter VideoItems to delete.
     * @example
     * // Delete a few VideoItems
     * const { count } = await prisma.videoItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoItemDeleteManyArgs>(args?: SelectSubset<T, VideoItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoItems
     * const videoItem = await prisma.videoItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoItemUpdateManyArgs>(args: SelectSubset<T, VideoItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VideoItem.
     * @param {VideoItemUpsertArgs} args - Arguments to update or create a VideoItem.
     * @example
     * // Update or create a VideoItem
     * const videoItem = await prisma.videoItem.upsert({
     *   create: {
     *     // ... data to create a VideoItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoItem we want to update
     *   }
     * })
     */
    upsert<T extends VideoItemUpsertArgs>(args: SelectSubset<T, VideoItemUpsertArgs<ExtArgs>>): Prisma__VideoItemClient<$Result.GetResult<Prisma.$VideoItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VideoItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoItemCountArgs} args - Arguments to filter VideoItems to count.
     * @example
     * // Count the number of VideoItems
     * const count = await prisma.videoItem.count({
     *   where: {
     *     // ... the filter for the VideoItems we want to count
     *   }
     * })
    **/
    count<T extends VideoItemCountArgs>(
      args?: Subset<T, VideoItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoItemAggregateArgs>(args: Subset<T, VideoItemAggregateArgs>): Prisma.PrismaPromise<GetVideoItemAggregateType<T>>

    /**
     * Group by VideoItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoItemGroupByArgs['orderBy'] }
        : { orderBy?: VideoItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoItem model
   */
  readonly fields: VideoItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activities<T extends VideoItem$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, VideoItem$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    questions<T extends VideoItem$questionsArgs<ExtArgs> = {}>(args?: Subset<T, VideoItem$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany"> | Null>
    subtitles<T extends VideoItem$subtitlesArgs<ExtArgs> = {}>(args?: Subset<T, VideoItem$subtitlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "findMany"> | Null>
    studyRooms<T extends VideoItem$studyRoomsArgs<ExtArgs> = {}>(args?: Subset<T, VideoItem$studyRoomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyRoomPayload<ExtArgs>, T, "findMany"> | Null>
    playlist<T extends PlaylistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaylistDefaultArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    permissions<T extends VideoItem$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, VideoItem$permissionsArgs<ExtArgs>>): Prisma__VideoPermissionsClient<$Result.GetResult<Prisma.$VideoPermissionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoItem model
   */ 
  interface VideoItemFieldRefs {
    readonly id: FieldRef<"VideoItem", 'Int'>
    readonly title: FieldRef<"VideoItem", 'String'>
    readonly description: FieldRef<"VideoItem", 'String'>
    readonly content: FieldRef<"VideoItem", 'String'>
    readonly url: FieldRef<"VideoItem", 'String'>
    readonly platform: FieldRef<"VideoItem", 'String'>
    readonly externalId: FieldRef<"VideoItem", 'String'>
    readonly playlistId: FieldRef<"VideoItem", 'String'>
    readonly itemTypeId: FieldRef<"VideoItem", 'String'>
    readonly order: FieldRef<"VideoItem", 'Int'>
    readonly isActive: FieldRef<"VideoItem", 'Boolean'>
    readonly isDeleted: FieldRef<"VideoItem", 'Boolean'>
    readonly deletedAt: FieldRef<"VideoItem", 'DateTime'>
    readonly createdAt: FieldRef<"VideoItem", 'DateTime'>
    readonly updatedAt: FieldRef<"VideoItem", 'DateTime'>
    readonly duration: FieldRef<"VideoItem", 'Int'>
    readonly categories: FieldRef<"VideoItem", 'String'>
    readonly language: FieldRef<"VideoItem", 'String'>
    readonly quality: FieldRef<"VideoItem", 'String'>
    readonly tags: FieldRef<"VideoItem", 'String'>
    readonly thumbnailUrl: FieldRef<"VideoItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VideoItem findUnique
   */
  export type VideoItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoItem
     */
    select?: VideoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoItemInclude<ExtArgs> | null
    /**
     * Filter, which VideoItem to fetch.
     */
    where: VideoItemWhereUniqueInput
  }

  /**
   * VideoItem findUniqueOrThrow
   */
  export type VideoItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoItem
     */
    select?: VideoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoItemInclude<ExtArgs> | null
    /**
     * Filter, which VideoItem to fetch.
     */
    where: VideoItemWhereUniqueInput
  }

  /**
   * VideoItem findFirst
   */
  export type VideoItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoItem
     */
    select?: VideoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoItemInclude<ExtArgs> | null
    /**
     * Filter, which VideoItem to fetch.
     */
    where?: VideoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoItems to fetch.
     */
    orderBy?: VideoItemOrderByWithRelationInput | VideoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoItems.
     */
    cursor?: VideoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoItems.
     */
    distinct?: VideoItemScalarFieldEnum | VideoItemScalarFieldEnum[]
  }

  /**
   * VideoItem findFirstOrThrow
   */
  export type VideoItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoItem
     */
    select?: VideoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoItemInclude<ExtArgs> | null
    /**
     * Filter, which VideoItem to fetch.
     */
    where?: VideoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoItems to fetch.
     */
    orderBy?: VideoItemOrderByWithRelationInput | VideoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoItems.
     */
    cursor?: VideoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoItems.
     */
    distinct?: VideoItemScalarFieldEnum | VideoItemScalarFieldEnum[]
  }

  /**
   * VideoItem findMany
   */
  export type VideoItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoItem
     */
    select?: VideoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoItemInclude<ExtArgs> | null
    /**
     * Filter, which VideoItems to fetch.
     */
    where?: VideoItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoItems to fetch.
     */
    orderBy?: VideoItemOrderByWithRelationInput | VideoItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoItems.
     */
    cursor?: VideoItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoItems.
     */
    skip?: number
    distinct?: VideoItemScalarFieldEnum | VideoItemScalarFieldEnum[]
  }

  /**
   * VideoItem create
   */
  export type VideoItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoItem
     */
    select?: VideoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoItemInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoItem.
     */
    data: XOR<VideoItemCreateInput, VideoItemUncheckedCreateInput>
  }

  /**
   * VideoItem createMany
   */
  export type VideoItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoItems.
     */
    data: VideoItemCreateManyInput | VideoItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoItem createManyAndReturn
   */
  export type VideoItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoItem
     */
    select?: VideoItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VideoItems.
     */
    data: VideoItemCreateManyInput | VideoItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoItem update
   */
  export type VideoItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoItem
     */
    select?: VideoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoItemInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoItem.
     */
    data: XOR<VideoItemUpdateInput, VideoItemUncheckedUpdateInput>
    /**
     * Choose, which VideoItem to update.
     */
    where: VideoItemWhereUniqueInput
  }

  /**
   * VideoItem updateMany
   */
  export type VideoItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoItems.
     */
    data: XOR<VideoItemUpdateManyMutationInput, VideoItemUncheckedUpdateManyInput>
    /**
     * Filter which VideoItems to update
     */
    where?: VideoItemWhereInput
  }

  /**
   * VideoItem upsert
   */
  export type VideoItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoItem
     */
    select?: VideoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoItemInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoItem to update in case it exists.
     */
    where: VideoItemWhereUniqueInput
    /**
     * In case the VideoItem found by the `where` argument doesn't exist, create a new VideoItem with this data.
     */
    create: XOR<VideoItemCreateInput, VideoItemUncheckedCreateInput>
    /**
     * In case the VideoItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoItemUpdateInput, VideoItemUncheckedUpdateInput>
  }

  /**
   * VideoItem delete
   */
  export type VideoItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoItem
     */
    select?: VideoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoItemInclude<ExtArgs> | null
    /**
     * Filter which VideoItem to delete.
     */
    where: VideoItemWhereUniqueInput
  }

  /**
   * VideoItem deleteMany
   */
  export type VideoItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoItems to delete
     */
    where?: VideoItemWhereInput
  }

  /**
   * VideoItem.activities
   */
  export type VideoItem$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * VideoItem.questions
   */
  export type VideoItem$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * VideoItem.subtitles
   */
  export type VideoItem$subtitlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    where?: SubtitleWhereInput
    orderBy?: SubtitleOrderByWithRelationInput | SubtitleOrderByWithRelationInput[]
    cursor?: SubtitleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtitleScalarFieldEnum | SubtitleScalarFieldEnum[]
  }

  /**
   * VideoItem.studyRooms
   */
  export type VideoItem$studyRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoom
     */
    select?: StudyRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomInclude<ExtArgs> | null
    where?: StudyRoomWhereInput
    orderBy?: StudyRoomOrderByWithRelationInput | StudyRoomOrderByWithRelationInput[]
    cursor?: StudyRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudyRoomScalarFieldEnum | StudyRoomScalarFieldEnum[]
  }

  /**
   * VideoItem.permissions
   */
  export type VideoItem$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoPermissions
     */
    select?: VideoPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoPermissionsInclude<ExtArgs> | null
    where?: VideoPermissionsWhereInput
  }

  /**
   * VideoItem without action
   */
  export type VideoItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoItem
     */
    select?: VideoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoItemInclude<ExtArgs> | null
  }


  /**
   * Model Subtitle
   */

  export type AggregateSubtitle = {
    _count: SubtitleCountAggregateOutputType | null
    _avg: SubtitleAvgAggregateOutputType | null
    _sum: SubtitleSumAggregateOutputType | null
    _min: SubtitleMinAggregateOutputType | null
    _max: SubtitleMaxAggregateOutputType | null
  }

  export type SubtitleAvgAggregateOutputType = {
    id: number | null
    videoItemId: number | null
  }

  export type SubtitleSumAggregateOutputType = {
    id: number | null
    videoItemId: number | null
  }

  export type SubtitleMinAggregateOutputType = {
    id: number | null
    videoItemId: number | null
    languageCode: string | null
    format: string | null
    content: string | null
    contentUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubtitleMaxAggregateOutputType = {
    id: number | null
    videoItemId: number | null
    languageCode: string | null
    format: string | null
    content: string | null
    contentUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubtitleCountAggregateOutputType = {
    id: number
    videoItemId: number
    languageCode: number
    format: number
    content: number
    contentUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubtitleAvgAggregateInputType = {
    id?: true
    videoItemId?: true
  }

  export type SubtitleSumAggregateInputType = {
    id?: true
    videoItemId?: true
  }

  export type SubtitleMinAggregateInputType = {
    id?: true
    videoItemId?: true
    languageCode?: true
    format?: true
    content?: true
    contentUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubtitleMaxAggregateInputType = {
    id?: true
    videoItemId?: true
    languageCode?: true
    format?: true
    content?: true
    contentUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubtitleCountAggregateInputType = {
    id?: true
    videoItemId?: true
    languageCode?: true
    format?: true
    content?: true
    contentUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubtitleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subtitle to aggregate.
     */
    where?: SubtitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtitles to fetch.
     */
    orderBy?: SubtitleOrderByWithRelationInput | SubtitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubtitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subtitles
    **/
    _count?: true | SubtitleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubtitleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubtitleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubtitleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubtitleMaxAggregateInputType
  }

  export type GetSubtitleAggregateType<T extends SubtitleAggregateArgs> = {
        [P in keyof T & keyof AggregateSubtitle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubtitle[P]>
      : GetScalarType<T[P], AggregateSubtitle[P]>
  }




  export type SubtitleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtitleWhereInput
    orderBy?: SubtitleOrderByWithAggregationInput | SubtitleOrderByWithAggregationInput[]
    by: SubtitleScalarFieldEnum[] | SubtitleScalarFieldEnum
    having?: SubtitleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubtitleCountAggregateInputType | true
    _avg?: SubtitleAvgAggregateInputType
    _sum?: SubtitleSumAggregateInputType
    _min?: SubtitleMinAggregateInputType
    _max?: SubtitleMaxAggregateInputType
  }

  export type SubtitleGroupByOutputType = {
    id: number
    videoItemId: number
    languageCode: string
    format: string
    content: string | null
    contentUrl: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubtitleCountAggregateOutputType | null
    _avg: SubtitleAvgAggregateOutputType | null
    _sum: SubtitleSumAggregateOutputType | null
    _min: SubtitleMinAggregateOutputType | null
    _max: SubtitleMaxAggregateOutputType | null
  }

  type GetSubtitleGroupByPayload<T extends SubtitleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubtitleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubtitleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubtitleGroupByOutputType[P]>
            : GetScalarType<T[P], SubtitleGroupByOutputType[P]>
        }
      >
    >


  export type SubtitleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoItemId?: boolean
    languageCode?: boolean
    format?: boolean
    content?: boolean
    contentUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    videoItem?: boolean | VideoItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subtitle"]>

  export type SubtitleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoItemId?: boolean
    languageCode?: boolean
    format?: boolean
    content?: boolean
    contentUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    videoItem?: boolean | VideoItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subtitle"]>

  export type SubtitleSelectScalar = {
    id?: boolean
    videoItemId?: boolean
    languageCode?: boolean
    format?: boolean
    content?: boolean
    contentUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubtitleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videoItem?: boolean | VideoItemDefaultArgs<ExtArgs>
  }
  export type SubtitleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videoItem?: boolean | VideoItemDefaultArgs<ExtArgs>
  }

  export type $SubtitlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subtitle"
    objects: {
      videoItem: Prisma.$VideoItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      videoItemId: number
      languageCode: string
      format: string
      content: string | null
      contentUrl: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subtitle"]>
    composites: {}
  }

  type SubtitleGetPayload<S extends boolean | null | undefined | SubtitleDefaultArgs> = $Result.GetResult<Prisma.$SubtitlePayload, S>

  type SubtitleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubtitleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubtitleCountAggregateInputType | true
    }

  export interface SubtitleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subtitle'], meta: { name: 'Subtitle' } }
    /**
     * Find zero or one Subtitle that matches the filter.
     * @param {SubtitleFindUniqueArgs} args - Arguments to find a Subtitle
     * @example
     * // Get one Subtitle
     * const subtitle = await prisma.subtitle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubtitleFindUniqueArgs>(args: SelectSubset<T, SubtitleFindUniqueArgs<ExtArgs>>): Prisma__SubtitleClient<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subtitle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubtitleFindUniqueOrThrowArgs} args - Arguments to find a Subtitle
     * @example
     * // Get one Subtitle
     * const subtitle = await prisma.subtitle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubtitleFindUniqueOrThrowArgs>(args: SelectSubset<T, SubtitleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubtitleClient<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subtitle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleFindFirstArgs} args - Arguments to find a Subtitle
     * @example
     * // Get one Subtitle
     * const subtitle = await prisma.subtitle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubtitleFindFirstArgs>(args?: SelectSubset<T, SubtitleFindFirstArgs<ExtArgs>>): Prisma__SubtitleClient<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subtitle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleFindFirstOrThrowArgs} args - Arguments to find a Subtitle
     * @example
     * // Get one Subtitle
     * const subtitle = await prisma.subtitle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubtitleFindFirstOrThrowArgs>(args?: SelectSubset<T, SubtitleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubtitleClient<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subtitles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subtitles
     * const subtitles = await prisma.subtitle.findMany()
     * 
     * // Get first 10 Subtitles
     * const subtitles = await prisma.subtitle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subtitleWithIdOnly = await prisma.subtitle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubtitleFindManyArgs>(args?: SelectSubset<T, SubtitleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subtitle.
     * @param {SubtitleCreateArgs} args - Arguments to create a Subtitle.
     * @example
     * // Create one Subtitle
     * const Subtitle = await prisma.subtitle.create({
     *   data: {
     *     // ... data to create a Subtitle
     *   }
     * })
     * 
     */
    create<T extends SubtitleCreateArgs>(args: SelectSubset<T, SubtitleCreateArgs<ExtArgs>>): Prisma__SubtitleClient<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subtitles.
     * @param {SubtitleCreateManyArgs} args - Arguments to create many Subtitles.
     * @example
     * // Create many Subtitles
     * const subtitle = await prisma.subtitle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubtitleCreateManyArgs>(args?: SelectSubset<T, SubtitleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subtitles and returns the data saved in the database.
     * @param {SubtitleCreateManyAndReturnArgs} args - Arguments to create many Subtitles.
     * @example
     * // Create many Subtitles
     * const subtitle = await prisma.subtitle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subtitles and only return the `id`
     * const subtitleWithIdOnly = await prisma.subtitle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubtitleCreateManyAndReturnArgs>(args?: SelectSubset<T, SubtitleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subtitle.
     * @param {SubtitleDeleteArgs} args - Arguments to delete one Subtitle.
     * @example
     * // Delete one Subtitle
     * const Subtitle = await prisma.subtitle.delete({
     *   where: {
     *     // ... filter to delete one Subtitle
     *   }
     * })
     * 
     */
    delete<T extends SubtitleDeleteArgs>(args: SelectSubset<T, SubtitleDeleteArgs<ExtArgs>>): Prisma__SubtitleClient<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subtitle.
     * @param {SubtitleUpdateArgs} args - Arguments to update one Subtitle.
     * @example
     * // Update one Subtitle
     * const subtitle = await prisma.subtitle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubtitleUpdateArgs>(args: SelectSubset<T, SubtitleUpdateArgs<ExtArgs>>): Prisma__SubtitleClient<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subtitles.
     * @param {SubtitleDeleteManyArgs} args - Arguments to filter Subtitles to delete.
     * @example
     * // Delete a few Subtitles
     * const { count } = await prisma.subtitle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubtitleDeleteManyArgs>(args?: SelectSubset<T, SubtitleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subtitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subtitles
     * const subtitle = await prisma.subtitle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubtitleUpdateManyArgs>(args: SelectSubset<T, SubtitleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subtitle.
     * @param {SubtitleUpsertArgs} args - Arguments to update or create a Subtitle.
     * @example
     * // Update or create a Subtitle
     * const subtitle = await prisma.subtitle.upsert({
     *   create: {
     *     // ... data to create a Subtitle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subtitle we want to update
     *   }
     * })
     */
    upsert<T extends SubtitleUpsertArgs>(args: SelectSubset<T, SubtitleUpsertArgs<ExtArgs>>): Prisma__SubtitleClient<$Result.GetResult<Prisma.$SubtitlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subtitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleCountArgs} args - Arguments to filter Subtitles to count.
     * @example
     * // Count the number of Subtitles
     * const count = await prisma.subtitle.count({
     *   where: {
     *     // ... the filter for the Subtitles we want to count
     *   }
     * })
    **/
    count<T extends SubtitleCountArgs>(
      args?: Subset<T, SubtitleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubtitleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subtitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubtitleAggregateArgs>(args: Subset<T, SubtitleAggregateArgs>): Prisma.PrismaPromise<GetSubtitleAggregateType<T>>

    /**
     * Group by Subtitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubtitleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubtitleGroupByArgs['orderBy'] }
        : { orderBy?: SubtitleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubtitleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubtitleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subtitle model
   */
  readonly fields: SubtitleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subtitle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubtitleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    videoItem<T extends VideoItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoItemDefaultArgs<ExtArgs>>): Prisma__VideoItemClient<$Result.GetResult<Prisma.$VideoItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subtitle model
   */ 
  interface SubtitleFieldRefs {
    readonly id: FieldRef<"Subtitle", 'Int'>
    readonly videoItemId: FieldRef<"Subtitle", 'Int'>
    readonly languageCode: FieldRef<"Subtitle", 'String'>
    readonly format: FieldRef<"Subtitle", 'String'>
    readonly content: FieldRef<"Subtitle", 'String'>
    readonly contentUrl: FieldRef<"Subtitle", 'String'>
    readonly isActive: FieldRef<"Subtitle", 'Boolean'>
    readonly createdAt: FieldRef<"Subtitle", 'DateTime'>
    readonly updatedAt: FieldRef<"Subtitle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subtitle findUnique
   */
  export type SubtitleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * Filter, which Subtitle to fetch.
     */
    where: SubtitleWhereUniqueInput
  }

  /**
   * Subtitle findUniqueOrThrow
   */
  export type SubtitleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * Filter, which Subtitle to fetch.
     */
    where: SubtitleWhereUniqueInput
  }

  /**
   * Subtitle findFirst
   */
  export type SubtitleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * Filter, which Subtitle to fetch.
     */
    where?: SubtitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtitles to fetch.
     */
    orderBy?: SubtitleOrderByWithRelationInput | SubtitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subtitles.
     */
    cursor?: SubtitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subtitles.
     */
    distinct?: SubtitleScalarFieldEnum | SubtitleScalarFieldEnum[]
  }

  /**
   * Subtitle findFirstOrThrow
   */
  export type SubtitleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * Filter, which Subtitle to fetch.
     */
    where?: SubtitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtitles to fetch.
     */
    orderBy?: SubtitleOrderByWithRelationInput | SubtitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subtitles.
     */
    cursor?: SubtitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subtitles.
     */
    distinct?: SubtitleScalarFieldEnum | SubtitleScalarFieldEnum[]
  }

  /**
   * Subtitle findMany
   */
  export type SubtitleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * Filter, which Subtitles to fetch.
     */
    where?: SubtitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subtitles to fetch.
     */
    orderBy?: SubtitleOrderByWithRelationInput | SubtitleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subtitles.
     */
    cursor?: SubtitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subtitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subtitles.
     */
    skip?: number
    distinct?: SubtitleScalarFieldEnum | SubtitleScalarFieldEnum[]
  }

  /**
   * Subtitle create
   */
  export type SubtitleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * The data needed to create a Subtitle.
     */
    data: XOR<SubtitleCreateInput, SubtitleUncheckedCreateInput>
  }

  /**
   * Subtitle createMany
   */
  export type SubtitleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subtitles.
     */
    data: SubtitleCreateManyInput | SubtitleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subtitle createManyAndReturn
   */
  export type SubtitleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subtitles.
     */
    data: SubtitleCreateManyInput | SubtitleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subtitle update
   */
  export type SubtitleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * The data needed to update a Subtitle.
     */
    data: XOR<SubtitleUpdateInput, SubtitleUncheckedUpdateInput>
    /**
     * Choose, which Subtitle to update.
     */
    where: SubtitleWhereUniqueInput
  }

  /**
   * Subtitle updateMany
   */
  export type SubtitleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subtitles.
     */
    data: XOR<SubtitleUpdateManyMutationInput, SubtitleUncheckedUpdateManyInput>
    /**
     * Filter which Subtitles to update
     */
    where?: SubtitleWhereInput
  }

  /**
   * Subtitle upsert
   */
  export type SubtitleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * The filter to search for the Subtitle to update in case it exists.
     */
    where: SubtitleWhereUniqueInput
    /**
     * In case the Subtitle found by the `where` argument doesn't exist, create a new Subtitle with this data.
     */
    create: XOR<SubtitleCreateInput, SubtitleUncheckedCreateInput>
    /**
     * In case the Subtitle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubtitleUpdateInput, SubtitleUncheckedUpdateInput>
  }

  /**
   * Subtitle delete
   */
  export type SubtitleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
    /**
     * Filter which Subtitle to delete.
     */
    where: SubtitleWhereUniqueInput
  }

  /**
   * Subtitle deleteMany
   */
  export type SubtitleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subtitles to delete
     */
    where?: SubtitleWhereInput
  }

  /**
   * Subtitle without action
   */
  export type SubtitleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subtitle
     */
    select?: SubtitleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleInclude<ExtArgs> | null
  }


  /**
   * Model Question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionAvgAggregateOutputType = {
    id: number | null
    videoItemId: number | null
    timestamp: number | null
    endTimestamp: number | null
  }

  export type QuestionSumAggregateOutputType = {
    id: number | null
    videoItemId: number | null
    timestamp: number | null
    endTimestamp: number | null
  }

  export type QuestionMinAggregateOutputType = {
    id: number | null
    videoItemId: number | null
    timestamp: number | null
    type: string | null
    text: string | null
    languageCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    endTimestamp: number | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: number | null
    videoItemId: number | null
    timestamp: number | null
    type: string | null
    text: string | null
    languageCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    endTimestamp: number | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    videoItemId: number
    timestamp: number
    type: number
    text: number
    languageCode: number
    isActive: number
    createdAt: number
    updatedAt: number
    endTimestamp: number
    _all: number
  }


  export type QuestionAvgAggregateInputType = {
    id?: true
    videoItemId?: true
    timestamp?: true
    endTimestamp?: true
  }

  export type QuestionSumAggregateInputType = {
    id?: true
    videoItemId?: true
    timestamp?: true
    endTimestamp?: true
  }

  export type QuestionMinAggregateInputType = {
    id?: true
    videoItemId?: true
    timestamp?: true
    type?: true
    text?: true
    languageCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    endTimestamp?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    videoItemId?: true
    timestamp?: true
    type?: true
    text?: true
    languageCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    endTimestamp?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    videoItemId?: true
    timestamp?: true
    type?: true
    text?: true
    languageCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    endTimestamp?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithAggregationInput | QuestionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _avg?: QuestionAvgAggregateInputType
    _sum?: QuestionSumAggregateInputType
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    id: number
    videoItemId: number
    timestamp: number
    type: string
    text: string
    languageCode: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    endTimestamp: number | null
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoItemId?: boolean
    timestamp?: boolean
    type?: boolean
    text?: boolean
    languageCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    endTimestamp?: boolean
    answerOptions?: boolean | Question$answerOptionsArgs<ExtArgs>
    videoItem?: boolean | VideoItemDefaultArgs<ExtArgs>
    userAnswers?: boolean | Question$userAnswersArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoItemId?: boolean
    timestamp?: boolean
    type?: boolean
    text?: boolean
    languageCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    endTimestamp?: boolean
    videoItem?: boolean | VideoItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectScalar = {
    id?: boolean
    videoItemId?: boolean
    timestamp?: boolean
    type?: boolean
    text?: boolean
    languageCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    endTimestamp?: boolean
  }

  export type QuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answerOptions?: boolean | Question$answerOptionsArgs<ExtArgs>
    videoItem?: boolean | VideoItemDefaultArgs<ExtArgs>
    userAnswers?: boolean | Question$userAnswersArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videoItem?: boolean | VideoItemDefaultArgs<ExtArgs>
  }

  export type $QuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Question"
    objects: {
      answerOptions: Prisma.$AnswerOptionPayload<ExtArgs>[]
      videoItem: Prisma.$VideoItemPayload<ExtArgs>
      userAnswers: Prisma.$UserAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      videoItemId: number
      timestamp: number
      type: string
      text: string
      languageCode: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      endTimestamp: number | null
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type QuestionGetPayload<S extends boolean | null | undefined | QuestionDefaultArgs> = $Result.GetResult<Prisma.$QuestionPayload, S>

  type QuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface QuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Question'], meta: { name: 'Question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionFindUniqueArgs>(args: SelectSubset<T, QuestionFindUniqueArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionFindFirstArgs>(args?: SelectSubset<T, QuestionFindFirstArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionFindManyArgs>(args?: SelectSubset<T, QuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends QuestionCreateArgs>(args: SelectSubset<T, QuestionCreateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questions.
     * @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCreateManyArgs>(args?: SelectSubset<T, QuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {QuestionCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends QuestionDeleteArgs>(args: SelectSubset<T, QuestionDeleteArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionUpdateArgs>(args: SelectSubset<T, QuestionUpdateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionDeleteManyArgs>(args?: SelectSubset<T, QuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionUpdateManyArgs>(args: SelectSubset<T, QuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends QuestionUpsertArgs>(args: SelectSubset<T, QuestionUpsertArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Question model
   */
  readonly fields: QuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    answerOptions<T extends Question$answerOptionsArgs<ExtArgs> = {}>(args?: Subset<T, Question$answerOptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerOptionPayload<ExtArgs>, T, "findMany"> | Null>
    videoItem<T extends VideoItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoItemDefaultArgs<ExtArgs>>): Prisma__VideoItemClient<$Result.GetResult<Prisma.$VideoItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    userAnswers<T extends Question$userAnswersArgs<ExtArgs> = {}>(args?: Subset<T, Question$userAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Question model
   */ 
  interface QuestionFieldRefs {
    readonly id: FieldRef<"Question", 'Int'>
    readonly videoItemId: FieldRef<"Question", 'Int'>
    readonly timestamp: FieldRef<"Question", 'Int'>
    readonly type: FieldRef<"Question", 'String'>
    readonly text: FieldRef<"Question", 'String'>
    readonly languageCode: FieldRef<"Question", 'String'>
    readonly isActive: FieldRef<"Question", 'Boolean'>
    readonly createdAt: FieldRef<"Question", 'DateTime'>
    readonly updatedAt: FieldRef<"Question", 'DateTime'>
    readonly endTimestamp: FieldRef<"Question", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findMany
   */
  export type QuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question create
   */
  export type QuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Question.
     */
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }

  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Question createManyAndReturn
   */
  export type QuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question update
   */
  export type QuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
  }

  /**
   * Question upsert
   */
  export type QuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }

  /**
   * Question delete
   */
  export type QuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput
  }

  /**
   * Question.answerOptions
   */
  export type Question$answerOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null
    where?: AnswerOptionWhereInput
    orderBy?: AnswerOptionOrderByWithRelationInput | AnswerOptionOrderByWithRelationInput[]
    cursor?: AnswerOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswerOptionScalarFieldEnum | AnswerOptionScalarFieldEnum[]
  }

  /**
   * Question.userAnswers
   */
  export type Question$userAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    where?: UserAnswerWhereInput
    orderBy?: UserAnswerOrderByWithRelationInput | UserAnswerOrderByWithRelationInput[]
    cursor?: UserAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAnswerScalarFieldEnum | UserAnswerScalarFieldEnum[]
  }

  /**
   * Question without action
   */
  export type QuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
  }


  /**
   * Model AnswerOption
   */

  export type AggregateAnswerOption = {
    _count: AnswerOptionCountAggregateOutputType | null
    _avg: AnswerOptionAvgAggregateOutputType | null
    _sum: AnswerOptionSumAggregateOutputType | null
    _min: AnswerOptionMinAggregateOutputType | null
    _max: AnswerOptionMaxAggregateOutputType | null
  }

  export type AnswerOptionAvgAggregateOutputType = {
    id: number | null
    questionId: number | null
    order: number | null
  }

  export type AnswerOptionSumAggregateOutputType = {
    id: number | null
    questionId: number | null
    order: number | null
  }

  export type AnswerOptionMinAggregateOutputType = {
    id: number | null
    questionId: number | null
    text: string | null
    isCorrect: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnswerOptionMaxAggregateOutputType = {
    id: number | null
    questionId: number | null
    text: string | null
    isCorrect: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnswerOptionCountAggregateOutputType = {
    id: number
    questionId: number
    text: number
    isCorrect: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnswerOptionAvgAggregateInputType = {
    id?: true
    questionId?: true
    order?: true
  }

  export type AnswerOptionSumAggregateInputType = {
    id?: true
    questionId?: true
    order?: true
  }

  export type AnswerOptionMinAggregateInputType = {
    id?: true
    questionId?: true
    text?: true
    isCorrect?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnswerOptionMaxAggregateInputType = {
    id?: true
    questionId?: true
    text?: true
    isCorrect?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnswerOptionCountAggregateInputType = {
    id?: true
    questionId?: true
    text?: true
    isCorrect?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnswerOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnswerOption to aggregate.
     */
    where?: AnswerOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnswerOptions to fetch.
     */
    orderBy?: AnswerOptionOrderByWithRelationInput | AnswerOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnswerOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnswerOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnswerOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnswerOptions
    **/
    _count?: true | AnswerOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnswerOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnswerOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnswerOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnswerOptionMaxAggregateInputType
  }

  export type GetAnswerOptionAggregateType<T extends AnswerOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswerOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswerOption[P]>
      : GetScalarType<T[P], AggregateAnswerOption[P]>
  }




  export type AnswerOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerOptionWhereInput
    orderBy?: AnswerOptionOrderByWithAggregationInput | AnswerOptionOrderByWithAggregationInput[]
    by: AnswerOptionScalarFieldEnum[] | AnswerOptionScalarFieldEnum
    having?: AnswerOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnswerOptionCountAggregateInputType | true
    _avg?: AnswerOptionAvgAggregateInputType
    _sum?: AnswerOptionSumAggregateInputType
    _min?: AnswerOptionMinAggregateInputType
    _max?: AnswerOptionMaxAggregateInputType
  }

  export type AnswerOptionGroupByOutputType = {
    id: number
    questionId: number
    text: string
    isCorrect: boolean
    order: number
    createdAt: Date
    updatedAt: Date
    _count: AnswerOptionCountAggregateOutputType | null
    _avg: AnswerOptionAvgAggregateOutputType | null
    _sum: AnswerOptionSumAggregateOutputType | null
    _min: AnswerOptionMinAggregateOutputType | null
    _max: AnswerOptionMaxAggregateOutputType | null
  }

  type GetAnswerOptionGroupByPayload<T extends AnswerOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnswerOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnswerOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswerOptionGroupByOutputType[P]>
            : GetScalarType<T[P], AnswerOptionGroupByOutputType[P]>
        }
      >
    >


  export type AnswerOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answerOption"]>

  export type AnswerOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answerOption"]>

  export type AnswerOptionSelectScalar = {
    id?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnswerOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type AnswerOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }

  export type $AnswerOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnswerOption"
    objects: {
      question: Prisma.$QuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      questionId: number
      text: string
      isCorrect: boolean
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["answerOption"]>
    composites: {}
  }

  type AnswerOptionGetPayload<S extends boolean | null | undefined | AnswerOptionDefaultArgs> = $Result.GetResult<Prisma.$AnswerOptionPayload, S>

  type AnswerOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnswerOptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnswerOptionCountAggregateInputType | true
    }

  export interface AnswerOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnswerOption'], meta: { name: 'AnswerOption' } }
    /**
     * Find zero or one AnswerOption that matches the filter.
     * @param {AnswerOptionFindUniqueArgs} args - Arguments to find a AnswerOption
     * @example
     * // Get one AnswerOption
     * const answerOption = await prisma.answerOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnswerOptionFindUniqueArgs>(args: SelectSubset<T, AnswerOptionFindUniqueArgs<ExtArgs>>): Prisma__AnswerOptionClient<$Result.GetResult<Prisma.$AnswerOptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AnswerOption that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnswerOptionFindUniqueOrThrowArgs} args - Arguments to find a AnswerOption
     * @example
     * // Get one AnswerOption
     * const answerOption = await prisma.answerOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnswerOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, AnswerOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnswerOptionClient<$Result.GetResult<Prisma.$AnswerOptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AnswerOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerOptionFindFirstArgs} args - Arguments to find a AnswerOption
     * @example
     * // Get one AnswerOption
     * const answerOption = await prisma.answerOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnswerOptionFindFirstArgs>(args?: SelectSubset<T, AnswerOptionFindFirstArgs<ExtArgs>>): Prisma__AnswerOptionClient<$Result.GetResult<Prisma.$AnswerOptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AnswerOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerOptionFindFirstOrThrowArgs} args - Arguments to find a AnswerOption
     * @example
     * // Get one AnswerOption
     * const answerOption = await prisma.answerOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnswerOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, AnswerOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnswerOptionClient<$Result.GetResult<Prisma.$AnswerOptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AnswerOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnswerOptions
     * const answerOptions = await prisma.answerOption.findMany()
     * 
     * // Get first 10 AnswerOptions
     * const answerOptions = await prisma.answerOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answerOptionWithIdOnly = await prisma.answerOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnswerOptionFindManyArgs>(args?: SelectSubset<T, AnswerOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerOptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AnswerOption.
     * @param {AnswerOptionCreateArgs} args - Arguments to create a AnswerOption.
     * @example
     * // Create one AnswerOption
     * const AnswerOption = await prisma.answerOption.create({
     *   data: {
     *     // ... data to create a AnswerOption
     *   }
     * })
     * 
     */
    create<T extends AnswerOptionCreateArgs>(args: SelectSubset<T, AnswerOptionCreateArgs<ExtArgs>>): Prisma__AnswerOptionClient<$Result.GetResult<Prisma.$AnswerOptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AnswerOptions.
     * @param {AnswerOptionCreateManyArgs} args - Arguments to create many AnswerOptions.
     * @example
     * // Create many AnswerOptions
     * const answerOption = await prisma.answerOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnswerOptionCreateManyArgs>(args?: SelectSubset<T, AnswerOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnswerOptions and returns the data saved in the database.
     * @param {AnswerOptionCreateManyAndReturnArgs} args - Arguments to create many AnswerOptions.
     * @example
     * // Create many AnswerOptions
     * const answerOption = await prisma.answerOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnswerOptions and only return the `id`
     * const answerOptionWithIdOnly = await prisma.answerOption.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnswerOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, AnswerOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerOptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AnswerOption.
     * @param {AnswerOptionDeleteArgs} args - Arguments to delete one AnswerOption.
     * @example
     * // Delete one AnswerOption
     * const AnswerOption = await prisma.answerOption.delete({
     *   where: {
     *     // ... filter to delete one AnswerOption
     *   }
     * })
     * 
     */
    delete<T extends AnswerOptionDeleteArgs>(args: SelectSubset<T, AnswerOptionDeleteArgs<ExtArgs>>): Prisma__AnswerOptionClient<$Result.GetResult<Prisma.$AnswerOptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AnswerOption.
     * @param {AnswerOptionUpdateArgs} args - Arguments to update one AnswerOption.
     * @example
     * // Update one AnswerOption
     * const answerOption = await prisma.answerOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnswerOptionUpdateArgs>(args: SelectSubset<T, AnswerOptionUpdateArgs<ExtArgs>>): Prisma__AnswerOptionClient<$Result.GetResult<Prisma.$AnswerOptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AnswerOptions.
     * @param {AnswerOptionDeleteManyArgs} args - Arguments to filter AnswerOptions to delete.
     * @example
     * // Delete a few AnswerOptions
     * const { count } = await prisma.answerOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnswerOptionDeleteManyArgs>(args?: SelectSubset<T, AnswerOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnswerOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnswerOptions
     * const answerOption = await prisma.answerOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnswerOptionUpdateManyArgs>(args: SelectSubset<T, AnswerOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnswerOption.
     * @param {AnswerOptionUpsertArgs} args - Arguments to update or create a AnswerOption.
     * @example
     * // Update or create a AnswerOption
     * const answerOption = await prisma.answerOption.upsert({
     *   create: {
     *     // ... data to create a AnswerOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnswerOption we want to update
     *   }
     * })
     */
    upsert<T extends AnswerOptionUpsertArgs>(args: SelectSubset<T, AnswerOptionUpsertArgs<ExtArgs>>): Prisma__AnswerOptionClient<$Result.GetResult<Prisma.$AnswerOptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AnswerOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerOptionCountArgs} args - Arguments to filter AnswerOptions to count.
     * @example
     * // Count the number of AnswerOptions
     * const count = await prisma.answerOption.count({
     *   where: {
     *     // ... the filter for the AnswerOptions we want to count
     *   }
     * })
    **/
    count<T extends AnswerOptionCountArgs>(
      args?: Subset<T, AnswerOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswerOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnswerOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnswerOptionAggregateArgs>(args: Subset<T, AnswerOptionAggregateArgs>): Prisma.PrismaPromise<GetAnswerOptionAggregateType<T>>

    /**
     * Group by AnswerOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnswerOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnswerOptionGroupByArgs['orderBy'] }
        : { orderBy?: AnswerOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnswerOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswerOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnswerOption model
   */
  readonly fields: AnswerOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnswerOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnswerOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnswerOption model
   */ 
  interface AnswerOptionFieldRefs {
    readonly id: FieldRef<"AnswerOption", 'Int'>
    readonly questionId: FieldRef<"AnswerOption", 'Int'>
    readonly text: FieldRef<"AnswerOption", 'String'>
    readonly isCorrect: FieldRef<"AnswerOption", 'Boolean'>
    readonly order: FieldRef<"AnswerOption", 'Int'>
    readonly createdAt: FieldRef<"AnswerOption", 'DateTime'>
    readonly updatedAt: FieldRef<"AnswerOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnswerOption findUnique
   */
  export type AnswerOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null
    /**
     * Filter, which AnswerOption to fetch.
     */
    where: AnswerOptionWhereUniqueInput
  }

  /**
   * AnswerOption findUniqueOrThrow
   */
  export type AnswerOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null
    /**
     * Filter, which AnswerOption to fetch.
     */
    where: AnswerOptionWhereUniqueInput
  }

  /**
   * AnswerOption findFirst
   */
  export type AnswerOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null
    /**
     * Filter, which AnswerOption to fetch.
     */
    where?: AnswerOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnswerOptions to fetch.
     */
    orderBy?: AnswerOptionOrderByWithRelationInput | AnswerOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnswerOptions.
     */
    cursor?: AnswerOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnswerOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnswerOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnswerOptions.
     */
    distinct?: AnswerOptionScalarFieldEnum | AnswerOptionScalarFieldEnum[]
  }

  /**
   * AnswerOption findFirstOrThrow
   */
  export type AnswerOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null
    /**
     * Filter, which AnswerOption to fetch.
     */
    where?: AnswerOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnswerOptions to fetch.
     */
    orderBy?: AnswerOptionOrderByWithRelationInput | AnswerOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnswerOptions.
     */
    cursor?: AnswerOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnswerOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnswerOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnswerOptions.
     */
    distinct?: AnswerOptionScalarFieldEnum | AnswerOptionScalarFieldEnum[]
  }

  /**
   * AnswerOption findMany
   */
  export type AnswerOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null
    /**
     * Filter, which AnswerOptions to fetch.
     */
    where?: AnswerOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnswerOptions to fetch.
     */
    orderBy?: AnswerOptionOrderByWithRelationInput | AnswerOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnswerOptions.
     */
    cursor?: AnswerOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnswerOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnswerOptions.
     */
    skip?: number
    distinct?: AnswerOptionScalarFieldEnum | AnswerOptionScalarFieldEnum[]
  }

  /**
   * AnswerOption create
   */
  export type AnswerOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a AnswerOption.
     */
    data: XOR<AnswerOptionCreateInput, AnswerOptionUncheckedCreateInput>
  }

  /**
   * AnswerOption createMany
   */
  export type AnswerOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnswerOptions.
     */
    data: AnswerOptionCreateManyInput | AnswerOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnswerOption createManyAndReturn
   */
  export type AnswerOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AnswerOptions.
     */
    data: AnswerOptionCreateManyInput | AnswerOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnswerOption update
   */
  export type AnswerOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a AnswerOption.
     */
    data: XOR<AnswerOptionUpdateInput, AnswerOptionUncheckedUpdateInput>
    /**
     * Choose, which AnswerOption to update.
     */
    where: AnswerOptionWhereUniqueInput
  }

  /**
   * AnswerOption updateMany
   */
  export type AnswerOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnswerOptions.
     */
    data: XOR<AnswerOptionUpdateManyMutationInput, AnswerOptionUncheckedUpdateManyInput>
    /**
     * Filter which AnswerOptions to update
     */
    where?: AnswerOptionWhereInput
  }

  /**
   * AnswerOption upsert
   */
  export type AnswerOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the AnswerOption to update in case it exists.
     */
    where: AnswerOptionWhereUniqueInput
    /**
     * In case the AnswerOption found by the `where` argument doesn't exist, create a new AnswerOption with this data.
     */
    create: XOR<AnswerOptionCreateInput, AnswerOptionUncheckedCreateInput>
    /**
     * In case the AnswerOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnswerOptionUpdateInput, AnswerOptionUncheckedUpdateInput>
  }

  /**
   * AnswerOption delete
   */
  export type AnswerOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null
    /**
     * Filter which AnswerOption to delete.
     */
    where: AnswerOptionWhereUniqueInput
  }

  /**
   * AnswerOption deleteMany
   */
  export type AnswerOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnswerOptions to delete
     */
    where?: AnswerOptionWhereInput
  }

  /**
   * AnswerOption without action
   */
  export type AnswerOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnswerOption
     */
    select?: AnswerOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerOptionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    topUserCount: number | null
  }

  export type UserSumAggregateOutputType = {
    topUserCount: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    avatarUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
    firstName: string | null
    lastName: string | null
    documentType: string | null
    documentNumber: string | null
    phone: string | null
    country: string | null
    address: string | null
    status: string | null
    topUserCount: number | null
    personalityId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    avatarUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
    firstName: string | null
    lastName: string | null
    documentType: string | null
    documentNumber: string | null
    phone: string | null
    country: string | null
    address: string | null
    status: string | null
    topUserCount: number | null
    personalityId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    avatarUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    username: number
    firstName: number
    lastName: number
    documentType: number
    documentNumber: number
    phone: number
    country: number
    address: number
    status: number
    topUserCount: number
    personalityId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    topUserCount?: true
  }

  export type UserSumAggregateInputType = {
    topUserCount?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    avatarUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    firstName?: true
    lastName?: true
    documentType?: true
    documentNumber?: true
    phone?: true
    country?: true
    address?: true
    status?: true
    topUserCount?: true
    personalityId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    avatarUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    firstName?: true
    lastName?: true
    documentType?: true
    documentNumber?: true
    phone?: true
    country?: true
    address?: true
    status?: true
    topUserCount?: true
    personalityId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    avatarUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    firstName?: true
    lastName?: true
    documentType?: true
    documentNumber?: true
    phone?: true
    country?: true
    address?: true
    status?: true
    topUserCount?: true
    personalityId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string | null
    avatarUrl: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    username: string | null
    firstName: string | null
    lastName: string | null
    documentType: string | null
    documentNumber: string | null
    phone: string | null
    country: string | null
    address: string | null
    status: string
    topUserCount: number
    personalityId: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    documentType?: boolean
    documentNumber?: boolean
    phone?: boolean
    country?: boolean
    address?: boolean
    status?: boolean
    topUserCount?: boolean
    personalityId?: boolean
    createdActivities?: boolean | User$createdActivitiesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    createdExperiences?: boolean | User$createdExperiencesArgs<ExtArgs>
    invitationsSent?: boolean | User$invitationsSentArgs<ExtArgs>
    ownedGroups?: boolean | User$ownedGroupsArgs<ExtArgs>
    createdInvitationTemplates?: boolean | User$createdInvitationTemplatesArgs<ExtArgs>
    merits?: boolean | User$meritsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    publications?: boolean | User$publicationsArgs<ExtArgs>
    createdReports?: boolean | User$createdReportsArgs<ExtArgs>
    assignedPermissions?: boolean | User$assignedPermissionsArgs<ExtArgs>
    tokens?: boolean | User$tokensArgs<ExtArgs>
    transactionsTo?: boolean | User$transactionsToArgs<ExtArgs>
    transactionsFrom?: boolean | User$transactionsFromArgs<ExtArgs>
    createdTemplates?: boolean | User$createdTemplatesArgs<ExtArgs>
    userAnswers?: boolean | User$userAnswersArgs<ExtArgs>
    userChallenges?: boolean | User$userChallengesArgs<ExtArgs>
    userGroups?: boolean | User$userGroupsArgs<ExtArgs>
    invitationsReceived?: boolean | User$invitationsReceivedArgs<ExtArgs>
    assignedRoles?: boolean | User$assignedRolesArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    hostedStudyRooms?: boolean | User$hostedStudyRoomsArgs<ExtArgs>
    studyRoomParticipants?: boolean | User$studyRoomParticipantsArgs<ExtArgs>
    sentChatMessages?: boolean | User$sentChatMessagesArgs<ExtArgs>
    personality?: boolean | User$personalityArgs<ExtArgs>
    videoPermissions?: boolean | User$videoPermissionsArgs<ExtArgs>
    wallet?: boolean | User$walletArgs<ExtArgs>
    createdWorlds?: boolean | User$createdWorldsArgs<ExtArgs>
    marketplaceItems?: boolean | User$marketplaceItemsArgs<ExtArgs>
    buyerMatches?: boolean | User$buyerMatchesArgs<ExtArgs>
    sellerMatches?: boolean | User$sellerMatchesArgs<ExtArgs>
    matchMessages?: boolean | User$matchMessagesArgs<ExtArgs>
    feedbackReports?: boolean | User$feedbackReportsArgs<ExtArgs>
    adminFeedbackResponses?: boolean | User$adminFeedbackResponsesArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    documentType?: boolean
    documentNumber?: boolean
    phone?: boolean
    country?: boolean
    address?: boolean
    status?: boolean
    topUserCount?: boolean
    personalityId?: boolean
    personality?: boolean | User$personalityArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    documentType?: boolean
    documentNumber?: boolean
    phone?: boolean
    country?: boolean
    address?: boolean
    status?: boolean
    topUserCount?: boolean
    personalityId?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdActivities?: boolean | User$createdActivitiesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    likes?: boolean | User$likesArgs<ExtArgs>
    createdExperiences?: boolean | User$createdExperiencesArgs<ExtArgs>
    invitationsSent?: boolean | User$invitationsSentArgs<ExtArgs>
    ownedGroups?: boolean | User$ownedGroupsArgs<ExtArgs>
    createdInvitationTemplates?: boolean | User$createdInvitationTemplatesArgs<ExtArgs>
    merits?: boolean | User$meritsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    publications?: boolean | User$publicationsArgs<ExtArgs>
    createdReports?: boolean | User$createdReportsArgs<ExtArgs>
    assignedPermissions?: boolean | User$assignedPermissionsArgs<ExtArgs>
    tokens?: boolean | User$tokensArgs<ExtArgs>
    transactionsTo?: boolean | User$transactionsToArgs<ExtArgs>
    transactionsFrom?: boolean | User$transactionsFromArgs<ExtArgs>
    createdTemplates?: boolean | User$createdTemplatesArgs<ExtArgs>
    userAnswers?: boolean | User$userAnswersArgs<ExtArgs>
    userChallenges?: boolean | User$userChallengesArgs<ExtArgs>
    userGroups?: boolean | User$userGroupsArgs<ExtArgs>
    invitationsReceived?: boolean | User$invitationsReceivedArgs<ExtArgs>
    assignedRoles?: boolean | User$assignedRolesArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    hostedStudyRooms?: boolean | User$hostedStudyRoomsArgs<ExtArgs>
    studyRoomParticipants?: boolean | User$studyRoomParticipantsArgs<ExtArgs>
    sentChatMessages?: boolean | User$sentChatMessagesArgs<ExtArgs>
    personality?: boolean | User$personalityArgs<ExtArgs>
    videoPermissions?: boolean | User$videoPermissionsArgs<ExtArgs>
    wallet?: boolean | User$walletArgs<ExtArgs>
    createdWorlds?: boolean | User$createdWorldsArgs<ExtArgs>
    marketplaceItems?: boolean | User$marketplaceItemsArgs<ExtArgs>
    buyerMatches?: boolean | User$buyerMatchesArgs<ExtArgs>
    sellerMatches?: boolean | User$sellerMatchesArgs<ExtArgs>
    matchMessages?: boolean | User$matchMessagesArgs<ExtArgs>
    feedbackReports?: boolean | User$feedbackReportsArgs<ExtArgs>
    adminFeedbackResponses?: boolean | User$adminFeedbackResponsesArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personality?: boolean | User$personalityArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      createdActivities: Prisma.$ActivityPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
      createdExperiences: Prisma.$ExperiencePayload<ExtArgs>[]
      invitationsSent: Prisma.$GiftCardPayload<ExtArgs>[]
      ownedGroups: Prisma.$GroupPayload<ExtArgs>[]
      createdInvitationTemplates: Prisma.$InvitationTemplatePayload<ExtArgs>[]
      merits: Prisma.$MeritPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      publications: Prisma.$PublicationPayload<ExtArgs>[]
      createdReports: Prisma.$ReportPayload<ExtArgs>[]
      assignedPermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
      tokens: Prisma.$TokenPayload<ExtArgs>[]
      transactionsTo: Prisma.$TransactionPayload<ExtArgs>[]
      transactionsFrom: Prisma.$TransactionPayload<ExtArgs>[]
      createdTemplates: Prisma.$UIComponentTemplatePayload<ExtArgs>[]
      userAnswers: Prisma.$UserAnswerPayload<ExtArgs>[]
      userChallenges: Prisma.$UserChallengePayload<ExtArgs>[]
      userGroups: Prisma.$UserGroupPayload<ExtArgs>[]
      invitationsReceived: Prisma.$UserInvitationPayload<ExtArgs>[]
      assignedRoles: Prisma.$UserRolePayload<ExtArgs>[]
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      hostedStudyRooms: Prisma.$StudyRoomPayload<ExtArgs>[]
      studyRoomParticipants: Prisma.$StudyRoomParticipantPayload<ExtArgs>[]
      sentChatMessages: Prisma.$StudyRoomMessagePayload<ExtArgs>[]
      personality: Prisma.$PersonalityPayload<ExtArgs> | null
      videoPermissions: Prisma.$VideoPermissionsPayload<ExtArgs>[]
      wallet: Prisma.$WalletPayload<ExtArgs> | null
      createdWorlds: Prisma.$WorldPayload<ExtArgs>[]
      marketplaceItems: Prisma.$MarketplaceItemPayload<ExtArgs>[]
      buyerMatches: Prisma.$MarketplaceMatchPayload<ExtArgs>[]
      sellerMatches: Prisma.$MarketplaceMatchPayload<ExtArgs>[]
      matchMessages: Prisma.$MatchMessagePayload<ExtArgs>[]
      feedbackReports: Prisma.$FeedbackReportPayload<ExtArgs>[]
      adminFeedbackResponses: Prisma.$FeedbackReportPayload<ExtArgs>[]
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string | null
      avatarUrl: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      username: string | null
      firstName: string | null
      lastName: string | null
      documentType: string | null
      documentNumber: string | null
      phone: string | null
      country: string | null
      address: string | null
      status: string
      topUserCount: number
      personalityId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdActivities<T extends User$createdActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    likes<T extends User$likesArgs<ExtArgs> = {}>(args?: Subset<T, User$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany"> | Null>
    createdExperiences<T extends User$createdExperiencesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdExperiencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findMany"> | Null>
    invitationsSent<T extends User$invitationsSentArgs<ExtArgs> = {}>(args?: Subset<T, User$invitationsSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "findMany"> | Null>
    ownedGroups<T extends User$ownedGroupsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany"> | Null>
    createdInvitationTemplates<T extends User$createdInvitationTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdInvitationTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    merits<T extends User$meritsArgs<ExtArgs> = {}>(args?: Subset<T, User$meritsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeritPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    publications<T extends User$publicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$publicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findMany"> | Null>
    createdReports<T extends User$createdReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    assignedPermissions<T extends User$assignedPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    tokens<T extends User$tokensArgs<ExtArgs> = {}>(args?: Subset<T, User$tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany"> | Null>
    transactionsTo<T extends User$transactionsToArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    transactionsFrom<T extends User$transactionsFromArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    createdTemplates<T extends User$createdTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UIComponentTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    userAnswers<T extends User$userAnswersArgs<ExtArgs> = {}>(args?: Subset<T, User$userAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    userChallenges<T extends User$userChallengesArgs<ExtArgs> = {}>(args?: Subset<T, User$userChallengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findMany"> | Null>
    userGroups<T extends User$userGroupsArgs<ExtArgs> = {}>(args?: Subset<T, User$userGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findMany"> | Null>
    invitationsReceived<T extends User$invitationsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$invitationsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    assignedRoles<T extends User$assignedRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    userRoles<T extends User$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    hostedStudyRooms<T extends User$hostedStudyRoomsArgs<ExtArgs> = {}>(args?: Subset<T, User$hostedStudyRoomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyRoomPayload<ExtArgs>, T, "findMany"> | Null>
    studyRoomParticipants<T extends User$studyRoomParticipantsArgs<ExtArgs> = {}>(args?: Subset<T, User$studyRoomParticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyRoomParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    sentChatMessages<T extends User$sentChatMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentChatMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyRoomMessagePayload<ExtArgs>, T, "findMany"> | Null>
    personality<T extends User$personalityArgs<ExtArgs> = {}>(args?: Subset<T, User$personalityArgs<ExtArgs>>): Prisma__PersonalityClient<$Result.GetResult<Prisma.$PersonalityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    videoPermissions<T extends User$videoPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$videoPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPermissionsPayload<ExtArgs>, T, "findMany"> | Null>
    wallet<T extends User$walletArgs<ExtArgs> = {}>(args?: Subset<T, User$walletArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdWorlds<T extends User$createdWorldsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdWorldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorldPayload<ExtArgs>, T, "findMany"> | Null>
    marketplaceItems<T extends User$marketplaceItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$marketplaceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findMany"> | Null>
    buyerMatches<T extends User$buyerMatchesArgs<ExtArgs> = {}>(args?: Subset<T, User$buyerMatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceMatchPayload<ExtArgs>, T, "findMany"> | Null>
    sellerMatches<T extends User$sellerMatchesArgs<ExtArgs> = {}>(args?: Subset<T, User$sellerMatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceMatchPayload<ExtArgs>, T, "findMany"> | Null>
    matchMessages<T extends User$matchMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$matchMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchMessagePayload<ExtArgs>, T, "findMany"> | Null>
    feedbackReports<T extends User$feedbackReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbackReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "findMany"> | Null>
    adminFeedbackResponses<T extends User$adminFeedbackResponsesArgs<ExtArgs> = {}>(args?: Subset<T, User$adminFeedbackResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "findMany"> | Null>
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly username: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly documentType: FieldRef<"User", 'String'>
    readonly documentNumber: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
    readonly topUserCount: FieldRef<"User", 'Int'>
    readonly personalityId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.createdActivities
   */
  export type User$createdActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.likes
   */
  export type User$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * User.createdExperiences
   */
  export type User$createdExperiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    where?: ExperienceWhereInput
    orderBy?: ExperienceOrderByWithRelationInput | ExperienceOrderByWithRelationInput[]
    cursor?: ExperienceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExperienceScalarFieldEnum | ExperienceScalarFieldEnum[]
  }

  /**
   * User.invitationsSent
   */
  export type User$invitationsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    where?: GiftCardWhereInput
    orderBy?: GiftCardOrderByWithRelationInput | GiftCardOrderByWithRelationInput[]
    cursor?: GiftCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GiftCardScalarFieldEnum | GiftCardScalarFieldEnum[]
  }

  /**
   * User.ownedGroups
   */
  export type User$ownedGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * User.createdInvitationTemplates
   */
  export type User$createdInvitationTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    where?: InvitationTemplateWhereInput
    orderBy?: InvitationTemplateOrderByWithRelationInput | InvitationTemplateOrderByWithRelationInput[]
    cursor?: InvitationTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationTemplateScalarFieldEnum | InvitationTemplateScalarFieldEnum[]
  }

  /**
   * User.merits
   */
  export type User$meritsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merit
     */
    select?: MeritSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeritInclude<ExtArgs> | null
    where?: MeritWhereInput
    orderBy?: MeritOrderByWithRelationInput | MeritOrderByWithRelationInput[]
    cursor?: MeritWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeritScalarFieldEnum | MeritScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.publications
   */
  export type User$publicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    where?: PublicationWhereInput
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    cursor?: PublicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }

  /**
   * User.createdReports
   */
  export type User$createdReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.assignedPermissions
   */
  export type User$assignedPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * User.tokens
   */
  export type User$tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    cursor?: TokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * User.transactionsTo
   */
  export type User$transactionsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.transactionsFrom
   */
  export type User$transactionsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.createdTemplates
   */
  export type User$createdTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UIComponentTemplate
     */
    select?: UIComponentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UIComponentTemplateInclude<ExtArgs> | null
    where?: UIComponentTemplateWhereInput
    orderBy?: UIComponentTemplateOrderByWithRelationInput | UIComponentTemplateOrderByWithRelationInput[]
    cursor?: UIComponentTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UIComponentTemplateScalarFieldEnum | UIComponentTemplateScalarFieldEnum[]
  }

  /**
   * User.userAnswers
   */
  export type User$userAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    where?: UserAnswerWhereInput
    orderBy?: UserAnswerOrderByWithRelationInput | UserAnswerOrderByWithRelationInput[]
    cursor?: UserAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAnswerScalarFieldEnum | UserAnswerScalarFieldEnum[]
  }

  /**
   * User.userChallenges
   */
  export type User$userChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    where?: UserChallengeWhereInput
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    cursor?: UserChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserChallengeScalarFieldEnum | UserChallengeScalarFieldEnum[]
  }

  /**
   * User.userGroups
   */
  export type User$userGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    where?: UserGroupWhereInput
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    cursor?: UserGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * User.invitationsReceived
   */
  export type User$invitationsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    where?: UserInvitationWhereInput
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    cursor?: UserInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * User.assignedRoles
   */
  export type User$assignedRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.userRoles
   */
  export type User$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.hostedStudyRooms
   */
  export type User$hostedStudyRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoom
     */
    select?: StudyRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomInclude<ExtArgs> | null
    where?: StudyRoomWhereInput
    orderBy?: StudyRoomOrderByWithRelationInput | StudyRoomOrderByWithRelationInput[]
    cursor?: StudyRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudyRoomScalarFieldEnum | StudyRoomScalarFieldEnum[]
  }

  /**
   * User.studyRoomParticipants
   */
  export type User$studyRoomParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomParticipant
     */
    select?: StudyRoomParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomParticipantInclude<ExtArgs> | null
    where?: StudyRoomParticipantWhereInput
    orderBy?: StudyRoomParticipantOrderByWithRelationInput | StudyRoomParticipantOrderByWithRelationInput[]
    cursor?: StudyRoomParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudyRoomParticipantScalarFieldEnum | StudyRoomParticipantScalarFieldEnum[]
  }

  /**
   * User.sentChatMessages
   */
  export type User$sentChatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomMessage
     */
    select?: StudyRoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomMessageInclude<ExtArgs> | null
    where?: StudyRoomMessageWhereInput
    orderBy?: StudyRoomMessageOrderByWithRelationInput | StudyRoomMessageOrderByWithRelationInput[]
    cursor?: StudyRoomMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudyRoomMessageScalarFieldEnum | StudyRoomMessageScalarFieldEnum[]
  }

  /**
   * User.personality
   */
  export type User$personalityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personality
     */
    select?: PersonalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityInclude<ExtArgs> | null
    where?: PersonalityWhereInput
  }

  /**
   * User.videoPermissions
   */
  export type User$videoPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoPermissions
     */
    select?: VideoPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoPermissionsInclude<ExtArgs> | null
    where?: VideoPermissionsWhereInput
    orderBy?: VideoPermissionsOrderByWithRelationInput | VideoPermissionsOrderByWithRelationInput[]
    cursor?: VideoPermissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoPermissionsScalarFieldEnum | VideoPermissionsScalarFieldEnum[]
  }

  /**
   * User.wallet
   */
  export type User$walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
  }

  /**
   * User.createdWorlds
   */
  export type User$createdWorldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the World
     */
    select?: WorldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorldInclude<ExtArgs> | null
    where?: WorldWhereInput
    orderBy?: WorldOrderByWithRelationInput | WorldOrderByWithRelationInput[]
    cursor?: WorldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorldScalarFieldEnum | WorldScalarFieldEnum[]
  }

  /**
   * User.marketplaceItems
   */
  export type User$marketplaceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    where?: MarketplaceItemWhereInput
    orderBy?: MarketplaceItemOrderByWithRelationInput | MarketplaceItemOrderByWithRelationInput[]
    cursor?: MarketplaceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketplaceItemScalarFieldEnum | MarketplaceItemScalarFieldEnum[]
  }

  /**
   * User.buyerMatches
   */
  export type User$buyerMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceMatch
     */
    select?: MarketplaceMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceMatchInclude<ExtArgs> | null
    where?: MarketplaceMatchWhereInput
    orderBy?: MarketplaceMatchOrderByWithRelationInput | MarketplaceMatchOrderByWithRelationInput[]
    cursor?: MarketplaceMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketplaceMatchScalarFieldEnum | MarketplaceMatchScalarFieldEnum[]
  }

  /**
   * User.sellerMatches
   */
  export type User$sellerMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceMatch
     */
    select?: MarketplaceMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceMatchInclude<ExtArgs> | null
    where?: MarketplaceMatchWhereInput
    orderBy?: MarketplaceMatchOrderByWithRelationInput | MarketplaceMatchOrderByWithRelationInput[]
    cursor?: MarketplaceMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketplaceMatchScalarFieldEnum | MarketplaceMatchScalarFieldEnum[]
  }

  /**
   * User.matchMessages
   */
  export type User$matchMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMessage
     */
    select?: MatchMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMessageInclude<ExtArgs> | null
    where?: MatchMessageWhereInput
    orderBy?: MatchMessageOrderByWithRelationInput | MatchMessageOrderByWithRelationInput[]
    cursor?: MatchMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchMessageScalarFieldEnum | MatchMessageScalarFieldEnum[]
  }

  /**
   * User.feedbackReports
   */
  export type User$feedbackReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    where?: FeedbackReportWhereInput
    orderBy?: FeedbackReportOrderByWithRelationInput | FeedbackReportOrderByWithRelationInput[]
    cursor?: FeedbackReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackReportScalarFieldEnum | FeedbackReportScalarFieldEnum[]
  }

  /**
   * User.adminFeedbackResponses
   */
  export type User$adminFeedbackResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    where?: FeedbackReportWhereInput
    orderBy?: FeedbackReportOrderByWithRelationInput | FeedbackReportOrderByWithRelationInput[]
    cursor?: FeedbackReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackReportScalarFieldEnum | FeedbackReportScalarFieldEnum[]
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rolePermissions?: boolean | Role$rolePermissionsArgs<ExtArgs>
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | Role$rolePermissionsArgs<ExtArgs>
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      rolePermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolePermissions<T extends Role$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    userRoles<T extends Role$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, Role$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.rolePermissions
   */
  export type Role$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role.userRoles
   */
  export type Role$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    userId: string | null
    roleId: string | null
    assignedAt: Date | null
    assignedById: string | null
  }

  export type UserRoleMaxAggregateOutputType = {
    userId: string | null
    roleId: string | null
    assignedAt: Date | null
    assignedById: string | null
  }

  export type UserRoleCountAggregateOutputType = {
    userId: number
    roleId: number
    assignedAt: number
    assignedById: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    userId?: true
    roleId?: true
    assignedAt?: true
    assignedById?: true
  }

  export type UserRoleMaxAggregateInputType = {
    userId?: true
    roleId?: true
    assignedAt?: true
    assignedById?: true
  }

  export type UserRoleCountAggregateInputType = {
    userId?: true
    roleId?: true
    assignedAt?: true
    assignedById?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    userId: string
    roleId: string
    assignedAt: Date
    assignedById: string | null
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedById?: boolean
    assignedBy?: boolean | UserRole$assignedByArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedById?: boolean
    assignedBy?: boolean | UserRole$assignedByArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedById?: boolean
  }

  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedBy?: boolean | UserRole$assignedByArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedBy?: boolean | UserRole$assignedByArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      assignedBy: Prisma.$UserPayload<ExtArgs> | null
      role: Prisma.$RolePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      roleId: string
      assignedAt: Date
      assignedById: string | null
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedBy<T extends UserRole$assignedByArgs<ExtArgs> = {}>(args?: Subset<T, UserRole$assignedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */ 
  interface UserRoleFieldRefs {
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
    readonly assignedAt: FieldRef<"UserRole", 'DateTime'>
    readonly assignedById: FieldRef<"UserRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole.assignedBy
   */
  export type UserRole$assignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      rolePermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolePermissions<T extends Permission$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission.rolePermissions
   */
  export type Permission$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model VideoPermissions
   */

  export type AggregateVideoPermissions = {
    _count: VideoPermissionsCountAggregateOutputType | null
    _avg: VideoPermissionsAvgAggregateOutputType | null
    _sum: VideoPermissionsSumAggregateOutputType | null
    _min: VideoPermissionsMinAggregateOutputType | null
    _max: VideoPermissionsMaxAggregateOutputType | null
  }

  export type VideoPermissionsAvgAggregateOutputType = {
    videoItemId: number | null
  }

  export type VideoPermissionsSumAggregateOutputType = {
    videoItemId: number | null
  }

  export type VideoPermissionsMinAggregateOutputType = {
    id: string | null
    videoItemId: number | null
    showWaveCount: boolean | null
    showVideos: boolean | null
    showVideoSubtitles: boolean | null
    showComments: boolean | null
    showPublishDate: boolean | null
    showVideoDuration: boolean | null
    showLikeButton: boolean | null
    allowRewindForward: boolean | null
    allowViewComments: boolean | null
    allowMakeComments: boolean | null
    showLikeComments: boolean | null
    sortCommentsByAffinity: boolean | null
    showCommenterName: boolean | null
    playlistPosition: string | null
    isDraft: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type VideoPermissionsMaxAggregateOutputType = {
    id: string | null
    videoItemId: number | null
    showWaveCount: boolean | null
    showVideos: boolean | null
    showVideoSubtitles: boolean | null
    showComments: boolean | null
    showPublishDate: boolean | null
    showVideoDuration: boolean | null
    showLikeButton: boolean | null
    allowRewindForward: boolean | null
    allowViewComments: boolean | null
    allowMakeComments: boolean | null
    showLikeComments: boolean | null
    sortCommentsByAffinity: boolean | null
    showCommenterName: boolean | null
    playlistPosition: string | null
    isDraft: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type VideoPermissionsCountAggregateOutputType = {
    id: number
    videoItemId: number
    showWaveCount: number
    showVideos: number
    showVideoSubtitles: number
    showComments: number
    showPublishDate: number
    showVideoDuration: number
    showLikeButton: number
    allowRewindForward: number
    allowViewComments: number
    allowMakeComments: number
    showLikeComments: number
    sortCommentsByAffinity: number
    showCommenterName: number
    playlistPosition: number
    isDraft: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type VideoPermissionsAvgAggregateInputType = {
    videoItemId?: true
  }

  export type VideoPermissionsSumAggregateInputType = {
    videoItemId?: true
  }

  export type VideoPermissionsMinAggregateInputType = {
    id?: true
    videoItemId?: true
    showWaveCount?: true
    showVideos?: true
    showVideoSubtitles?: true
    showComments?: true
    showPublishDate?: true
    showVideoDuration?: true
    showLikeButton?: true
    allowRewindForward?: true
    allowViewComments?: true
    allowMakeComments?: true
    showLikeComments?: true
    sortCommentsByAffinity?: true
    showCommenterName?: true
    playlistPosition?: true
    isDraft?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type VideoPermissionsMaxAggregateInputType = {
    id?: true
    videoItemId?: true
    showWaveCount?: true
    showVideos?: true
    showVideoSubtitles?: true
    showComments?: true
    showPublishDate?: true
    showVideoDuration?: true
    showLikeButton?: true
    allowRewindForward?: true
    allowViewComments?: true
    allowMakeComments?: true
    showLikeComments?: true
    sortCommentsByAffinity?: true
    showCommenterName?: true
    playlistPosition?: true
    isDraft?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type VideoPermissionsCountAggregateInputType = {
    id?: true
    videoItemId?: true
    showWaveCount?: true
    showVideos?: true
    showVideoSubtitles?: true
    showComments?: true
    showPublishDate?: true
    showVideoDuration?: true
    showLikeButton?: true
    allowRewindForward?: true
    allowViewComments?: true
    allowMakeComments?: true
    showLikeComments?: true
    sortCommentsByAffinity?: true
    showCommenterName?: true
    playlistPosition?: true
    isDraft?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type VideoPermissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoPermissions to aggregate.
     */
    where?: VideoPermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoPermissions to fetch.
     */
    orderBy?: VideoPermissionsOrderByWithRelationInput | VideoPermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoPermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoPermissions
    **/
    _count?: true | VideoPermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoPermissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoPermissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoPermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoPermissionsMaxAggregateInputType
  }

  export type GetVideoPermissionsAggregateType<T extends VideoPermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoPermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoPermissions[P]>
      : GetScalarType<T[P], AggregateVideoPermissions[P]>
  }




  export type VideoPermissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoPermissionsWhereInput
    orderBy?: VideoPermissionsOrderByWithAggregationInput | VideoPermissionsOrderByWithAggregationInput[]
    by: VideoPermissionsScalarFieldEnum[] | VideoPermissionsScalarFieldEnum
    having?: VideoPermissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoPermissionsCountAggregateInputType | true
    _avg?: VideoPermissionsAvgAggregateInputType
    _sum?: VideoPermissionsSumAggregateInputType
    _min?: VideoPermissionsMinAggregateInputType
    _max?: VideoPermissionsMaxAggregateInputType
  }

  export type VideoPermissionsGroupByOutputType = {
    id: string
    videoItemId: number
    showWaveCount: boolean
    showVideos: boolean
    showVideoSubtitles: boolean
    showComments: boolean
    showPublishDate: boolean
    showVideoDuration: boolean
    showLikeButton: boolean
    allowRewindForward: boolean
    allowViewComments: boolean
    allowMakeComments: boolean
    showLikeComments: boolean
    sortCommentsByAffinity: boolean
    showCommenterName: boolean
    playlistPosition: string
    isDraft: boolean
    createdAt: Date
    updatedAt: Date
    createdById: string | null
    _count: VideoPermissionsCountAggregateOutputType | null
    _avg: VideoPermissionsAvgAggregateOutputType | null
    _sum: VideoPermissionsSumAggregateOutputType | null
    _min: VideoPermissionsMinAggregateOutputType | null
    _max: VideoPermissionsMaxAggregateOutputType | null
  }

  type GetVideoPermissionsGroupByPayload<T extends VideoPermissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoPermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoPermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoPermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], VideoPermissionsGroupByOutputType[P]>
        }
      >
    >


  export type VideoPermissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoItemId?: boolean
    showWaveCount?: boolean
    showVideos?: boolean
    showVideoSubtitles?: boolean
    showComments?: boolean
    showPublishDate?: boolean
    showVideoDuration?: boolean
    showLikeButton?: boolean
    allowRewindForward?: boolean
    allowViewComments?: boolean
    allowMakeComments?: boolean
    showLikeComments?: boolean
    sortCommentsByAffinity?: boolean
    showCommenterName?: boolean
    playlistPosition?: boolean
    isDraft?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | VideoPermissions$createdByArgs<ExtArgs>
    videoItem?: boolean | VideoItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoPermissions"]>

  export type VideoPermissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoItemId?: boolean
    showWaveCount?: boolean
    showVideos?: boolean
    showVideoSubtitles?: boolean
    showComments?: boolean
    showPublishDate?: boolean
    showVideoDuration?: boolean
    showLikeButton?: boolean
    allowRewindForward?: boolean
    allowViewComments?: boolean
    allowMakeComments?: boolean
    showLikeComments?: boolean
    sortCommentsByAffinity?: boolean
    showCommenterName?: boolean
    playlistPosition?: boolean
    isDraft?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | VideoPermissions$createdByArgs<ExtArgs>
    videoItem?: boolean | VideoItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoPermissions"]>

  export type VideoPermissionsSelectScalar = {
    id?: boolean
    videoItemId?: boolean
    showWaveCount?: boolean
    showVideos?: boolean
    showVideoSubtitles?: boolean
    showComments?: boolean
    showPublishDate?: boolean
    showVideoDuration?: boolean
    showLikeButton?: boolean
    allowRewindForward?: boolean
    allowViewComments?: boolean
    allowMakeComments?: boolean
    showLikeComments?: boolean
    sortCommentsByAffinity?: boolean
    showCommenterName?: boolean
    playlistPosition?: boolean
    isDraft?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type VideoPermissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | VideoPermissions$createdByArgs<ExtArgs>
    videoItem?: boolean | VideoItemDefaultArgs<ExtArgs>
  }
  export type VideoPermissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | VideoPermissions$createdByArgs<ExtArgs>
    videoItem?: boolean | VideoItemDefaultArgs<ExtArgs>
  }

  export type $VideoPermissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoPermissions"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      videoItem: Prisma.$VideoItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      videoItemId: number
      showWaveCount: boolean
      showVideos: boolean
      showVideoSubtitles: boolean
      showComments: boolean
      showPublishDate: boolean
      showVideoDuration: boolean
      showLikeButton: boolean
      allowRewindForward: boolean
      allowViewComments: boolean
      allowMakeComments: boolean
      showLikeComments: boolean
      sortCommentsByAffinity: boolean
      showCommenterName: boolean
      playlistPosition: string
      isDraft: boolean
      createdAt: Date
      updatedAt: Date
      createdById: string | null
    }, ExtArgs["result"]["videoPermissions"]>
    composites: {}
  }

  type VideoPermissionsGetPayload<S extends boolean | null | undefined | VideoPermissionsDefaultArgs> = $Result.GetResult<Prisma.$VideoPermissionsPayload, S>

  type VideoPermissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VideoPermissionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VideoPermissionsCountAggregateInputType | true
    }

  export interface VideoPermissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoPermissions'], meta: { name: 'VideoPermissions' } }
    /**
     * Find zero or one VideoPermissions that matches the filter.
     * @param {VideoPermissionsFindUniqueArgs} args - Arguments to find a VideoPermissions
     * @example
     * // Get one VideoPermissions
     * const videoPermissions = await prisma.videoPermissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoPermissionsFindUniqueArgs>(args: SelectSubset<T, VideoPermissionsFindUniqueArgs<ExtArgs>>): Prisma__VideoPermissionsClient<$Result.GetResult<Prisma.$VideoPermissionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VideoPermissions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VideoPermissionsFindUniqueOrThrowArgs} args - Arguments to find a VideoPermissions
     * @example
     * // Get one VideoPermissions
     * const videoPermissions = await prisma.videoPermissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoPermissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoPermissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoPermissionsClient<$Result.GetResult<Prisma.$VideoPermissionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VideoPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoPermissionsFindFirstArgs} args - Arguments to find a VideoPermissions
     * @example
     * // Get one VideoPermissions
     * const videoPermissions = await prisma.videoPermissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoPermissionsFindFirstArgs>(args?: SelectSubset<T, VideoPermissionsFindFirstArgs<ExtArgs>>): Prisma__VideoPermissionsClient<$Result.GetResult<Prisma.$VideoPermissionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VideoPermissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoPermissionsFindFirstOrThrowArgs} args - Arguments to find a VideoPermissions
     * @example
     * // Get one VideoPermissions
     * const videoPermissions = await prisma.videoPermissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoPermissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoPermissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoPermissionsClient<$Result.GetResult<Prisma.$VideoPermissionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VideoPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoPermissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoPermissions
     * const videoPermissions = await prisma.videoPermissions.findMany()
     * 
     * // Get first 10 VideoPermissions
     * const videoPermissions = await prisma.videoPermissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoPermissionsWithIdOnly = await prisma.videoPermissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoPermissionsFindManyArgs>(args?: SelectSubset<T, VideoPermissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPermissionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VideoPermissions.
     * @param {VideoPermissionsCreateArgs} args - Arguments to create a VideoPermissions.
     * @example
     * // Create one VideoPermissions
     * const VideoPermissions = await prisma.videoPermissions.create({
     *   data: {
     *     // ... data to create a VideoPermissions
     *   }
     * })
     * 
     */
    create<T extends VideoPermissionsCreateArgs>(args: SelectSubset<T, VideoPermissionsCreateArgs<ExtArgs>>): Prisma__VideoPermissionsClient<$Result.GetResult<Prisma.$VideoPermissionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VideoPermissions.
     * @param {VideoPermissionsCreateManyArgs} args - Arguments to create many VideoPermissions.
     * @example
     * // Create many VideoPermissions
     * const videoPermissions = await prisma.videoPermissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoPermissionsCreateManyArgs>(args?: SelectSubset<T, VideoPermissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoPermissions and returns the data saved in the database.
     * @param {VideoPermissionsCreateManyAndReturnArgs} args - Arguments to create many VideoPermissions.
     * @example
     * // Create many VideoPermissions
     * const videoPermissions = await prisma.videoPermissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoPermissions and only return the `id`
     * const videoPermissionsWithIdOnly = await prisma.videoPermissions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoPermissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoPermissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPermissionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VideoPermissions.
     * @param {VideoPermissionsDeleteArgs} args - Arguments to delete one VideoPermissions.
     * @example
     * // Delete one VideoPermissions
     * const VideoPermissions = await prisma.videoPermissions.delete({
     *   where: {
     *     // ... filter to delete one VideoPermissions
     *   }
     * })
     * 
     */
    delete<T extends VideoPermissionsDeleteArgs>(args: SelectSubset<T, VideoPermissionsDeleteArgs<ExtArgs>>): Prisma__VideoPermissionsClient<$Result.GetResult<Prisma.$VideoPermissionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VideoPermissions.
     * @param {VideoPermissionsUpdateArgs} args - Arguments to update one VideoPermissions.
     * @example
     * // Update one VideoPermissions
     * const videoPermissions = await prisma.videoPermissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoPermissionsUpdateArgs>(args: SelectSubset<T, VideoPermissionsUpdateArgs<ExtArgs>>): Prisma__VideoPermissionsClient<$Result.GetResult<Prisma.$VideoPermissionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VideoPermissions.
     * @param {VideoPermissionsDeleteManyArgs} args - Arguments to filter VideoPermissions to delete.
     * @example
     * // Delete a few VideoPermissions
     * const { count } = await prisma.videoPermissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoPermissionsDeleteManyArgs>(args?: SelectSubset<T, VideoPermissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoPermissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoPermissions
     * const videoPermissions = await prisma.videoPermissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoPermissionsUpdateManyArgs>(args: SelectSubset<T, VideoPermissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VideoPermissions.
     * @param {VideoPermissionsUpsertArgs} args - Arguments to update or create a VideoPermissions.
     * @example
     * // Update or create a VideoPermissions
     * const videoPermissions = await prisma.videoPermissions.upsert({
     *   create: {
     *     // ... data to create a VideoPermissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoPermissions we want to update
     *   }
     * })
     */
    upsert<T extends VideoPermissionsUpsertArgs>(args: SelectSubset<T, VideoPermissionsUpsertArgs<ExtArgs>>): Prisma__VideoPermissionsClient<$Result.GetResult<Prisma.$VideoPermissionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VideoPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoPermissionsCountArgs} args - Arguments to filter VideoPermissions to count.
     * @example
     * // Count the number of VideoPermissions
     * const count = await prisma.videoPermissions.count({
     *   where: {
     *     // ... the filter for the VideoPermissions we want to count
     *   }
     * })
    **/
    count<T extends VideoPermissionsCountArgs>(
      args?: Subset<T, VideoPermissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoPermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoPermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoPermissionsAggregateArgs>(args: Subset<T, VideoPermissionsAggregateArgs>): Prisma.PrismaPromise<GetVideoPermissionsAggregateType<T>>

    /**
     * Group by VideoPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoPermissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoPermissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoPermissionsGroupByArgs['orderBy'] }
        : { orderBy?: VideoPermissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoPermissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoPermissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoPermissions model
   */
  readonly fields: VideoPermissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoPermissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoPermissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends VideoPermissions$createdByArgs<ExtArgs> = {}>(args?: Subset<T, VideoPermissions$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    videoItem<T extends VideoItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoItemDefaultArgs<ExtArgs>>): Prisma__VideoItemClient<$Result.GetResult<Prisma.$VideoItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoPermissions model
   */ 
  interface VideoPermissionsFieldRefs {
    readonly id: FieldRef<"VideoPermissions", 'String'>
    readonly videoItemId: FieldRef<"VideoPermissions", 'Int'>
    readonly showWaveCount: FieldRef<"VideoPermissions", 'Boolean'>
    readonly showVideos: FieldRef<"VideoPermissions", 'Boolean'>
    readonly showVideoSubtitles: FieldRef<"VideoPermissions", 'Boolean'>
    readonly showComments: FieldRef<"VideoPermissions", 'Boolean'>
    readonly showPublishDate: FieldRef<"VideoPermissions", 'Boolean'>
    readonly showVideoDuration: FieldRef<"VideoPermissions", 'Boolean'>
    readonly showLikeButton: FieldRef<"VideoPermissions", 'Boolean'>
    readonly allowRewindForward: FieldRef<"VideoPermissions", 'Boolean'>
    readonly allowViewComments: FieldRef<"VideoPermissions", 'Boolean'>
    readonly allowMakeComments: FieldRef<"VideoPermissions", 'Boolean'>
    readonly showLikeComments: FieldRef<"VideoPermissions", 'Boolean'>
    readonly sortCommentsByAffinity: FieldRef<"VideoPermissions", 'Boolean'>
    readonly showCommenterName: FieldRef<"VideoPermissions", 'Boolean'>
    readonly playlistPosition: FieldRef<"VideoPermissions", 'String'>
    readonly isDraft: FieldRef<"VideoPermissions", 'Boolean'>
    readonly createdAt: FieldRef<"VideoPermissions", 'DateTime'>
    readonly updatedAt: FieldRef<"VideoPermissions", 'DateTime'>
    readonly createdById: FieldRef<"VideoPermissions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VideoPermissions findUnique
   */
  export type VideoPermissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoPermissions
     */
    select?: VideoPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoPermissionsInclude<ExtArgs> | null
    /**
     * Filter, which VideoPermissions to fetch.
     */
    where: VideoPermissionsWhereUniqueInput
  }

  /**
   * VideoPermissions findUniqueOrThrow
   */
  export type VideoPermissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoPermissions
     */
    select?: VideoPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoPermissionsInclude<ExtArgs> | null
    /**
     * Filter, which VideoPermissions to fetch.
     */
    where: VideoPermissionsWhereUniqueInput
  }

  /**
   * VideoPermissions findFirst
   */
  export type VideoPermissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoPermissions
     */
    select?: VideoPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoPermissionsInclude<ExtArgs> | null
    /**
     * Filter, which VideoPermissions to fetch.
     */
    where?: VideoPermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoPermissions to fetch.
     */
    orderBy?: VideoPermissionsOrderByWithRelationInput | VideoPermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoPermissions.
     */
    cursor?: VideoPermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoPermissions.
     */
    distinct?: VideoPermissionsScalarFieldEnum | VideoPermissionsScalarFieldEnum[]
  }

  /**
   * VideoPermissions findFirstOrThrow
   */
  export type VideoPermissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoPermissions
     */
    select?: VideoPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoPermissionsInclude<ExtArgs> | null
    /**
     * Filter, which VideoPermissions to fetch.
     */
    where?: VideoPermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoPermissions to fetch.
     */
    orderBy?: VideoPermissionsOrderByWithRelationInput | VideoPermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoPermissions.
     */
    cursor?: VideoPermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoPermissions.
     */
    distinct?: VideoPermissionsScalarFieldEnum | VideoPermissionsScalarFieldEnum[]
  }

  /**
   * VideoPermissions findMany
   */
  export type VideoPermissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoPermissions
     */
    select?: VideoPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoPermissionsInclude<ExtArgs> | null
    /**
     * Filter, which VideoPermissions to fetch.
     */
    where?: VideoPermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoPermissions to fetch.
     */
    orderBy?: VideoPermissionsOrderByWithRelationInput | VideoPermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoPermissions.
     */
    cursor?: VideoPermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoPermissions.
     */
    skip?: number
    distinct?: VideoPermissionsScalarFieldEnum | VideoPermissionsScalarFieldEnum[]
  }

  /**
   * VideoPermissions create
   */
  export type VideoPermissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoPermissions
     */
    select?: VideoPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoPermissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoPermissions.
     */
    data: XOR<VideoPermissionsCreateInput, VideoPermissionsUncheckedCreateInput>
  }

  /**
   * VideoPermissions createMany
   */
  export type VideoPermissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoPermissions.
     */
    data: VideoPermissionsCreateManyInput | VideoPermissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoPermissions createManyAndReturn
   */
  export type VideoPermissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoPermissions
     */
    select?: VideoPermissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VideoPermissions.
     */
    data: VideoPermissionsCreateManyInput | VideoPermissionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoPermissionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoPermissions update
   */
  export type VideoPermissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoPermissions
     */
    select?: VideoPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoPermissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoPermissions.
     */
    data: XOR<VideoPermissionsUpdateInput, VideoPermissionsUncheckedUpdateInput>
    /**
     * Choose, which VideoPermissions to update.
     */
    where: VideoPermissionsWhereUniqueInput
  }

  /**
   * VideoPermissions updateMany
   */
  export type VideoPermissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoPermissions.
     */
    data: XOR<VideoPermissionsUpdateManyMutationInput, VideoPermissionsUncheckedUpdateManyInput>
    /**
     * Filter which VideoPermissions to update
     */
    where?: VideoPermissionsWhereInput
  }

  /**
   * VideoPermissions upsert
   */
  export type VideoPermissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoPermissions
     */
    select?: VideoPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoPermissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoPermissions to update in case it exists.
     */
    where: VideoPermissionsWhereUniqueInput
    /**
     * In case the VideoPermissions found by the `where` argument doesn't exist, create a new VideoPermissions with this data.
     */
    create: XOR<VideoPermissionsCreateInput, VideoPermissionsUncheckedCreateInput>
    /**
     * In case the VideoPermissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoPermissionsUpdateInput, VideoPermissionsUncheckedUpdateInput>
  }

  /**
   * VideoPermissions delete
   */
  export type VideoPermissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoPermissions
     */
    select?: VideoPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoPermissionsInclude<ExtArgs> | null
    /**
     * Filter which VideoPermissions to delete.
     */
    where: VideoPermissionsWhereUniqueInput
  }

  /**
   * VideoPermissions deleteMany
   */
  export type VideoPermissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoPermissions to delete
     */
    where?: VideoPermissionsWhereInput
  }

  /**
   * VideoPermissions.createdBy
   */
  export type VideoPermissions$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * VideoPermissions without action
   */
  export type VideoPermissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoPermissions
     */
    select?: VideoPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoPermissionsInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    roleId: string | null
    permissionId: string | null
    assignedAt: Date | null
    assignedById: string | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    roleId: string | null
    permissionId: string | null
    assignedAt: Date | null
    assignedById: string | null
  }

  export type RolePermissionCountAggregateOutputType = {
    roleId: number
    permissionId: number
    assignedAt: number
    assignedById: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    roleId?: true
    permissionId?: true
    assignedAt?: true
    assignedById?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    roleId?: true
    permissionId?: true
    assignedAt?: true
    assignedById?: true
  }

  export type RolePermissionCountAggregateInputType = {
    roleId?: true
    permissionId?: true
    assignedAt?: true
    assignedById?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    roleId: string
    permissionId: string
    assignedAt: Date
    assignedById: string | null
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permissionId?: boolean
    assignedAt?: boolean
    assignedById?: boolean
    assignedBy?: boolean | RolePermission$assignedByArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permissionId?: boolean
    assignedAt?: boolean
    assignedById?: boolean
    assignedBy?: boolean | RolePermission$assignedByArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    roleId?: boolean
    permissionId?: boolean
    assignedAt?: boolean
    assignedById?: boolean
  }

  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedBy?: boolean | RolePermission$assignedByArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedBy?: boolean | RolePermission$assignedByArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      assignedBy: Prisma.$UserPayload<ExtArgs> | null
      permission: Prisma.$PermissionPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      roleId: string
      permissionId: string
      assignedAt: Date
      assignedById: string | null
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `roleId`
     * const rolePermissionWithRoleIdOnly = await prisma.rolePermission.findMany({ select: { roleId: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `roleId`
     * const rolePermissionWithRoleIdOnly = await prisma.rolePermission.createManyAndReturn({ 
     *   select: { roleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedBy<T extends RolePermission$assignedByArgs<ExtArgs> = {}>(args?: Subset<T, RolePermission$assignedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */ 
  interface RolePermissionFieldRefs {
    readonly roleId: FieldRef<"RolePermission", 'String'>
    readonly permissionId: FieldRef<"RolePermission", 'String'>
    readonly assignedAt: FieldRef<"RolePermission", 'DateTime'>
    readonly assignedById: FieldRef<"RolePermission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission.assignedBy
   */
  export type RolePermission$assignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model World
   */

  export type AggregateWorld = {
    _count: WorldCountAggregateOutputType | null
    _min: WorldMinAggregateOutputType | null
    _max: WorldMaxAggregateOutputType | null
  }

  export type WorldMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: string | null
    creatorId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    mundoId: string | null
  }

  export type WorldMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: string | null
    creatorId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    mundoId: string | null
  }

  export type WorldCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    creatorId: number
    status: number
    createdAt: number
    updatedAt: number
    mundoId: number
    _all: number
  }


  export type WorldMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    creatorId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    mundoId?: true
  }

  export type WorldMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    creatorId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    mundoId?: true
  }

  export type WorldCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    creatorId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    mundoId?: true
    _all?: true
  }

  export type WorldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which World to aggregate.
     */
    where?: WorldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Worlds to fetch.
     */
    orderBy?: WorldOrderByWithRelationInput | WorldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Worlds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Worlds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Worlds
    **/
    _count?: true | WorldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorldMaxAggregateInputType
  }

  export type GetWorldAggregateType<T extends WorldAggregateArgs> = {
        [P in keyof T & keyof AggregateWorld]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorld[P]>
      : GetScalarType<T[P], AggregateWorld[P]>
  }




  export type WorldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorldWhereInput
    orderBy?: WorldOrderByWithAggregationInput | WorldOrderByWithAggregationInput[]
    by: WorldScalarFieldEnum[] | WorldScalarFieldEnum
    having?: WorldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorldCountAggregateInputType | true
    _min?: WorldMinAggregateInputType
    _max?: WorldMaxAggregateInputType
  }

  export type WorldGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: string
    creatorId: string
    status: string
    createdAt: Date
    updatedAt: Date
    mundoId: string | null
    _count: WorldCountAggregateOutputType | null
    _min: WorldMinAggregateOutputType | null
    _max: WorldMaxAggregateOutputType | null
  }

  type GetWorldGroupByPayload<T extends WorldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorldGroupByOutputType[P]>
            : GetScalarType<T[P], WorldGroupByOutputType[P]>
        }
      >
    >


  export type WorldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    creatorId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mundoId?: boolean
    stages?: boolean | World$stagesArgs<ExtArgs>
    mundo?: boolean | World$mundoArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | WorldCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["world"]>

  export type WorldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    creatorId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mundoId?: boolean
    mundo?: boolean | World$mundoArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["world"]>

  export type WorldSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    creatorId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mundoId?: boolean
  }

  export type WorldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stages?: boolean | World$stagesArgs<ExtArgs>
    mundo?: boolean | World$mundoArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | WorldCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mundo?: boolean | World$mundoArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "World"
    objects: {
      stages: Prisma.$StagePayload<ExtArgs>[]
      mundo: Prisma.$MundoPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: string
      creatorId: string
      status: string
      createdAt: Date
      updatedAt: Date
      mundoId: string | null
    }, ExtArgs["result"]["world"]>
    composites: {}
  }

  type WorldGetPayload<S extends boolean | null | undefined | WorldDefaultArgs> = $Result.GetResult<Prisma.$WorldPayload, S>

  type WorldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorldFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorldCountAggregateInputType | true
    }

  export interface WorldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['World'], meta: { name: 'World' } }
    /**
     * Find zero or one World that matches the filter.
     * @param {WorldFindUniqueArgs} args - Arguments to find a World
     * @example
     * // Get one World
     * const world = await prisma.world.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorldFindUniqueArgs>(args: SelectSubset<T, WorldFindUniqueArgs<ExtArgs>>): Prisma__WorldClient<$Result.GetResult<Prisma.$WorldPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one World that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorldFindUniqueOrThrowArgs} args - Arguments to find a World
     * @example
     * // Get one World
     * const world = await prisma.world.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorldFindUniqueOrThrowArgs>(args: SelectSubset<T, WorldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorldClient<$Result.GetResult<Prisma.$WorldPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first World that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldFindFirstArgs} args - Arguments to find a World
     * @example
     * // Get one World
     * const world = await prisma.world.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorldFindFirstArgs>(args?: SelectSubset<T, WorldFindFirstArgs<ExtArgs>>): Prisma__WorldClient<$Result.GetResult<Prisma.$WorldPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first World that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldFindFirstOrThrowArgs} args - Arguments to find a World
     * @example
     * // Get one World
     * const world = await prisma.world.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorldFindFirstOrThrowArgs>(args?: SelectSubset<T, WorldFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorldClient<$Result.GetResult<Prisma.$WorldPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Worlds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Worlds
     * const worlds = await prisma.world.findMany()
     * 
     * // Get first 10 Worlds
     * const worlds = await prisma.world.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const worldWithIdOnly = await prisma.world.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorldFindManyArgs>(args?: SelectSubset<T, WorldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorldPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a World.
     * @param {WorldCreateArgs} args - Arguments to create a World.
     * @example
     * // Create one World
     * const World = await prisma.world.create({
     *   data: {
     *     // ... data to create a World
     *   }
     * })
     * 
     */
    create<T extends WorldCreateArgs>(args: SelectSubset<T, WorldCreateArgs<ExtArgs>>): Prisma__WorldClient<$Result.GetResult<Prisma.$WorldPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Worlds.
     * @param {WorldCreateManyArgs} args - Arguments to create many Worlds.
     * @example
     * // Create many Worlds
     * const world = await prisma.world.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorldCreateManyArgs>(args?: SelectSubset<T, WorldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Worlds and returns the data saved in the database.
     * @param {WorldCreateManyAndReturnArgs} args - Arguments to create many Worlds.
     * @example
     * // Create many Worlds
     * const world = await prisma.world.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Worlds and only return the `id`
     * const worldWithIdOnly = await prisma.world.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorldCreateManyAndReturnArgs>(args?: SelectSubset<T, WorldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorldPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a World.
     * @param {WorldDeleteArgs} args - Arguments to delete one World.
     * @example
     * // Delete one World
     * const World = await prisma.world.delete({
     *   where: {
     *     // ... filter to delete one World
     *   }
     * })
     * 
     */
    delete<T extends WorldDeleteArgs>(args: SelectSubset<T, WorldDeleteArgs<ExtArgs>>): Prisma__WorldClient<$Result.GetResult<Prisma.$WorldPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one World.
     * @param {WorldUpdateArgs} args - Arguments to update one World.
     * @example
     * // Update one World
     * const world = await prisma.world.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorldUpdateArgs>(args: SelectSubset<T, WorldUpdateArgs<ExtArgs>>): Prisma__WorldClient<$Result.GetResult<Prisma.$WorldPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Worlds.
     * @param {WorldDeleteManyArgs} args - Arguments to filter Worlds to delete.
     * @example
     * // Delete a few Worlds
     * const { count } = await prisma.world.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorldDeleteManyArgs>(args?: SelectSubset<T, WorldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Worlds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Worlds
     * const world = await prisma.world.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorldUpdateManyArgs>(args: SelectSubset<T, WorldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one World.
     * @param {WorldUpsertArgs} args - Arguments to update or create a World.
     * @example
     * // Update or create a World
     * const world = await prisma.world.upsert({
     *   create: {
     *     // ... data to create a World
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the World we want to update
     *   }
     * })
     */
    upsert<T extends WorldUpsertArgs>(args: SelectSubset<T, WorldUpsertArgs<ExtArgs>>): Prisma__WorldClient<$Result.GetResult<Prisma.$WorldPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Worlds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldCountArgs} args - Arguments to filter Worlds to count.
     * @example
     * // Count the number of Worlds
     * const count = await prisma.world.count({
     *   where: {
     *     // ... the filter for the Worlds we want to count
     *   }
     * })
    **/
    count<T extends WorldCountArgs>(
      args?: Subset<T, WorldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a World.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorldAggregateArgs>(args: Subset<T, WorldAggregateArgs>): Prisma.PrismaPromise<GetWorldAggregateType<T>>

    /**
     * Group by World.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorldGroupByArgs['orderBy'] }
        : { orderBy?: WorldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the World model
   */
  readonly fields: WorldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for World.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stages<T extends World$stagesArgs<ExtArgs> = {}>(args?: Subset<T, World$stagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findMany"> | Null>
    mundo<T extends World$mundoArgs<ExtArgs> = {}>(args?: Subset<T, World$mundoArgs<ExtArgs>>): Prisma__MundoClient<$Result.GetResult<Prisma.$MundoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the World model
   */ 
  interface WorldFieldRefs {
    readonly id: FieldRef<"World", 'String'>
    readonly name: FieldRef<"World", 'String'>
    readonly description: FieldRef<"World", 'String'>
    readonly type: FieldRef<"World", 'String'>
    readonly creatorId: FieldRef<"World", 'String'>
    readonly status: FieldRef<"World", 'String'>
    readonly createdAt: FieldRef<"World", 'DateTime'>
    readonly updatedAt: FieldRef<"World", 'DateTime'>
    readonly mundoId: FieldRef<"World", 'String'>
  }
    

  // Custom InputTypes
  /**
   * World findUnique
   */
  export type WorldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the World
     */
    select?: WorldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorldInclude<ExtArgs> | null
    /**
     * Filter, which World to fetch.
     */
    where: WorldWhereUniqueInput
  }

  /**
   * World findUniqueOrThrow
   */
  export type WorldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the World
     */
    select?: WorldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorldInclude<ExtArgs> | null
    /**
     * Filter, which World to fetch.
     */
    where: WorldWhereUniqueInput
  }

  /**
   * World findFirst
   */
  export type WorldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the World
     */
    select?: WorldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorldInclude<ExtArgs> | null
    /**
     * Filter, which World to fetch.
     */
    where?: WorldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Worlds to fetch.
     */
    orderBy?: WorldOrderByWithRelationInput | WorldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Worlds.
     */
    cursor?: WorldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Worlds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Worlds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Worlds.
     */
    distinct?: WorldScalarFieldEnum | WorldScalarFieldEnum[]
  }

  /**
   * World findFirstOrThrow
   */
  export type WorldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the World
     */
    select?: WorldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorldInclude<ExtArgs> | null
    /**
     * Filter, which World to fetch.
     */
    where?: WorldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Worlds to fetch.
     */
    orderBy?: WorldOrderByWithRelationInput | WorldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Worlds.
     */
    cursor?: WorldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Worlds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Worlds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Worlds.
     */
    distinct?: WorldScalarFieldEnum | WorldScalarFieldEnum[]
  }

  /**
   * World findMany
   */
  export type WorldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the World
     */
    select?: WorldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorldInclude<ExtArgs> | null
    /**
     * Filter, which Worlds to fetch.
     */
    where?: WorldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Worlds to fetch.
     */
    orderBy?: WorldOrderByWithRelationInput | WorldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Worlds.
     */
    cursor?: WorldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Worlds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Worlds.
     */
    skip?: number
    distinct?: WorldScalarFieldEnum | WorldScalarFieldEnum[]
  }

  /**
   * World create
   */
  export type WorldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the World
     */
    select?: WorldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorldInclude<ExtArgs> | null
    /**
     * The data needed to create a World.
     */
    data: XOR<WorldCreateInput, WorldUncheckedCreateInput>
  }

  /**
   * World createMany
   */
  export type WorldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Worlds.
     */
    data: WorldCreateManyInput | WorldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * World createManyAndReturn
   */
  export type WorldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the World
     */
    select?: WorldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Worlds.
     */
    data: WorldCreateManyInput | WorldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * World update
   */
  export type WorldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the World
     */
    select?: WorldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorldInclude<ExtArgs> | null
    /**
     * The data needed to update a World.
     */
    data: XOR<WorldUpdateInput, WorldUncheckedUpdateInput>
    /**
     * Choose, which World to update.
     */
    where: WorldWhereUniqueInput
  }

  /**
   * World updateMany
   */
  export type WorldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Worlds.
     */
    data: XOR<WorldUpdateManyMutationInput, WorldUncheckedUpdateManyInput>
    /**
     * Filter which Worlds to update
     */
    where?: WorldWhereInput
  }

  /**
   * World upsert
   */
  export type WorldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the World
     */
    select?: WorldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorldInclude<ExtArgs> | null
    /**
     * The filter to search for the World to update in case it exists.
     */
    where: WorldWhereUniqueInput
    /**
     * In case the World found by the `where` argument doesn't exist, create a new World with this data.
     */
    create: XOR<WorldCreateInput, WorldUncheckedCreateInput>
    /**
     * In case the World was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorldUpdateInput, WorldUncheckedUpdateInput>
  }

  /**
   * World delete
   */
  export type WorldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the World
     */
    select?: WorldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorldInclude<ExtArgs> | null
    /**
     * Filter which World to delete.
     */
    where: WorldWhereUniqueInput
  }

  /**
   * World deleteMany
   */
  export type WorldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Worlds to delete
     */
    where?: WorldWhereInput
  }

  /**
   * World.stages
   */
  export type World$stagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    where?: StageWhereInput
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    cursor?: StageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StageScalarFieldEnum | StageScalarFieldEnum[]
  }

  /**
   * World.mundo
   */
  export type World$mundoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mundo
     */
    select?: MundoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MundoInclude<ExtArgs> | null
    where?: MundoWhereInput
  }

  /**
   * World without action
   */
  export type WorldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the World
     */
    select?: WorldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorldInclude<ExtArgs> | null
  }


  /**
   * Model Stage
   */

  export type AggregateStage = {
    _count: StageCountAggregateOutputType | null
    _avg: StageAvgAggregateOutputType | null
    _sum: StageSumAggregateOutputType | null
    _min: StageMinAggregateOutputType | null
    _max: StageMaxAggregateOutputType | null
  }

  export type StageAvgAggregateOutputType = {
    order: number | null
  }

  export type StageSumAggregateOutputType = {
    order: number | null
  }

  export type StageMinAggregateOutputType = {
    id: string | null
    worldId: string | null
    name: string | null
    order: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StageMaxAggregateOutputType = {
    id: string | null
    worldId: string | null
    name: string | null
    order: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StageCountAggregateOutputType = {
    id: number
    worldId: number
    name: number
    order: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StageAvgAggregateInputType = {
    order?: true
  }

  export type StageSumAggregateInputType = {
    order?: true
  }

  export type StageMinAggregateInputType = {
    id?: true
    worldId?: true
    name?: true
    order?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StageMaxAggregateInputType = {
    id?: true
    worldId?: true
    name?: true
    order?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StageCountAggregateInputType = {
    id?: true
    worldId?: true
    name?: true
    order?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stage to aggregate.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stages
    **/
    _count?: true | StageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StageMaxAggregateInputType
  }

  export type GetStageAggregateType<T extends StageAggregateArgs> = {
        [P in keyof T & keyof AggregateStage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStage[P]>
      : GetScalarType<T[P], AggregateStage[P]>
  }




  export type StageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageWhereInput
    orderBy?: StageOrderByWithAggregationInput | StageOrderByWithAggregationInput[]
    by: StageScalarFieldEnum[] | StageScalarFieldEnum
    having?: StageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StageCountAggregateInputType | true
    _avg?: StageAvgAggregateInputType
    _sum?: StageSumAggregateInputType
    _min?: StageMinAggregateInputType
    _max?: StageMaxAggregateInputType
  }

  export type StageGroupByOutputType = {
    id: string
    worldId: string
    name: string
    order: number
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: StageCountAggregateOutputType | null
    _avg: StageAvgAggregateOutputType | null
    _sum: StageSumAggregateOutputType | null
    _min: StageMinAggregateOutputType | null
    _max: StageMaxAggregateOutputType | null
  }

  type GetStageGroupByPayload<T extends StageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StageGroupByOutputType[P]>
            : GetScalarType<T[P], StageGroupByOutputType[P]>
        }
      >
    >


  export type StageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    worldId?: boolean
    name?: boolean
    order?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    experiences?: boolean | Stage$experiencesArgs<ExtArgs>
    world?: boolean | WorldDefaultArgs<ExtArgs>
    _count?: boolean | StageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stage"]>

  export type StageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    worldId?: boolean
    name?: boolean
    order?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    world?: boolean | WorldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stage"]>

  export type StageSelectScalar = {
    id?: boolean
    worldId?: boolean
    name?: boolean
    order?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    experiences?: boolean | Stage$experiencesArgs<ExtArgs>
    world?: boolean | WorldDefaultArgs<ExtArgs>
    _count?: boolean | StageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    world?: boolean | WorldDefaultArgs<ExtArgs>
  }

  export type $StagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stage"
    objects: {
      experiences: Prisma.$ExperiencePayload<ExtArgs>[]
      world: Prisma.$WorldPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      worldId: string
      name: string
      order: number
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stage"]>
    composites: {}
  }

  type StageGetPayload<S extends boolean | null | undefined | StageDefaultArgs> = $Result.GetResult<Prisma.$StagePayload, S>

  type StageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StageCountAggregateInputType | true
    }

  export interface StageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stage'], meta: { name: 'Stage' } }
    /**
     * Find zero or one Stage that matches the filter.
     * @param {StageFindUniqueArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StageFindUniqueArgs>(args: SelectSubset<T, StageFindUniqueArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Stage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StageFindUniqueOrThrowArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StageFindUniqueOrThrowArgs>(args: SelectSubset<T, StageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Stage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageFindFirstArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StageFindFirstArgs>(args?: SelectSubset<T, StageFindFirstArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Stage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageFindFirstOrThrowArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StageFindFirstOrThrowArgs>(args?: SelectSubset<T, StageFindFirstOrThrowArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Stages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stages
     * const stages = await prisma.stage.findMany()
     * 
     * // Get first 10 Stages
     * const stages = await prisma.stage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stageWithIdOnly = await prisma.stage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StageFindManyArgs>(args?: SelectSubset<T, StageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Stage.
     * @param {StageCreateArgs} args - Arguments to create a Stage.
     * @example
     * // Create one Stage
     * const Stage = await prisma.stage.create({
     *   data: {
     *     // ... data to create a Stage
     *   }
     * })
     * 
     */
    create<T extends StageCreateArgs>(args: SelectSubset<T, StageCreateArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Stages.
     * @param {StageCreateManyArgs} args - Arguments to create many Stages.
     * @example
     * // Create many Stages
     * const stage = await prisma.stage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StageCreateManyArgs>(args?: SelectSubset<T, StageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stages and returns the data saved in the database.
     * @param {StageCreateManyAndReturnArgs} args - Arguments to create many Stages.
     * @example
     * // Create many Stages
     * const stage = await prisma.stage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stages and only return the `id`
     * const stageWithIdOnly = await prisma.stage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StageCreateManyAndReturnArgs>(args?: SelectSubset<T, StageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Stage.
     * @param {StageDeleteArgs} args - Arguments to delete one Stage.
     * @example
     * // Delete one Stage
     * const Stage = await prisma.stage.delete({
     *   where: {
     *     // ... filter to delete one Stage
     *   }
     * })
     * 
     */
    delete<T extends StageDeleteArgs>(args: SelectSubset<T, StageDeleteArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Stage.
     * @param {StageUpdateArgs} args - Arguments to update one Stage.
     * @example
     * // Update one Stage
     * const stage = await prisma.stage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StageUpdateArgs>(args: SelectSubset<T, StageUpdateArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Stages.
     * @param {StageDeleteManyArgs} args - Arguments to filter Stages to delete.
     * @example
     * // Delete a few Stages
     * const { count } = await prisma.stage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StageDeleteManyArgs>(args?: SelectSubset<T, StageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stages
     * const stage = await prisma.stage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StageUpdateManyArgs>(args: SelectSubset<T, StageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stage.
     * @param {StageUpsertArgs} args - Arguments to update or create a Stage.
     * @example
     * // Update or create a Stage
     * const stage = await prisma.stage.upsert({
     *   create: {
     *     // ... data to create a Stage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stage we want to update
     *   }
     * })
     */
    upsert<T extends StageUpsertArgs>(args: SelectSubset<T, StageUpsertArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Stages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageCountArgs} args - Arguments to filter Stages to count.
     * @example
     * // Count the number of Stages
     * const count = await prisma.stage.count({
     *   where: {
     *     // ... the filter for the Stages we want to count
     *   }
     * })
    **/
    count<T extends StageCountArgs>(
      args?: Subset<T, StageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StageAggregateArgs>(args: Subset<T, StageAggregateArgs>): Prisma.PrismaPromise<GetStageAggregateType<T>>

    /**
     * Group by Stage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StageGroupByArgs['orderBy'] }
        : { orderBy?: StageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stage model
   */
  readonly fields: StageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    experiences<T extends Stage$experiencesArgs<ExtArgs> = {}>(args?: Subset<T, Stage$experiencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findMany"> | Null>
    world<T extends WorldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorldDefaultArgs<ExtArgs>>): Prisma__WorldClient<$Result.GetResult<Prisma.$WorldPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stage model
   */ 
  interface StageFieldRefs {
    readonly id: FieldRef<"Stage", 'String'>
    readonly worldId: FieldRef<"Stage", 'String'>
    readonly name: FieldRef<"Stage", 'String'>
    readonly order: FieldRef<"Stage", 'Int'>
    readonly description: FieldRef<"Stage", 'String'>
    readonly createdAt: FieldRef<"Stage", 'DateTime'>
    readonly updatedAt: FieldRef<"Stage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stage findUnique
   */
  export type StageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stage to fetch.
     */
    where: StageWhereUniqueInput
  }

  /**
   * Stage findUniqueOrThrow
   */
  export type StageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stage to fetch.
     */
    where: StageWhereUniqueInput
  }

  /**
   * Stage findFirst
   */
  export type StageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stage to fetch.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stages.
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stages.
     */
    distinct?: StageScalarFieldEnum | StageScalarFieldEnum[]
  }

  /**
   * Stage findFirstOrThrow
   */
  export type StageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stage to fetch.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stages.
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stages.
     */
    distinct?: StageScalarFieldEnum | StageScalarFieldEnum[]
  }

  /**
   * Stage findMany
   */
  export type StageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stages to fetch.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stages.
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    distinct?: StageScalarFieldEnum | StageScalarFieldEnum[]
  }

  /**
   * Stage create
   */
  export type StageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * The data needed to create a Stage.
     */
    data: XOR<StageCreateInput, StageUncheckedCreateInput>
  }

  /**
   * Stage createMany
   */
  export type StageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stages.
     */
    data: StageCreateManyInput | StageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stage createManyAndReturn
   */
  export type StageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Stages.
     */
    data: StageCreateManyInput | StageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stage update
   */
  export type StageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * The data needed to update a Stage.
     */
    data: XOR<StageUpdateInput, StageUncheckedUpdateInput>
    /**
     * Choose, which Stage to update.
     */
    where: StageWhereUniqueInput
  }

  /**
   * Stage updateMany
   */
  export type StageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stages.
     */
    data: XOR<StageUpdateManyMutationInput, StageUncheckedUpdateManyInput>
    /**
     * Filter which Stages to update
     */
    where?: StageWhereInput
  }

  /**
   * Stage upsert
   */
  export type StageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * The filter to search for the Stage to update in case it exists.
     */
    where: StageWhereUniqueInput
    /**
     * In case the Stage found by the `where` argument doesn't exist, create a new Stage with this data.
     */
    create: XOR<StageCreateInput, StageUncheckedCreateInput>
    /**
     * In case the Stage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StageUpdateInput, StageUncheckedUpdateInput>
  }

  /**
   * Stage delete
   */
  export type StageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter which Stage to delete.
     */
    where: StageWhereUniqueInput
  }

  /**
   * Stage deleteMany
   */
  export type StageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stages to delete
     */
    where?: StageWhereInput
  }

  /**
   * Stage.experiences
   */
  export type Stage$experiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    where?: ExperienceWhereInput
    orderBy?: ExperienceOrderByWithRelationInput | ExperienceOrderByWithRelationInput[]
    cursor?: ExperienceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExperienceScalarFieldEnum | ExperienceScalarFieldEnum[]
  }

  /**
   * Stage without action
   */
  export type StageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
  }


  /**
   * Model Experience
   */

  export type AggregateExperience = {
    _count: ExperienceCountAggregateOutputType | null
    _min: ExperienceMinAggregateOutputType | null
    _max: ExperienceMaxAggregateOutputType | null
  }

  export type ExperienceMinAggregateOutputType = {
    id: string | null
    stageId: string | null
    title: string | null
    description: string | null
    type: string | null
    gamificationFramework: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExperienceMaxAggregateOutputType = {
    id: string | null
    stageId: string | null
    title: string | null
    description: string | null
    type: string | null
    gamificationFramework: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExperienceCountAggregateOutputType = {
    id: number
    stageId: number
    title: number
    description: number
    type: number
    gamificationFramework: number
    creatorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExperienceMinAggregateInputType = {
    id?: true
    stageId?: true
    title?: true
    description?: true
    type?: true
    gamificationFramework?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExperienceMaxAggregateInputType = {
    id?: true
    stageId?: true
    title?: true
    description?: true
    type?: true
    gamificationFramework?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExperienceCountAggregateInputType = {
    id?: true
    stageId?: true
    title?: true
    description?: true
    type?: true
    gamificationFramework?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExperienceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Experience to aggregate.
     */
    where?: ExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Experiences to fetch.
     */
    orderBy?: ExperienceOrderByWithRelationInput | ExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Experiences
    **/
    _count?: true | ExperienceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExperienceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExperienceMaxAggregateInputType
  }

  export type GetExperienceAggregateType<T extends ExperienceAggregateArgs> = {
        [P in keyof T & keyof AggregateExperience]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExperience[P]>
      : GetScalarType<T[P], AggregateExperience[P]>
  }




  export type ExperienceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExperienceWhereInput
    orderBy?: ExperienceOrderByWithAggregationInput | ExperienceOrderByWithAggregationInput[]
    by: ExperienceScalarFieldEnum[] | ExperienceScalarFieldEnum
    having?: ExperienceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExperienceCountAggregateInputType | true
    _min?: ExperienceMinAggregateInputType
    _max?: ExperienceMaxAggregateInputType
  }

  export type ExperienceGroupByOutputType = {
    id: string
    stageId: string
    title: string
    description: string | null
    type: string
    gamificationFramework: string | null
    creatorId: string
    createdAt: Date
    updatedAt: Date
    _count: ExperienceCountAggregateOutputType | null
    _min: ExperienceMinAggregateOutputType | null
    _max: ExperienceMaxAggregateOutputType | null
  }

  type GetExperienceGroupByPayload<T extends ExperienceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExperienceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExperienceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExperienceGroupByOutputType[P]>
            : GetScalarType<T[P], ExperienceGroupByOutputType[P]>
        }
      >
    >


  export type ExperienceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stageId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    gamificationFramework?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activities?: boolean | Experience$activitiesArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    stage?: boolean | StageDefaultArgs<ExtArgs>
    _count?: boolean | ExperienceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["experience"]>

  export type ExperienceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stageId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    gamificationFramework?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    stage?: boolean | StageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["experience"]>

  export type ExperienceSelectScalar = {
    id?: boolean
    stageId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    gamificationFramework?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExperienceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | Experience$activitiesArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    stage?: boolean | StageDefaultArgs<ExtArgs>
    _count?: boolean | ExperienceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExperienceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    stage?: boolean | StageDefaultArgs<ExtArgs>
  }

  export type $ExperiencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Experience"
    objects: {
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      creator: Prisma.$UserPayload<ExtArgs>
      stage: Prisma.$StagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stageId: string
      title: string
      description: string | null
      type: string
      gamificationFramework: string | null
      creatorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["experience"]>
    composites: {}
  }

  type ExperienceGetPayload<S extends boolean | null | undefined | ExperienceDefaultArgs> = $Result.GetResult<Prisma.$ExperiencePayload, S>

  type ExperienceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExperienceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExperienceCountAggregateInputType | true
    }

  export interface ExperienceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Experience'], meta: { name: 'Experience' } }
    /**
     * Find zero or one Experience that matches the filter.
     * @param {ExperienceFindUniqueArgs} args - Arguments to find a Experience
     * @example
     * // Get one Experience
     * const experience = await prisma.experience.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExperienceFindUniqueArgs>(args: SelectSubset<T, ExperienceFindUniqueArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Experience that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExperienceFindUniqueOrThrowArgs} args - Arguments to find a Experience
     * @example
     * // Get one Experience
     * const experience = await prisma.experience.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExperienceFindUniqueOrThrowArgs>(args: SelectSubset<T, ExperienceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Experience that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceFindFirstArgs} args - Arguments to find a Experience
     * @example
     * // Get one Experience
     * const experience = await prisma.experience.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExperienceFindFirstArgs>(args?: SelectSubset<T, ExperienceFindFirstArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Experience that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceFindFirstOrThrowArgs} args - Arguments to find a Experience
     * @example
     * // Get one Experience
     * const experience = await prisma.experience.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExperienceFindFirstOrThrowArgs>(args?: SelectSubset<T, ExperienceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Experiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Experiences
     * const experiences = await prisma.experience.findMany()
     * 
     * // Get first 10 Experiences
     * const experiences = await prisma.experience.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const experienceWithIdOnly = await prisma.experience.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExperienceFindManyArgs>(args?: SelectSubset<T, ExperienceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Experience.
     * @param {ExperienceCreateArgs} args - Arguments to create a Experience.
     * @example
     * // Create one Experience
     * const Experience = await prisma.experience.create({
     *   data: {
     *     // ... data to create a Experience
     *   }
     * })
     * 
     */
    create<T extends ExperienceCreateArgs>(args: SelectSubset<T, ExperienceCreateArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Experiences.
     * @param {ExperienceCreateManyArgs} args - Arguments to create many Experiences.
     * @example
     * // Create many Experiences
     * const experience = await prisma.experience.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExperienceCreateManyArgs>(args?: SelectSubset<T, ExperienceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Experiences and returns the data saved in the database.
     * @param {ExperienceCreateManyAndReturnArgs} args - Arguments to create many Experiences.
     * @example
     * // Create many Experiences
     * const experience = await prisma.experience.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Experiences and only return the `id`
     * const experienceWithIdOnly = await prisma.experience.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExperienceCreateManyAndReturnArgs>(args?: SelectSubset<T, ExperienceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Experience.
     * @param {ExperienceDeleteArgs} args - Arguments to delete one Experience.
     * @example
     * // Delete one Experience
     * const Experience = await prisma.experience.delete({
     *   where: {
     *     // ... filter to delete one Experience
     *   }
     * })
     * 
     */
    delete<T extends ExperienceDeleteArgs>(args: SelectSubset<T, ExperienceDeleteArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Experience.
     * @param {ExperienceUpdateArgs} args - Arguments to update one Experience.
     * @example
     * // Update one Experience
     * const experience = await prisma.experience.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExperienceUpdateArgs>(args: SelectSubset<T, ExperienceUpdateArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Experiences.
     * @param {ExperienceDeleteManyArgs} args - Arguments to filter Experiences to delete.
     * @example
     * // Delete a few Experiences
     * const { count } = await prisma.experience.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExperienceDeleteManyArgs>(args?: SelectSubset<T, ExperienceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Experiences
     * const experience = await prisma.experience.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExperienceUpdateManyArgs>(args: SelectSubset<T, ExperienceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Experience.
     * @param {ExperienceUpsertArgs} args - Arguments to update or create a Experience.
     * @example
     * // Update or create a Experience
     * const experience = await prisma.experience.upsert({
     *   create: {
     *     // ... data to create a Experience
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Experience we want to update
     *   }
     * })
     */
    upsert<T extends ExperienceUpsertArgs>(args: SelectSubset<T, ExperienceUpsertArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceCountArgs} args - Arguments to filter Experiences to count.
     * @example
     * // Count the number of Experiences
     * const count = await prisma.experience.count({
     *   where: {
     *     // ... the filter for the Experiences we want to count
     *   }
     * })
    **/
    count<T extends ExperienceCountArgs>(
      args?: Subset<T, ExperienceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExperienceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Experience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExperienceAggregateArgs>(args: Subset<T, ExperienceAggregateArgs>): Prisma.PrismaPromise<GetExperienceAggregateType<T>>

    /**
     * Group by Experience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExperienceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExperienceGroupByArgs['orderBy'] }
        : { orderBy?: ExperienceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExperienceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExperienceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Experience model
   */
  readonly fields: ExperienceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Experience.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExperienceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activities<T extends Experience$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Experience$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stage<T extends StageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StageDefaultArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Experience model
   */ 
  interface ExperienceFieldRefs {
    readonly id: FieldRef<"Experience", 'String'>
    readonly stageId: FieldRef<"Experience", 'String'>
    readonly title: FieldRef<"Experience", 'String'>
    readonly description: FieldRef<"Experience", 'String'>
    readonly type: FieldRef<"Experience", 'String'>
    readonly gamificationFramework: FieldRef<"Experience", 'String'>
    readonly creatorId: FieldRef<"Experience", 'String'>
    readonly createdAt: FieldRef<"Experience", 'DateTime'>
    readonly updatedAt: FieldRef<"Experience", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Experience findUnique
   */
  export type ExperienceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter, which Experience to fetch.
     */
    where: ExperienceWhereUniqueInput
  }

  /**
   * Experience findUniqueOrThrow
   */
  export type ExperienceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter, which Experience to fetch.
     */
    where: ExperienceWhereUniqueInput
  }

  /**
   * Experience findFirst
   */
  export type ExperienceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter, which Experience to fetch.
     */
    where?: ExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Experiences to fetch.
     */
    orderBy?: ExperienceOrderByWithRelationInput | ExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Experiences.
     */
    cursor?: ExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Experiences.
     */
    distinct?: ExperienceScalarFieldEnum | ExperienceScalarFieldEnum[]
  }

  /**
   * Experience findFirstOrThrow
   */
  export type ExperienceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter, which Experience to fetch.
     */
    where?: ExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Experiences to fetch.
     */
    orderBy?: ExperienceOrderByWithRelationInput | ExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Experiences.
     */
    cursor?: ExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Experiences.
     */
    distinct?: ExperienceScalarFieldEnum | ExperienceScalarFieldEnum[]
  }

  /**
   * Experience findMany
   */
  export type ExperienceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter, which Experiences to fetch.
     */
    where?: ExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Experiences to fetch.
     */
    orderBy?: ExperienceOrderByWithRelationInput | ExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Experiences.
     */
    cursor?: ExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Experiences.
     */
    skip?: number
    distinct?: ExperienceScalarFieldEnum | ExperienceScalarFieldEnum[]
  }

  /**
   * Experience create
   */
  export type ExperienceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * The data needed to create a Experience.
     */
    data: XOR<ExperienceCreateInput, ExperienceUncheckedCreateInput>
  }

  /**
   * Experience createMany
   */
  export type ExperienceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Experiences.
     */
    data: ExperienceCreateManyInput | ExperienceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Experience createManyAndReturn
   */
  export type ExperienceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Experiences.
     */
    data: ExperienceCreateManyInput | ExperienceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Experience update
   */
  export type ExperienceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * The data needed to update a Experience.
     */
    data: XOR<ExperienceUpdateInput, ExperienceUncheckedUpdateInput>
    /**
     * Choose, which Experience to update.
     */
    where: ExperienceWhereUniqueInput
  }

  /**
   * Experience updateMany
   */
  export type ExperienceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Experiences.
     */
    data: XOR<ExperienceUpdateManyMutationInput, ExperienceUncheckedUpdateManyInput>
    /**
     * Filter which Experiences to update
     */
    where?: ExperienceWhereInput
  }

  /**
   * Experience upsert
   */
  export type ExperienceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * The filter to search for the Experience to update in case it exists.
     */
    where: ExperienceWhereUniqueInput
    /**
     * In case the Experience found by the `where` argument doesn't exist, create a new Experience with this data.
     */
    create: XOR<ExperienceCreateInput, ExperienceUncheckedCreateInput>
    /**
     * In case the Experience was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExperienceUpdateInput, ExperienceUncheckedUpdateInput>
  }

  /**
   * Experience delete
   */
  export type ExperienceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter which Experience to delete.
     */
    where: ExperienceWhereUniqueInput
  }

  /**
   * Experience deleteMany
   */
  export type ExperienceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Experiences to delete
     */
    where?: ExperienceWhereInput
  }

  /**
   * Experience.activities
   */
  export type Experience$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Experience without action
   */
  export type ExperienceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    duration: number | null
    order: number | null
    videoItemId: number | null
  }

  export type ActivitySumAggregateOutputType = {
    duration: number | null
    order: number | null
    videoItemId: number | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    experienceId: string | null
    title: string | null
    description: string | null
    type: string | null
    multimediaType: string | null
    contentUrl: string | null
    duration: number | null
    order: number | null
    status: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    videoItemId: number | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    experienceId: string | null
    title: string | null
    description: string | null
    type: string | null
    multimediaType: string | null
    contentUrl: string | null
    duration: number | null
    order: number | null
    status: string | null
    creatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    videoItemId: number | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    experienceId: number
    title: number
    description: number
    type: number
    multimediaType: number
    contentUrl: number
    duration: number
    order: number
    status: number
    creatorId: number
    createdAt: number
    updatedAt: number
    videoItemId: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    duration?: true
    order?: true
    videoItemId?: true
  }

  export type ActivitySumAggregateInputType = {
    duration?: true
    order?: true
    videoItemId?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    experienceId?: true
    title?: true
    description?: true
    type?: true
    multimediaType?: true
    contentUrl?: true
    duration?: true
    order?: true
    status?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    videoItemId?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    experienceId?: true
    title?: true
    description?: true
    type?: true
    multimediaType?: true
    contentUrl?: true
    duration?: true
    order?: true
    status?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    videoItemId?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    experienceId?: true
    title?: true
    description?: true
    type?: true
    multimediaType?: true
    contentUrl?: true
    duration?: true
    order?: true
    status?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    videoItemId?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    experienceId: string
    title: string
    description: string | null
    type: string
    multimediaType: string | null
    contentUrl: string | null
    duration: number | null
    order: number
    status: string
    creatorId: string
    createdAt: Date
    updatedAt: Date
    videoItemId: number | null
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experienceId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    multimediaType?: boolean
    contentUrl?: boolean
    duration?: boolean
    order?: boolean
    status?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    videoItemId?: boolean
    videoItem?: boolean | Activity$videoItemArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    experience?: boolean | ExperienceDefaultArgs<ExtArgs>
    questions?: boolean | Activity$questionsArgs<ExtArgs>
    gamifiedPlaylists?: boolean | Activity$gamifiedPlaylistsArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    experienceId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    multimediaType?: boolean
    contentUrl?: boolean
    duration?: boolean
    order?: boolean
    status?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    videoItemId?: boolean
    videoItem?: boolean | Activity$videoItemArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    experience?: boolean | ExperienceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    experienceId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    multimediaType?: boolean
    contentUrl?: boolean
    duration?: boolean
    order?: boolean
    status?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    videoItemId?: boolean
  }

  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videoItem?: boolean | Activity$videoItemArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    experience?: boolean | ExperienceDefaultArgs<ExtArgs>
    questions?: boolean | Activity$questionsArgs<ExtArgs>
    gamifiedPlaylists?: boolean | Activity$gamifiedPlaylistsArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videoItem?: boolean | Activity$videoItemArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    experience?: boolean | ExperienceDefaultArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      videoItem: Prisma.$VideoItemPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
      experience: Prisma.$ExperiencePayload<ExtArgs>
      questions: Prisma.$ActivityQuestionPayload<ExtArgs>[]
      gamifiedPlaylists: Prisma.$GamifiedPlaylistPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      experienceId: string
      title: string
      description: string | null
      type: string
      multimediaType: string | null
      contentUrl: string | null
      duration: number | null
      order: number
      status: string
      creatorId: string
      createdAt: Date
      updatedAt: Date
      videoItemId: number | null
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    videoItem<T extends Activity$videoItemArgs<ExtArgs> = {}>(args?: Subset<T, Activity$videoItemArgs<ExtArgs>>): Prisma__VideoItemClient<$Result.GetResult<Prisma.$VideoItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    experience<T extends ExperienceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExperienceDefaultArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    questions<T extends Activity$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Activity$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityQuestionPayload<ExtArgs>, T, "findMany"> | Null>
    gamifiedPlaylists<T extends Activity$gamifiedPlaylistsArgs<ExtArgs> = {}>(args?: Subset<T, Activity$gamifiedPlaylistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamifiedPlaylistPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */ 
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly experienceId: FieldRef<"Activity", 'String'>
    readonly title: FieldRef<"Activity", 'String'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly type: FieldRef<"Activity", 'String'>
    readonly multimediaType: FieldRef<"Activity", 'String'>
    readonly contentUrl: FieldRef<"Activity", 'String'>
    readonly duration: FieldRef<"Activity", 'Int'>
    readonly order: FieldRef<"Activity", 'Int'>
    readonly status: FieldRef<"Activity", 'String'>
    readonly creatorId: FieldRef<"Activity", 'String'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
    readonly updatedAt: FieldRef<"Activity", 'DateTime'>
    readonly videoItemId: FieldRef<"Activity", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
  }

  /**
   * Activity.videoItem
   */
  export type Activity$videoItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoItem
     */
    select?: VideoItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoItemInclude<ExtArgs> | null
    where?: VideoItemWhereInput
  }

  /**
   * Activity.questions
   */
  export type Activity$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityQuestion
     */
    select?: ActivityQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityQuestionInclude<ExtArgs> | null
    where?: ActivityQuestionWhereInput
    orderBy?: ActivityQuestionOrderByWithRelationInput | ActivityQuestionOrderByWithRelationInput[]
    cursor?: ActivityQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityQuestionScalarFieldEnum | ActivityQuestionScalarFieldEnum[]
  }

  /**
   * Activity.gamifiedPlaylists
   */
  export type Activity$gamifiedPlaylistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamifiedPlaylist
     */
    select?: GamifiedPlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamifiedPlaylistInclude<ExtArgs> | null
    where?: GamifiedPlaylistWhereInput
    orderBy?: GamifiedPlaylistOrderByWithRelationInput | GamifiedPlaylistOrderByWithRelationInput[]
    cursor?: GamifiedPlaylistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamifiedPlaylistScalarFieldEnum | GamifiedPlaylistScalarFieldEnum[]
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model GamifiedPlaylist
   */

  export type AggregateGamifiedPlaylist = {
    _count: GamifiedPlaylistCountAggregateOutputType | null
    _min: GamifiedPlaylistMinAggregateOutputType | null
    _max: GamifiedPlaylistMaxAggregateOutputType | null
  }

  export type GamifiedPlaylistMinAggregateOutputType = {
    id: string | null
    activityId: string | null
    playlistId: string | null
    name: string | null
    type: string | null
    sequenceType: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GamifiedPlaylistMaxAggregateOutputType = {
    id: string | null
    activityId: string | null
    playlistId: string | null
    name: string | null
    type: string | null
    sequenceType: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GamifiedPlaylistCountAggregateOutputType = {
    id: number
    activityId: number
    playlistId: number
    name: number
    type: number
    sequenceType: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GamifiedPlaylistMinAggregateInputType = {
    id?: true
    activityId?: true
    playlistId?: true
    name?: true
    type?: true
    sequenceType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GamifiedPlaylistMaxAggregateInputType = {
    id?: true
    activityId?: true
    playlistId?: true
    name?: true
    type?: true
    sequenceType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GamifiedPlaylistCountAggregateInputType = {
    id?: true
    activityId?: true
    playlistId?: true
    name?: true
    type?: true
    sequenceType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GamifiedPlaylistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GamifiedPlaylist to aggregate.
     */
    where?: GamifiedPlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GamifiedPlaylists to fetch.
     */
    orderBy?: GamifiedPlaylistOrderByWithRelationInput | GamifiedPlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GamifiedPlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GamifiedPlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GamifiedPlaylists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GamifiedPlaylists
    **/
    _count?: true | GamifiedPlaylistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GamifiedPlaylistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GamifiedPlaylistMaxAggregateInputType
  }

  export type GetGamifiedPlaylistAggregateType<T extends GamifiedPlaylistAggregateArgs> = {
        [P in keyof T & keyof AggregateGamifiedPlaylist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGamifiedPlaylist[P]>
      : GetScalarType<T[P], AggregateGamifiedPlaylist[P]>
  }




  export type GamifiedPlaylistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GamifiedPlaylistWhereInput
    orderBy?: GamifiedPlaylistOrderByWithAggregationInput | GamifiedPlaylistOrderByWithAggregationInput[]
    by: GamifiedPlaylistScalarFieldEnum[] | GamifiedPlaylistScalarFieldEnum
    having?: GamifiedPlaylistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GamifiedPlaylistCountAggregateInputType | true
    _min?: GamifiedPlaylistMinAggregateInputType
    _max?: GamifiedPlaylistMaxAggregateInputType
  }

  export type GamifiedPlaylistGroupByOutputType = {
    id: string
    activityId: string | null
    playlistId: string | null
    name: string
    type: string
    sequenceType: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: GamifiedPlaylistCountAggregateOutputType | null
    _min: GamifiedPlaylistMinAggregateOutputType | null
    _max: GamifiedPlaylistMaxAggregateOutputType | null
  }

  type GetGamifiedPlaylistGroupByPayload<T extends GamifiedPlaylistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GamifiedPlaylistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GamifiedPlaylistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GamifiedPlaylistGroupByOutputType[P]>
            : GetScalarType<T[P], GamifiedPlaylistGroupByOutputType[P]>
        }
      >
    >


  export type GamifiedPlaylistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activityId?: boolean
    playlistId?: boolean
    name?: boolean
    type?: boolean
    sequenceType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    playlist?: boolean | GamifiedPlaylist$playlistArgs<ExtArgs>
    activity?: boolean | GamifiedPlaylist$activityArgs<ExtArgs>
  }, ExtArgs["result"]["gamifiedPlaylist"]>

  export type GamifiedPlaylistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activityId?: boolean
    playlistId?: boolean
    name?: boolean
    type?: boolean
    sequenceType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    playlist?: boolean | GamifiedPlaylist$playlistArgs<ExtArgs>
    activity?: boolean | GamifiedPlaylist$activityArgs<ExtArgs>
  }, ExtArgs["result"]["gamifiedPlaylist"]>

  export type GamifiedPlaylistSelectScalar = {
    id?: boolean
    activityId?: boolean
    playlistId?: boolean
    name?: boolean
    type?: boolean
    sequenceType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GamifiedPlaylistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | GamifiedPlaylist$playlistArgs<ExtArgs>
    activity?: boolean | GamifiedPlaylist$activityArgs<ExtArgs>
  }
  export type GamifiedPlaylistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlist?: boolean | GamifiedPlaylist$playlistArgs<ExtArgs>
    activity?: boolean | GamifiedPlaylist$activityArgs<ExtArgs>
  }

  export type $GamifiedPlaylistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GamifiedPlaylist"
    objects: {
      playlist: Prisma.$PlaylistPayload<ExtArgs> | null
      activity: Prisma.$ActivityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      activityId: string | null
      playlistId: string | null
      name: string
      type: string
      sequenceType: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gamifiedPlaylist"]>
    composites: {}
  }

  type GamifiedPlaylistGetPayload<S extends boolean | null | undefined | GamifiedPlaylistDefaultArgs> = $Result.GetResult<Prisma.$GamifiedPlaylistPayload, S>

  type GamifiedPlaylistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GamifiedPlaylistFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GamifiedPlaylistCountAggregateInputType | true
    }

  export interface GamifiedPlaylistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GamifiedPlaylist'], meta: { name: 'GamifiedPlaylist' } }
    /**
     * Find zero or one GamifiedPlaylist that matches the filter.
     * @param {GamifiedPlaylistFindUniqueArgs} args - Arguments to find a GamifiedPlaylist
     * @example
     * // Get one GamifiedPlaylist
     * const gamifiedPlaylist = await prisma.gamifiedPlaylist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GamifiedPlaylistFindUniqueArgs>(args: SelectSubset<T, GamifiedPlaylistFindUniqueArgs<ExtArgs>>): Prisma__GamifiedPlaylistClient<$Result.GetResult<Prisma.$GamifiedPlaylistPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GamifiedPlaylist that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GamifiedPlaylistFindUniqueOrThrowArgs} args - Arguments to find a GamifiedPlaylist
     * @example
     * // Get one GamifiedPlaylist
     * const gamifiedPlaylist = await prisma.gamifiedPlaylist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GamifiedPlaylistFindUniqueOrThrowArgs>(args: SelectSubset<T, GamifiedPlaylistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GamifiedPlaylistClient<$Result.GetResult<Prisma.$GamifiedPlaylistPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GamifiedPlaylist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamifiedPlaylistFindFirstArgs} args - Arguments to find a GamifiedPlaylist
     * @example
     * // Get one GamifiedPlaylist
     * const gamifiedPlaylist = await prisma.gamifiedPlaylist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GamifiedPlaylistFindFirstArgs>(args?: SelectSubset<T, GamifiedPlaylistFindFirstArgs<ExtArgs>>): Prisma__GamifiedPlaylistClient<$Result.GetResult<Prisma.$GamifiedPlaylistPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GamifiedPlaylist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamifiedPlaylistFindFirstOrThrowArgs} args - Arguments to find a GamifiedPlaylist
     * @example
     * // Get one GamifiedPlaylist
     * const gamifiedPlaylist = await prisma.gamifiedPlaylist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GamifiedPlaylistFindFirstOrThrowArgs>(args?: SelectSubset<T, GamifiedPlaylistFindFirstOrThrowArgs<ExtArgs>>): Prisma__GamifiedPlaylistClient<$Result.GetResult<Prisma.$GamifiedPlaylistPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GamifiedPlaylists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamifiedPlaylistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GamifiedPlaylists
     * const gamifiedPlaylists = await prisma.gamifiedPlaylist.findMany()
     * 
     * // Get first 10 GamifiedPlaylists
     * const gamifiedPlaylists = await prisma.gamifiedPlaylist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gamifiedPlaylistWithIdOnly = await prisma.gamifiedPlaylist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GamifiedPlaylistFindManyArgs>(args?: SelectSubset<T, GamifiedPlaylistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamifiedPlaylistPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GamifiedPlaylist.
     * @param {GamifiedPlaylistCreateArgs} args - Arguments to create a GamifiedPlaylist.
     * @example
     * // Create one GamifiedPlaylist
     * const GamifiedPlaylist = await prisma.gamifiedPlaylist.create({
     *   data: {
     *     // ... data to create a GamifiedPlaylist
     *   }
     * })
     * 
     */
    create<T extends GamifiedPlaylistCreateArgs>(args: SelectSubset<T, GamifiedPlaylistCreateArgs<ExtArgs>>): Prisma__GamifiedPlaylistClient<$Result.GetResult<Prisma.$GamifiedPlaylistPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GamifiedPlaylists.
     * @param {GamifiedPlaylistCreateManyArgs} args - Arguments to create many GamifiedPlaylists.
     * @example
     * // Create many GamifiedPlaylists
     * const gamifiedPlaylist = await prisma.gamifiedPlaylist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GamifiedPlaylistCreateManyArgs>(args?: SelectSubset<T, GamifiedPlaylistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GamifiedPlaylists and returns the data saved in the database.
     * @param {GamifiedPlaylistCreateManyAndReturnArgs} args - Arguments to create many GamifiedPlaylists.
     * @example
     * // Create many GamifiedPlaylists
     * const gamifiedPlaylist = await prisma.gamifiedPlaylist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GamifiedPlaylists and only return the `id`
     * const gamifiedPlaylistWithIdOnly = await prisma.gamifiedPlaylist.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GamifiedPlaylistCreateManyAndReturnArgs>(args?: SelectSubset<T, GamifiedPlaylistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamifiedPlaylistPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GamifiedPlaylist.
     * @param {GamifiedPlaylistDeleteArgs} args - Arguments to delete one GamifiedPlaylist.
     * @example
     * // Delete one GamifiedPlaylist
     * const GamifiedPlaylist = await prisma.gamifiedPlaylist.delete({
     *   where: {
     *     // ... filter to delete one GamifiedPlaylist
     *   }
     * })
     * 
     */
    delete<T extends GamifiedPlaylistDeleteArgs>(args: SelectSubset<T, GamifiedPlaylistDeleteArgs<ExtArgs>>): Prisma__GamifiedPlaylistClient<$Result.GetResult<Prisma.$GamifiedPlaylistPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GamifiedPlaylist.
     * @param {GamifiedPlaylistUpdateArgs} args - Arguments to update one GamifiedPlaylist.
     * @example
     * // Update one GamifiedPlaylist
     * const gamifiedPlaylist = await prisma.gamifiedPlaylist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GamifiedPlaylistUpdateArgs>(args: SelectSubset<T, GamifiedPlaylistUpdateArgs<ExtArgs>>): Prisma__GamifiedPlaylistClient<$Result.GetResult<Prisma.$GamifiedPlaylistPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GamifiedPlaylists.
     * @param {GamifiedPlaylistDeleteManyArgs} args - Arguments to filter GamifiedPlaylists to delete.
     * @example
     * // Delete a few GamifiedPlaylists
     * const { count } = await prisma.gamifiedPlaylist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GamifiedPlaylistDeleteManyArgs>(args?: SelectSubset<T, GamifiedPlaylistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GamifiedPlaylists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamifiedPlaylistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GamifiedPlaylists
     * const gamifiedPlaylist = await prisma.gamifiedPlaylist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GamifiedPlaylistUpdateManyArgs>(args: SelectSubset<T, GamifiedPlaylistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GamifiedPlaylist.
     * @param {GamifiedPlaylistUpsertArgs} args - Arguments to update or create a GamifiedPlaylist.
     * @example
     * // Update or create a GamifiedPlaylist
     * const gamifiedPlaylist = await prisma.gamifiedPlaylist.upsert({
     *   create: {
     *     // ... data to create a GamifiedPlaylist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GamifiedPlaylist we want to update
     *   }
     * })
     */
    upsert<T extends GamifiedPlaylistUpsertArgs>(args: SelectSubset<T, GamifiedPlaylistUpsertArgs<ExtArgs>>): Prisma__GamifiedPlaylistClient<$Result.GetResult<Prisma.$GamifiedPlaylistPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GamifiedPlaylists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamifiedPlaylistCountArgs} args - Arguments to filter GamifiedPlaylists to count.
     * @example
     * // Count the number of GamifiedPlaylists
     * const count = await prisma.gamifiedPlaylist.count({
     *   where: {
     *     // ... the filter for the GamifiedPlaylists we want to count
     *   }
     * })
    **/
    count<T extends GamifiedPlaylistCountArgs>(
      args?: Subset<T, GamifiedPlaylistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GamifiedPlaylistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GamifiedPlaylist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamifiedPlaylistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GamifiedPlaylistAggregateArgs>(args: Subset<T, GamifiedPlaylistAggregateArgs>): Prisma.PrismaPromise<GetGamifiedPlaylistAggregateType<T>>

    /**
     * Group by GamifiedPlaylist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamifiedPlaylistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GamifiedPlaylistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GamifiedPlaylistGroupByArgs['orderBy'] }
        : { orderBy?: GamifiedPlaylistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GamifiedPlaylistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGamifiedPlaylistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GamifiedPlaylist model
   */
  readonly fields: GamifiedPlaylistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GamifiedPlaylist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GamifiedPlaylistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playlist<T extends GamifiedPlaylist$playlistArgs<ExtArgs> = {}>(args?: Subset<T, GamifiedPlaylist$playlistArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    activity<T extends GamifiedPlaylist$activityArgs<ExtArgs> = {}>(args?: Subset<T, GamifiedPlaylist$activityArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GamifiedPlaylist model
   */ 
  interface GamifiedPlaylistFieldRefs {
    readonly id: FieldRef<"GamifiedPlaylist", 'String'>
    readonly activityId: FieldRef<"GamifiedPlaylist", 'String'>
    readonly playlistId: FieldRef<"GamifiedPlaylist", 'String'>
    readonly name: FieldRef<"GamifiedPlaylist", 'String'>
    readonly type: FieldRef<"GamifiedPlaylist", 'String'>
    readonly sequenceType: FieldRef<"GamifiedPlaylist", 'String'>
    readonly status: FieldRef<"GamifiedPlaylist", 'String'>
    readonly createdAt: FieldRef<"GamifiedPlaylist", 'DateTime'>
    readonly updatedAt: FieldRef<"GamifiedPlaylist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GamifiedPlaylist findUnique
   */
  export type GamifiedPlaylistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamifiedPlaylist
     */
    select?: GamifiedPlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamifiedPlaylistInclude<ExtArgs> | null
    /**
     * Filter, which GamifiedPlaylist to fetch.
     */
    where: GamifiedPlaylistWhereUniqueInput
  }

  /**
   * GamifiedPlaylist findUniqueOrThrow
   */
  export type GamifiedPlaylistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamifiedPlaylist
     */
    select?: GamifiedPlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamifiedPlaylistInclude<ExtArgs> | null
    /**
     * Filter, which GamifiedPlaylist to fetch.
     */
    where: GamifiedPlaylistWhereUniqueInput
  }

  /**
   * GamifiedPlaylist findFirst
   */
  export type GamifiedPlaylistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamifiedPlaylist
     */
    select?: GamifiedPlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamifiedPlaylistInclude<ExtArgs> | null
    /**
     * Filter, which GamifiedPlaylist to fetch.
     */
    where?: GamifiedPlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GamifiedPlaylists to fetch.
     */
    orderBy?: GamifiedPlaylistOrderByWithRelationInput | GamifiedPlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GamifiedPlaylists.
     */
    cursor?: GamifiedPlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GamifiedPlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GamifiedPlaylists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GamifiedPlaylists.
     */
    distinct?: GamifiedPlaylistScalarFieldEnum | GamifiedPlaylistScalarFieldEnum[]
  }

  /**
   * GamifiedPlaylist findFirstOrThrow
   */
  export type GamifiedPlaylistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamifiedPlaylist
     */
    select?: GamifiedPlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamifiedPlaylistInclude<ExtArgs> | null
    /**
     * Filter, which GamifiedPlaylist to fetch.
     */
    where?: GamifiedPlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GamifiedPlaylists to fetch.
     */
    orderBy?: GamifiedPlaylistOrderByWithRelationInput | GamifiedPlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GamifiedPlaylists.
     */
    cursor?: GamifiedPlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GamifiedPlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GamifiedPlaylists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GamifiedPlaylists.
     */
    distinct?: GamifiedPlaylistScalarFieldEnum | GamifiedPlaylistScalarFieldEnum[]
  }

  /**
   * GamifiedPlaylist findMany
   */
  export type GamifiedPlaylistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamifiedPlaylist
     */
    select?: GamifiedPlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamifiedPlaylistInclude<ExtArgs> | null
    /**
     * Filter, which GamifiedPlaylists to fetch.
     */
    where?: GamifiedPlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GamifiedPlaylists to fetch.
     */
    orderBy?: GamifiedPlaylistOrderByWithRelationInput | GamifiedPlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GamifiedPlaylists.
     */
    cursor?: GamifiedPlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GamifiedPlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GamifiedPlaylists.
     */
    skip?: number
    distinct?: GamifiedPlaylistScalarFieldEnum | GamifiedPlaylistScalarFieldEnum[]
  }

  /**
   * GamifiedPlaylist create
   */
  export type GamifiedPlaylistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamifiedPlaylist
     */
    select?: GamifiedPlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamifiedPlaylistInclude<ExtArgs> | null
    /**
     * The data needed to create a GamifiedPlaylist.
     */
    data: XOR<GamifiedPlaylistCreateInput, GamifiedPlaylistUncheckedCreateInput>
  }

  /**
   * GamifiedPlaylist createMany
   */
  export type GamifiedPlaylistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GamifiedPlaylists.
     */
    data: GamifiedPlaylistCreateManyInput | GamifiedPlaylistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GamifiedPlaylist createManyAndReturn
   */
  export type GamifiedPlaylistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamifiedPlaylist
     */
    select?: GamifiedPlaylistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GamifiedPlaylists.
     */
    data: GamifiedPlaylistCreateManyInput | GamifiedPlaylistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamifiedPlaylistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GamifiedPlaylist update
   */
  export type GamifiedPlaylistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamifiedPlaylist
     */
    select?: GamifiedPlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamifiedPlaylistInclude<ExtArgs> | null
    /**
     * The data needed to update a GamifiedPlaylist.
     */
    data: XOR<GamifiedPlaylistUpdateInput, GamifiedPlaylistUncheckedUpdateInput>
    /**
     * Choose, which GamifiedPlaylist to update.
     */
    where: GamifiedPlaylistWhereUniqueInput
  }

  /**
   * GamifiedPlaylist updateMany
   */
  export type GamifiedPlaylistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GamifiedPlaylists.
     */
    data: XOR<GamifiedPlaylistUpdateManyMutationInput, GamifiedPlaylistUncheckedUpdateManyInput>
    /**
     * Filter which GamifiedPlaylists to update
     */
    where?: GamifiedPlaylistWhereInput
  }

  /**
   * GamifiedPlaylist upsert
   */
  export type GamifiedPlaylistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamifiedPlaylist
     */
    select?: GamifiedPlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamifiedPlaylistInclude<ExtArgs> | null
    /**
     * The filter to search for the GamifiedPlaylist to update in case it exists.
     */
    where: GamifiedPlaylistWhereUniqueInput
    /**
     * In case the GamifiedPlaylist found by the `where` argument doesn't exist, create a new GamifiedPlaylist with this data.
     */
    create: XOR<GamifiedPlaylistCreateInput, GamifiedPlaylistUncheckedCreateInput>
    /**
     * In case the GamifiedPlaylist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GamifiedPlaylistUpdateInput, GamifiedPlaylistUncheckedUpdateInput>
  }

  /**
   * GamifiedPlaylist delete
   */
  export type GamifiedPlaylistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamifiedPlaylist
     */
    select?: GamifiedPlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamifiedPlaylistInclude<ExtArgs> | null
    /**
     * Filter which GamifiedPlaylist to delete.
     */
    where: GamifiedPlaylistWhereUniqueInput
  }

  /**
   * GamifiedPlaylist deleteMany
   */
  export type GamifiedPlaylistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GamifiedPlaylists to delete
     */
    where?: GamifiedPlaylistWhereInput
  }

  /**
   * GamifiedPlaylist.playlist
   */
  export type GamifiedPlaylist$playlistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    where?: PlaylistWhereInput
  }

  /**
   * GamifiedPlaylist.activity
   */
  export type GamifiedPlaylist$activityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
  }

  /**
   * GamifiedPlaylist without action
   */
  export type GamifiedPlaylistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamifiedPlaylist
     */
    select?: GamifiedPlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamifiedPlaylistInclude<ExtArgs> | null
  }


  /**
   * Model ActivityQuestion
   */

  export type AggregateActivityQuestion = {
    _count: ActivityQuestionCountAggregateOutputType | null
    _avg: ActivityQuestionAvgAggregateOutputType | null
    _sum: ActivityQuestionSumAggregateOutputType | null
    _min: ActivityQuestionMinAggregateOutputType | null
    _max: ActivityQuestionMaxAggregateOutputType | null
  }

  export type ActivityQuestionAvgAggregateOutputType = {
    displayTimeSeconds: number | null
    optionalDisplaySeconds: number | null
  }

  export type ActivityQuestionSumAggregateOutputType = {
    displayTimeSeconds: number | null
    optionalDisplaySeconds: number | null
  }

  export type ActivityQuestionMinAggregateOutputType = {
    id: string | null
    activityId: string | null
    type: string | null
    questionType: string | null
    questionText: string | null
    options: string | null
    correctAnswer: string | null
    ondasList: string | null
    displayTimeSeconds: number | null
    optionalDisplaySeconds: number | null
    createdAt: Date | null
  }

  export type ActivityQuestionMaxAggregateOutputType = {
    id: string | null
    activityId: string | null
    type: string | null
    questionType: string | null
    questionText: string | null
    options: string | null
    correctAnswer: string | null
    ondasList: string | null
    displayTimeSeconds: number | null
    optionalDisplaySeconds: number | null
    createdAt: Date | null
  }

  export type ActivityQuestionCountAggregateOutputType = {
    id: number
    activityId: number
    type: number
    questionType: number
    questionText: number
    options: number
    correctAnswer: number
    ondasList: number
    displayTimeSeconds: number
    optionalDisplaySeconds: number
    createdAt: number
    _all: number
  }


  export type ActivityQuestionAvgAggregateInputType = {
    displayTimeSeconds?: true
    optionalDisplaySeconds?: true
  }

  export type ActivityQuestionSumAggregateInputType = {
    displayTimeSeconds?: true
    optionalDisplaySeconds?: true
  }

  export type ActivityQuestionMinAggregateInputType = {
    id?: true
    activityId?: true
    type?: true
    questionType?: true
    questionText?: true
    options?: true
    correctAnswer?: true
    ondasList?: true
    displayTimeSeconds?: true
    optionalDisplaySeconds?: true
    createdAt?: true
  }

  export type ActivityQuestionMaxAggregateInputType = {
    id?: true
    activityId?: true
    type?: true
    questionType?: true
    questionText?: true
    options?: true
    correctAnswer?: true
    ondasList?: true
    displayTimeSeconds?: true
    optionalDisplaySeconds?: true
    createdAt?: true
  }

  export type ActivityQuestionCountAggregateInputType = {
    id?: true
    activityId?: true
    type?: true
    questionType?: true
    questionText?: true
    options?: true
    correctAnswer?: true
    ondasList?: true
    displayTimeSeconds?: true
    optionalDisplaySeconds?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityQuestion to aggregate.
     */
    where?: ActivityQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityQuestions to fetch.
     */
    orderBy?: ActivityQuestionOrderByWithRelationInput | ActivityQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityQuestions
    **/
    _count?: true | ActivityQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityQuestionMaxAggregateInputType
  }

  export type GetActivityQuestionAggregateType<T extends ActivityQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityQuestion[P]>
      : GetScalarType<T[P], AggregateActivityQuestion[P]>
  }




  export type ActivityQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityQuestionWhereInput
    orderBy?: ActivityQuestionOrderByWithAggregationInput | ActivityQuestionOrderByWithAggregationInput[]
    by: ActivityQuestionScalarFieldEnum[] | ActivityQuestionScalarFieldEnum
    having?: ActivityQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityQuestionCountAggregateInputType | true
    _avg?: ActivityQuestionAvgAggregateInputType
    _sum?: ActivityQuestionSumAggregateInputType
    _min?: ActivityQuestionMinAggregateInputType
    _max?: ActivityQuestionMaxAggregateInputType
  }

  export type ActivityQuestionGroupByOutputType = {
    id: string
    activityId: string
    type: string
    questionType: string
    questionText: string
    options: string | null
    correctAnswer: string | null
    ondasList: string | null
    displayTimeSeconds: number | null
    optionalDisplaySeconds: number | null
    createdAt: Date
    _count: ActivityQuestionCountAggregateOutputType | null
    _avg: ActivityQuestionAvgAggregateOutputType | null
    _sum: ActivityQuestionSumAggregateOutputType | null
    _min: ActivityQuestionMinAggregateOutputType | null
    _max: ActivityQuestionMaxAggregateOutputType | null
  }

  type GetActivityQuestionGroupByPayload<T extends ActivityQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityQuestionGroupByOutputType[P]>
        }
      >
    >


  export type ActivityQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activityId?: boolean
    type?: boolean
    questionType?: boolean
    questionText?: boolean
    options?: boolean
    correctAnswer?: boolean
    ondasList?: boolean
    displayTimeSeconds?: boolean
    optionalDisplaySeconds?: boolean
    createdAt?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    userAnswers?: boolean | ActivityQuestion$userAnswersArgs<ExtArgs>
    _count?: boolean | ActivityQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityQuestion"]>

  export type ActivityQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activityId?: boolean
    type?: boolean
    questionType?: boolean
    questionText?: boolean
    options?: boolean
    correctAnswer?: boolean
    ondasList?: boolean
    displayTimeSeconds?: boolean
    optionalDisplaySeconds?: boolean
    createdAt?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityQuestion"]>

  export type ActivityQuestionSelectScalar = {
    id?: boolean
    activityId?: boolean
    type?: boolean
    questionType?: boolean
    questionText?: boolean
    options?: boolean
    correctAnswer?: boolean
    ondasList?: boolean
    displayTimeSeconds?: boolean
    optionalDisplaySeconds?: boolean
    createdAt?: boolean
  }

  export type ActivityQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    userAnswers?: boolean | ActivityQuestion$userAnswersArgs<ExtArgs>
    _count?: boolean | ActivityQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
  }

  export type $ActivityQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityQuestion"
    objects: {
      activity: Prisma.$ActivityPayload<ExtArgs>
      userAnswers: Prisma.$UserAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      activityId: string
      type: string
      questionType: string
      questionText: string
      options: string | null
      correctAnswer: string | null
      ondasList: string | null
      displayTimeSeconds: number | null
      optionalDisplaySeconds: number | null
      createdAt: Date
    }, ExtArgs["result"]["activityQuestion"]>
    composites: {}
  }

  type ActivityQuestionGetPayload<S extends boolean | null | undefined | ActivityQuestionDefaultArgs> = $Result.GetResult<Prisma.$ActivityQuestionPayload, S>

  type ActivityQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityQuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityQuestionCountAggregateInputType | true
    }

  export interface ActivityQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityQuestion'], meta: { name: 'ActivityQuestion' } }
    /**
     * Find zero or one ActivityQuestion that matches the filter.
     * @param {ActivityQuestionFindUniqueArgs} args - Arguments to find a ActivityQuestion
     * @example
     * // Get one ActivityQuestion
     * const activityQuestion = await prisma.activityQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityQuestionFindUniqueArgs>(args: SelectSubset<T, ActivityQuestionFindUniqueArgs<ExtArgs>>): Prisma__ActivityQuestionClient<$Result.GetResult<Prisma.$ActivityQuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActivityQuestion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityQuestionFindUniqueOrThrowArgs} args - Arguments to find a ActivityQuestion
     * @example
     * // Get one ActivityQuestion
     * const activityQuestion = await prisma.activityQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityQuestionClient<$Result.GetResult<Prisma.$ActivityQuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActivityQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityQuestionFindFirstArgs} args - Arguments to find a ActivityQuestion
     * @example
     * // Get one ActivityQuestion
     * const activityQuestion = await prisma.activityQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityQuestionFindFirstArgs>(args?: SelectSubset<T, ActivityQuestionFindFirstArgs<ExtArgs>>): Prisma__ActivityQuestionClient<$Result.GetResult<Prisma.$ActivityQuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActivityQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityQuestionFindFirstOrThrowArgs} args - Arguments to find a ActivityQuestion
     * @example
     * // Get one ActivityQuestion
     * const activityQuestion = await prisma.activityQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityQuestionClient<$Result.GetResult<Prisma.$ActivityQuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActivityQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityQuestions
     * const activityQuestions = await prisma.activityQuestion.findMany()
     * 
     * // Get first 10 ActivityQuestions
     * const activityQuestions = await prisma.activityQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityQuestionWithIdOnly = await prisma.activityQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityQuestionFindManyArgs>(args?: SelectSubset<T, ActivityQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityQuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActivityQuestion.
     * @param {ActivityQuestionCreateArgs} args - Arguments to create a ActivityQuestion.
     * @example
     * // Create one ActivityQuestion
     * const ActivityQuestion = await prisma.activityQuestion.create({
     *   data: {
     *     // ... data to create a ActivityQuestion
     *   }
     * })
     * 
     */
    create<T extends ActivityQuestionCreateArgs>(args: SelectSubset<T, ActivityQuestionCreateArgs<ExtArgs>>): Prisma__ActivityQuestionClient<$Result.GetResult<Prisma.$ActivityQuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActivityQuestions.
     * @param {ActivityQuestionCreateManyArgs} args - Arguments to create many ActivityQuestions.
     * @example
     * // Create many ActivityQuestions
     * const activityQuestion = await prisma.activityQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityQuestionCreateManyArgs>(args?: SelectSubset<T, ActivityQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityQuestions and returns the data saved in the database.
     * @param {ActivityQuestionCreateManyAndReturnArgs} args - Arguments to create many ActivityQuestions.
     * @example
     * // Create many ActivityQuestions
     * const activityQuestion = await prisma.activityQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityQuestions and only return the `id`
     * const activityQuestionWithIdOnly = await prisma.activityQuestion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityQuestionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActivityQuestion.
     * @param {ActivityQuestionDeleteArgs} args - Arguments to delete one ActivityQuestion.
     * @example
     * // Delete one ActivityQuestion
     * const ActivityQuestion = await prisma.activityQuestion.delete({
     *   where: {
     *     // ... filter to delete one ActivityQuestion
     *   }
     * })
     * 
     */
    delete<T extends ActivityQuestionDeleteArgs>(args: SelectSubset<T, ActivityQuestionDeleteArgs<ExtArgs>>): Prisma__ActivityQuestionClient<$Result.GetResult<Prisma.$ActivityQuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActivityQuestion.
     * @param {ActivityQuestionUpdateArgs} args - Arguments to update one ActivityQuestion.
     * @example
     * // Update one ActivityQuestion
     * const activityQuestion = await prisma.activityQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityQuestionUpdateArgs>(args: SelectSubset<T, ActivityQuestionUpdateArgs<ExtArgs>>): Prisma__ActivityQuestionClient<$Result.GetResult<Prisma.$ActivityQuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActivityQuestions.
     * @param {ActivityQuestionDeleteManyArgs} args - Arguments to filter ActivityQuestions to delete.
     * @example
     * // Delete a few ActivityQuestions
     * const { count } = await prisma.activityQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityQuestionDeleteManyArgs>(args?: SelectSubset<T, ActivityQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityQuestions
     * const activityQuestion = await prisma.activityQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityQuestionUpdateManyArgs>(args: SelectSubset<T, ActivityQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityQuestion.
     * @param {ActivityQuestionUpsertArgs} args - Arguments to update or create a ActivityQuestion.
     * @example
     * // Update or create a ActivityQuestion
     * const activityQuestion = await prisma.activityQuestion.upsert({
     *   create: {
     *     // ... data to create a ActivityQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityQuestion we want to update
     *   }
     * })
     */
    upsert<T extends ActivityQuestionUpsertArgs>(args: SelectSubset<T, ActivityQuestionUpsertArgs<ExtArgs>>): Prisma__ActivityQuestionClient<$Result.GetResult<Prisma.$ActivityQuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActivityQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityQuestionCountArgs} args - Arguments to filter ActivityQuestions to count.
     * @example
     * // Count the number of ActivityQuestions
     * const count = await prisma.activityQuestion.count({
     *   where: {
     *     // ... the filter for the ActivityQuestions we want to count
     *   }
     * })
    **/
    count<T extends ActivityQuestionCountArgs>(
      args?: Subset<T, ActivityQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityQuestionAggregateArgs>(args: Subset<T, ActivityQuestionAggregateArgs>): Prisma.PrismaPromise<GetActivityQuestionAggregateType<T>>

    /**
     * Group by ActivityQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityQuestionGroupByArgs['orderBy'] }
        : { orderBy?: ActivityQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityQuestion model
   */
  readonly fields: ActivityQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activity<T extends ActivityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityDefaultArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    userAnswers<T extends ActivityQuestion$userAnswersArgs<ExtArgs> = {}>(args?: Subset<T, ActivityQuestion$userAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityQuestion model
   */ 
  interface ActivityQuestionFieldRefs {
    readonly id: FieldRef<"ActivityQuestion", 'String'>
    readonly activityId: FieldRef<"ActivityQuestion", 'String'>
    readonly type: FieldRef<"ActivityQuestion", 'String'>
    readonly questionType: FieldRef<"ActivityQuestion", 'String'>
    readonly questionText: FieldRef<"ActivityQuestion", 'String'>
    readonly options: FieldRef<"ActivityQuestion", 'String'>
    readonly correctAnswer: FieldRef<"ActivityQuestion", 'String'>
    readonly ondasList: FieldRef<"ActivityQuestion", 'String'>
    readonly displayTimeSeconds: FieldRef<"ActivityQuestion", 'Int'>
    readonly optionalDisplaySeconds: FieldRef<"ActivityQuestion", 'Int'>
    readonly createdAt: FieldRef<"ActivityQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityQuestion findUnique
   */
  export type ActivityQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityQuestion
     */
    select?: ActivityQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ActivityQuestion to fetch.
     */
    where: ActivityQuestionWhereUniqueInput
  }

  /**
   * ActivityQuestion findUniqueOrThrow
   */
  export type ActivityQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityQuestion
     */
    select?: ActivityQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ActivityQuestion to fetch.
     */
    where: ActivityQuestionWhereUniqueInput
  }

  /**
   * ActivityQuestion findFirst
   */
  export type ActivityQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityQuestion
     */
    select?: ActivityQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ActivityQuestion to fetch.
     */
    where?: ActivityQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityQuestions to fetch.
     */
    orderBy?: ActivityQuestionOrderByWithRelationInput | ActivityQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityQuestions.
     */
    cursor?: ActivityQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityQuestions.
     */
    distinct?: ActivityQuestionScalarFieldEnum | ActivityQuestionScalarFieldEnum[]
  }

  /**
   * ActivityQuestion findFirstOrThrow
   */
  export type ActivityQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityQuestion
     */
    select?: ActivityQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ActivityQuestion to fetch.
     */
    where?: ActivityQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityQuestions to fetch.
     */
    orderBy?: ActivityQuestionOrderByWithRelationInput | ActivityQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityQuestions.
     */
    cursor?: ActivityQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityQuestions.
     */
    distinct?: ActivityQuestionScalarFieldEnum | ActivityQuestionScalarFieldEnum[]
  }

  /**
   * ActivityQuestion findMany
   */
  export type ActivityQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityQuestion
     */
    select?: ActivityQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ActivityQuestions to fetch.
     */
    where?: ActivityQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityQuestions to fetch.
     */
    orderBy?: ActivityQuestionOrderByWithRelationInput | ActivityQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityQuestions.
     */
    cursor?: ActivityQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityQuestions.
     */
    skip?: number
    distinct?: ActivityQuestionScalarFieldEnum | ActivityQuestionScalarFieldEnum[]
  }

  /**
   * ActivityQuestion create
   */
  export type ActivityQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityQuestion
     */
    select?: ActivityQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityQuestion.
     */
    data: XOR<ActivityQuestionCreateInput, ActivityQuestionUncheckedCreateInput>
  }

  /**
   * ActivityQuestion createMany
   */
  export type ActivityQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityQuestions.
     */
    data: ActivityQuestionCreateManyInput | ActivityQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityQuestion createManyAndReturn
   */
  export type ActivityQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityQuestion
     */
    select?: ActivityQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActivityQuestions.
     */
    data: ActivityQuestionCreateManyInput | ActivityQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityQuestion update
   */
  export type ActivityQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityQuestion
     */
    select?: ActivityQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityQuestion.
     */
    data: XOR<ActivityQuestionUpdateInput, ActivityQuestionUncheckedUpdateInput>
    /**
     * Choose, which ActivityQuestion to update.
     */
    where: ActivityQuestionWhereUniqueInput
  }

  /**
   * ActivityQuestion updateMany
   */
  export type ActivityQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityQuestions.
     */
    data: XOR<ActivityQuestionUpdateManyMutationInput, ActivityQuestionUncheckedUpdateManyInput>
    /**
     * Filter which ActivityQuestions to update
     */
    where?: ActivityQuestionWhereInput
  }

  /**
   * ActivityQuestion upsert
   */
  export type ActivityQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityQuestion
     */
    select?: ActivityQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityQuestion to update in case it exists.
     */
    where: ActivityQuestionWhereUniqueInput
    /**
     * In case the ActivityQuestion found by the `where` argument doesn't exist, create a new ActivityQuestion with this data.
     */
    create: XOR<ActivityQuestionCreateInput, ActivityQuestionUncheckedCreateInput>
    /**
     * In case the ActivityQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityQuestionUpdateInput, ActivityQuestionUncheckedUpdateInput>
  }

  /**
   * ActivityQuestion delete
   */
  export type ActivityQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityQuestion
     */
    select?: ActivityQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityQuestionInclude<ExtArgs> | null
    /**
     * Filter which ActivityQuestion to delete.
     */
    where: ActivityQuestionWhereUniqueInput
  }

  /**
   * ActivityQuestion deleteMany
   */
  export type ActivityQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityQuestions to delete
     */
    where?: ActivityQuestionWhereInput
  }

  /**
   * ActivityQuestion.userAnswers
   */
  export type ActivityQuestion$userAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    where?: UserAnswerWhereInput
    orderBy?: UserAnswerOrderByWithRelationInput | UserAnswerOrderByWithRelationInput[]
    cursor?: UserAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAnswerScalarFieldEnum | UserAnswerScalarFieldEnum[]
  }

  /**
   * ActivityQuestion without action
   */
  export type ActivityQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityQuestion
     */
    select?: ActivityQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityQuestionInclude<ExtArgs> | null
  }


  /**
   * Model UserAnswer
   */

  export type AggregateUserAnswer = {
    _count: UserAnswerCountAggregateOutputType | null
    _avg: UserAnswerAvgAggregateOutputType | null
    _sum: UserAnswerSumAggregateOutputType | null
    _min: UserAnswerMinAggregateOutputType | null
    _max: UserAnswerMaxAggregateOutputType | null
  }

  export type UserAnswerAvgAggregateOutputType = {
    questionId: number | null
    ondasEarned: number | null
  }

  export type UserAnswerSumAggregateOutputType = {
    questionId: number | null
    ondasEarned: number | null
  }

  export type UserAnswerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    questionId: number | null
    activityQuestionId: string | null
    answerGiven: string | null
    isCorrect: boolean | null
    ondasEarned: number | null
    createdAt: Date | null
  }

  export type UserAnswerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    questionId: number | null
    activityQuestionId: string | null
    answerGiven: string | null
    isCorrect: boolean | null
    ondasEarned: number | null
    createdAt: Date | null
  }

  export type UserAnswerCountAggregateOutputType = {
    id: number
    userId: number
    questionId: number
    activityQuestionId: number
    answerGiven: number
    isCorrect: number
    ondasEarned: number
    createdAt: number
    _all: number
  }


  export type UserAnswerAvgAggregateInputType = {
    questionId?: true
    ondasEarned?: true
  }

  export type UserAnswerSumAggregateInputType = {
    questionId?: true
    ondasEarned?: true
  }

  export type UserAnswerMinAggregateInputType = {
    id?: true
    userId?: true
    questionId?: true
    activityQuestionId?: true
    answerGiven?: true
    isCorrect?: true
    ondasEarned?: true
    createdAt?: true
  }

  export type UserAnswerMaxAggregateInputType = {
    id?: true
    userId?: true
    questionId?: true
    activityQuestionId?: true
    answerGiven?: true
    isCorrect?: true
    ondasEarned?: true
    createdAt?: true
  }

  export type UserAnswerCountAggregateInputType = {
    id?: true
    userId?: true
    questionId?: true
    activityQuestionId?: true
    answerGiven?: true
    isCorrect?: true
    ondasEarned?: true
    createdAt?: true
    _all?: true
  }

  export type UserAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAnswer to aggregate.
     */
    where?: UserAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnswers to fetch.
     */
    orderBy?: UserAnswerOrderByWithRelationInput | UserAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAnswers
    **/
    _count?: true | UserAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAnswerMaxAggregateInputType
  }

  export type GetUserAnswerAggregateType<T extends UserAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAnswer[P]>
      : GetScalarType<T[P], AggregateUserAnswer[P]>
  }




  export type UserAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAnswerWhereInput
    orderBy?: UserAnswerOrderByWithAggregationInput | UserAnswerOrderByWithAggregationInput[]
    by: UserAnswerScalarFieldEnum[] | UserAnswerScalarFieldEnum
    having?: UserAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAnswerCountAggregateInputType | true
    _avg?: UserAnswerAvgAggregateInputType
    _sum?: UserAnswerSumAggregateInputType
    _min?: UserAnswerMinAggregateInputType
    _max?: UserAnswerMaxAggregateInputType
  }

  export type UserAnswerGroupByOutputType = {
    id: string
    userId: string
    questionId: number | null
    activityQuestionId: string | null
    answerGiven: string
    isCorrect: boolean | null
    ondasEarned: number
    createdAt: Date
    _count: UserAnswerCountAggregateOutputType | null
    _avg: UserAnswerAvgAggregateOutputType | null
    _sum: UserAnswerSumAggregateOutputType | null
    _min: UserAnswerMinAggregateOutputType | null
    _max: UserAnswerMaxAggregateOutputType | null
  }

  type GetUserAnswerGroupByPayload<T extends UserAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], UserAnswerGroupByOutputType[P]>
        }
      >
    >


  export type UserAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    questionId?: boolean
    activityQuestionId?: boolean
    answerGiven?: boolean
    isCorrect?: boolean
    ondasEarned?: boolean
    createdAt?: boolean
    activityQuestion?: boolean | UserAnswer$activityQuestionArgs<ExtArgs>
    question?: boolean | UserAnswer$questionArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAnswer"]>

  export type UserAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    questionId?: boolean
    activityQuestionId?: boolean
    answerGiven?: boolean
    isCorrect?: boolean
    ondasEarned?: boolean
    createdAt?: boolean
    activityQuestion?: boolean | UserAnswer$activityQuestionArgs<ExtArgs>
    question?: boolean | UserAnswer$questionArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAnswer"]>

  export type UserAnswerSelectScalar = {
    id?: boolean
    userId?: boolean
    questionId?: boolean
    activityQuestionId?: boolean
    answerGiven?: boolean
    isCorrect?: boolean
    ondasEarned?: boolean
    createdAt?: boolean
  }

  export type UserAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityQuestion?: boolean | UserAnswer$activityQuestionArgs<ExtArgs>
    question?: boolean | UserAnswer$questionArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityQuestion?: boolean | UserAnswer$activityQuestionArgs<ExtArgs>
    question?: boolean | UserAnswer$questionArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAnswer"
    objects: {
      activityQuestion: Prisma.$ActivityQuestionPayload<ExtArgs> | null
      question: Prisma.$QuestionPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      questionId: number | null
      activityQuestionId: string | null
      answerGiven: string
      isCorrect: boolean | null
      ondasEarned: number
      createdAt: Date
    }, ExtArgs["result"]["userAnswer"]>
    composites: {}
  }

  type UserAnswerGetPayload<S extends boolean | null | undefined | UserAnswerDefaultArgs> = $Result.GetResult<Prisma.$UserAnswerPayload, S>

  type UserAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAnswerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAnswerCountAggregateInputType | true
    }

  export interface UserAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAnswer'], meta: { name: 'UserAnswer' } }
    /**
     * Find zero or one UserAnswer that matches the filter.
     * @param {UserAnswerFindUniqueArgs} args - Arguments to find a UserAnswer
     * @example
     * // Get one UserAnswer
     * const userAnswer = await prisma.userAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAnswerFindUniqueArgs>(args: SelectSubset<T, UserAnswerFindUniqueArgs<ExtArgs>>): Prisma__UserAnswerClient<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAnswer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAnswerFindUniqueOrThrowArgs} args - Arguments to find a UserAnswer
     * @example
     * // Get one UserAnswer
     * const userAnswer = await prisma.userAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAnswerClient<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswerFindFirstArgs} args - Arguments to find a UserAnswer
     * @example
     * // Get one UserAnswer
     * const userAnswer = await prisma.userAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAnswerFindFirstArgs>(args?: SelectSubset<T, UserAnswerFindFirstArgs<ExtArgs>>): Prisma__UserAnswerClient<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswerFindFirstOrThrowArgs} args - Arguments to find a UserAnswer
     * @example
     * // Get one UserAnswer
     * const userAnswer = await prisma.userAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAnswerClient<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAnswers
     * const userAnswers = await prisma.userAnswer.findMany()
     * 
     * // Get first 10 UserAnswers
     * const userAnswers = await prisma.userAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAnswerWithIdOnly = await prisma.userAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAnswerFindManyArgs>(args?: SelectSubset<T, UserAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAnswer.
     * @param {UserAnswerCreateArgs} args - Arguments to create a UserAnswer.
     * @example
     * // Create one UserAnswer
     * const UserAnswer = await prisma.userAnswer.create({
     *   data: {
     *     // ... data to create a UserAnswer
     *   }
     * })
     * 
     */
    create<T extends UserAnswerCreateArgs>(args: SelectSubset<T, UserAnswerCreateArgs<ExtArgs>>): Prisma__UserAnswerClient<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAnswers.
     * @param {UserAnswerCreateManyArgs} args - Arguments to create many UserAnswers.
     * @example
     * // Create many UserAnswers
     * const userAnswer = await prisma.userAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAnswerCreateManyArgs>(args?: SelectSubset<T, UserAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAnswers and returns the data saved in the database.
     * @param {UserAnswerCreateManyAndReturnArgs} args - Arguments to create many UserAnswers.
     * @example
     * // Create many UserAnswers
     * const userAnswer = await prisma.userAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAnswers and only return the `id`
     * const userAnswerWithIdOnly = await prisma.userAnswer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserAnswer.
     * @param {UserAnswerDeleteArgs} args - Arguments to delete one UserAnswer.
     * @example
     * // Delete one UserAnswer
     * const UserAnswer = await prisma.userAnswer.delete({
     *   where: {
     *     // ... filter to delete one UserAnswer
     *   }
     * })
     * 
     */
    delete<T extends UserAnswerDeleteArgs>(args: SelectSubset<T, UserAnswerDeleteArgs<ExtArgs>>): Prisma__UserAnswerClient<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAnswer.
     * @param {UserAnswerUpdateArgs} args - Arguments to update one UserAnswer.
     * @example
     * // Update one UserAnswer
     * const userAnswer = await prisma.userAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAnswerUpdateArgs>(args: SelectSubset<T, UserAnswerUpdateArgs<ExtArgs>>): Prisma__UserAnswerClient<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAnswers.
     * @param {UserAnswerDeleteManyArgs} args - Arguments to filter UserAnswers to delete.
     * @example
     * // Delete a few UserAnswers
     * const { count } = await prisma.userAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAnswerDeleteManyArgs>(args?: SelectSubset<T, UserAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAnswers
     * const userAnswer = await prisma.userAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAnswerUpdateManyArgs>(args: SelectSubset<T, UserAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAnswer.
     * @param {UserAnswerUpsertArgs} args - Arguments to update or create a UserAnswer.
     * @example
     * // Update or create a UserAnswer
     * const userAnswer = await prisma.userAnswer.upsert({
     *   create: {
     *     // ... data to create a UserAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAnswer we want to update
     *   }
     * })
     */
    upsert<T extends UserAnswerUpsertArgs>(args: SelectSubset<T, UserAnswerUpsertArgs<ExtArgs>>): Prisma__UserAnswerClient<$Result.GetResult<Prisma.$UserAnswerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswerCountArgs} args - Arguments to filter UserAnswers to count.
     * @example
     * // Count the number of UserAnswers
     * const count = await prisma.userAnswer.count({
     *   where: {
     *     // ... the filter for the UserAnswers we want to count
     *   }
     * })
    **/
    count<T extends UserAnswerCountArgs>(
      args?: Subset<T, UserAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAnswerAggregateArgs>(args: Subset<T, UserAnswerAggregateArgs>): Prisma.PrismaPromise<GetUserAnswerAggregateType<T>>

    /**
     * Group by UserAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAnswerGroupByArgs['orderBy'] }
        : { orderBy?: UserAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAnswer model
   */
  readonly fields: UserAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activityQuestion<T extends UserAnswer$activityQuestionArgs<ExtArgs> = {}>(args?: Subset<T, UserAnswer$activityQuestionArgs<ExtArgs>>): Prisma__ActivityQuestionClient<$Result.GetResult<Prisma.$ActivityQuestionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    question<T extends UserAnswer$questionArgs<ExtArgs> = {}>(args?: Subset<T, UserAnswer$questionArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAnswer model
   */ 
  interface UserAnswerFieldRefs {
    readonly id: FieldRef<"UserAnswer", 'String'>
    readonly userId: FieldRef<"UserAnswer", 'String'>
    readonly questionId: FieldRef<"UserAnswer", 'Int'>
    readonly activityQuestionId: FieldRef<"UserAnswer", 'String'>
    readonly answerGiven: FieldRef<"UserAnswer", 'String'>
    readonly isCorrect: FieldRef<"UserAnswer", 'Boolean'>
    readonly ondasEarned: FieldRef<"UserAnswer", 'Int'>
    readonly createdAt: FieldRef<"UserAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAnswer findUnique
   */
  export type UserAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * Filter, which UserAnswer to fetch.
     */
    where: UserAnswerWhereUniqueInput
  }

  /**
   * UserAnswer findUniqueOrThrow
   */
  export type UserAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * Filter, which UserAnswer to fetch.
     */
    where: UserAnswerWhereUniqueInput
  }

  /**
   * UserAnswer findFirst
   */
  export type UserAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * Filter, which UserAnswer to fetch.
     */
    where?: UserAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnswers to fetch.
     */
    orderBy?: UserAnswerOrderByWithRelationInput | UserAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAnswers.
     */
    cursor?: UserAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAnswers.
     */
    distinct?: UserAnswerScalarFieldEnum | UserAnswerScalarFieldEnum[]
  }

  /**
   * UserAnswer findFirstOrThrow
   */
  export type UserAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * Filter, which UserAnswer to fetch.
     */
    where?: UserAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnswers to fetch.
     */
    orderBy?: UserAnswerOrderByWithRelationInput | UserAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAnswers.
     */
    cursor?: UserAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAnswers.
     */
    distinct?: UserAnswerScalarFieldEnum | UserAnswerScalarFieldEnum[]
  }

  /**
   * UserAnswer findMany
   */
  export type UserAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * Filter, which UserAnswers to fetch.
     */
    where?: UserAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAnswers to fetch.
     */
    orderBy?: UserAnswerOrderByWithRelationInput | UserAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAnswers.
     */
    cursor?: UserAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAnswers.
     */
    skip?: number
    distinct?: UserAnswerScalarFieldEnum | UserAnswerScalarFieldEnum[]
  }

  /**
   * UserAnswer create
   */
  export type UserAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAnswer.
     */
    data: XOR<UserAnswerCreateInput, UserAnswerUncheckedCreateInput>
  }

  /**
   * UserAnswer createMany
   */
  export type UserAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAnswers.
     */
    data: UserAnswerCreateManyInput | UserAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAnswer createManyAndReturn
   */
  export type UserAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserAnswers.
     */
    data: UserAnswerCreateManyInput | UserAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAnswer update
   */
  export type UserAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAnswer.
     */
    data: XOR<UserAnswerUpdateInput, UserAnswerUncheckedUpdateInput>
    /**
     * Choose, which UserAnswer to update.
     */
    where: UserAnswerWhereUniqueInput
  }

  /**
   * UserAnswer updateMany
   */
  export type UserAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAnswers.
     */
    data: XOR<UserAnswerUpdateManyMutationInput, UserAnswerUncheckedUpdateManyInput>
    /**
     * Filter which UserAnswers to update
     */
    where?: UserAnswerWhereInput
  }

  /**
   * UserAnswer upsert
   */
  export type UserAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAnswer to update in case it exists.
     */
    where: UserAnswerWhereUniqueInput
    /**
     * In case the UserAnswer found by the `where` argument doesn't exist, create a new UserAnswer with this data.
     */
    create: XOR<UserAnswerCreateInput, UserAnswerUncheckedCreateInput>
    /**
     * In case the UserAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAnswerUpdateInput, UserAnswerUncheckedUpdateInput>
  }

  /**
   * UserAnswer delete
   */
  export type UserAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
    /**
     * Filter which UserAnswer to delete.
     */
    where: UserAnswerWhereUniqueInput
  }

  /**
   * UserAnswer deleteMany
   */
  export type UserAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAnswers to delete
     */
    where?: UserAnswerWhereInput
  }

  /**
   * UserAnswer.activityQuestion
   */
  export type UserAnswer$activityQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityQuestion
     */
    select?: ActivityQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityQuestionInclude<ExtArgs> | null
    where?: ActivityQuestionWhereInput
  }

  /**
   * UserAnswer.question
   */
  export type UserAnswer$questionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
  }

  /**
   * UserAnswer without action
   */
  export type UserAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAnswer
     */
    select?: UserAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAnswerInclude<ExtArgs> | null
  }


  /**
   * Model Token
   */

  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  export type TokenAvgAggregateOutputType = {
    amount: number | null
  }

  export type TokenSumAggregateOutputType = {
    amount: number | null
  }

  export type TokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    type: string | null
    status: string | null
    caducityDate: Date | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    type: string | null
    status: string | null
    caducityDate: Date | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokenCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    type: number
    status: number
    caducityDate: number
    source: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TokenAvgAggregateInputType = {
    amount?: true
  }

  export type TokenSumAggregateInputType = {
    amount?: true
  }

  export type TokenMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    type?: true
    status?: true
    caducityDate?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokenMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    type?: true
    status?: true
    caducityDate?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokenCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    type?: true
    status?: true
    caducityDate?: true
    source?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Token to aggregate.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }




  export type TokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithAggregationInput | TokenOrderByWithAggregationInput[]
    by: TokenScalarFieldEnum[] | TokenScalarFieldEnum
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _avg?: TokenAvgAggregateInputType
    _sum?: TokenSumAggregateInputType
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }

  export type TokenGroupByOutputType = {
    id: string
    userId: string
    amount: number
    type: string
    status: string
    caducityDate: Date | null
    source: string
    createdAt: Date
    updatedAt: Date
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenGroupByOutputType[P]>
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      >
    >


  export type TokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    type?: boolean
    status?: boolean
    caducityDate?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    type?: boolean
    status?: boolean
    caducityDate?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    type?: boolean
    status?: boolean
    caducityDate?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Token"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: number
      type: string
      status: string
      caducityDate: Date | null
      source: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["token"]>
    composites: {}
  }

  type TokenGetPayload<S extends boolean | null | undefined | TokenDefaultArgs> = $Result.GetResult<Prisma.$TokenPayload, S>

  type TokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TokenCountAggregateInputType | true
    }

  export interface TokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Token'], meta: { name: 'Token' } }
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenFindUniqueArgs>(args: SelectSubset<T, TokenFindUniqueArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Token that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TokenFindUniqueOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenFindFirstArgs>(args?: SelectSubset<T, TokenFindFirstArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenFindManyArgs>(args?: SelectSubset<T, TokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
     */
    create<T extends TokenCreateArgs>(args: SelectSubset<T, TokenCreateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tokens.
     * @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenCreateManyArgs>(args?: SelectSubset<T, TokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tokens and returns the data saved in the database.
     * @param {TokenCreateManyAndReturnArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
     */
    delete<T extends TokenDeleteArgs>(args: SelectSubset<T, TokenDeleteArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenUpdateArgs>(args: SelectSubset<T, TokenUpdateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenDeleteManyArgs>(args?: SelectSubset<T, TokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenUpdateManyArgs>(args: SelectSubset<T, TokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
     */
    upsert<T extends TokenUpsertArgs>(args: SelectSubset<T, TokenUpsertArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): Prisma.PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Token model
   */
  readonly fields: TokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Token model
   */ 
  interface TokenFieldRefs {
    readonly id: FieldRef<"Token", 'String'>
    readonly userId: FieldRef<"Token", 'String'>
    readonly amount: FieldRef<"Token", 'Float'>
    readonly type: FieldRef<"Token", 'String'>
    readonly status: FieldRef<"Token", 'String'>
    readonly caducityDate: FieldRef<"Token", 'DateTime'>
    readonly source: FieldRef<"Token", 'String'>
    readonly createdAt: FieldRef<"Token", 'DateTime'>
    readonly updatedAt: FieldRef<"Token", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Token findUnique
   */
  export type TokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findUniqueOrThrow
   */
  export type TokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findFirst
   */
  export type TokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findFirstOrThrow
   */
  export type TokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findMany
   */
  export type TokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Tokens to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token create
   */
  export type TokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to create a Token.
     */
    data: XOR<TokenCreateInput, TokenUncheckedCreateInput>
  }

  /**
   * Token createMany
   */
  export type TokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Token createManyAndReturn
   */
  export type TokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Token update
   */
  export type TokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to update a Token.
     */
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
  }

  /**
   * Token upsert
   */
  export type TokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The filter to search for the Token to update in case it exists.
     */
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     */
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
  }

  /**
   * Token delete
   */
  export type TokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter which Token to delete.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tokens to delete
     */
    where?: TokenWhereInput
  }

  /**
   * Token without action
   */
  export type TokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
  }


  /**
   * Model Merit
   */

  export type AggregateMerit = {
    _count: MeritCountAggregateOutputType | null
    _avg: MeritAvgAggregateOutputType | null
    _sum: MeritSumAggregateOutputType | null
    _min: MeritMinAggregateOutputType | null
    _max: MeritMaxAggregateOutputType | null
  }

  export type MeritAvgAggregateOutputType = {
    amount: number | null
  }

  export type MeritSumAggregateOutputType = {
    amount: number | null
  }

  export type MeritMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    type: string | null
    source: string | null
    relatedEntityId: string | null
    createdAt: Date | null
  }

  export type MeritMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    type: string | null
    source: string | null
    relatedEntityId: string | null
    createdAt: Date | null
  }

  export type MeritCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    type: number
    source: number
    relatedEntityId: number
    createdAt: number
    _all: number
  }


  export type MeritAvgAggregateInputType = {
    amount?: true
  }

  export type MeritSumAggregateInputType = {
    amount?: true
  }

  export type MeritMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    type?: true
    source?: true
    relatedEntityId?: true
    createdAt?: true
  }

  export type MeritMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    type?: true
    source?: true
    relatedEntityId?: true
    createdAt?: true
  }

  export type MeritCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    type?: true
    source?: true
    relatedEntityId?: true
    createdAt?: true
    _all?: true
  }

  export type MeritAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Merit to aggregate.
     */
    where?: MeritWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merits to fetch.
     */
    orderBy?: MeritOrderByWithRelationInput | MeritOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeritWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Merits
    **/
    _count?: true | MeritCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeritAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeritSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeritMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeritMaxAggregateInputType
  }

  export type GetMeritAggregateType<T extends MeritAggregateArgs> = {
        [P in keyof T & keyof AggregateMerit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMerit[P]>
      : GetScalarType<T[P], AggregateMerit[P]>
  }




  export type MeritGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeritWhereInput
    orderBy?: MeritOrderByWithAggregationInput | MeritOrderByWithAggregationInput[]
    by: MeritScalarFieldEnum[] | MeritScalarFieldEnum
    having?: MeritScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeritCountAggregateInputType | true
    _avg?: MeritAvgAggregateInputType
    _sum?: MeritSumAggregateInputType
    _min?: MeritMinAggregateInputType
    _max?: MeritMaxAggregateInputType
  }

  export type MeritGroupByOutputType = {
    id: string
    userId: string
    amount: number
    type: string
    source: string
    relatedEntityId: string | null
    createdAt: Date
    _count: MeritCountAggregateOutputType | null
    _avg: MeritAvgAggregateOutputType | null
    _sum: MeritSumAggregateOutputType | null
    _min: MeritMinAggregateOutputType | null
    _max: MeritMaxAggregateOutputType | null
  }

  type GetMeritGroupByPayload<T extends MeritGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeritGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeritGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeritGroupByOutputType[P]>
            : GetScalarType<T[P], MeritGroupByOutputType[P]>
        }
      >
    >


  export type MeritSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    type?: boolean
    source?: boolean
    relatedEntityId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merit"]>

  export type MeritSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    type?: boolean
    source?: boolean
    relatedEntityId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merit"]>

  export type MeritSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    type?: boolean
    source?: boolean
    relatedEntityId?: boolean
    createdAt?: boolean
  }

  export type MeritInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MeritIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MeritPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Merit"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: number
      type: string
      source: string
      relatedEntityId: string | null
      createdAt: Date
    }, ExtArgs["result"]["merit"]>
    composites: {}
  }

  type MeritGetPayload<S extends boolean | null | undefined | MeritDefaultArgs> = $Result.GetResult<Prisma.$MeritPayload, S>

  type MeritCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MeritFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MeritCountAggregateInputType | true
    }

  export interface MeritDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Merit'], meta: { name: 'Merit' } }
    /**
     * Find zero or one Merit that matches the filter.
     * @param {MeritFindUniqueArgs} args - Arguments to find a Merit
     * @example
     * // Get one Merit
     * const merit = await prisma.merit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeritFindUniqueArgs>(args: SelectSubset<T, MeritFindUniqueArgs<ExtArgs>>): Prisma__MeritClient<$Result.GetResult<Prisma.$MeritPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Merit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MeritFindUniqueOrThrowArgs} args - Arguments to find a Merit
     * @example
     * // Get one Merit
     * const merit = await prisma.merit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeritFindUniqueOrThrowArgs>(args: SelectSubset<T, MeritFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeritClient<$Result.GetResult<Prisma.$MeritPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Merit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeritFindFirstArgs} args - Arguments to find a Merit
     * @example
     * // Get one Merit
     * const merit = await prisma.merit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeritFindFirstArgs>(args?: SelectSubset<T, MeritFindFirstArgs<ExtArgs>>): Prisma__MeritClient<$Result.GetResult<Prisma.$MeritPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Merit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeritFindFirstOrThrowArgs} args - Arguments to find a Merit
     * @example
     * // Get one Merit
     * const merit = await prisma.merit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeritFindFirstOrThrowArgs>(args?: SelectSubset<T, MeritFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeritClient<$Result.GetResult<Prisma.$MeritPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Merits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeritFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Merits
     * const merits = await prisma.merit.findMany()
     * 
     * // Get first 10 Merits
     * const merits = await prisma.merit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meritWithIdOnly = await prisma.merit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeritFindManyArgs>(args?: SelectSubset<T, MeritFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeritPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Merit.
     * @param {MeritCreateArgs} args - Arguments to create a Merit.
     * @example
     * // Create one Merit
     * const Merit = await prisma.merit.create({
     *   data: {
     *     // ... data to create a Merit
     *   }
     * })
     * 
     */
    create<T extends MeritCreateArgs>(args: SelectSubset<T, MeritCreateArgs<ExtArgs>>): Prisma__MeritClient<$Result.GetResult<Prisma.$MeritPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Merits.
     * @param {MeritCreateManyArgs} args - Arguments to create many Merits.
     * @example
     * // Create many Merits
     * const merit = await prisma.merit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeritCreateManyArgs>(args?: SelectSubset<T, MeritCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Merits and returns the data saved in the database.
     * @param {MeritCreateManyAndReturnArgs} args - Arguments to create many Merits.
     * @example
     * // Create many Merits
     * const merit = await prisma.merit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Merits and only return the `id`
     * const meritWithIdOnly = await prisma.merit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeritCreateManyAndReturnArgs>(args?: SelectSubset<T, MeritCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeritPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Merit.
     * @param {MeritDeleteArgs} args - Arguments to delete one Merit.
     * @example
     * // Delete one Merit
     * const Merit = await prisma.merit.delete({
     *   where: {
     *     // ... filter to delete one Merit
     *   }
     * })
     * 
     */
    delete<T extends MeritDeleteArgs>(args: SelectSubset<T, MeritDeleteArgs<ExtArgs>>): Prisma__MeritClient<$Result.GetResult<Prisma.$MeritPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Merit.
     * @param {MeritUpdateArgs} args - Arguments to update one Merit.
     * @example
     * // Update one Merit
     * const merit = await prisma.merit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeritUpdateArgs>(args: SelectSubset<T, MeritUpdateArgs<ExtArgs>>): Prisma__MeritClient<$Result.GetResult<Prisma.$MeritPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Merits.
     * @param {MeritDeleteManyArgs} args - Arguments to filter Merits to delete.
     * @example
     * // Delete a few Merits
     * const { count } = await prisma.merit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeritDeleteManyArgs>(args?: SelectSubset<T, MeritDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Merits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeritUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Merits
     * const merit = await prisma.merit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeritUpdateManyArgs>(args: SelectSubset<T, MeritUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Merit.
     * @param {MeritUpsertArgs} args - Arguments to update or create a Merit.
     * @example
     * // Update or create a Merit
     * const merit = await prisma.merit.upsert({
     *   create: {
     *     // ... data to create a Merit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Merit we want to update
     *   }
     * })
     */
    upsert<T extends MeritUpsertArgs>(args: SelectSubset<T, MeritUpsertArgs<ExtArgs>>): Prisma__MeritClient<$Result.GetResult<Prisma.$MeritPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Merits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeritCountArgs} args - Arguments to filter Merits to count.
     * @example
     * // Count the number of Merits
     * const count = await prisma.merit.count({
     *   where: {
     *     // ... the filter for the Merits we want to count
     *   }
     * })
    **/
    count<T extends MeritCountArgs>(
      args?: Subset<T, MeritCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeritCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Merit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeritAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeritAggregateArgs>(args: Subset<T, MeritAggregateArgs>): Prisma.PrismaPromise<GetMeritAggregateType<T>>

    /**
     * Group by Merit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeritGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeritGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeritGroupByArgs['orderBy'] }
        : { orderBy?: MeritGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeritGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeritGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Merit model
   */
  readonly fields: MeritFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Merit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeritClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Merit model
   */ 
  interface MeritFieldRefs {
    readonly id: FieldRef<"Merit", 'String'>
    readonly userId: FieldRef<"Merit", 'String'>
    readonly amount: FieldRef<"Merit", 'Float'>
    readonly type: FieldRef<"Merit", 'String'>
    readonly source: FieldRef<"Merit", 'String'>
    readonly relatedEntityId: FieldRef<"Merit", 'String'>
    readonly createdAt: FieldRef<"Merit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Merit findUnique
   */
  export type MeritFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merit
     */
    select?: MeritSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeritInclude<ExtArgs> | null
    /**
     * Filter, which Merit to fetch.
     */
    where: MeritWhereUniqueInput
  }

  /**
   * Merit findUniqueOrThrow
   */
  export type MeritFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merit
     */
    select?: MeritSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeritInclude<ExtArgs> | null
    /**
     * Filter, which Merit to fetch.
     */
    where: MeritWhereUniqueInput
  }

  /**
   * Merit findFirst
   */
  export type MeritFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merit
     */
    select?: MeritSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeritInclude<ExtArgs> | null
    /**
     * Filter, which Merit to fetch.
     */
    where?: MeritWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merits to fetch.
     */
    orderBy?: MeritOrderByWithRelationInput | MeritOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Merits.
     */
    cursor?: MeritWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Merits.
     */
    distinct?: MeritScalarFieldEnum | MeritScalarFieldEnum[]
  }

  /**
   * Merit findFirstOrThrow
   */
  export type MeritFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merit
     */
    select?: MeritSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeritInclude<ExtArgs> | null
    /**
     * Filter, which Merit to fetch.
     */
    where?: MeritWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merits to fetch.
     */
    orderBy?: MeritOrderByWithRelationInput | MeritOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Merits.
     */
    cursor?: MeritWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Merits.
     */
    distinct?: MeritScalarFieldEnum | MeritScalarFieldEnum[]
  }

  /**
   * Merit findMany
   */
  export type MeritFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merit
     */
    select?: MeritSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeritInclude<ExtArgs> | null
    /**
     * Filter, which Merits to fetch.
     */
    where?: MeritWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Merits to fetch.
     */
    orderBy?: MeritOrderByWithRelationInput | MeritOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Merits.
     */
    cursor?: MeritWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Merits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Merits.
     */
    skip?: number
    distinct?: MeritScalarFieldEnum | MeritScalarFieldEnum[]
  }

  /**
   * Merit create
   */
  export type MeritCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merit
     */
    select?: MeritSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeritInclude<ExtArgs> | null
    /**
     * The data needed to create a Merit.
     */
    data: XOR<MeritCreateInput, MeritUncheckedCreateInput>
  }

  /**
   * Merit createMany
   */
  export type MeritCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Merits.
     */
    data: MeritCreateManyInput | MeritCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Merit createManyAndReturn
   */
  export type MeritCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merit
     */
    select?: MeritSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Merits.
     */
    data: MeritCreateManyInput | MeritCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeritIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Merit update
   */
  export type MeritUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merit
     */
    select?: MeritSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeritInclude<ExtArgs> | null
    /**
     * The data needed to update a Merit.
     */
    data: XOR<MeritUpdateInput, MeritUncheckedUpdateInput>
    /**
     * Choose, which Merit to update.
     */
    where: MeritWhereUniqueInput
  }

  /**
   * Merit updateMany
   */
  export type MeritUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Merits.
     */
    data: XOR<MeritUpdateManyMutationInput, MeritUncheckedUpdateManyInput>
    /**
     * Filter which Merits to update
     */
    where?: MeritWhereInput
  }

  /**
   * Merit upsert
   */
  export type MeritUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merit
     */
    select?: MeritSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeritInclude<ExtArgs> | null
    /**
     * The filter to search for the Merit to update in case it exists.
     */
    where: MeritWhereUniqueInput
    /**
     * In case the Merit found by the `where` argument doesn't exist, create a new Merit with this data.
     */
    create: XOR<MeritCreateInput, MeritUncheckedCreateInput>
    /**
     * In case the Merit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeritUpdateInput, MeritUncheckedUpdateInput>
  }

  /**
   * Merit delete
   */
  export type MeritDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merit
     */
    select?: MeritSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeritInclude<ExtArgs> | null
    /**
     * Filter which Merit to delete.
     */
    where: MeritWhereUniqueInput
  }

  /**
   * Merit deleteMany
   */
  export type MeritDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Merits to delete
     */
    where?: MeritWhereInput
  }

  /**
   * Merit without action
   */
  export type MeritDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Merit
     */
    select?: MeritSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeritInclude<ExtArgs> | null
  }


  /**
   * Model Wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    balanceUnits: number | null
    balanceToins: number | null
  }

  export type WalletSumAggregateOutputType = {
    balanceUnits: number | null
    balanceToins: number | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    userId: string | null
    blockchainAddress: string | null
    balanceUnits: number | null
    balanceToins: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    blockchainAddress: string | null
    balanceUnits: number | null
    balanceToins: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    userId: number
    blockchainAddress: number
    balanceUnits: number
    balanceToins: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    balanceUnits?: true
    balanceToins?: true
  }

  export type WalletSumAggregateInputType = {
    balanceUnits?: true
    balanceToins?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    userId?: true
    blockchainAddress?: true
    balanceUnits?: true
    balanceToins?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    userId?: true
    blockchainAddress?: true
    balanceUnits?: true
    balanceToins?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    userId?: true
    blockchainAddress?: true
    balanceUnits?: true
    balanceToins?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallet to aggregate.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithAggregationInput | WalletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    id: string
    userId: string
    blockchainAddress: string | null
    balanceUnits: number
    balanceToins: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    blockchainAddress?: boolean
    balanceUnits?: boolean
    balanceToins?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionsTo?: boolean | Wallet$transactionsToArgs<ExtArgs>
    transactionsFrom?: boolean | Wallet$transactionsFromArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    blockchainAddress?: boolean
    balanceUnits?: boolean
    balanceToins?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectScalar = {
    id?: boolean
    userId?: boolean
    blockchainAddress?: boolean
    balanceUnits?: boolean
    balanceToins?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactionsTo?: boolean | Wallet$transactionsToArgs<ExtArgs>
    transactionsFrom?: boolean | Wallet$transactionsFromArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wallet"
    objects: {
      transactionsTo: Prisma.$TransactionPayload<ExtArgs>[]
      transactionsFrom: Prisma.$TransactionPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      blockchainAddress: string | null
      balanceUnits: number
      balanceToins: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type WalletGetPayload<S extends boolean | null | undefined | WalletDefaultArgs> = $Result.GetResult<Prisma.$WalletPayload, S>

  type WalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WalletFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface WalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wallet'], meta: { name: 'Wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletFindUniqueArgs>(args: SelectSubset<T, WalletFindUniqueArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletFindFirstArgs>(args?: SelectSubset<T, WalletFindFirstArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletFindManyArgs>(args?: SelectSubset<T, WalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends WalletCreateArgs>(args: SelectSubset<T, WalletCreateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Wallets.
     * @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletCreateManyArgs>(args?: SelectSubset<T, WalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallets and returns the data saved in the database.
     * @param {WalletCreateManyAndReturnArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends WalletDeleteArgs>(args: SelectSubset<T, WalletDeleteArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletUpdateArgs>(args: SelectSubset<T, WalletUpdateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletDeleteManyArgs>(args?: SelectSubset<T, WalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletUpdateManyArgs>(args: SelectSubset<T, WalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends WalletUpsertArgs>(args: SelectSubset<T, WalletUpsertArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wallet model
   */
  readonly fields: WalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactionsTo<T extends Wallet$transactionsToArgs<ExtArgs> = {}>(args?: Subset<T, Wallet$transactionsToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    transactionsFrom<T extends Wallet$transactionsFromArgs<ExtArgs> = {}>(args?: Subset<T, Wallet$transactionsFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wallet model
   */ 
  interface WalletFieldRefs {
    readonly id: FieldRef<"Wallet", 'String'>
    readonly userId: FieldRef<"Wallet", 'String'>
    readonly blockchainAddress: FieldRef<"Wallet", 'String'>
    readonly balanceUnits: FieldRef<"Wallet", 'Float'>
    readonly balanceToins: FieldRef<"Wallet", 'Float'>
    readonly status: FieldRef<"Wallet", 'String'>
    readonly createdAt: FieldRef<"Wallet", 'DateTime'>
    readonly updatedAt: FieldRef<"Wallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet create
   */
  export type WalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to create a Wallet.
     */
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }

  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wallet createManyAndReturn
   */
  export type WalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet update
   */
  export type WalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to update a Wallet.
     */
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
  }

  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     */
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     */
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }

  /**
   * Wallet delete
   */
  export type WalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter which Wallet to delete.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletWhereInput
  }

  /**
   * Wallet.transactionsTo
   */
  export type Wallet$transactionsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Wallet.transactionsFrom
   */
  export type Wallet$transactionsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Wallet without action
   */
  export type WalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    fromUserId: string | null
    toUserId: string | null
    amount: number | null
    tokenType: string | null
    type: string | null
    status: string | null
    description: string | null
    createdAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    fromUserId: string | null
    toUserId: string | null
    amount: number | null
    tokenType: string | null
    type: string | null
    status: string | null
    description: string | null
    createdAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    fromUserId: number
    toUserId: number
    amount: number
    tokenType: number
    type: number
    status: number
    description: number
    createdAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    amount?: true
    tokenType?: true
    type?: true
    status?: true
    description?: true
    createdAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    amount?: true
    tokenType?: true
    type?: true
    status?: true
    description?: true
    createdAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    amount?: true
    tokenType?: true
    type?: true
    status?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    fromUserId: string | null
    toUserId: string
    amount: number
    tokenType: string
    type: string
    status: string
    description: string | null
    createdAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    amount?: boolean
    tokenType?: boolean
    type?: boolean
    status?: boolean
    description?: boolean
    createdAt?: boolean
    toWallet?: boolean | WalletDefaultArgs<ExtArgs>
    fromWallet?: boolean | Transaction$fromWalletArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
    fromUser?: boolean | Transaction$fromUserArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    amount?: boolean
    tokenType?: boolean
    type?: boolean
    status?: boolean
    description?: boolean
    createdAt?: boolean
    toWallet?: boolean | WalletDefaultArgs<ExtArgs>
    fromWallet?: boolean | Transaction$fromWalletArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
    fromUser?: boolean | Transaction$fromUserArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    amount?: boolean
    tokenType?: boolean
    type?: boolean
    status?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toWallet?: boolean | WalletDefaultArgs<ExtArgs>
    fromWallet?: boolean | Transaction$fromWalletArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
    fromUser?: boolean | Transaction$fromUserArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toWallet?: boolean | WalletDefaultArgs<ExtArgs>
    fromWallet?: boolean | Transaction$fromWalletArgs<ExtArgs>
    toUser?: boolean | UserDefaultArgs<ExtArgs>
    fromUser?: boolean | Transaction$fromUserArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      toWallet: Prisma.$WalletPayload<ExtArgs>
      fromWallet: Prisma.$WalletPayload<ExtArgs> | null
      toUser: Prisma.$UserPayload<ExtArgs>
      fromUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromUserId: string | null
      toUserId: string
      amount: number
      tokenType: string
      type: string
      status: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    toWallet<T extends WalletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WalletDefaultArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    fromWallet<T extends Transaction$fromWalletArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$fromWalletArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    toUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    fromUser<T extends Transaction$fromUserArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$fromUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly fromUserId: FieldRef<"Transaction", 'String'>
    readonly toUserId: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly tokenType: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction.fromWallet
   */
  export type Transaction$fromWalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
  }

  /**
   * Transaction.fromUser
   */
  export type Transaction$fromUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ownerId: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ownerId: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    ownerId: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: string
    name: string
    description: string | null
    ownerId: string
    type: string
    createdAt: Date
    updatedAt: Date
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    userGroups?: boolean | Group$userGroupsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    userGroups?: boolean | Group$userGroupsArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      userGroups: Prisma.$UserGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      ownerId: string
      type: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    userGroups<T extends Group$userGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Group$userGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */ 
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'String'>
    readonly name: FieldRef<"Group", 'String'>
    readonly description: FieldRef<"Group", 'String'>
    readonly ownerId: FieldRef<"Group", 'String'>
    readonly type: FieldRef<"Group", 'String'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
    readonly updatedAt: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
  }

  /**
   * Group.userGroups
   */
  export type Group$userGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    where?: UserGroupWhereInput
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    cursor?: UserGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model UserGroup
   */

  export type AggregateUserGroup = {
    _count: UserGroupCountAggregateOutputType | null
    _min: UserGroupMinAggregateOutputType | null
    _max: UserGroupMaxAggregateOutputType | null
  }

  export type UserGroupMinAggregateOutputType = {
    userId: string | null
    groupId: string | null
    roleInGroup: string | null
    joinedAt: Date | null
  }

  export type UserGroupMaxAggregateOutputType = {
    userId: string | null
    groupId: string | null
    roleInGroup: string | null
    joinedAt: Date | null
  }

  export type UserGroupCountAggregateOutputType = {
    userId: number
    groupId: number
    roleInGroup: number
    joinedAt: number
    _all: number
  }


  export type UserGroupMinAggregateInputType = {
    userId?: true
    groupId?: true
    roleInGroup?: true
    joinedAt?: true
  }

  export type UserGroupMaxAggregateInputType = {
    userId?: true
    groupId?: true
    roleInGroup?: true
    joinedAt?: true
  }

  export type UserGroupCountAggregateInputType = {
    userId?: true
    groupId?: true
    roleInGroup?: true
    joinedAt?: true
    _all?: true
  }

  export type UserGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGroup to aggregate.
     */
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserGroups
    **/
    _count?: true | UserGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserGroupMaxAggregateInputType
  }

  export type GetUserGroupAggregateType<T extends UserGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateUserGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserGroup[P]>
      : GetScalarType<T[P], AggregateUserGroup[P]>
  }




  export type UserGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGroupWhereInput
    orderBy?: UserGroupOrderByWithAggregationInput | UserGroupOrderByWithAggregationInput[]
    by: UserGroupScalarFieldEnum[] | UserGroupScalarFieldEnum
    having?: UserGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserGroupCountAggregateInputType | true
    _min?: UserGroupMinAggregateInputType
    _max?: UserGroupMaxAggregateInputType
  }

  export type UserGroupGroupByOutputType = {
    userId: string
    groupId: string
    roleInGroup: string
    joinedAt: Date
    _count: UserGroupCountAggregateOutputType | null
    _min: UserGroupMinAggregateOutputType | null
    _max: UserGroupMaxAggregateOutputType | null
  }

  type GetUserGroupGroupByPayload<T extends UserGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupGroupByOutputType[P]>
        }
      >
    >


  export type UserGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    groupId?: boolean
    roleInGroup?: boolean
    joinedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGroup"]>

  export type UserGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    groupId?: boolean
    roleInGroup?: boolean
    joinedAt?: boolean
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGroup"]>

  export type UserGroupSelectScalar = {
    userId?: boolean
    groupId?: boolean
    roleInGroup?: boolean
    joinedAt?: boolean
  }

  export type UserGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | GroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserGroup"
    objects: {
      group: Prisma.$GroupPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      groupId: string
      roleInGroup: string
      joinedAt: Date
    }, ExtArgs["result"]["userGroup"]>
    composites: {}
  }

  type UserGroupGetPayload<S extends boolean | null | undefined | UserGroupDefaultArgs> = $Result.GetResult<Prisma.$UserGroupPayload, S>

  type UserGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserGroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserGroupCountAggregateInputType | true
    }

  export interface UserGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserGroup'], meta: { name: 'UserGroup' } }
    /**
     * Find zero or one UserGroup that matches the filter.
     * @param {UserGroupFindUniqueArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserGroupFindUniqueArgs>(args: SelectSubset<T, UserGroupFindUniqueArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserGroup that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserGroupFindUniqueOrThrowArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, UserGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupFindFirstArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserGroupFindFirstArgs>(args?: SelectSubset<T, UserGroupFindFirstArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupFindFirstOrThrowArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, UserGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserGroups
     * const userGroups = await prisma.userGroup.findMany()
     * 
     * // Get first 10 UserGroups
     * const userGroups = await prisma.userGroup.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userGroupWithUserIdOnly = await prisma.userGroup.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserGroupFindManyArgs>(args?: SelectSubset<T, UserGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserGroup.
     * @param {UserGroupCreateArgs} args - Arguments to create a UserGroup.
     * @example
     * // Create one UserGroup
     * const UserGroup = await prisma.userGroup.create({
     *   data: {
     *     // ... data to create a UserGroup
     *   }
     * })
     * 
     */
    create<T extends UserGroupCreateArgs>(args: SelectSubset<T, UserGroupCreateArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserGroups.
     * @param {UserGroupCreateManyArgs} args - Arguments to create many UserGroups.
     * @example
     * // Create many UserGroups
     * const userGroup = await prisma.userGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserGroupCreateManyArgs>(args?: SelectSubset<T, UserGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserGroups and returns the data saved in the database.
     * @param {UserGroupCreateManyAndReturnArgs} args - Arguments to create many UserGroups.
     * @example
     * // Create many UserGroups
     * const userGroup = await prisma.userGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserGroups and only return the `userId`
     * const userGroupWithUserIdOnly = await prisma.userGroup.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, UserGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserGroup.
     * @param {UserGroupDeleteArgs} args - Arguments to delete one UserGroup.
     * @example
     * // Delete one UserGroup
     * const UserGroup = await prisma.userGroup.delete({
     *   where: {
     *     // ... filter to delete one UserGroup
     *   }
     * })
     * 
     */
    delete<T extends UserGroupDeleteArgs>(args: SelectSubset<T, UserGroupDeleteArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserGroup.
     * @param {UserGroupUpdateArgs} args - Arguments to update one UserGroup.
     * @example
     * // Update one UserGroup
     * const userGroup = await prisma.userGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserGroupUpdateArgs>(args: SelectSubset<T, UserGroupUpdateArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserGroups.
     * @param {UserGroupDeleteManyArgs} args - Arguments to filter UserGroups to delete.
     * @example
     * // Delete a few UserGroups
     * const { count } = await prisma.userGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserGroupDeleteManyArgs>(args?: SelectSubset<T, UserGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserGroups
     * const userGroup = await prisma.userGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserGroupUpdateManyArgs>(args: SelectSubset<T, UserGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserGroup.
     * @param {UserGroupUpsertArgs} args - Arguments to update or create a UserGroup.
     * @example
     * // Update or create a UserGroup
     * const userGroup = await prisma.userGroup.upsert({
     *   create: {
     *     // ... data to create a UserGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserGroup we want to update
     *   }
     * })
     */
    upsert<T extends UserGroupUpsertArgs>(args: SelectSubset<T, UserGroupUpsertArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupCountArgs} args - Arguments to filter UserGroups to count.
     * @example
     * // Count the number of UserGroups
     * const count = await prisma.userGroup.count({
     *   where: {
     *     // ... the filter for the UserGroups we want to count
     *   }
     * })
    **/
    count<T extends UserGroupCountArgs>(
      args?: Subset<T, UserGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserGroupAggregateArgs>(args: Subset<T, UserGroupAggregateArgs>): Prisma.PrismaPromise<GetUserGroupAggregateType<T>>

    /**
     * Group by UserGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserGroup model
   */
  readonly fields: UserGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserGroup model
   */ 
  interface UserGroupFieldRefs {
    readonly userId: FieldRef<"UserGroup", 'String'>
    readonly groupId: FieldRef<"UserGroup", 'String'>
    readonly roleInGroup: FieldRef<"UserGroup", 'String'>
    readonly joinedAt: FieldRef<"UserGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserGroup findUnique
   */
  export type UserGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroup to fetch.
     */
    where: UserGroupWhereUniqueInput
  }

  /**
   * UserGroup findUniqueOrThrow
   */
  export type UserGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroup to fetch.
     */
    where: UserGroupWhereUniqueInput
  }

  /**
   * UserGroup findFirst
   */
  export type UserGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroup to fetch.
     */
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGroups.
     */
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGroups.
     */
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * UserGroup findFirstOrThrow
   */
  export type UserGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroup to fetch.
     */
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGroups.
     */
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGroups.
     */
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * UserGroup findMany
   */
  export type UserGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroups to fetch.
     */
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserGroups.
     */
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * UserGroup create
   */
  export type UserGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a UserGroup.
     */
    data: XOR<UserGroupCreateInput, UserGroupUncheckedCreateInput>
  }

  /**
   * UserGroup createMany
   */
  export type UserGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserGroups.
     */
    data: UserGroupCreateManyInput | UserGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserGroup createManyAndReturn
   */
  export type UserGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserGroups.
     */
    data: UserGroupCreateManyInput | UserGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserGroup update
   */
  export type UserGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a UserGroup.
     */
    data: XOR<UserGroupUpdateInput, UserGroupUncheckedUpdateInput>
    /**
     * Choose, which UserGroup to update.
     */
    where: UserGroupWhereUniqueInput
  }

  /**
   * UserGroup updateMany
   */
  export type UserGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserGroups.
     */
    data: XOR<UserGroupUpdateManyMutationInput, UserGroupUncheckedUpdateManyInput>
    /**
     * Filter which UserGroups to update
     */
    where?: UserGroupWhereInput
  }

  /**
   * UserGroup upsert
   */
  export type UserGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the UserGroup to update in case it exists.
     */
    where: UserGroupWhereUniqueInput
    /**
     * In case the UserGroup found by the `where` argument doesn't exist, create a new UserGroup with this data.
     */
    create: XOR<UserGroupCreateInput, UserGroupUncheckedCreateInput>
    /**
     * In case the UserGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserGroupUpdateInput, UserGroupUncheckedUpdateInput>
  }

  /**
   * UserGroup delete
   */
  export type UserGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter which UserGroup to delete.
     */
    where: UserGroupWhereUniqueInput
  }

  /**
   * UserGroup deleteMany
   */
  export type UserGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGroups to delete
     */
    where?: UserGroupWhereInput
  }

  /**
   * UserGroup without action
   */
  export type UserGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
  }


  /**
   * Model Publication
   */

  export type AggregatePublication = {
    _count: PublicationCountAggregateOutputType | null
    _min: PublicationMinAggregateOutputType | null
    _max: PublicationMaxAggregateOutputType | null
  }

  export type PublicationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PublicationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PublicationCountAggregateOutputType = {
    id: number
    userId: number
    content: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PublicationMinAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PublicationMaxAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PublicationCountAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PublicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Publication to aggregate.
     */
    where?: PublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Publications
    **/
    _count?: true | PublicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicationMaxAggregateInputType
  }

  export type GetPublicationAggregateType<T extends PublicationAggregateArgs> = {
        [P in keyof T & keyof AggregatePublication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublication[P]>
      : GetScalarType<T[P], AggregatePublication[P]>
  }




  export type PublicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationWhereInput
    orderBy?: PublicationOrderByWithAggregationInput | PublicationOrderByWithAggregationInput[]
    by: PublicationScalarFieldEnum[] | PublicationScalarFieldEnum
    having?: PublicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicationCountAggregateInputType | true
    _min?: PublicationMinAggregateInputType
    _max?: PublicationMaxAggregateInputType
  }

  export type PublicationGroupByOutputType = {
    id: string
    userId: string
    content: string
    type: string
    createdAt: Date
    updatedAt: Date
    _count: PublicationCountAggregateOutputType | null
    _min: PublicationMinAggregateOutputType | null
    _max: PublicationMaxAggregateOutputType | null
  }

  type GetPublicationGroupByPayload<T extends PublicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicationGroupByOutputType[P]>
            : GetScalarType<T[P], PublicationGroupByOutputType[P]>
        }
      >
    >


  export type PublicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comments?: boolean | Publication$commentsArgs<ExtArgs>
    likes?: boolean | Publication$likesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PublicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publication"]>

  export type PublicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publication"]>

  export type PublicationSelectScalar = {
    id?: boolean
    userId?: boolean
    content?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PublicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | Publication$commentsArgs<ExtArgs>
    likes?: boolean | Publication$likesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PublicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PublicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PublicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Publication"
    objects: {
      comments: Prisma.$CommentPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      content: string
      type: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["publication"]>
    composites: {}
  }

  type PublicationGetPayload<S extends boolean | null | undefined | PublicationDefaultArgs> = $Result.GetResult<Prisma.$PublicationPayload, S>

  type PublicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PublicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PublicationCountAggregateInputType | true
    }

  export interface PublicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Publication'], meta: { name: 'Publication' } }
    /**
     * Find zero or one Publication that matches the filter.
     * @param {PublicationFindUniqueArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PublicationFindUniqueArgs>(args: SelectSubset<T, PublicationFindUniqueArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Publication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PublicationFindUniqueOrThrowArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PublicationFindUniqueOrThrowArgs>(args: SelectSubset<T, PublicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Publication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationFindFirstArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PublicationFindFirstArgs>(args?: SelectSubset<T, PublicationFindFirstArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Publication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationFindFirstOrThrowArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PublicationFindFirstOrThrowArgs>(args?: SelectSubset<T, PublicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Publications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publications
     * const publications = await prisma.publication.findMany()
     * 
     * // Get first 10 Publications
     * const publications = await prisma.publication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publicationWithIdOnly = await prisma.publication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PublicationFindManyArgs>(args?: SelectSubset<T, PublicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Publication.
     * @param {PublicationCreateArgs} args - Arguments to create a Publication.
     * @example
     * // Create one Publication
     * const Publication = await prisma.publication.create({
     *   data: {
     *     // ... data to create a Publication
     *   }
     * })
     * 
     */
    create<T extends PublicationCreateArgs>(args: SelectSubset<T, PublicationCreateArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Publications.
     * @param {PublicationCreateManyArgs} args - Arguments to create many Publications.
     * @example
     * // Create many Publications
     * const publication = await prisma.publication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PublicationCreateManyArgs>(args?: SelectSubset<T, PublicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Publications and returns the data saved in the database.
     * @param {PublicationCreateManyAndReturnArgs} args - Arguments to create many Publications.
     * @example
     * // Create many Publications
     * const publication = await prisma.publication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Publications and only return the `id`
     * const publicationWithIdOnly = await prisma.publication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PublicationCreateManyAndReturnArgs>(args?: SelectSubset<T, PublicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Publication.
     * @param {PublicationDeleteArgs} args - Arguments to delete one Publication.
     * @example
     * // Delete one Publication
     * const Publication = await prisma.publication.delete({
     *   where: {
     *     // ... filter to delete one Publication
     *   }
     * })
     * 
     */
    delete<T extends PublicationDeleteArgs>(args: SelectSubset<T, PublicationDeleteArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Publication.
     * @param {PublicationUpdateArgs} args - Arguments to update one Publication.
     * @example
     * // Update one Publication
     * const publication = await prisma.publication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PublicationUpdateArgs>(args: SelectSubset<T, PublicationUpdateArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Publications.
     * @param {PublicationDeleteManyArgs} args - Arguments to filter Publications to delete.
     * @example
     * // Delete a few Publications
     * const { count } = await prisma.publication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PublicationDeleteManyArgs>(args?: SelectSubset<T, PublicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publications
     * const publication = await prisma.publication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PublicationUpdateManyArgs>(args: SelectSubset<T, PublicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Publication.
     * @param {PublicationUpsertArgs} args - Arguments to update or create a Publication.
     * @example
     * // Update or create a Publication
     * const publication = await prisma.publication.upsert({
     *   create: {
     *     // ... data to create a Publication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publication we want to update
     *   }
     * })
     */
    upsert<T extends PublicationUpsertArgs>(args: SelectSubset<T, PublicationUpsertArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationCountArgs} args - Arguments to filter Publications to count.
     * @example
     * // Count the number of Publications
     * const count = await prisma.publication.count({
     *   where: {
     *     // ... the filter for the Publications we want to count
     *   }
     * })
    **/
    count<T extends PublicationCountArgs>(
      args?: Subset<T, PublicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicationAggregateArgs>(args: Subset<T, PublicationAggregateArgs>): Prisma.PrismaPromise<GetPublicationAggregateType<T>>

    /**
     * Group by Publication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublicationGroupByArgs['orderBy'] }
        : { orderBy?: PublicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Publication model
   */
  readonly fields: PublicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Publication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PublicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends Publication$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Publication$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    likes<T extends Publication$likesArgs<ExtArgs> = {}>(args?: Subset<T, Publication$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Publication model
   */ 
  interface PublicationFieldRefs {
    readonly id: FieldRef<"Publication", 'String'>
    readonly userId: FieldRef<"Publication", 'String'>
    readonly content: FieldRef<"Publication", 'String'>
    readonly type: FieldRef<"Publication", 'String'>
    readonly createdAt: FieldRef<"Publication", 'DateTime'>
    readonly updatedAt: FieldRef<"Publication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Publication findUnique
   */
  export type PublicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publication to fetch.
     */
    where: PublicationWhereUniqueInput
  }

  /**
   * Publication findUniqueOrThrow
   */
  export type PublicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publication to fetch.
     */
    where: PublicationWhereUniqueInput
  }

  /**
   * Publication findFirst
   */
  export type PublicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publication to fetch.
     */
    where?: PublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Publications.
     */
    cursor?: PublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Publications.
     */
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }

  /**
   * Publication findFirstOrThrow
   */
  export type PublicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publication to fetch.
     */
    where?: PublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Publications.
     */
    cursor?: PublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Publications.
     */
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }

  /**
   * Publication findMany
   */
  export type PublicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publications to fetch.
     */
    where?: PublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Publications.
     */
    cursor?: PublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }

  /**
   * Publication create
   */
  export type PublicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Publication.
     */
    data: XOR<PublicationCreateInput, PublicationUncheckedCreateInput>
  }

  /**
   * Publication createMany
   */
  export type PublicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Publications.
     */
    data: PublicationCreateManyInput | PublicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Publication createManyAndReturn
   */
  export type PublicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Publications.
     */
    data: PublicationCreateManyInput | PublicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Publication update
   */
  export type PublicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Publication.
     */
    data: XOR<PublicationUpdateInput, PublicationUncheckedUpdateInput>
    /**
     * Choose, which Publication to update.
     */
    where: PublicationWhereUniqueInput
  }

  /**
   * Publication updateMany
   */
  export type PublicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Publications.
     */
    data: XOR<PublicationUpdateManyMutationInput, PublicationUncheckedUpdateManyInput>
    /**
     * Filter which Publications to update
     */
    where?: PublicationWhereInput
  }

  /**
   * Publication upsert
   */
  export type PublicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Publication to update in case it exists.
     */
    where: PublicationWhereUniqueInput
    /**
     * In case the Publication found by the `where` argument doesn't exist, create a new Publication with this data.
     */
    create: XOR<PublicationCreateInput, PublicationUncheckedCreateInput>
    /**
     * In case the Publication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PublicationUpdateInput, PublicationUncheckedUpdateInput>
  }

  /**
   * Publication delete
   */
  export type PublicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter which Publication to delete.
     */
    where: PublicationWhereUniqueInput
  }

  /**
   * Publication deleteMany
   */
  export type PublicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Publications to delete
     */
    where?: PublicationWhereInput
  }

  /**
   * Publication.comments
   */
  export type Publication$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Publication.likes
   */
  export type Publication$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Publication without action
   */
  export type PublicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    publicationId: string | null
    activityId: string | null
    text: string | null
    createdAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    publicationId: string | null
    activityId: string | null
    text: string | null
    createdAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    userId: number
    publicationId: number
    activityId: number
    text: number
    createdAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    userId?: true
    publicationId?: true
    activityId?: true
    text?: true
    createdAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    userId?: true
    publicationId?: true
    activityId?: true
    text?: true
    createdAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    userId?: true
    publicationId?: true
    activityId?: true
    text?: true
    createdAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    userId: string
    publicationId: string | null
    activityId: string | null
    text: string
    createdAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    publicationId?: boolean
    activityId?: boolean
    text?: boolean
    createdAt?: boolean
    publication?: boolean | Comment$publicationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    publicationId?: boolean
    activityId?: boolean
    text?: boolean
    createdAt?: boolean
    publication?: boolean | Comment$publicationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    userId?: boolean
    publicationId?: boolean
    activityId?: boolean
    text?: boolean
    createdAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publication?: boolean | Comment$publicationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publication?: boolean | Comment$publicationArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      publication: Prisma.$PublicationPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      publicationId: string | null
      activityId: string | null
      text: string
      createdAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    publication<T extends Comment$publicationArgs<ExtArgs> = {}>(args?: Subset<T, Comment$publicationArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
    readonly publicationId: FieldRef<"Comment", 'String'>
    readonly activityId: FieldRef<"Comment", 'String'>
    readonly text: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment.publication
   */
  export type Comment$publicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicationInclude<ExtArgs> | null
    where?: PublicationWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Like
   */

  export type AggregateLike = {
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  export type LikeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    publicationId: string | null
    createdAt: Date | null
  }

  export type LikeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    publicationId: string | null
    createdAt: Date | null
  }

  export type LikeCountAggregateOutputType = {
    id: number
    userId: number
    publicationId: number
    createdAt: number
    _all: number
  }


  export type LikeMinAggregateInputType = {
    id?: true
    userId?: true
    publicationId?: true
    createdAt?: true
  }

  export type LikeMaxAggregateInputType = {
    id?: true
    userId?: true
    publicationId?: true
    createdAt?: true
  }

  export type LikeCountAggregateInputType = {
    id?: true
    userId?: true
    publicationId?: true
    createdAt?: true
    _all?: true
  }

  export type LikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Like to aggregate.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Likes
    **/
    _count?: true | LikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeMaxAggregateInputType
  }

  export type GetLikeAggregateType<T extends LikeAggregateArgs> = {
        [P in keyof T & keyof AggregateLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLike[P]>
      : GetScalarType<T[P], AggregateLike[P]>
  }




  export type LikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithAggregationInput | LikeOrderByWithAggregationInput[]
    by: LikeScalarFieldEnum[] | LikeScalarFieldEnum
    having?: LikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeCountAggregateInputType | true
    _min?: LikeMinAggregateInputType
    _max?: LikeMaxAggregateInputType
  }

  export type LikeGroupByOutputType = {
    id: string
    userId: string
    publicationId: string
    createdAt: Date
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  type GetLikeGroupByPayload<T extends LikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeGroupByOutputType[P]>
            : GetScalarType<T[P], LikeGroupByOutputType[P]>
        }
      >
    >


  export type LikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    publicationId?: boolean
    createdAt?: boolean
    publication?: boolean | PublicationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    publicationId?: boolean
    createdAt?: boolean
    publication?: boolean | PublicationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectScalar = {
    id?: boolean
    userId?: boolean
    publicationId?: boolean
    createdAt?: boolean
  }

  export type LikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publication?: boolean | PublicationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publication?: boolean | PublicationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Like"
    objects: {
      publication: Prisma.$PublicationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      publicationId: string
      createdAt: Date
    }, ExtArgs["result"]["like"]>
    composites: {}
  }

  type LikeGetPayload<S extends boolean | null | undefined | LikeDefaultArgs> = $Result.GetResult<Prisma.$LikePayload, S>

  type LikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LikeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LikeCountAggregateInputType | true
    }

  export interface LikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Like'], meta: { name: 'Like' } }
    /**
     * Find zero or one Like that matches the filter.
     * @param {LikeFindUniqueArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikeFindUniqueArgs>(args: SelectSubset<T, LikeFindUniqueArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Like that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LikeFindUniqueOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikeFindUniqueOrThrowArgs>(args: SelectSubset<T, LikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikeFindFirstArgs>(args?: SelectSubset<T, LikeFindFirstArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikeFindFirstOrThrowArgs>(args?: SelectSubset<T, LikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.like.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.like.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeWithIdOnly = await prisma.like.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikeFindManyArgs>(args?: SelectSubset<T, LikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Like.
     * @param {LikeCreateArgs} args - Arguments to create a Like.
     * @example
     * // Create one Like
     * const Like = await prisma.like.create({
     *   data: {
     *     // ... data to create a Like
     *   }
     * })
     * 
     */
    create<T extends LikeCreateArgs>(args: SelectSubset<T, LikeCreateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Likes.
     * @param {LikeCreateManyArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikeCreateManyArgs>(args?: SelectSubset<T, LikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Likes and returns the data saved in the database.
     * @param {LikeCreateManyAndReturnArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Likes and only return the `id`
     * const likeWithIdOnly = await prisma.like.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikeCreateManyAndReturnArgs>(args?: SelectSubset<T, LikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Like.
     * @param {LikeDeleteArgs} args - Arguments to delete one Like.
     * @example
     * // Delete one Like
     * const Like = await prisma.like.delete({
     *   where: {
     *     // ... filter to delete one Like
     *   }
     * })
     * 
     */
    delete<T extends LikeDeleteArgs>(args: SelectSubset<T, LikeDeleteArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Like.
     * @param {LikeUpdateArgs} args - Arguments to update one Like.
     * @example
     * // Update one Like
     * const like = await prisma.like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikeUpdateArgs>(args: SelectSubset<T, LikeUpdateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Likes.
     * @param {LikeDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikeDeleteManyArgs>(args?: SelectSubset<T, LikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikeUpdateManyArgs>(args: SelectSubset<T, LikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Like.
     * @param {LikeUpsertArgs} args - Arguments to update or create a Like.
     * @example
     * // Update or create a Like
     * const like = await prisma.like.upsert({
     *   create: {
     *     // ... data to create a Like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Like we want to update
     *   }
     * })
     */
    upsert<T extends LikeUpsertArgs>(args: SelectSubset<T, LikeUpsertArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.like.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends LikeCountArgs>(
      args?: Subset<T, LikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeAggregateArgs>(args: Subset<T, LikeAggregateArgs>): Prisma.PrismaPromise<GetLikeAggregateType<T>>

    /**
     * Group by Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeGroupByArgs['orderBy'] }
        : { orderBy?: LikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Like model
   */
  readonly fields: LikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    publication<T extends PublicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PublicationDefaultArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Like model
   */ 
  interface LikeFieldRefs {
    readonly id: FieldRef<"Like", 'String'>
    readonly userId: FieldRef<"Like", 'String'>
    readonly publicationId: FieldRef<"Like", 'String'>
    readonly createdAt: FieldRef<"Like", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Like findUnique
   */
  export type LikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findUniqueOrThrow
   */
  export type LikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findFirst
   */
  export type LikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findFirstOrThrow
   */
  export type LikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findMany
   */
  export type LikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like create
   */
  export type LikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to create a Like.
     */
    data: XOR<LikeCreateInput, LikeUncheckedCreateInput>
  }

  /**
   * Like createMany
   */
  export type LikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Like createManyAndReturn
   */
  export type LikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Like update
   */
  export type LikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to update a Like.
     */
    data: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
    /**
     * Choose, which Like to update.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like updateMany
   */
  export type LikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
  }

  /**
   * Like upsert
   */
  export type LikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The filter to search for the Like to update in case it exists.
     */
    where: LikeWhereUniqueInput
    /**
     * In case the Like found by the `where` argument doesn't exist, create a new Like with this data.
     */
    create: XOR<LikeCreateInput, LikeUncheckedCreateInput>
    /**
     * In case the Like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
  }

  /**
   * Like delete
   */
  export type LikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter which Like to delete.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like deleteMany
   */
  export type LikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to delete
     */
    where?: LikeWhereInput
  }

  /**
   * Like without action
   */
  export type LikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    message: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    message: string
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      message: string
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model InvitationTemplate
   */

  export type AggregateInvitationTemplate = {
    _count: InvitationTemplateCountAggregateOutputType | null
    _min: InvitationTemplateMinAggregateOutputType | null
    _max: InvitationTemplateMaxAggregateOutputType | null
  }

  export type InvitationTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    content: string | null
    creatorId: string | null
    createdAt: Date | null
  }

  export type InvitationTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    content: string | null
    creatorId: string | null
    createdAt: Date | null
  }

  export type InvitationTemplateCountAggregateOutputType = {
    id: number
    name: number
    content: number
    creatorId: number
    createdAt: number
    _all: number
  }


  export type InvitationTemplateMinAggregateInputType = {
    id?: true
    name?: true
    content?: true
    creatorId?: true
    createdAt?: true
  }

  export type InvitationTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    content?: true
    creatorId?: true
    createdAt?: true
  }

  export type InvitationTemplateCountAggregateInputType = {
    id?: true
    name?: true
    content?: true
    creatorId?: true
    createdAt?: true
    _all?: true
  }

  export type InvitationTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvitationTemplate to aggregate.
     */
    where?: InvitationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationTemplates to fetch.
     */
    orderBy?: InvitationTemplateOrderByWithRelationInput | InvitationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvitationTemplates
    **/
    _count?: true | InvitationTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationTemplateMaxAggregateInputType
  }

  export type GetInvitationTemplateAggregateType<T extends InvitationTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitationTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitationTemplate[P]>
      : GetScalarType<T[P], AggregateInvitationTemplate[P]>
  }




  export type InvitationTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationTemplateWhereInput
    orderBy?: InvitationTemplateOrderByWithAggregationInput | InvitationTemplateOrderByWithAggregationInput[]
    by: InvitationTemplateScalarFieldEnum[] | InvitationTemplateScalarFieldEnum
    having?: InvitationTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationTemplateCountAggregateInputType | true
    _min?: InvitationTemplateMinAggregateInputType
    _max?: InvitationTemplateMaxAggregateInputType
  }

  export type InvitationTemplateGroupByOutputType = {
    id: string
    name: string
    content: string
    creatorId: string
    createdAt: Date
    _count: InvitationTemplateCountAggregateOutputType | null
    _min: InvitationTemplateMinAggregateOutputType | null
    _max: InvitationTemplateMaxAggregateOutputType | null
  }

  type GetInvitationTemplateGroupByPayload<T extends InvitationTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationTemplateGroupByOutputType[P]>
        }
      >
    >


  export type InvitationTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    creatorId?: boolean
    createdAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitationTemplate"]>

  export type InvitationTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    creatorId?: boolean
    createdAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitationTemplate"]>

  export type InvitationTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    content?: boolean
    creatorId?: boolean
    createdAt?: boolean
  }

  export type InvitationTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvitationTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvitationTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvitationTemplate"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      content: string
      creatorId: string
      createdAt: Date
    }, ExtArgs["result"]["invitationTemplate"]>
    composites: {}
  }

  type InvitationTemplateGetPayload<S extends boolean | null | undefined | InvitationTemplateDefaultArgs> = $Result.GetResult<Prisma.$InvitationTemplatePayload, S>

  type InvitationTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvitationTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvitationTemplateCountAggregateInputType | true
    }

  export interface InvitationTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvitationTemplate'], meta: { name: 'InvitationTemplate' } }
    /**
     * Find zero or one InvitationTemplate that matches the filter.
     * @param {InvitationTemplateFindUniqueArgs} args - Arguments to find a InvitationTemplate
     * @example
     * // Get one InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationTemplateFindUniqueArgs>(args: SelectSubset<T, InvitationTemplateFindUniqueArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvitationTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvitationTemplateFindUniqueOrThrowArgs} args - Arguments to find a InvitationTemplate
     * @example
     * // Get one InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvitationTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateFindFirstArgs} args - Arguments to find a InvitationTemplate
     * @example
     * // Get one InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationTemplateFindFirstArgs>(args?: SelectSubset<T, InvitationTemplateFindFirstArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvitationTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateFindFirstOrThrowArgs} args - Arguments to find a InvitationTemplate
     * @example
     * // Get one InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvitationTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvitationTemplates
     * const invitationTemplates = await prisma.invitationTemplate.findMany()
     * 
     * // Get first 10 InvitationTemplates
     * const invitationTemplates = await prisma.invitationTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationTemplateWithIdOnly = await prisma.invitationTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationTemplateFindManyArgs>(args?: SelectSubset<T, InvitationTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvitationTemplate.
     * @param {InvitationTemplateCreateArgs} args - Arguments to create a InvitationTemplate.
     * @example
     * // Create one InvitationTemplate
     * const InvitationTemplate = await prisma.invitationTemplate.create({
     *   data: {
     *     // ... data to create a InvitationTemplate
     *   }
     * })
     * 
     */
    create<T extends InvitationTemplateCreateArgs>(args: SelectSubset<T, InvitationTemplateCreateArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvitationTemplates.
     * @param {InvitationTemplateCreateManyArgs} args - Arguments to create many InvitationTemplates.
     * @example
     * // Create many InvitationTemplates
     * const invitationTemplate = await prisma.invitationTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationTemplateCreateManyArgs>(args?: SelectSubset<T, InvitationTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvitationTemplates and returns the data saved in the database.
     * @param {InvitationTemplateCreateManyAndReturnArgs} args - Arguments to create many InvitationTemplates.
     * @example
     * // Create many InvitationTemplates
     * const invitationTemplate = await prisma.invitationTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvitationTemplates and only return the `id`
     * const invitationTemplateWithIdOnly = await prisma.invitationTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvitationTemplate.
     * @param {InvitationTemplateDeleteArgs} args - Arguments to delete one InvitationTemplate.
     * @example
     * // Delete one InvitationTemplate
     * const InvitationTemplate = await prisma.invitationTemplate.delete({
     *   where: {
     *     // ... filter to delete one InvitationTemplate
     *   }
     * })
     * 
     */
    delete<T extends InvitationTemplateDeleteArgs>(args: SelectSubset<T, InvitationTemplateDeleteArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvitationTemplate.
     * @param {InvitationTemplateUpdateArgs} args - Arguments to update one InvitationTemplate.
     * @example
     * // Update one InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationTemplateUpdateArgs>(args: SelectSubset<T, InvitationTemplateUpdateArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvitationTemplates.
     * @param {InvitationTemplateDeleteManyArgs} args - Arguments to filter InvitationTemplates to delete.
     * @example
     * // Delete a few InvitationTemplates
     * const { count } = await prisma.invitationTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationTemplateDeleteManyArgs>(args?: SelectSubset<T, InvitationTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvitationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvitationTemplates
     * const invitationTemplate = await prisma.invitationTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationTemplateUpdateManyArgs>(args: SelectSubset<T, InvitationTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvitationTemplate.
     * @param {InvitationTemplateUpsertArgs} args - Arguments to update or create a InvitationTemplate.
     * @example
     * // Update or create a InvitationTemplate
     * const invitationTemplate = await prisma.invitationTemplate.upsert({
     *   create: {
     *     // ... data to create a InvitationTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvitationTemplate we want to update
     *   }
     * })
     */
    upsert<T extends InvitationTemplateUpsertArgs>(args: SelectSubset<T, InvitationTemplateUpsertArgs<ExtArgs>>): Prisma__InvitationTemplateClient<$Result.GetResult<Prisma.$InvitationTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvitationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateCountArgs} args - Arguments to filter InvitationTemplates to count.
     * @example
     * // Count the number of InvitationTemplates
     * const count = await prisma.invitationTemplate.count({
     *   where: {
     *     // ... the filter for the InvitationTemplates we want to count
     *   }
     * })
    **/
    count<T extends InvitationTemplateCountArgs>(
      args?: Subset<T, InvitationTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvitationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationTemplateAggregateArgs>(args: Subset<T, InvitationTemplateAggregateArgs>): Prisma.PrismaPromise<GetInvitationTemplateAggregateType<T>>

    /**
     * Group by InvitationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationTemplateGroupByArgs['orderBy'] }
        : { orderBy?: InvitationTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvitationTemplate model
   */
  readonly fields: InvitationTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvitationTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvitationTemplate model
   */ 
  interface InvitationTemplateFieldRefs {
    readonly id: FieldRef<"InvitationTemplate", 'String'>
    readonly name: FieldRef<"InvitationTemplate", 'String'>
    readonly content: FieldRef<"InvitationTemplate", 'String'>
    readonly creatorId: FieldRef<"InvitationTemplate", 'String'>
    readonly createdAt: FieldRef<"InvitationTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvitationTemplate findUnique
   */
  export type InvitationTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which InvitationTemplate to fetch.
     */
    where: InvitationTemplateWhereUniqueInput
  }

  /**
   * InvitationTemplate findUniqueOrThrow
   */
  export type InvitationTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which InvitationTemplate to fetch.
     */
    where: InvitationTemplateWhereUniqueInput
  }

  /**
   * InvitationTemplate findFirst
   */
  export type InvitationTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which InvitationTemplate to fetch.
     */
    where?: InvitationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationTemplates to fetch.
     */
    orderBy?: InvitationTemplateOrderByWithRelationInput | InvitationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvitationTemplates.
     */
    cursor?: InvitationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvitationTemplates.
     */
    distinct?: InvitationTemplateScalarFieldEnum | InvitationTemplateScalarFieldEnum[]
  }

  /**
   * InvitationTemplate findFirstOrThrow
   */
  export type InvitationTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which InvitationTemplate to fetch.
     */
    where?: InvitationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationTemplates to fetch.
     */
    orderBy?: InvitationTemplateOrderByWithRelationInput | InvitationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvitationTemplates.
     */
    cursor?: InvitationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvitationTemplates.
     */
    distinct?: InvitationTemplateScalarFieldEnum | InvitationTemplateScalarFieldEnum[]
  }

  /**
   * InvitationTemplate findMany
   */
  export type InvitationTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which InvitationTemplates to fetch.
     */
    where?: InvitationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvitationTemplates to fetch.
     */
    orderBy?: InvitationTemplateOrderByWithRelationInput | InvitationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvitationTemplates.
     */
    cursor?: InvitationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvitationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvitationTemplates.
     */
    skip?: number
    distinct?: InvitationTemplateScalarFieldEnum | InvitationTemplateScalarFieldEnum[]
  }

  /**
   * InvitationTemplate create
   */
  export type InvitationTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a InvitationTemplate.
     */
    data: XOR<InvitationTemplateCreateInput, InvitationTemplateUncheckedCreateInput>
  }

  /**
   * InvitationTemplate createMany
   */
  export type InvitationTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvitationTemplates.
     */
    data: InvitationTemplateCreateManyInput | InvitationTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvitationTemplate createManyAndReturn
   */
  export type InvitationTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvitationTemplates.
     */
    data: InvitationTemplateCreateManyInput | InvitationTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvitationTemplate update
   */
  export type InvitationTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a InvitationTemplate.
     */
    data: XOR<InvitationTemplateUpdateInput, InvitationTemplateUncheckedUpdateInput>
    /**
     * Choose, which InvitationTemplate to update.
     */
    where: InvitationTemplateWhereUniqueInput
  }

  /**
   * InvitationTemplate updateMany
   */
  export type InvitationTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvitationTemplates.
     */
    data: XOR<InvitationTemplateUpdateManyMutationInput, InvitationTemplateUncheckedUpdateManyInput>
    /**
     * Filter which InvitationTemplates to update
     */
    where?: InvitationTemplateWhereInput
  }

  /**
   * InvitationTemplate upsert
   */
  export type InvitationTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the InvitationTemplate to update in case it exists.
     */
    where: InvitationTemplateWhereUniqueInput
    /**
     * In case the InvitationTemplate found by the `where` argument doesn't exist, create a new InvitationTemplate with this data.
     */
    create: XOR<InvitationTemplateCreateInput, InvitationTemplateUncheckedCreateInput>
    /**
     * In case the InvitationTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationTemplateUpdateInput, InvitationTemplateUncheckedUpdateInput>
  }

  /**
   * InvitationTemplate delete
   */
  export type InvitationTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
    /**
     * Filter which InvitationTemplate to delete.
     */
    where: InvitationTemplateWhereUniqueInput
  }

  /**
   * InvitationTemplate deleteMany
   */
  export type InvitationTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvitationTemplates to delete
     */
    where?: InvitationTemplateWhereInput
  }

  /**
   * InvitationTemplate without action
   */
  export type InvitationTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvitationTemplate
     */
    select?: InvitationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationTemplateInclude<ExtArgs> | null
  }


  /**
   * Model GiftCard
   */

  export type AggregateGiftCard = {
    _count: GiftCardCountAggregateOutputType | null
    _avg: GiftCardAvgAggregateOutputType | null
    _sum: GiftCardSumAggregateOutputType | null
    _min: GiftCardMinAggregateOutputType | null
    _max: GiftCardMaxAggregateOutputType | null
  }

  export type GiftCardAvgAggregateOutputType = {
    unitsAmount: number | null
  }

  export type GiftCardSumAggregateOutputType = {
    unitsAmount: number | null
  }

  export type GiftCardMinAggregateOutputType = {
    id: string | null
    inviterId: string | null
    invitedName: string | null
    invitedEmail: string | null
    token: string | null
    unitsAmount: number | null
    suggestions: string | null
    status: string | null
    createdAt: Date | null
  }

  export type GiftCardMaxAggregateOutputType = {
    id: string | null
    inviterId: string | null
    invitedName: string | null
    invitedEmail: string | null
    token: string | null
    unitsAmount: number | null
    suggestions: string | null
    status: string | null
    createdAt: Date | null
  }

  export type GiftCardCountAggregateOutputType = {
    id: number
    inviterId: number
    invitedName: number
    invitedEmail: number
    token: number
    unitsAmount: number
    suggestions: number
    status: number
    createdAt: number
    _all: number
  }


  export type GiftCardAvgAggregateInputType = {
    unitsAmount?: true
  }

  export type GiftCardSumAggregateInputType = {
    unitsAmount?: true
  }

  export type GiftCardMinAggregateInputType = {
    id?: true
    inviterId?: true
    invitedName?: true
    invitedEmail?: true
    token?: true
    unitsAmount?: true
    suggestions?: true
    status?: true
    createdAt?: true
  }

  export type GiftCardMaxAggregateInputType = {
    id?: true
    inviterId?: true
    invitedName?: true
    invitedEmail?: true
    token?: true
    unitsAmount?: true
    suggestions?: true
    status?: true
    createdAt?: true
  }

  export type GiftCardCountAggregateInputType = {
    id?: true
    inviterId?: true
    invitedName?: true
    invitedEmail?: true
    token?: true
    unitsAmount?: true
    suggestions?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type GiftCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GiftCard to aggregate.
     */
    where?: GiftCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GiftCards to fetch.
     */
    orderBy?: GiftCardOrderByWithRelationInput | GiftCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GiftCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GiftCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GiftCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GiftCards
    **/
    _count?: true | GiftCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GiftCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GiftCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GiftCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GiftCardMaxAggregateInputType
  }

  export type GetGiftCardAggregateType<T extends GiftCardAggregateArgs> = {
        [P in keyof T & keyof AggregateGiftCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGiftCard[P]>
      : GetScalarType<T[P], AggregateGiftCard[P]>
  }




  export type GiftCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GiftCardWhereInput
    orderBy?: GiftCardOrderByWithAggregationInput | GiftCardOrderByWithAggregationInput[]
    by: GiftCardScalarFieldEnum[] | GiftCardScalarFieldEnum
    having?: GiftCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GiftCardCountAggregateInputType | true
    _avg?: GiftCardAvgAggregateInputType
    _sum?: GiftCardSumAggregateInputType
    _min?: GiftCardMinAggregateInputType
    _max?: GiftCardMaxAggregateInputType
  }

  export type GiftCardGroupByOutputType = {
    id: string
    inviterId: string
    invitedName: string
    invitedEmail: string
    token: string
    unitsAmount: number
    suggestions: string | null
    status: string
    createdAt: Date
    _count: GiftCardCountAggregateOutputType | null
    _avg: GiftCardAvgAggregateOutputType | null
    _sum: GiftCardSumAggregateOutputType | null
    _min: GiftCardMinAggregateOutputType | null
    _max: GiftCardMaxAggregateOutputType | null
  }

  type GetGiftCardGroupByPayload<T extends GiftCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GiftCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GiftCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GiftCardGroupByOutputType[P]>
            : GetScalarType<T[P], GiftCardGroupByOutputType[P]>
        }
      >
    >


  export type GiftCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviterId?: boolean
    invitedName?: boolean
    invitedEmail?: boolean
    token?: boolean
    unitsAmount?: boolean
    suggestions?: boolean
    status?: boolean
    createdAt?: boolean
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    userInvitations?: boolean | GiftCard$userInvitationsArgs<ExtArgs>
    _count?: boolean | GiftCardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["giftCard"]>

  export type GiftCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviterId?: boolean
    invitedName?: boolean
    invitedEmail?: boolean
    token?: boolean
    unitsAmount?: boolean
    suggestions?: boolean
    status?: boolean
    createdAt?: boolean
    inviter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["giftCard"]>

  export type GiftCardSelectScalar = {
    id?: boolean
    inviterId?: boolean
    invitedName?: boolean
    invitedEmail?: boolean
    token?: boolean
    unitsAmount?: boolean
    suggestions?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type GiftCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    userInvitations?: boolean | GiftCard$userInvitationsArgs<ExtArgs>
    _count?: boolean | GiftCardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GiftCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GiftCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GiftCard"
    objects: {
      inviter: Prisma.$UserPayload<ExtArgs>
      userInvitations: Prisma.$UserInvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inviterId: string
      invitedName: string
      invitedEmail: string
      token: string
      unitsAmount: number
      suggestions: string | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["giftCard"]>
    composites: {}
  }

  type GiftCardGetPayload<S extends boolean | null | undefined | GiftCardDefaultArgs> = $Result.GetResult<Prisma.$GiftCardPayload, S>

  type GiftCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GiftCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GiftCardCountAggregateInputType | true
    }

  export interface GiftCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GiftCard'], meta: { name: 'GiftCard' } }
    /**
     * Find zero or one GiftCard that matches the filter.
     * @param {GiftCardFindUniqueArgs} args - Arguments to find a GiftCard
     * @example
     * // Get one GiftCard
     * const giftCard = await prisma.giftCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GiftCardFindUniqueArgs>(args: SelectSubset<T, GiftCardFindUniqueArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GiftCard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GiftCardFindUniqueOrThrowArgs} args - Arguments to find a GiftCard
     * @example
     * // Get one GiftCard
     * const giftCard = await prisma.giftCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GiftCardFindUniqueOrThrowArgs>(args: SelectSubset<T, GiftCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GiftCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCardFindFirstArgs} args - Arguments to find a GiftCard
     * @example
     * // Get one GiftCard
     * const giftCard = await prisma.giftCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GiftCardFindFirstArgs>(args?: SelectSubset<T, GiftCardFindFirstArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GiftCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCardFindFirstOrThrowArgs} args - Arguments to find a GiftCard
     * @example
     * // Get one GiftCard
     * const giftCard = await prisma.giftCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GiftCardFindFirstOrThrowArgs>(args?: SelectSubset<T, GiftCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GiftCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GiftCards
     * const giftCards = await prisma.giftCard.findMany()
     * 
     * // Get first 10 GiftCards
     * const giftCards = await prisma.giftCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const giftCardWithIdOnly = await prisma.giftCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GiftCardFindManyArgs>(args?: SelectSubset<T, GiftCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GiftCard.
     * @param {GiftCardCreateArgs} args - Arguments to create a GiftCard.
     * @example
     * // Create one GiftCard
     * const GiftCard = await prisma.giftCard.create({
     *   data: {
     *     // ... data to create a GiftCard
     *   }
     * })
     * 
     */
    create<T extends GiftCardCreateArgs>(args: SelectSubset<T, GiftCardCreateArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GiftCards.
     * @param {GiftCardCreateManyArgs} args - Arguments to create many GiftCards.
     * @example
     * // Create many GiftCards
     * const giftCard = await prisma.giftCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GiftCardCreateManyArgs>(args?: SelectSubset<T, GiftCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GiftCards and returns the data saved in the database.
     * @param {GiftCardCreateManyAndReturnArgs} args - Arguments to create many GiftCards.
     * @example
     * // Create many GiftCards
     * const giftCard = await prisma.giftCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GiftCards and only return the `id`
     * const giftCardWithIdOnly = await prisma.giftCard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GiftCardCreateManyAndReturnArgs>(args?: SelectSubset<T, GiftCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GiftCard.
     * @param {GiftCardDeleteArgs} args - Arguments to delete one GiftCard.
     * @example
     * // Delete one GiftCard
     * const GiftCard = await prisma.giftCard.delete({
     *   where: {
     *     // ... filter to delete one GiftCard
     *   }
     * })
     * 
     */
    delete<T extends GiftCardDeleteArgs>(args: SelectSubset<T, GiftCardDeleteArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GiftCard.
     * @param {GiftCardUpdateArgs} args - Arguments to update one GiftCard.
     * @example
     * // Update one GiftCard
     * const giftCard = await prisma.giftCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GiftCardUpdateArgs>(args: SelectSubset<T, GiftCardUpdateArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GiftCards.
     * @param {GiftCardDeleteManyArgs} args - Arguments to filter GiftCards to delete.
     * @example
     * // Delete a few GiftCards
     * const { count } = await prisma.giftCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GiftCardDeleteManyArgs>(args?: SelectSubset<T, GiftCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GiftCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GiftCards
     * const giftCard = await prisma.giftCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GiftCardUpdateManyArgs>(args: SelectSubset<T, GiftCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GiftCard.
     * @param {GiftCardUpsertArgs} args - Arguments to update or create a GiftCard.
     * @example
     * // Update or create a GiftCard
     * const giftCard = await prisma.giftCard.upsert({
     *   create: {
     *     // ... data to create a GiftCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GiftCard we want to update
     *   }
     * })
     */
    upsert<T extends GiftCardUpsertArgs>(args: SelectSubset<T, GiftCardUpsertArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GiftCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCardCountArgs} args - Arguments to filter GiftCards to count.
     * @example
     * // Count the number of GiftCards
     * const count = await prisma.giftCard.count({
     *   where: {
     *     // ... the filter for the GiftCards we want to count
     *   }
     * })
    **/
    count<T extends GiftCardCountArgs>(
      args?: Subset<T, GiftCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GiftCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GiftCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GiftCardAggregateArgs>(args: Subset<T, GiftCardAggregateArgs>): Prisma.PrismaPromise<GetGiftCardAggregateType<T>>

    /**
     * Group by GiftCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GiftCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GiftCardGroupByArgs['orderBy'] }
        : { orderBy?: GiftCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GiftCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGiftCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GiftCard model
   */
  readonly fields: GiftCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GiftCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GiftCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inviter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    userInvitations<T extends GiftCard$userInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, GiftCard$userInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GiftCard model
   */ 
  interface GiftCardFieldRefs {
    readonly id: FieldRef<"GiftCard", 'String'>
    readonly inviterId: FieldRef<"GiftCard", 'String'>
    readonly invitedName: FieldRef<"GiftCard", 'String'>
    readonly invitedEmail: FieldRef<"GiftCard", 'String'>
    readonly token: FieldRef<"GiftCard", 'String'>
    readonly unitsAmount: FieldRef<"GiftCard", 'Float'>
    readonly suggestions: FieldRef<"GiftCard", 'String'>
    readonly status: FieldRef<"GiftCard", 'String'>
    readonly createdAt: FieldRef<"GiftCard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GiftCard findUnique
   */
  export type GiftCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * Filter, which GiftCard to fetch.
     */
    where: GiftCardWhereUniqueInput
  }

  /**
   * GiftCard findUniqueOrThrow
   */
  export type GiftCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * Filter, which GiftCard to fetch.
     */
    where: GiftCardWhereUniqueInput
  }

  /**
   * GiftCard findFirst
   */
  export type GiftCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * Filter, which GiftCard to fetch.
     */
    where?: GiftCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GiftCards to fetch.
     */
    orderBy?: GiftCardOrderByWithRelationInput | GiftCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GiftCards.
     */
    cursor?: GiftCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GiftCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GiftCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GiftCards.
     */
    distinct?: GiftCardScalarFieldEnum | GiftCardScalarFieldEnum[]
  }

  /**
   * GiftCard findFirstOrThrow
   */
  export type GiftCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * Filter, which GiftCard to fetch.
     */
    where?: GiftCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GiftCards to fetch.
     */
    orderBy?: GiftCardOrderByWithRelationInput | GiftCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GiftCards.
     */
    cursor?: GiftCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GiftCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GiftCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GiftCards.
     */
    distinct?: GiftCardScalarFieldEnum | GiftCardScalarFieldEnum[]
  }

  /**
   * GiftCard findMany
   */
  export type GiftCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * Filter, which GiftCards to fetch.
     */
    where?: GiftCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GiftCards to fetch.
     */
    orderBy?: GiftCardOrderByWithRelationInput | GiftCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GiftCards.
     */
    cursor?: GiftCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GiftCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GiftCards.
     */
    skip?: number
    distinct?: GiftCardScalarFieldEnum | GiftCardScalarFieldEnum[]
  }

  /**
   * GiftCard create
   */
  export type GiftCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * The data needed to create a GiftCard.
     */
    data: XOR<GiftCardCreateInput, GiftCardUncheckedCreateInput>
  }

  /**
   * GiftCard createMany
   */
  export type GiftCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GiftCards.
     */
    data: GiftCardCreateManyInput | GiftCardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GiftCard createManyAndReturn
   */
  export type GiftCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GiftCards.
     */
    data: GiftCardCreateManyInput | GiftCardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GiftCard update
   */
  export type GiftCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * The data needed to update a GiftCard.
     */
    data: XOR<GiftCardUpdateInput, GiftCardUncheckedUpdateInput>
    /**
     * Choose, which GiftCard to update.
     */
    where: GiftCardWhereUniqueInput
  }

  /**
   * GiftCard updateMany
   */
  export type GiftCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GiftCards.
     */
    data: XOR<GiftCardUpdateManyMutationInput, GiftCardUncheckedUpdateManyInput>
    /**
     * Filter which GiftCards to update
     */
    where?: GiftCardWhereInput
  }

  /**
   * GiftCard upsert
   */
  export type GiftCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * The filter to search for the GiftCard to update in case it exists.
     */
    where: GiftCardWhereUniqueInput
    /**
     * In case the GiftCard found by the `where` argument doesn't exist, create a new GiftCard with this data.
     */
    create: XOR<GiftCardCreateInput, GiftCardUncheckedCreateInput>
    /**
     * In case the GiftCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GiftCardUpdateInput, GiftCardUncheckedUpdateInput>
  }

  /**
   * GiftCard delete
   */
  export type GiftCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
    /**
     * Filter which GiftCard to delete.
     */
    where: GiftCardWhereUniqueInput
  }

  /**
   * GiftCard deleteMany
   */
  export type GiftCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GiftCards to delete
     */
    where?: GiftCardWhereInput
  }

  /**
   * GiftCard.userInvitations
   */
  export type GiftCard$userInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    where?: UserInvitationWhereInput
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    cursor?: UserInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * GiftCard without action
   */
  export type GiftCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftCard
     */
    select?: GiftCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftCardInclude<ExtArgs> | null
  }


  /**
   * Model UserInvitation
   */

  export type AggregateUserInvitation = {
    _count: UserInvitationCountAggregateOutputType | null
    _min: UserInvitationMinAggregateOutputType | null
    _max: UserInvitationMaxAggregateOutputType | null
  }

  export type UserInvitationMinAggregateOutputType = {
    id: string | null
    giftCardId: string | null
    invitedUserId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type UserInvitationMaxAggregateOutputType = {
    id: string | null
    giftCardId: string | null
    invitedUserId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type UserInvitationCountAggregateOutputType = {
    id: number
    giftCardId: number
    invitedUserId: number
    status: number
    createdAt: number
    _all: number
  }


  export type UserInvitationMinAggregateInputType = {
    id?: true
    giftCardId?: true
    invitedUserId?: true
    status?: true
    createdAt?: true
  }

  export type UserInvitationMaxAggregateInputType = {
    id?: true
    giftCardId?: true
    invitedUserId?: true
    status?: true
    createdAt?: true
  }

  export type UserInvitationCountAggregateInputType = {
    id?: true
    giftCardId?: true
    invitedUserId?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type UserInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInvitation to aggregate.
     */
    where?: UserInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInvitations to fetch.
     */
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserInvitations
    **/
    _count?: true | UserInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserInvitationMaxAggregateInputType
  }

  export type GetUserInvitationAggregateType<T extends UserInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserInvitation[P]>
      : GetScalarType<T[P], AggregateUserInvitation[P]>
  }




  export type UserInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInvitationWhereInput
    orderBy?: UserInvitationOrderByWithAggregationInput | UserInvitationOrderByWithAggregationInput[]
    by: UserInvitationScalarFieldEnum[] | UserInvitationScalarFieldEnum
    having?: UserInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserInvitationCountAggregateInputType | true
    _min?: UserInvitationMinAggregateInputType
    _max?: UserInvitationMaxAggregateInputType
  }

  export type UserInvitationGroupByOutputType = {
    id: string
    giftCardId: string
    invitedUserId: string | null
    status: string
    createdAt: Date
    _count: UserInvitationCountAggregateOutputType | null
    _min: UserInvitationMinAggregateOutputType | null
    _max: UserInvitationMaxAggregateOutputType | null
  }

  type GetUserInvitationGroupByPayload<T extends UserInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], UserInvitationGroupByOutputType[P]>
        }
      >
    >


  export type UserInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    giftCardId?: boolean
    invitedUserId?: boolean
    status?: boolean
    createdAt?: boolean
    invitedUser?: boolean | UserInvitation$invitedUserArgs<ExtArgs>
    giftCard?: boolean | GiftCardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInvitation"]>

  export type UserInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    giftCardId?: boolean
    invitedUserId?: boolean
    status?: boolean
    createdAt?: boolean
    invitedUser?: boolean | UserInvitation$invitedUserArgs<ExtArgs>
    giftCard?: boolean | GiftCardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInvitation"]>

  export type UserInvitationSelectScalar = {
    id?: boolean
    giftCardId?: boolean
    invitedUserId?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type UserInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitedUser?: boolean | UserInvitation$invitedUserArgs<ExtArgs>
    giftCard?: boolean | GiftCardDefaultArgs<ExtArgs>
  }
  export type UserInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitedUser?: boolean | UserInvitation$invitedUserArgs<ExtArgs>
    giftCard?: boolean | GiftCardDefaultArgs<ExtArgs>
  }

  export type $UserInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserInvitation"
    objects: {
      invitedUser: Prisma.$UserPayload<ExtArgs> | null
      giftCard: Prisma.$GiftCardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      giftCardId: string
      invitedUserId: string | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["userInvitation"]>
    composites: {}
  }

  type UserInvitationGetPayload<S extends boolean | null | undefined | UserInvitationDefaultArgs> = $Result.GetResult<Prisma.$UserInvitationPayload, S>

  type UserInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserInvitationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserInvitationCountAggregateInputType | true
    }

  export interface UserInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserInvitation'], meta: { name: 'UserInvitation' } }
    /**
     * Find zero or one UserInvitation that matches the filter.
     * @param {UserInvitationFindUniqueArgs} args - Arguments to find a UserInvitation
     * @example
     * // Get one UserInvitation
     * const userInvitation = await prisma.userInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserInvitationFindUniqueArgs>(args: SelectSubset<T, UserInvitationFindUniqueArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserInvitation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserInvitationFindUniqueOrThrowArgs} args - Arguments to find a UserInvitation
     * @example
     * // Get one UserInvitation
     * const userInvitation = await prisma.userInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationFindFirstArgs} args - Arguments to find a UserInvitation
     * @example
     * // Get one UserInvitation
     * const userInvitation = await prisma.userInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserInvitationFindFirstArgs>(args?: SelectSubset<T, UserInvitationFindFirstArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationFindFirstOrThrowArgs} args - Arguments to find a UserInvitation
     * @example
     * // Get one UserInvitation
     * const userInvitation = await prisma.userInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserInvitations
     * const userInvitations = await prisma.userInvitation.findMany()
     * 
     * // Get first 10 UserInvitations
     * const userInvitations = await prisma.userInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userInvitationWithIdOnly = await prisma.userInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserInvitationFindManyArgs>(args?: SelectSubset<T, UserInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserInvitation.
     * @param {UserInvitationCreateArgs} args - Arguments to create a UserInvitation.
     * @example
     * // Create one UserInvitation
     * const UserInvitation = await prisma.userInvitation.create({
     *   data: {
     *     // ... data to create a UserInvitation
     *   }
     * })
     * 
     */
    create<T extends UserInvitationCreateArgs>(args: SelectSubset<T, UserInvitationCreateArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserInvitations.
     * @param {UserInvitationCreateManyArgs} args - Arguments to create many UserInvitations.
     * @example
     * // Create many UserInvitations
     * const userInvitation = await prisma.userInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserInvitationCreateManyArgs>(args?: SelectSubset<T, UserInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserInvitations and returns the data saved in the database.
     * @param {UserInvitationCreateManyAndReturnArgs} args - Arguments to create many UserInvitations.
     * @example
     * // Create many UserInvitations
     * const userInvitation = await prisma.userInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserInvitations and only return the `id`
     * const userInvitationWithIdOnly = await prisma.userInvitation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserInvitation.
     * @param {UserInvitationDeleteArgs} args - Arguments to delete one UserInvitation.
     * @example
     * // Delete one UserInvitation
     * const UserInvitation = await prisma.userInvitation.delete({
     *   where: {
     *     // ... filter to delete one UserInvitation
     *   }
     * })
     * 
     */
    delete<T extends UserInvitationDeleteArgs>(args: SelectSubset<T, UserInvitationDeleteArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserInvitation.
     * @param {UserInvitationUpdateArgs} args - Arguments to update one UserInvitation.
     * @example
     * // Update one UserInvitation
     * const userInvitation = await prisma.userInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserInvitationUpdateArgs>(args: SelectSubset<T, UserInvitationUpdateArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserInvitations.
     * @param {UserInvitationDeleteManyArgs} args - Arguments to filter UserInvitations to delete.
     * @example
     * // Delete a few UserInvitations
     * const { count } = await prisma.userInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserInvitationDeleteManyArgs>(args?: SelectSubset<T, UserInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserInvitations
     * const userInvitation = await prisma.userInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserInvitationUpdateManyArgs>(args: SelectSubset<T, UserInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserInvitation.
     * @param {UserInvitationUpsertArgs} args - Arguments to update or create a UserInvitation.
     * @example
     * // Update or create a UserInvitation
     * const userInvitation = await prisma.userInvitation.upsert({
     *   create: {
     *     // ... data to create a UserInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserInvitation we want to update
     *   }
     * })
     */
    upsert<T extends UserInvitationUpsertArgs>(args: SelectSubset<T, UserInvitationUpsertArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationCountArgs} args - Arguments to filter UserInvitations to count.
     * @example
     * // Count the number of UserInvitations
     * const count = await prisma.userInvitation.count({
     *   where: {
     *     // ... the filter for the UserInvitations we want to count
     *   }
     * })
    **/
    count<T extends UserInvitationCountArgs>(
      args?: Subset<T, UserInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserInvitationAggregateArgs>(args: Subset<T, UserInvitationAggregateArgs>): Prisma.PrismaPromise<GetUserInvitationAggregateType<T>>

    /**
     * Group by UserInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserInvitationGroupByArgs['orderBy'] }
        : { orderBy?: UserInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserInvitation model
   */
  readonly fields: UserInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invitedUser<T extends UserInvitation$invitedUserArgs<ExtArgs> = {}>(args?: Subset<T, UserInvitation$invitedUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    giftCard<T extends GiftCardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GiftCardDefaultArgs<ExtArgs>>): Prisma__GiftCardClient<$Result.GetResult<Prisma.$GiftCardPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserInvitation model
   */ 
  interface UserInvitationFieldRefs {
    readonly id: FieldRef<"UserInvitation", 'String'>
    readonly giftCardId: FieldRef<"UserInvitation", 'String'>
    readonly invitedUserId: FieldRef<"UserInvitation", 'String'>
    readonly status: FieldRef<"UserInvitation", 'String'>
    readonly createdAt: FieldRef<"UserInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserInvitation findUnique
   */
  export type UserInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitation to fetch.
     */
    where: UserInvitationWhereUniqueInput
  }

  /**
   * UserInvitation findUniqueOrThrow
   */
  export type UserInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitation to fetch.
     */
    where: UserInvitationWhereUniqueInput
  }

  /**
   * UserInvitation findFirst
   */
  export type UserInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitation to fetch.
     */
    where?: UserInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInvitations to fetch.
     */
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInvitations.
     */
    cursor?: UserInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInvitations.
     */
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * UserInvitation findFirstOrThrow
   */
  export type UserInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitation to fetch.
     */
    where?: UserInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInvitations to fetch.
     */
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInvitations.
     */
    cursor?: UserInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInvitations.
     */
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * UserInvitation findMany
   */
  export type UserInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitations to fetch.
     */
    where?: UserInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInvitations to fetch.
     */
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserInvitations.
     */
    cursor?: UserInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInvitations.
     */
    skip?: number
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * UserInvitation create
   */
  export type UserInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserInvitation.
     */
    data: XOR<UserInvitationCreateInput, UserInvitationUncheckedCreateInput>
  }

  /**
   * UserInvitation createMany
   */
  export type UserInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserInvitations.
     */
    data: UserInvitationCreateManyInput | UserInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserInvitation createManyAndReturn
   */
  export type UserInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserInvitations.
     */
    data: UserInvitationCreateManyInput | UserInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInvitation update
   */
  export type UserInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserInvitation.
     */
    data: XOR<UserInvitationUpdateInput, UserInvitationUncheckedUpdateInput>
    /**
     * Choose, which UserInvitation to update.
     */
    where: UserInvitationWhereUniqueInput
  }

  /**
   * UserInvitation updateMany
   */
  export type UserInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserInvitations.
     */
    data: XOR<UserInvitationUpdateManyMutationInput, UserInvitationUncheckedUpdateManyInput>
    /**
     * Filter which UserInvitations to update
     */
    where?: UserInvitationWhereInput
  }

  /**
   * UserInvitation upsert
   */
  export type UserInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserInvitation to update in case it exists.
     */
    where: UserInvitationWhereUniqueInput
    /**
     * In case the UserInvitation found by the `where` argument doesn't exist, create a new UserInvitation with this data.
     */
    create: XOR<UserInvitationCreateInput, UserInvitationUncheckedCreateInput>
    /**
     * In case the UserInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserInvitationUpdateInput, UserInvitationUncheckedUpdateInput>
  }

  /**
   * UserInvitation delete
   */
  export type UserInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter which UserInvitation to delete.
     */
    where: UserInvitationWhereUniqueInput
  }

  /**
   * UserInvitation deleteMany
   */
  export type UserInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInvitations to delete
     */
    where?: UserInvitationWhereInput
  }

  /**
   * UserInvitation.invitedUser
   */
  export type UserInvitation$invitedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserInvitation without action
   */
  export type UserInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    parameters: string | null
    generatedAt: Date | null
    data: string | null
    creatorId: string | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    parameters: string | null
    generatedAt: Date | null
    data: string | null
    creatorId: string | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    name: number
    type: number
    parameters: number
    generatedAt: number
    data: number
    creatorId: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    parameters?: true
    generatedAt?: true
    data?: true
    creatorId?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    parameters?: true
    generatedAt?: true
    data?: true
    creatorId?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    parameters?: true
    generatedAt?: true
    data?: true
    creatorId?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    name: string
    type: string
    parameters: string | null
    generatedAt: Date
    data: string
    creatorId: string
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    parameters?: boolean
    generatedAt?: boolean
    data?: boolean
    creatorId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    parameters?: boolean
    generatedAt?: boolean
    data?: boolean
    creatorId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    parameters?: boolean
    generatedAt?: boolean
    data?: boolean
    creatorId?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      parameters: string | null
      generatedAt: Date
      data: string
      creatorId: string
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly name: FieldRef<"Report", 'String'>
    readonly type: FieldRef<"Report", 'String'>
    readonly parameters: FieldRef<"Report", 'String'>
    readonly generatedAt: FieldRef<"Report", 'DateTime'>
    readonly data: FieldRef<"Report", 'String'>
    readonly creatorId: FieldRef<"Report", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model Configuration
   */

  export type AggregateConfiguration = {
    _count: ConfigurationCountAggregateOutputType | null
    _min: ConfigurationMinAggregateOutputType | null
    _max: ConfigurationMaxAggregateOutputType | null
  }

  export type ConfigurationMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    type: string | null
    updatedAt: Date | null
  }

  export type ConfigurationMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    type: string | null
    updatedAt: Date | null
  }

  export type ConfigurationCountAggregateOutputType = {
    id: number
    key: number
    value: number
    type: number
    updatedAt: number
    _all: number
  }


  export type ConfigurationMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    updatedAt?: true
  }

  export type ConfigurationMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    updatedAt?: true
  }

  export type ConfigurationCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    updatedAt?: true
    _all?: true
  }

  export type ConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Configuration to aggregate.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Configurations
    **/
    _count?: true | ConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigurationMaxAggregateInputType
  }

  export type GetConfigurationAggregateType<T extends ConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfiguration[P]>
      : GetScalarType<T[P], AggregateConfiguration[P]>
  }




  export type ConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigurationWhereInput
    orderBy?: ConfigurationOrderByWithAggregationInput | ConfigurationOrderByWithAggregationInput[]
    by: ConfigurationScalarFieldEnum[] | ConfigurationScalarFieldEnum
    having?: ConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigurationCountAggregateInputType | true
    _min?: ConfigurationMinAggregateInputType
    _max?: ConfigurationMaxAggregateInputType
  }

  export type ConfigurationGroupByOutputType = {
    id: string
    key: string
    value: string
    type: string
    updatedAt: Date
    _count: ConfigurationCountAggregateOutputType | null
    _min: ConfigurationMinAggregateOutputType | null
    _max: ConfigurationMaxAggregateOutputType | null
  }

  type GetConfigurationGroupByPayload<T extends ConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type ConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configuration"]>

  export type ConfigurationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configuration"]>

  export type ConfigurationSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    updatedAt?: boolean
  }


  export type $ConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Configuration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      type: string
      updatedAt: Date
    }, ExtArgs["result"]["configuration"]>
    composites: {}
  }

  type ConfigurationGetPayload<S extends boolean | null | undefined | ConfigurationDefaultArgs> = $Result.GetResult<Prisma.$ConfigurationPayload, S>

  type ConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConfigurationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConfigurationCountAggregateInputType | true
    }

  export interface ConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Configuration'], meta: { name: 'Configuration' } }
    /**
     * Find zero or one Configuration that matches the filter.
     * @param {ConfigurationFindUniqueArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigurationFindUniqueArgs>(args: SelectSubset<T, ConfigurationFindUniqueArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Configuration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConfigurationFindUniqueOrThrowArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Configuration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindFirstArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigurationFindFirstArgs>(args?: SelectSubset<T, ConfigurationFindFirstArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Configuration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindFirstOrThrowArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Configurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configurations
     * const configurations = await prisma.configuration.findMany()
     * 
     * // Get first 10 Configurations
     * const configurations = await prisma.configuration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configurationWithIdOnly = await prisma.configuration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfigurationFindManyArgs>(args?: SelectSubset<T, ConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Configuration.
     * @param {ConfigurationCreateArgs} args - Arguments to create a Configuration.
     * @example
     * // Create one Configuration
     * const Configuration = await prisma.configuration.create({
     *   data: {
     *     // ... data to create a Configuration
     *   }
     * })
     * 
     */
    create<T extends ConfigurationCreateArgs>(args: SelectSubset<T, ConfigurationCreateArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Configurations.
     * @param {ConfigurationCreateManyArgs} args - Arguments to create many Configurations.
     * @example
     * // Create many Configurations
     * const configuration = await prisma.configuration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigurationCreateManyArgs>(args?: SelectSubset<T, ConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Configurations and returns the data saved in the database.
     * @param {ConfigurationCreateManyAndReturnArgs} args - Arguments to create many Configurations.
     * @example
     * // Create many Configurations
     * const configuration = await prisma.configuration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Configurations and only return the `id`
     * const configurationWithIdOnly = await prisma.configuration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfigurationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfigurationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Configuration.
     * @param {ConfigurationDeleteArgs} args - Arguments to delete one Configuration.
     * @example
     * // Delete one Configuration
     * const Configuration = await prisma.configuration.delete({
     *   where: {
     *     // ... filter to delete one Configuration
     *   }
     * })
     * 
     */
    delete<T extends ConfigurationDeleteArgs>(args: SelectSubset<T, ConfigurationDeleteArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Configuration.
     * @param {ConfigurationUpdateArgs} args - Arguments to update one Configuration.
     * @example
     * // Update one Configuration
     * const configuration = await prisma.configuration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigurationUpdateArgs>(args: SelectSubset<T, ConfigurationUpdateArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Configurations.
     * @param {ConfigurationDeleteManyArgs} args - Arguments to filter Configurations to delete.
     * @example
     * // Delete a few Configurations
     * const { count } = await prisma.configuration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigurationDeleteManyArgs>(args?: SelectSubset<T, ConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configurations
     * const configuration = await prisma.configuration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigurationUpdateManyArgs>(args: SelectSubset<T, ConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Configuration.
     * @param {ConfigurationUpsertArgs} args - Arguments to update or create a Configuration.
     * @example
     * // Update or create a Configuration
     * const configuration = await prisma.configuration.upsert({
     *   create: {
     *     // ... data to create a Configuration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Configuration we want to update
     *   }
     * })
     */
    upsert<T extends ConfigurationUpsertArgs>(args: SelectSubset<T, ConfigurationUpsertArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationCountArgs} args - Arguments to filter Configurations to count.
     * @example
     * // Count the number of Configurations
     * const count = await prisma.configuration.count({
     *   where: {
     *     // ... the filter for the Configurations we want to count
     *   }
     * })
    **/
    count<T extends ConfigurationCountArgs>(
      args?: Subset<T, ConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Configuration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigurationAggregateArgs>(args: Subset<T, ConfigurationAggregateArgs>): Prisma.PrismaPromise<GetConfigurationAggregateType<T>>

    /**
     * Group by Configuration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: ConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Configuration model
   */
  readonly fields: ConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Configuration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Configuration model
   */ 
  interface ConfigurationFieldRefs {
    readonly id: FieldRef<"Configuration", 'String'>
    readonly key: FieldRef<"Configuration", 'String'>
    readonly value: FieldRef<"Configuration", 'String'>
    readonly type: FieldRef<"Configuration", 'String'>
    readonly updatedAt: FieldRef<"Configuration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Configuration findUnique
   */
  export type ConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration findUniqueOrThrow
   */
  export type ConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration findFirst
   */
  export type ConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configurations.
     */
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * Configuration findFirstOrThrow
   */
  export type ConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configurations.
     */
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * Configuration findMany
   */
  export type ConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Filter, which Configurations to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * Configuration create
   */
  export type ConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * The data needed to create a Configuration.
     */
    data: XOR<ConfigurationCreateInput, ConfigurationUncheckedCreateInput>
  }

  /**
   * Configuration createMany
   */
  export type ConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Configurations.
     */
    data: ConfigurationCreateManyInput | ConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Configuration createManyAndReturn
   */
  export type ConfigurationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Configurations.
     */
    data: ConfigurationCreateManyInput | ConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Configuration update
   */
  export type ConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * The data needed to update a Configuration.
     */
    data: XOR<ConfigurationUpdateInput, ConfigurationUncheckedUpdateInput>
    /**
     * Choose, which Configuration to update.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration updateMany
   */
  export type ConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Configurations.
     */
    data: XOR<ConfigurationUpdateManyMutationInput, ConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which Configurations to update
     */
    where?: ConfigurationWhereInput
  }

  /**
   * Configuration upsert
   */
  export type ConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * The filter to search for the Configuration to update in case it exists.
     */
    where: ConfigurationWhereUniqueInput
    /**
     * In case the Configuration found by the `where` argument doesn't exist, create a new Configuration with this data.
     */
    create: XOR<ConfigurationCreateInput, ConfigurationUncheckedCreateInput>
    /**
     * In case the Configuration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigurationUpdateInput, ConfigurationUncheckedUpdateInput>
  }

  /**
   * Configuration delete
   */
  export type ConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Filter which Configuration to delete.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration deleteMany
   */
  export type ConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Configurations to delete
     */
    where?: ConfigurationWhereInput
  }

  /**
   * Configuration without action
   */
  export type ConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
  }


  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogMinAggregateOutputType = {
    id: string | null
    level: string | null
    message: string | null
    context: string | null
    timestamp: Date | null
    metadata: string | null
  }

  export type LogMaxAggregateOutputType = {
    id: string | null
    level: string | null
    message: string | null
    context: string | null
    timestamp: Date | null
    metadata: string | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    level: number
    message: number
    context: number
    timestamp: number
    metadata: number
    _all: number
  }


  export type LogMinAggregateInputType = {
    id?: true
    level?: true
    message?: true
    context?: true
    timestamp?: true
    metadata?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    level?: true
    message?: true
    context?: true
    timestamp?: true
    metadata?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    level?: true
    message?: true
    context?: true
    timestamp?: true
    metadata?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: string
    level: string
    message: string
    context: string | null
    timestamp: Date
    metadata: string | null
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    message?: boolean
    context?: boolean
    timestamp?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["log"]>

  export type LogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    message?: boolean
    context?: boolean
    timestamp?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["log"]>

  export type LogSelectScalar = {
    id?: boolean
    level?: boolean
    message?: boolean
    context?: boolean
    timestamp?: boolean
    metadata?: boolean
  }


  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      level: string
      message: string
      context: string | null
      timestamp: Date
      metadata: string | null
    }, ExtArgs["result"]["log"]>
    composites: {}
  }

  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogFindUniqueArgs>(args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(args: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogFindFirstArgs>(args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogFindManyArgs>(args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends LogCreateArgs>(args: SelectSubset<T, LogCreateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Logs.
     * @param {LogCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogCreateManyArgs>(args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logs and returns the data saved in the database.
     * @param {LogCreateManyAndReturnArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogCreateManyAndReturnArgs>(args?: SelectSubset<T, LogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends LogDeleteArgs>(args: SelectSubset<T, LogDeleteArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogUpdateArgs>(args: SelectSubset<T, LogUpdateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogDeleteManyArgs>(args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogUpdateManyArgs>(args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends LogUpsertArgs>(args: SelectSubset<T, LogUpsertArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Log model
   */ 
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'String'>
    readonly level: FieldRef<"Log", 'String'>
    readonly message: FieldRef<"Log", 'String'>
    readonly context: FieldRef<"Log", 'String'>
    readonly timestamp: FieldRef<"Log", 'DateTime'>
    readonly metadata: FieldRef<"Log", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
  }

  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Log createManyAndReturn
   */
  export type LogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
  }

  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }

  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
  }

  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
  }


  /**
   * Model AnalyticsData
   */

  export type AggregateAnalyticsData = {
    _count: AnalyticsDataCountAggregateOutputType | null
    _min: AnalyticsDataMinAggregateOutputType | null
    _max: AnalyticsDataMaxAggregateOutputType | null
  }

  export type AnalyticsDataMinAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: string | null
    videoItemId: string | null
    playlistId: string | null
    mundoId: string | null
    sessionId: string | null
    eventData: string | null
    metadata: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type AnalyticsDataMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: string | null
    videoItemId: string | null
    playlistId: string | null
    mundoId: string | null
    sessionId: string | null
    eventData: string | null
    metadata: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type AnalyticsDataCountAggregateOutputType = {
    id: number
    userId: number
    eventType: number
    videoItemId: number
    playlistId: number
    mundoId: number
    sessionId: number
    eventData: number
    metadata: number
    timestamp: number
    createdAt: number
    _all: number
  }


  export type AnalyticsDataMinAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    videoItemId?: true
    playlistId?: true
    mundoId?: true
    sessionId?: true
    eventData?: true
    metadata?: true
    timestamp?: true
    createdAt?: true
  }

  export type AnalyticsDataMaxAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    videoItemId?: true
    playlistId?: true
    mundoId?: true
    sessionId?: true
    eventData?: true
    metadata?: true
    timestamp?: true
    createdAt?: true
  }

  export type AnalyticsDataCountAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    videoItemId?: true
    playlistId?: true
    mundoId?: true
    sessionId?: true
    eventData?: true
    metadata?: true
    timestamp?: true
    createdAt?: true
    _all?: true
  }

  export type AnalyticsDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsData to aggregate.
     */
    where?: AnalyticsDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsData to fetch.
     */
    orderBy?: AnalyticsDataOrderByWithRelationInput | AnalyticsDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsData
    **/
    _count?: true | AnalyticsDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsDataMaxAggregateInputType
  }

  export type GetAnalyticsDataAggregateType<T extends AnalyticsDataAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsData[P]>
      : GetScalarType<T[P], AggregateAnalyticsData[P]>
  }




  export type AnalyticsDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsDataWhereInput
    orderBy?: AnalyticsDataOrderByWithAggregationInput | AnalyticsDataOrderByWithAggregationInput[]
    by: AnalyticsDataScalarFieldEnum[] | AnalyticsDataScalarFieldEnum
    having?: AnalyticsDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsDataCountAggregateInputType | true
    _min?: AnalyticsDataMinAggregateInputType
    _max?: AnalyticsDataMaxAggregateInputType
  }

  export type AnalyticsDataGroupByOutputType = {
    id: string
    userId: string | null
    eventType: string
    videoItemId: string | null
    playlistId: string | null
    mundoId: string | null
    sessionId: string | null
    eventData: string | null
    metadata: string | null
    timestamp: Date
    createdAt: Date
    _count: AnalyticsDataCountAggregateOutputType | null
    _min: AnalyticsDataMinAggregateOutputType | null
    _max: AnalyticsDataMaxAggregateOutputType | null
  }

  type GetAnalyticsDataGroupByPayload<T extends AnalyticsDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsDataGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsDataGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    videoItemId?: boolean
    playlistId?: boolean
    mundoId?: boolean
    sessionId?: boolean
    eventData?: boolean
    metadata?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsData"]>

  export type AnalyticsDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    videoItemId?: boolean
    playlistId?: boolean
    mundoId?: boolean
    sessionId?: boolean
    eventData?: boolean
    metadata?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analyticsData"]>

  export type AnalyticsDataSelectScalar = {
    id?: boolean
    userId?: boolean
    eventType?: boolean
    videoItemId?: boolean
    playlistId?: boolean
    mundoId?: boolean
    sessionId?: boolean
    eventData?: boolean
    metadata?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }


  export type $AnalyticsDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsData"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      eventType: string
      videoItemId: string | null
      playlistId: string | null
      mundoId: string | null
      sessionId: string | null
      eventData: string | null
      metadata: string | null
      timestamp: Date
      createdAt: Date
    }, ExtArgs["result"]["analyticsData"]>
    composites: {}
  }

  type AnalyticsDataGetPayload<S extends boolean | null | undefined | AnalyticsDataDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsDataPayload, S>

  type AnalyticsDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnalyticsDataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnalyticsDataCountAggregateInputType | true
    }

  export interface AnalyticsDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsData'], meta: { name: 'AnalyticsData' } }
    /**
     * Find zero or one AnalyticsData that matches the filter.
     * @param {AnalyticsDataFindUniqueArgs} args - Arguments to find a AnalyticsData
     * @example
     * // Get one AnalyticsData
     * const analyticsData = await prisma.analyticsData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsDataFindUniqueArgs>(args: SelectSubset<T, AnalyticsDataFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsDataClient<$Result.GetResult<Prisma.$AnalyticsDataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AnalyticsData that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnalyticsDataFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsData
     * @example
     * // Get one AnalyticsData
     * const analyticsData = await prisma.analyticsData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsDataFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsDataClient<$Result.GetResult<Prisma.$AnalyticsDataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AnalyticsData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsDataFindFirstArgs} args - Arguments to find a AnalyticsData
     * @example
     * // Get one AnalyticsData
     * const analyticsData = await prisma.analyticsData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsDataFindFirstArgs>(args?: SelectSubset<T, AnalyticsDataFindFirstArgs<ExtArgs>>): Prisma__AnalyticsDataClient<$Result.GetResult<Prisma.$AnalyticsDataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AnalyticsData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsDataFindFirstOrThrowArgs} args - Arguments to find a AnalyticsData
     * @example
     * // Get one AnalyticsData
     * const analyticsData = await prisma.analyticsData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsDataFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsDataClient<$Result.GetResult<Prisma.$AnalyticsDataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AnalyticsData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsData
     * const analyticsData = await prisma.analyticsData.findMany()
     * 
     * // Get first 10 AnalyticsData
     * const analyticsData = await prisma.analyticsData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsDataWithIdOnly = await prisma.analyticsData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsDataFindManyArgs>(args?: SelectSubset<T, AnalyticsDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsDataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AnalyticsData.
     * @param {AnalyticsDataCreateArgs} args - Arguments to create a AnalyticsData.
     * @example
     * // Create one AnalyticsData
     * const AnalyticsData = await prisma.analyticsData.create({
     *   data: {
     *     // ... data to create a AnalyticsData
     *   }
     * })
     * 
     */
    create<T extends AnalyticsDataCreateArgs>(args: SelectSubset<T, AnalyticsDataCreateArgs<ExtArgs>>): Prisma__AnalyticsDataClient<$Result.GetResult<Prisma.$AnalyticsDataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AnalyticsData.
     * @param {AnalyticsDataCreateManyArgs} args - Arguments to create many AnalyticsData.
     * @example
     * // Create many AnalyticsData
     * const analyticsData = await prisma.analyticsData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsDataCreateManyArgs>(args?: SelectSubset<T, AnalyticsDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsData and returns the data saved in the database.
     * @param {AnalyticsDataCreateManyAndReturnArgs} args - Arguments to create many AnalyticsData.
     * @example
     * // Create many AnalyticsData
     * const analyticsData = await prisma.analyticsData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsData and only return the `id`
     * const analyticsDataWithIdOnly = await prisma.analyticsData.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsDataCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsDataPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AnalyticsData.
     * @param {AnalyticsDataDeleteArgs} args - Arguments to delete one AnalyticsData.
     * @example
     * // Delete one AnalyticsData
     * const AnalyticsData = await prisma.analyticsData.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsData
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsDataDeleteArgs>(args: SelectSubset<T, AnalyticsDataDeleteArgs<ExtArgs>>): Prisma__AnalyticsDataClient<$Result.GetResult<Prisma.$AnalyticsDataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AnalyticsData.
     * @param {AnalyticsDataUpdateArgs} args - Arguments to update one AnalyticsData.
     * @example
     * // Update one AnalyticsData
     * const analyticsData = await prisma.analyticsData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsDataUpdateArgs>(args: SelectSubset<T, AnalyticsDataUpdateArgs<ExtArgs>>): Prisma__AnalyticsDataClient<$Result.GetResult<Prisma.$AnalyticsDataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AnalyticsData.
     * @param {AnalyticsDataDeleteManyArgs} args - Arguments to filter AnalyticsData to delete.
     * @example
     * // Delete a few AnalyticsData
     * const { count } = await prisma.analyticsData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsDataDeleteManyArgs>(args?: SelectSubset<T, AnalyticsDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsData
     * const analyticsData = await prisma.analyticsData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsDataUpdateManyArgs>(args: SelectSubset<T, AnalyticsDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnalyticsData.
     * @param {AnalyticsDataUpsertArgs} args - Arguments to update or create a AnalyticsData.
     * @example
     * // Update or create a AnalyticsData
     * const analyticsData = await prisma.analyticsData.upsert({
     *   create: {
     *     // ... data to create a AnalyticsData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsData we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsDataUpsertArgs>(args: SelectSubset<T, AnalyticsDataUpsertArgs<ExtArgs>>): Prisma__AnalyticsDataClient<$Result.GetResult<Prisma.$AnalyticsDataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AnalyticsData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsDataCountArgs} args - Arguments to filter AnalyticsData to count.
     * @example
     * // Count the number of AnalyticsData
     * const count = await prisma.analyticsData.count({
     *   where: {
     *     // ... the filter for the AnalyticsData we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsDataCountArgs>(
      args?: Subset<T, AnalyticsDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsDataAggregateArgs>(args: Subset<T, AnalyticsDataAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsDataAggregateType<T>>

    /**
     * Group by AnalyticsData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsDataGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsData model
   */
  readonly fields: AnalyticsDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsData model
   */ 
  interface AnalyticsDataFieldRefs {
    readonly id: FieldRef<"AnalyticsData", 'String'>
    readonly userId: FieldRef<"AnalyticsData", 'String'>
    readonly eventType: FieldRef<"AnalyticsData", 'String'>
    readonly videoItemId: FieldRef<"AnalyticsData", 'String'>
    readonly playlistId: FieldRef<"AnalyticsData", 'String'>
    readonly mundoId: FieldRef<"AnalyticsData", 'String'>
    readonly sessionId: FieldRef<"AnalyticsData", 'String'>
    readonly eventData: FieldRef<"AnalyticsData", 'String'>
    readonly metadata: FieldRef<"AnalyticsData", 'String'>
    readonly timestamp: FieldRef<"AnalyticsData", 'DateTime'>
    readonly createdAt: FieldRef<"AnalyticsData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsData findUnique
   */
  export type AnalyticsDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsData
     */
    select?: AnalyticsDataSelect<ExtArgs> | null
    /**
     * Filter, which AnalyticsData to fetch.
     */
    where: AnalyticsDataWhereUniqueInput
  }

  /**
   * AnalyticsData findUniqueOrThrow
   */
  export type AnalyticsDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsData
     */
    select?: AnalyticsDataSelect<ExtArgs> | null
    /**
     * Filter, which AnalyticsData to fetch.
     */
    where: AnalyticsDataWhereUniqueInput
  }

  /**
   * AnalyticsData findFirst
   */
  export type AnalyticsDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsData
     */
    select?: AnalyticsDataSelect<ExtArgs> | null
    /**
     * Filter, which AnalyticsData to fetch.
     */
    where?: AnalyticsDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsData to fetch.
     */
    orderBy?: AnalyticsDataOrderByWithRelationInput | AnalyticsDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsData.
     */
    cursor?: AnalyticsDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsData.
     */
    distinct?: AnalyticsDataScalarFieldEnum | AnalyticsDataScalarFieldEnum[]
  }

  /**
   * AnalyticsData findFirstOrThrow
   */
  export type AnalyticsDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsData
     */
    select?: AnalyticsDataSelect<ExtArgs> | null
    /**
     * Filter, which AnalyticsData to fetch.
     */
    where?: AnalyticsDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsData to fetch.
     */
    orderBy?: AnalyticsDataOrderByWithRelationInput | AnalyticsDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsData.
     */
    cursor?: AnalyticsDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsData.
     */
    distinct?: AnalyticsDataScalarFieldEnum | AnalyticsDataScalarFieldEnum[]
  }

  /**
   * AnalyticsData findMany
   */
  export type AnalyticsDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsData
     */
    select?: AnalyticsDataSelect<ExtArgs> | null
    /**
     * Filter, which AnalyticsData to fetch.
     */
    where?: AnalyticsDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsData to fetch.
     */
    orderBy?: AnalyticsDataOrderByWithRelationInput | AnalyticsDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsData.
     */
    cursor?: AnalyticsDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsData.
     */
    skip?: number
    distinct?: AnalyticsDataScalarFieldEnum | AnalyticsDataScalarFieldEnum[]
  }

  /**
   * AnalyticsData create
   */
  export type AnalyticsDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsData
     */
    select?: AnalyticsDataSelect<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsData.
     */
    data: XOR<AnalyticsDataCreateInput, AnalyticsDataUncheckedCreateInput>
  }

  /**
   * AnalyticsData createMany
   */
  export type AnalyticsDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsData.
     */
    data: AnalyticsDataCreateManyInput | AnalyticsDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsData createManyAndReturn
   */
  export type AnalyticsDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsData
     */
    select?: AnalyticsDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AnalyticsData.
     */
    data: AnalyticsDataCreateManyInput | AnalyticsDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsData update
   */
  export type AnalyticsDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsData
     */
    select?: AnalyticsDataSelect<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsData.
     */
    data: XOR<AnalyticsDataUpdateInput, AnalyticsDataUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsData to update.
     */
    where: AnalyticsDataWhereUniqueInput
  }

  /**
   * AnalyticsData updateMany
   */
  export type AnalyticsDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsData.
     */
    data: XOR<AnalyticsDataUpdateManyMutationInput, AnalyticsDataUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsData to update
     */
    where?: AnalyticsDataWhereInput
  }

  /**
   * AnalyticsData upsert
   */
  export type AnalyticsDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsData
     */
    select?: AnalyticsDataSelect<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsData to update in case it exists.
     */
    where: AnalyticsDataWhereUniqueInput
    /**
     * In case the AnalyticsData found by the `where` argument doesn't exist, create a new AnalyticsData with this data.
     */
    create: XOR<AnalyticsDataCreateInput, AnalyticsDataUncheckedCreateInput>
    /**
     * In case the AnalyticsData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsDataUpdateInput, AnalyticsDataUncheckedUpdateInput>
  }

  /**
   * AnalyticsData delete
   */
  export type AnalyticsDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsData
     */
    select?: AnalyticsDataSelect<ExtArgs> | null
    /**
     * Filter which AnalyticsData to delete.
     */
    where: AnalyticsDataWhereUniqueInput
  }

  /**
   * AnalyticsData deleteMany
   */
  export type AnalyticsDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsData to delete
     */
    where?: AnalyticsDataWhereInput
  }

  /**
   * AnalyticsData without action
   */
  export type AnalyticsDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsData
     */
    select?: AnalyticsDataSelect<ExtArgs> | null
  }


  /**
   * Model Ranking
   */

  export type AggregateRanking = {
    _count: RankingCountAggregateOutputType | null
    _min: RankingMinAggregateOutputType | null
    _max: RankingMaxAggregateOutputType | null
  }

  export type RankingMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    period: string | null
    data: string | null
    createdAt: Date | null
  }

  export type RankingMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    period: string | null
    data: string | null
    createdAt: Date | null
  }

  export type RankingCountAggregateOutputType = {
    id: number
    name: number
    type: number
    period: number
    data: number
    createdAt: number
    _all: number
  }


  export type RankingMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    period?: true
    data?: true
    createdAt?: true
  }

  export type RankingMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    period?: true
    data?: true
    createdAt?: true
  }

  export type RankingCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    period?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type RankingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ranking to aggregate.
     */
    where?: RankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rankings to fetch.
     */
    orderBy?: RankingOrderByWithRelationInput | RankingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rankings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rankings
    **/
    _count?: true | RankingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RankingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RankingMaxAggregateInputType
  }

  export type GetRankingAggregateType<T extends RankingAggregateArgs> = {
        [P in keyof T & keyof AggregateRanking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRanking[P]>
      : GetScalarType<T[P], AggregateRanking[P]>
  }




  export type RankingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RankingWhereInput
    orderBy?: RankingOrderByWithAggregationInput | RankingOrderByWithAggregationInput[]
    by: RankingScalarFieldEnum[] | RankingScalarFieldEnum
    having?: RankingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RankingCountAggregateInputType | true
    _min?: RankingMinAggregateInputType
    _max?: RankingMaxAggregateInputType
  }

  export type RankingGroupByOutputType = {
    id: string
    name: string
    type: string
    period: string
    data: string
    createdAt: Date
    _count: RankingCountAggregateOutputType | null
    _min: RankingMinAggregateOutputType | null
    _max: RankingMaxAggregateOutputType | null
  }

  type GetRankingGroupByPayload<T extends RankingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RankingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RankingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RankingGroupByOutputType[P]>
            : GetScalarType<T[P], RankingGroupByOutputType[P]>
        }
      >
    >


  export type RankingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    period?: boolean
    data?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ranking"]>

  export type RankingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    period?: boolean
    data?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["ranking"]>

  export type RankingSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    period?: boolean
    data?: boolean
    createdAt?: boolean
  }


  export type $RankingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ranking"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      period: string
      data: string
      createdAt: Date
    }, ExtArgs["result"]["ranking"]>
    composites: {}
  }

  type RankingGetPayload<S extends boolean | null | undefined | RankingDefaultArgs> = $Result.GetResult<Prisma.$RankingPayload, S>

  type RankingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RankingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RankingCountAggregateInputType | true
    }

  export interface RankingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ranking'], meta: { name: 'Ranking' } }
    /**
     * Find zero or one Ranking that matches the filter.
     * @param {RankingFindUniqueArgs} args - Arguments to find a Ranking
     * @example
     * // Get one Ranking
     * const ranking = await prisma.ranking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RankingFindUniqueArgs>(args: SelectSubset<T, RankingFindUniqueArgs<ExtArgs>>): Prisma__RankingClient<$Result.GetResult<Prisma.$RankingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ranking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RankingFindUniqueOrThrowArgs} args - Arguments to find a Ranking
     * @example
     * // Get one Ranking
     * const ranking = await prisma.ranking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RankingFindUniqueOrThrowArgs>(args: SelectSubset<T, RankingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RankingClient<$Result.GetResult<Prisma.$RankingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ranking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingFindFirstArgs} args - Arguments to find a Ranking
     * @example
     * // Get one Ranking
     * const ranking = await prisma.ranking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RankingFindFirstArgs>(args?: SelectSubset<T, RankingFindFirstArgs<ExtArgs>>): Prisma__RankingClient<$Result.GetResult<Prisma.$RankingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ranking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingFindFirstOrThrowArgs} args - Arguments to find a Ranking
     * @example
     * // Get one Ranking
     * const ranking = await prisma.ranking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RankingFindFirstOrThrowArgs>(args?: SelectSubset<T, RankingFindFirstOrThrowArgs<ExtArgs>>): Prisma__RankingClient<$Result.GetResult<Prisma.$RankingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rankings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rankings
     * const rankings = await prisma.ranking.findMany()
     * 
     * // Get first 10 Rankings
     * const rankings = await prisma.ranking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rankingWithIdOnly = await prisma.ranking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RankingFindManyArgs>(args?: SelectSubset<T, RankingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RankingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ranking.
     * @param {RankingCreateArgs} args - Arguments to create a Ranking.
     * @example
     * // Create one Ranking
     * const Ranking = await prisma.ranking.create({
     *   data: {
     *     // ... data to create a Ranking
     *   }
     * })
     * 
     */
    create<T extends RankingCreateArgs>(args: SelectSubset<T, RankingCreateArgs<ExtArgs>>): Prisma__RankingClient<$Result.GetResult<Prisma.$RankingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rankings.
     * @param {RankingCreateManyArgs} args - Arguments to create many Rankings.
     * @example
     * // Create many Rankings
     * const ranking = await prisma.ranking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RankingCreateManyArgs>(args?: SelectSubset<T, RankingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rankings and returns the data saved in the database.
     * @param {RankingCreateManyAndReturnArgs} args - Arguments to create many Rankings.
     * @example
     * // Create many Rankings
     * const ranking = await prisma.ranking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rankings and only return the `id`
     * const rankingWithIdOnly = await prisma.ranking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RankingCreateManyAndReturnArgs>(args?: SelectSubset<T, RankingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RankingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ranking.
     * @param {RankingDeleteArgs} args - Arguments to delete one Ranking.
     * @example
     * // Delete one Ranking
     * const Ranking = await prisma.ranking.delete({
     *   where: {
     *     // ... filter to delete one Ranking
     *   }
     * })
     * 
     */
    delete<T extends RankingDeleteArgs>(args: SelectSubset<T, RankingDeleteArgs<ExtArgs>>): Prisma__RankingClient<$Result.GetResult<Prisma.$RankingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ranking.
     * @param {RankingUpdateArgs} args - Arguments to update one Ranking.
     * @example
     * // Update one Ranking
     * const ranking = await prisma.ranking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RankingUpdateArgs>(args: SelectSubset<T, RankingUpdateArgs<ExtArgs>>): Prisma__RankingClient<$Result.GetResult<Prisma.$RankingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rankings.
     * @param {RankingDeleteManyArgs} args - Arguments to filter Rankings to delete.
     * @example
     * // Delete a few Rankings
     * const { count } = await prisma.ranking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RankingDeleteManyArgs>(args?: SelectSubset<T, RankingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rankings
     * const ranking = await prisma.ranking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RankingUpdateManyArgs>(args: SelectSubset<T, RankingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ranking.
     * @param {RankingUpsertArgs} args - Arguments to update or create a Ranking.
     * @example
     * // Update or create a Ranking
     * const ranking = await prisma.ranking.upsert({
     *   create: {
     *     // ... data to create a Ranking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ranking we want to update
     *   }
     * })
     */
    upsert<T extends RankingUpsertArgs>(args: SelectSubset<T, RankingUpsertArgs<ExtArgs>>): Prisma__RankingClient<$Result.GetResult<Prisma.$RankingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingCountArgs} args - Arguments to filter Rankings to count.
     * @example
     * // Count the number of Rankings
     * const count = await prisma.ranking.count({
     *   where: {
     *     // ... the filter for the Rankings we want to count
     *   }
     * })
    **/
    count<T extends RankingCountArgs>(
      args?: Subset<T, RankingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RankingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ranking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RankingAggregateArgs>(args: Subset<T, RankingAggregateArgs>): Prisma.PrismaPromise<GetRankingAggregateType<T>>

    /**
     * Group by Ranking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RankingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RankingGroupByArgs['orderBy'] }
        : { orderBy?: RankingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RankingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRankingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ranking model
   */
  readonly fields: RankingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ranking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RankingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ranking model
   */ 
  interface RankingFieldRefs {
    readonly id: FieldRef<"Ranking", 'String'>
    readonly name: FieldRef<"Ranking", 'String'>
    readonly type: FieldRef<"Ranking", 'String'>
    readonly period: FieldRef<"Ranking", 'String'>
    readonly data: FieldRef<"Ranking", 'String'>
    readonly createdAt: FieldRef<"Ranking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ranking findUnique
   */
  export type RankingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranking
     */
    select?: RankingSelect<ExtArgs> | null
    /**
     * Filter, which Ranking to fetch.
     */
    where: RankingWhereUniqueInput
  }

  /**
   * Ranking findUniqueOrThrow
   */
  export type RankingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranking
     */
    select?: RankingSelect<ExtArgs> | null
    /**
     * Filter, which Ranking to fetch.
     */
    where: RankingWhereUniqueInput
  }

  /**
   * Ranking findFirst
   */
  export type RankingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranking
     */
    select?: RankingSelect<ExtArgs> | null
    /**
     * Filter, which Ranking to fetch.
     */
    where?: RankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rankings to fetch.
     */
    orderBy?: RankingOrderByWithRelationInput | RankingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rankings.
     */
    cursor?: RankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rankings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rankings.
     */
    distinct?: RankingScalarFieldEnum | RankingScalarFieldEnum[]
  }

  /**
   * Ranking findFirstOrThrow
   */
  export type RankingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranking
     */
    select?: RankingSelect<ExtArgs> | null
    /**
     * Filter, which Ranking to fetch.
     */
    where?: RankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rankings to fetch.
     */
    orderBy?: RankingOrderByWithRelationInput | RankingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rankings.
     */
    cursor?: RankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rankings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rankings.
     */
    distinct?: RankingScalarFieldEnum | RankingScalarFieldEnum[]
  }

  /**
   * Ranking findMany
   */
  export type RankingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranking
     */
    select?: RankingSelect<ExtArgs> | null
    /**
     * Filter, which Rankings to fetch.
     */
    where?: RankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rankings to fetch.
     */
    orderBy?: RankingOrderByWithRelationInput | RankingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rankings.
     */
    cursor?: RankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rankings.
     */
    skip?: number
    distinct?: RankingScalarFieldEnum | RankingScalarFieldEnum[]
  }

  /**
   * Ranking create
   */
  export type RankingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranking
     */
    select?: RankingSelect<ExtArgs> | null
    /**
     * The data needed to create a Ranking.
     */
    data: XOR<RankingCreateInput, RankingUncheckedCreateInput>
  }

  /**
   * Ranking createMany
   */
  export type RankingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rankings.
     */
    data: RankingCreateManyInput | RankingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ranking createManyAndReturn
   */
  export type RankingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranking
     */
    select?: RankingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Rankings.
     */
    data: RankingCreateManyInput | RankingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ranking update
   */
  export type RankingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranking
     */
    select?: RankingSelect<ExtArgs> | null
    /**
     * The data needed to update a Ranking.
     */
    data: XOR<RankingUpdateInput, RankingUncheckedUpdateInput>
    /**
     * Choose, which Ranking to update.
     */
    where: RankingWhereUniqueInput
  }

  /**
   * Ranking updateMany
   */
  export type RankingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rankings.
     */
    data: XOR<RankingUpdateManyMutationInput, RankingUncheckedUpdateManyInput>
    /**
     * Filter which Rankings to update
     */
    where?: RankingWhereInput
  }

  /**
   * Ranking upsert
   */
  export type RankingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranking
     */
    select?: RankingSelect<ExtArgs> | null
    /**
     * The filter to search for the Ranking to update in case it exists.
     */
    where: RankingWhereUniqueInput
    /**
     * In case the Ranking found by the `where` argument doesn't exist, create a new Ranking with this data.
     */
    create: XOR<RankingCreateInput, RankingUncheckedCreateInput>
    /**
     * In case the Ranking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RankingUpdateInput, RankingUncheckedUpdateInput>
  }

  /**
   * Ranking delete
   */
  export type RankingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranking
     */
    select?: RankingSelect<ExtArgs> | null
    /**
     * Filter which Ranking to delete.
     */
    where: RankingWhereUniqueInput
  }

  /**
   * Ranking deleteMany
   */
  export type RankingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rankings to delete
     */
    where?: RankingWhereInput
  }

  /**
   * Ranking without action
   */
  export type RankingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ranking
     */
    select?: RankingSelect<ExtArgs> | null
  }


  /**
   * Model Personality
   */

  export type AggregatePersonality = {
    _count: PersonalityCountAggregateOutputType | null
    _min: PersonalityMinAggregateOutputType | null
    _max: PersonalityMaxAggregateOutputType | null
  }

  export type PersonalityMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    traits: string | null
    createdAt: Date | null
  }

  export type PersonalityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    traits: string | null
    createdAt: Date | null
  }

  export type PersonalityCountAggregateOutputType = {
    id: number
    name: number
    description: number
    traits: number
    createdAt: number
    _all: number
  }


  export type PersonalityMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    traits?: true
    createdAt?: true
  }

  export type PersonalityMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    traits?: true
    createdAt?: true
  }

  export type PersonalityCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    traits?: true
    createdAt?: true
    _all?: true
  }

  export type PersonalityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Personality to aggregate.
     */
    where?: PersonalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personalities to fetch.
     */
    orderBy?: PersonalityOrderByWithRelationInput | PersonalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Personalities
    **/
    _count?: true | PersonalityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalityMaxAggregateInputType
  }

  export type GetPersonalityAggregateType<T extends PersonalityAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonality]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonality[P]>
      : GetScalarType<T[P], AggregatePersonality[P]>
  }




  export type PersonalityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalityWhereInput
    orderBy?: PersonalityOrderByWithAggregationInput | PersonalityOrderByWithAggregationInput[]
    by: PersonalityScalarFieldEnum[] | PersonalityScalarFieldEnum
    having?: PersonalityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalityCountAggregateInputType | true
    _min?: PersonalityMinAggregateInputType
    _max?: PersonalityMaxAggregateInputType
  }

  export type PersonalityGroupByOutputType = {
    id: string
    name: string
    description: string | null
    traits: string
    createdAt: Date
    _count: PersonalityCountAggregateOutputType | null
    _min: PersonalityMinAggregateOutputType | null
    _max: PersonalityMaxAggregateOutputType | null
  }

  type GetPersonalityGroupByPayload<T extends PersonalityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonalityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalityGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalityGroupByOutputType[P]>
        }
      >
    >


  export type PersonalitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    traits?: boolean
    createdAt?: boolean
    users?: boolean | Personality$usersArgs<ExtArgs>
    _count?: boolean | PersonalityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personality"]>

  export type PersonalitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    traits?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["personality"]>

  export type PersonalitySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    traits?: boolean
    createdAt?: boolean
  }

  export type PersonalityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Personality$usersArgs<ExtArgs>
    _count?: boolean | PersonalityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PersonalityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PersonalityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Personality"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      traits: string
      createdAt: Date
    }, ExtArgs["result"]["personality"]>
    composites: {}
  }

  type PersonalityGetPayload<S extends boolean | null | undefined | PersonalityDefaultArgs> = $Result.GetResult<Prisma.$PersonalityPayload, S>

  type PersonalityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonalityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonalityCountAggregateInputType | true
    }

  export interface PersonalityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Personality'], meta: { name: 'Personality' } }
    /**
     * Find zero or one Personality that matches the filter.
     * @param {PersonalityFindUniqueArgs} args - Arguments to find a Personality
     * @example
     * // Get one Personality
     * const personality = await prisma.personality.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonalityFindUniqueArgs>(args: SelectSubset<T, PersonalityFindUniqueArgs<ExtArgs>>): Prisma__PersonalityClient<$Result.GetResult<Prisma.$PersonalityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Personality that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonalityFindUniqueOrThrowArgs} args - Arguments to find a Personality
     * @example
     * // Get one Personality
     * const personality = await prisma.personality.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonalityFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonalityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonalityClient<$Result.GetResult<Prisma.$PersonalityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Personality that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityFindFirstArgs} args - Arguments to find a Personality
     * @example
     * // Get one Personality
     * const personality = await prisma.personality.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonalityFindFirstArgs>(args?: SelectSubset<T, PersonalityFindFirstArgs<ExtArgs>>): Prisma__PersonalityClient<$Result.GetResult<Prisma.$PersonalityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Personality that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityFindFirstOrThrowArgs} args - Arguments to find a Personality
     * @example
     * // Get one Personality
     * const personality = await prisma.personality.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonalityFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonalityFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonalityClient<$Result.GetResult<Prisma.$PersonalityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Personalities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personalities
     * const personalities = await prisma.personality.findMany()
     * 
     * // Get first 10 Personalities
     * const personalities = await prisma.personality.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personalityWithIdOnly = await prisma.personality.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonalityFindManyArgs>(args?: SelectSubset<T, PersonalityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Personality.
     * @param {PersonalityCreateArgs} args - Arguments to create a Personality.
     * @example
     * // Create one Personality
     * const Personality = await prisma.personality.create({
     *   data: {
     *     // ... data to create a Personality
     *   }
     * })
     * 
     */
    create<T extends PersonalityCreateArgs>(args: SelectSubset<T, PersonalityCreateArgs<ExtArgs>>): Prisma__PersonalityClient<$Result.GetResult<Prisma.$PersonalityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Personalities.
     * @param {PersonalityCreateManyArgs} args - Arguments to create many Personalities.
     * @example
     * // Create many Personalities
     * const personality = await prisma.personality.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonalityCreateManyArgs>(args?: SelectSubset<T, PersonalityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Personalities and returns the data saved in the database.
     * @param {PersonalityCreateManyAndReturnArgs} args - Arguments to create many Personalities.
     * @example
     * // Create many Personalities
     * const personality = await prisma.personality.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Personalities and only return the `id`
     * const personalityWithIdOnly = await prisma.personality.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonalityCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonalityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Personality.
     * @param {PersonalityDeleteArgs} args - Arguments to delete one Personality.
     * @example
     * // Delete one Personality
     * const Personality = await prisma.personality.delete({
     *   where: {
     *     // ... filter to delete one Personality
     *   }
     * })
     * 
     */
    delete<T extends PersonalityDeleteArgs>(args: SelectSubset<T, PersonalityDeleteArgs<ExtArgs>>): Prisma__PersonalityClient<$Result.GetResult<Prisma.$PersonalityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Personality.
     * @param {PersonalityUpdateArgs} args - Arguments to update one Personality.
     * @example
     * // Update one Personality
     * const personality = await prisma.personality.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonalityUpdateArgs>(args: SelectSubset<T, PersonalityUpdateArgs<ExtArgs>>): Prisma__PersonalityClient<$Result.GetResult<Prisma.$PersonalityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Personalities.
     * @param {PersonalityDeleteManyArgs} args - Arguments to filter Personalities to delete.
     * @example
     * // Delete a few Personalities
     * const { count } = await prisma.personality.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonalityDeleteManyArgs>(args?: SelectSubset<T, PersonalityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personalities
     * const personality = await prisma.personality.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonalityUpdateManyArgs>(args: SelectSubset<T, PersonalityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Personality.
     * @param {PersonalityUpsertArgs} args - Arguments to update or create a Personality.
     * @example
     * // Update or create a Personality
     * const personality = await prisma.personality.upsert({
     *   create: {
     *     // ... data to create a Personality
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personality we want to update
     *   }
     * })
     */
    upsert<T extends PersonalityUpsertArgs>(args: SelectSubset<T, PersonalityUpsertArgs<ExtArgs>>): Prisma__PersonalityClient<$Result.GetResult<Prisma.$PersonalityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Personalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityCountArgs} args - Arguments to filter Personalities to count.
     * @example
     * // Count the number of Personalities
     * const count = await prisma.personality.count({
     *   where: {
     *     // ... the filter for the Personalities we want to count
     *   }
     * })
    **/
    count<T extends PersonalityCountArgs>(
      args?: Subset<T, PersonalityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalityAggregateArgs>(args: Subset<T, PersonalityAggregateArgs>): Prisma.PrismaPromise<GetPersonalityAggregateType<T>>

    /**
     * Group by Personality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonalityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonalityGroupByArgs['orderBy'] }
        : { orderBy?: PersonalityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonalityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Personality model
   */
  readonly fields: PersonalityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Personality.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonalityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Personality$usersArgs<ExtArgs> = {}>(args?: Subset<T, Personality$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Personality model
   */ 
  interface PersonalityFieldRefs {
    readonly id: FieldRef<"Personality", 'String'>
    readonly name: FieldRef<"Personality", 'String'>
    readonly description: FieldRef<"Personality", 'String'>
    readonly traits: FieldRef<"Personality", 'String'>
    readonly createdAt: FieldRef<"Personality", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Personality findUnique
   */
  export type PersonalityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personality
     */
    select?: PersonalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityInclude<ExtArgs> | null
    /**
     * Filter, which Personality to fetch.
     */
    where: PersonalityWhereUniqueInput
  }

  /**
   * Personality findUniqueOrThrow
   */
  export type PersonalityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personality
     */
    select?: PersonalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityInclude<ExtArgs> | null
    /**
     * Filter, which Personality to fetch.
     */
    where: PersonalityWhereUniqueInput
  }

  /**
   * Personality findFirst
   */
  export type PersonalityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personality
     */
    select?: PersonalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityInclude<ExtArgs> | null
    /**
     * Filter, which Personality to fetch.
     */
    where?: PersonalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personalities to fetch.
     */
    orderBy?: PersonalityOrderByWithRelationInput | PersonalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personalities.
     */
    cursor?: PersonalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personalities.
     */
    distinct?: PersonalityScalarFieldEnum | PersonalityScalarFieldEnum[]
  }

  /**
   * Personality findFirstOrThrow
   */
  export type PersonalityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personality
     */
    select?: PersonalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityInclude<ExtArgs> | null
    /**
     * Filter, which Personality to fetch.
     */
    where?: PersonalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personalities to fetch.
     */
    orderBy?: PersonalityOrderByWithRelationInput | PersonalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personalities.
     */
    cursor?: PersonalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personalities.
     */
    distinct?: PersonalityScalarFieldEnum | PersonalityScalarFieldEnum[]
  }

  /**
   * Personality findMany
   */
  export type PersonalityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personality
     */
    select?: PersonalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityInclude<ExtArgs> | null
    /**
     * Filter, which Personalities to fetch.
     */
    where?: PersonalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personalities to fetch.
     */
    orderBy?: PersonalityOrderByWithRelationInput | PersonalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Personalities.
     */
    cursor?: PersonalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personalities.
     */
    skip?: number
    distinct?: PersonalityScalarFieldEnum | PersonalityScalarFieldEnum[]
  }

  /**
   * Personality create
   */
  export type PersonalityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personality
     */
    select?: PersonalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityInclude<ExtArgs> | null
    /**
     * The data needed to create a Personality.
     */
    data: XOR<PersonalityCreateInput, PersonalityUncheckedCreateInput>
  }

  /**
   * Personality createMany
   */
  export type PersonalityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Personalities.
     */
    data: PersonalityCreateManyInput | PersonalityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Personality createManyAndReturn
   */
  export type PersonalityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personality
     */
    select?: PersonalitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Personalities.
     */
    data: PersonalityCreateManyInput | PersonalityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Personality update
   */
  export type PersonalityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personality
     */
    select?: PersonalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityInclude<ExtArgs> | null
    /**
     * The data needed to update a Personality.
     */
    data: XOR<PersonalityUpdateInput, PersonalityUncheckedUpdateInput>
    /**
     * Choose, which Personality to update.
     */
    where: PersonalityWhereUniqueInput
  }

  /**
   * Personality updateMany
   */
  export type PersonalityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Personalities.
     */
    data: XOR<PersonalityUpdateManyMutationInput, PersonalityUncheckedUpdateManyInput>
    /**
     * Filter which Personalities to update
     */
    where?: PersonalityWhereInput
  }

  /**
   * Personality upsert
   */
  export type PersonalityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personality
     */
    select?: PersonalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityInclude<ExtArgs> | null
    /**
     * The filter to search for the Personality to update in case it exists.
     */
    where: PersonalityWhereUniqueInput
    /**
     * In case the Personality found by the `where` argument doesn't exist, create a new Personality with this data.
     */
    create: XOR<PersonalityCreateInput, PersonalityUncheckedCreateInput>
    /**
     * In case the Personality was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonalityUpdateInput, PersonalityUncheckedUpdateInput>
  }

  /**
   * Personality delete
   */
  export type PersonalityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personality
     */
    select?: PersonalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityInclude<ExtArgs> | null
    /**
     * Filter which Personality to delete.
     */
    where: PersonalityWhereUniqueInput
  }

  /**
   * Personality deleteMany
   */
  export type PersonalityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Personalities to delete
     */
    where?: PersonalityWhereInput
  }

  /**
   * Personality.users
   */
  export type Personality$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Personality without action
   */
  export type PersonalityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Personality
     */
    select?: PersonalitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalityInclude<ExtArgs> | null
  }


  /**
   * Model UIComponentTemplate
   */

  export type AggregateUIComponentTemplate = {
    _count: UIComponentTemplateCountAggregateOutputType | null
    _min: UIComponentTemplateMinAggregateOutputType | null
    _max: UIComponentTemplateMaxAggregateOutputType | null
  }

  export type UIComponentTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    templateJson: string | null
    creatorId: string | null
    createdAt: Date | null
  }

  export type UIComponentTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    templateJson: string | null
    creatorId: string | null
    createdAt: Date | null
  }

  export type UIComponentTemplateCountAggregateOutputType = {
    id: number
    name: number
    type: number
    templateJson: number
    creatorId: number
    createdAt: number
    _all: number
  }


  export type UIComponentTemplateMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    templateJson?: true
    creatorId?: true
    createdAt?: true
  }

  export type UIComponentTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    templateJson?: true
    creatorId?: true
    createdAt?: true
  }

  export type UIComponentTemplateCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    templateJson?: true
    creatorId?: true
    createdAt?: true
    _all?: true
  }

  export type UIComponentTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UIComponentTemplate to aggregate.
     */
    where?: UIComponentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UIComponentTemplates to fetch.
     */
    orderBy?: UIComponentTemplateOrderByWithRelationInput | UIComponentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UIComponentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UIComponentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UIComponentTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UIComponentTemplates
    **/
    _count?: true | UIComponentTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UIComponentTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UIComponentTemplateMaxAggregateInputType
  }

  export type GetUIComponentTemplateAggregateType<T extends UIComponentTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateUIComponentTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUIComponentTemplate[P]>
      : GetScalarType<T[P], AggregateUIComponentTemplate[P]>
  }




  export type UIComponentTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UIComponentTemplateWhereInput
    orderBy?: UIComponentTemplateOrderByWithAggregationInput | UIComponentTemplateOrderByWithAggregationInput[]
    by: UIComponentTemplateScalarFieldEnum[] | UIComponentTemplateScalarFieldEnum
    having?: UIComponentTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UIComponentTemplateCountAggregateInputType | true
    _min?: UIComponentTemplateMinAggregateInputType
    _max?: UIComponentTemplateMaxAggregateInputType
  }

  export type UIComponentTemplateGroupByOutputType = {
    id: string
    name: string
    type: string
    templateJson: string
    creatorId: string
    createdAt: Date
    _count: UIComponentTemplateCountAggregateOutputType | null
    _min: UIComponentTemplateMinAggregateOutputType | null
    _max: UIComponentTemplateMaxAggregateOutputType | null
  }

  type GetUIComponentTemplateGroupByPayload<T extends UIComponentTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UIComponentTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UIComponentTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UIComponentTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], UIComponentTemplateGroupByOutputType[P]>
        }
      >
    >


  export type UIComponentTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    templateJson?: boolean
    creatorId?: boolean
    createdAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["uIComponentTemplate"]>

  export type UIComponentTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    templateJson?: boolean
    creatorId?: boolean
    createdAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["uIComponentTemplate"]>

  export type UIComponentTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    templateJson?: boolean
    creatorId?: boolean
    createdAt?: boolean
  }

  export type UIComponentTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UIComponentTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UIComponentTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UIComponentTemplate"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      templateJson: string
      creatorId: string
      createdAt: Date
    }, ExtArgs["result"]["uIComponentTemplate"]>
    composites: {}
  }

  type UIComponentTemplateGetPayload<S extends boolean | null | undefined | UIComponentTemplateDefaultArgs> = $Result.GetResult<Prisma.$UIComponentTemplatePayload, S>

  type UIComponentTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UIComponentTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UIComponentTemplateCountAggregateInputType | true
    }

  export interface UIComponentTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UIComponentTemplate'], meta: { name: 'UIComponentTemplate' } }
    /**
     * Find zero or one UIComponentTemplate that matches the filter.
     * @param {UIComponentTemplateFindUniqueArgs} args - Arguments to find a UIComponentTemplate
     * @example
     * // Get one UIComponentTemplate
     * const uIComponentTemplate = await prisma.uIComponentTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UIComponentTemplateFindUniqueArgs>(args: SelectSubset<T, UIComponentTemplateFindUniqueArgs<ExtArgs>>): Prisma__UIComponentTemplateClient<$Result.GetResult<Prisma.$UIComponentTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UIComponentTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UIComponentTemplateFindUniqueOrThrowArgs} args - Arguments to find a UIComponentTemplate
     * @example
     * // Get one UIComponentTemplate
     * const uIComponentTemplate = await prisma.uIComponentTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UIComponentTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, UIComponentTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UIComponentTemplateClient<$Result.GetResult<Prisma.$UIComponentTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UIComponentTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UIComponentTemplateFindFirstArgs} args - Arguments to find a UIComponentTemplate
     * @example
     * // Get one UIComponentTemplate
     * const uIComponentTemplate = await prisma.uIComponentTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UIComponentTemplateFindFirstArgs>(args?: SelectSubset<T, UIComponentTemplateFindFirstArgs<ExtArgs>>): Prisma__UIComponentTemplateClient<$Result.GetResult<Prisma.$UIComponentTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UIComponentTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UIComponentTemplateFindFirstOrThrowArgs} args - Arguments to find a UIComponentTemplate
     * @example
     * // Get one UIComponentTemplate
     * const uIComponentTemplate = await prisma.uIComponentTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UIComponentTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, UIComponentTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__UIComponentTemplateClient<$Result.GetResult<Prisma.$UIComponentTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UIComponentTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UIComponentTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UIComponentTemplates
     * const uIComponentTemplates = await prisma.uIComponentTemplate.findMany()
     * 
     * // Get first 10 UIComponentTemplates
     * const uIComponentTemplates = await prisma.uIComponentTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uIComponentTemplateWithIdOnly = await prisma.uIComponentTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UIComponentTemplateFindManyArgs>(args?: SelectSubset<T, UIComponentTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UIComponentTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UIComponentTemplate.
     * @param {UIComponentTemplateCreateArgs} args - Arguments to create a UIComponentTemplate.
     * @example
     * // Create one UIComponentTemplate
     * const UIComponentTemplate = await prisma.uIComponentTemplate.create({
     *   data: {
     *     // ... data to create a UIComponentTemplate
     *   }
     * })
     * 
     */
    create<T extends UIComponentTemplateCreateArgs>(args: SelectSubset<T, UIComponentTemplateCreateArgs<ExtArgs>>): Prisma__UIComponentTemplateClient<$Result.GetResult<Prisma.$UIComponentTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UIComponentTemplates.
     * @param {UIComponentTemplateCreateManyArgs} args - Arguments to create many UIComponentTemplates.
     * @example
     * // Create many UIComponentTemplates
     * const uIComponentTemplate = await prisma.uIComponentTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UIComponentTemplateCreateManyArgs>(args?: SelectSubset<T, UIComponentTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UIComponentTemplates and returns the data saved in the database.
     * @param {UIComponentTemplateCreateManyAndReturnArgs} args - Arguments to create many UIComponentTemplates.
     * @example
     * // Create many UIComponentTemplates
     * const uIComponentTemplate = await prisma.uIComponentTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UIComponentTemplates and only return the `id`
     * const uIComponentTemplateWithIdOnly = await prisma.uIComponentTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UIComponentTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, UIComponentTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UIComponentTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UIComponentTemplate.
     * @param {UIComponentTemplateDeleteArgs} args - Arguments to delete one UIComponentTemplate.
     * @example
     * // Delete one UIComponentTemplate
     * const UIComponentTemplate = await prisma.uIComponentTemplate.delete({
     *   where: {
     *     // ... filter to delete one UIComponentTemplate
     *   }
     * })
     * 
     */
    delete<T extends UIComponentTemplateDeleteArgs>(args: SelectSubset<T, UIComponentTemplateDeleteArgs<ExtArgs>>): Prisma__UIComponentTemplateClient<$Result.GetResult<Prisma.$UIComponentTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UIComponentTemplate.
     * @param {UIComponentTemplateUpdateArgs} args - Arguments to update one UIComponentTemplate.
     * @example
     * // Update one UIComponentTemplate
     * const uIComponentTemplate = await prisma.uIComponentTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UIComponentTemplateUpdateArgs>(args: SelectSubset<T, UIComponentTemplateUpdateArgs<ExtArgs>>): Prisma__UIComponentTemplateClient<$Result.GetResult<Prisma.$UIComponentTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UIComponentTemplates.
     * @param {UIComponentTemplateDeleteManyArgs} args - Arguments to filter UIComponentTemplates to delete.
     * @example
     * // Delete a few UIComponentTemplates
     * const { count } = await prisma.uIComponentTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UIComponentTemplateDeleteManyArgs>(args?: SelectSubset<T, UIComponentTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UIComponentTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UIComponentTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UIComponentTemplates
     * const uIComponentTemplate = await prisma.uIComponentTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UIComponentTemplateUpdateManyArgs>(args: SelectSubset<T, UIComponentTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UIComponentTemplate.
     * @param {UIComponentTemplateUpsertArgs} args - Arguments to update or create a UIComponentTemplate.
     * @example
     * // Update or create a UIComponentTemplate
     * const uIComponentTemplate = await prisma.uIComponentTemplate.upsert({
     *   create: {
     *     // ... data to create a UIComponentTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UIComponentTemplate we want to update
     *   }
     * })
     */
    upsert<T extends UIComponentTemplateUpsertArgs>(args: SelectSubset<T, UIComponentTemplateUpsertArgs<ExtArgs>>): Prisma__UIComponentTemplateClient<$Result.GetResult<Prisma.$UIComponentTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UIComponentTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UIComponentTemplateCountArgs} args - Arguments to filter UIComponentTemplates to count.
     * @example
     * // Count the number of UIComponentTemplates
     * const count = await prisma.uIComponentTemplate.count({
     *   where: {
     *     // ... the filter for the UIComponentTemplates we want to count
     *   }
     * })
    **/
    count<T extends UIComponentTemplateCountArgs>(
      args?: Subset<T, UIComponentTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UIComponentTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UIComponentTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UIComponentTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UIComponentTemplateAggregateArgs>(args: Subset<T, UIComponentTemplateAggregateArgs>): Prisma.PrismaPromise<GetUIComponentTemplateAggregateType<T>>

    /**
     * Group by UIComponentTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UIComponentTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UIComponentTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UIComponentTemplateGroupByArgs['orderBy'] }
        : { orderBy?: UIComponentTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UIComponentTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUIComponentTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UIComponentTemplate model
   */
  readonly fields: UIComponentTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UIComponentTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UIComponentTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UIComponentTemplate model
   */ 
  interface UIComponentTemplateFieldRefs {
    readonly id: FieldRef<"UIComponentTemplate", 'String'>
    readonly name: FieldRef<"UIComponentTemplate", 'String'>
    readonly type: FieldRef<"UIComponentTemplate", 'String'>
    readonly templateJson: FieldRef<"UIComponentTemplate", 'String'>
    readonly creatorId: FieldRef<"UIComponentTemplate", 'String'>
    readonly createdAt: FieldRef<"UIComponentTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UIComponentTemplate findUnique
   */
  export type UIComponentTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UIComponentTemplate
     */
    select?: UIComponentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UIComponentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which UIComponentTemplate to fetch.
     */
    where: UIComponentTemplateWhereUniqueInput
  }

  /**
   * UIComponentTemplate findUniqueOrThrow
   */
  export type UIComponentTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UIComponentTemplate
     */
    select?: UIComponentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UIComponentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which UIComponentTemplate to fetch.
     */
    where: UIComponentTemplateWhereUniqueInput
  }

  /**
   * UIComponentTemplate findFirst
   */
  export type UIComponentTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UIComponentTemplate
     */
    select?: UIComponentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UIComponentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which UIComponentTemplate to fetch.
     */
    where?: UIComponentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UIComponentTemplates to fetch.
     */
    orderBy?: UIComponentTemplateOrderByWithRelationInput | UIComponentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UIComponentTemplates.
     */
    cursor?: UIComponentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UIComponentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UIComponentTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UIComponentTemplates.
     */
    distinct?: UIComponentTemplateScalarFieldEnum | UIComponentTemplateScalarFieldEnum[]
  }

  /**
   * UIComponentTemplate findFirstOrThrow
   */
  export type UIComponentTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UIComponentTemplate
     */
    select?: UIComponentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UIComponentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which UIComponentTemplate to fetch.
     */
    where?: UIComponentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UIComponentTemplates to fetch.
     */
    orderBy?: UIComponentTemplateOrderByWithRelationInput | UIComponentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UIComponentTemplates.
     */
    cursor?: UIComponentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UIComponentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UIComponentTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UIComponentTemplates.
     */
    distinct?: UIComponentTemplateScalarFieldEnum | UIComponentTemplateScalarFieldEnum[]
  }

  /**
   * UIComponentTemplate findMany
   */
  export type UIComponentTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UIComponentTemplate
     */
    select?: UIComponentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UIComponentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which UIComponentTemplates to fetch.
     */
    where?: UIComponentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UIComponentTemplates to fetch.
     */
    orderBy?: UIComponentTemplateOrderByWithRelationInput | UIComponentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UIComponentTemplates.
     */
    cursor?: UIComponentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UIComponentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UIComponentTemplates.
     */
    skip?: number
    distinct?: UIComponentTemplateScalarFieldEnum | UIComponentTemplateScalarFieldEnum[]
  }

  /**
   * UIComponentTemplate create
   */
  export type UIComponentTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UIComponentTemplate
     */
    select?: UIComponentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UIComponentTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a UIComponentTemplate.
     */
    data: XOR<UIComponentTemplateCreateInput, UIComponentTemplateUncheckedCreateInput>
  }

  /**
   * UIComponentTemplate createMany
   */
  export type UIComponentTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UIComponentTemplates.
     */
    data: UIComponentTemplateCreateManyInput | UIComponentTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UIComponentTemplate createManyAndReturn
   */
  export type UIComponentTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UIComponentTemplate
     */
    select?: UIComponentTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UIComponentTemplates.
     */
    data: UIComponentTemplateCreateManyInput | UIComponentTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UIComponentTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UIComponentTemplate update
   */
  export type UIComponentTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UIComponentTemplate
     */
    select?: UIComponentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UIComponentTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a UIComponentTemplate.
     */
    data: XOR<UIComponentTemplateUpdateInput, UIComponentTemplateUncheckedUpdateInput>
    /**
     * Choose, which UIComponentTemplate to update.
     */
    where: UIComponentTemplateWhereUniqueInput
  }

  /**
   * UIComponentTemplate updateMany
   */
  export type UIComponentTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UIComponentTemplates.
     */
    data: XOR<UIComponentTemplateUpdateManyMutationInput, UIComponentTemplateUncheckedUpdateManyInput>
    /**
     * Filter which UIComponentTemplates to update
     */
    where?: UIComponentTemplateWhereInput
  }

  /**
   * UIComponentTemplate upsert
   */
  export type UIComponentTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UIComponentTemplate
     */
    select?: UIComponentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UIComponentTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the UIComponentTemplate to update in case it exists.
     */
    where: UIComponentTemplateWhereUniqueInput
    /**
     * In case the UIComponentTemplate found by the `where` argument doesn't exist, create a new UIComponentTemplate with this data.
     */
    create: XOR<UIComponentTemplateCreateInput, UIComponentTemplateUncheckedCreateInput>
    /**
     * In case the UIComponentTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UIComponentTemplateUpdateInput, UIComponentTemplateUncheckedUpdateInput>
  }

  /**
   * UIComponentTemplate delete
   */
  export type UIComponentTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UIComponentTemplate
     */
    select?: UIComponentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UIComponentTemplateInclude<ExtArgs> | null
    /**
     * Filter which UIComponentTemplate to delete.
     */
    where: UIComponentTemplateWhereUniqueInput
  }

  /**
   * UIComponentTemplate deleteMany
   */
  export type UIComponentTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UIComponentTemplates to delete
     */
    where?: UIComponentTemplateWhereInput
  }

  /**
   * UIComponentTemplate without action
   */
  export type UIComponentTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UIComponentTemplate
     */
    select?: UIComponentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UIComponentTemplateInclude<ExtArgs> | null
  }


  /**
   * Model ItemType
   */

  export type AggregateItemType = {
    _count: ItemTypeCountAggregateOutputType | null
    _min: ItemTypeMinAggregateOutputType | null
    _max: ItemTypeMaxAggregateOutputType | null
  }

  export type ItemTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemType to aggregate.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemTypes
    **/
    _count?: true | ItemTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemTypeMaxAggregateInputType
  }

  export type GetItemTypeAggregateType<T extends ItemTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateItemType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemType[P]>
      : GetScalarType<T[P], AggregateItemType[P]>
  }




  export type ItemTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemTypeWhereInput
    orderBy?: ItemTypeOrderByWithAggregationInput | ItemTypeOrderByWithAggregationInput[]
    by: ItemTypeScalarFieldEnum[] | ItemTypeScalarFieldEnum
    having?: ItemTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemTypeCountAggregateInputType | true
    _min?: ItemTypeMinAggregateInputType
    _max?: ItemTypeMaxAggregateInputType
  }

  export type ItemTypeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isActive: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: ItemTypeCountAggregateOutputType | null
    _min: ItemTypeMinAggregateOutputType | null
    _max: ItemTypeMaxAggregateOutputType | null
  }

  type GetItemTypeGroupByPayload<T extends ItemTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ItemTypeGroupByOutputType[P]>
        }
      >
    >


  export type ItemTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contentItems?: boolean | ItemType$contentItemsArgs<ExtArgs>
    _count?: boolean | ItemTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemType"]>

  export type ItemTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["itemType"]>

  export type ItemTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentItems?: boolean | ItemType$contentItemsArgs<ExtArgs>
    _count?: boolean | ItemTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemType"
    objects: {
      contentItems: Prisma.$ContentItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isActive: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["itemType"]>
    composites: {}
  }

  type ItemTypeGetPayload<S extends boolean | null | undefined | ItemTypeDefaultArgs> = $Result.GetResult<Prisma.$ItemTypePayload, S>

  type ItemTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemTypeCountAggregateInputType | true
    }

  export interface ItemTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemType'], meta: { name: 'ItemType' } }
    /**
     * Find zero or one ItemType that matches the filter.
     * @param {ItemTypeFindUniqueArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemTypeFindUniqueArgs>(args: SelectSubset<T, ItemTypeFindUniqueArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ItemType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ItemTypeFindUniqueOrThrowArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ItemType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindFirstArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemTypeFindFirstArgs>(args?: SelectSubset<T, ItemTypeFindFirstArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ItemType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindFirstOrThrowArgs} args - Arguments to find a ItemType
     * @example
     * // Get one ItemType
     * const itemType = await prisma.itemType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ItemTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemTypes
     * const itemTypes = await prisma.itemType.findMany()
     * 
     * // Get first 10 ItemTypes
     * const itemTypes = await prisma.itemType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemTypeWithIdOnly = await prisma.itemType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemTypeFindManyArgs>(args?: SelectSubset<T, ItemTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ItemType.
     * @param {ItemTypeCreateArgs} args - Arguments to create a ItemType.
     * @example
     * // Create one ItemType
     * const ItemType = await prisma.itemType.create({
     *   data: {
     *     // ... data to create a ItemType
     *   }
     * })
     * 
     */
    create<T extends ItemTypeCreateArgs>(args: SelectSubset<T, ItemTypeCreateArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ItemTypes.
     * @param {ItemTypeCreateManyArgs} args - Arguments to create many ItemTypes.
     * @example
     * // Create many ItemTypes
     * const itemType = await prisma.itemType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemTypeCreateManyArgs>(args?: SelectSubset<T, ItemTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemTypes and returns the data saved in the database.
     * @param {ItemTypeCreateManyAndReturnArgs} args - Arguments to create many ItemTypes.
     * @example
     * // Create many ItemTypes
     * const itemType = await prisma.itemType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemTypes and only return the `id`
     * const itemTypeWithIdOnly = await prisma.itemType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ItemType.
     * @param {ItemTypeDeleteArgs} args - Arguments to delete one ItemType.
     * @example
     * // Delete one ItemType
     * const ItemType = await prisma.itemType.delete({
     *   where: {
     *     // ... filter to delete one ItemType
     *   }
     * })
     * 
     */
    delete<T extends ItemTypeDeleteArgs>(args: SelectSubset<T, ItemTypeDeleteArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ItemType.
     * @param {ItemTypeUpdateArgs} args - Arguments to update one ItemType.
     * @example
     * // Update one ItemType
     * const itemType = await prisma.itemType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemTypeUpdateArgs>(args: SelectSubset<T, ItemTypeUpdateArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ItemTypes.
     * @param {ItemTypeDeleteManyArgs} args - Arguments to filter ItemTypes to delete.
     * @example
     * // Delete a few ItemTypes
     * const { count } = await prisma.itemType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemTypeDeleteManyArgs>(args?: SelectSubset<T, ItemTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemTypes
     * const itemType = await prisma.itemType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemTypeUpdateManyArgs>(args: SelectSubset<T, ItemTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemType.
     * @param {ItemTypeUpsertArgs} args - Arguments to update or create a ItemType.
     * @example
     * // Update or create a ItemType
     * const itemType = await prisma.itemType.upsert({
     *   create: {
     *     // ... data to create a ItemType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemType we want to update
     *   }
     * })
     */
    upsert<T extends ItemTypeUpsertArgs>(args: SelectSubset<T, ItemTypeUpsertArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ItemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeCountArgs} args - Arguments to filter ItemTypes to count.
     * @example
     * // Count the number of ItemTypes
     * const count = await prisma.itemType.count({
     *   where: {
     *     // ... the filter for the ItemTypes we want to count
     *   }
     * })
    **/
    count<T extends ItemTypeCountArgs>(
      args?: Subset<T, ItemTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemTypeAggregateArgs>(args: Subset<T, ItemTypeAggregateArgs>): Prisma.PrismaPromise<GetItemTypeAggregateType<T>>

    /**
     * Group by ItemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemTypeGroupByArgs['orderBy'] }
        : { orderBy?: ItemTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemType model
   */
  readonly fields: ItemTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contentItems<T extends ItemType$contentItemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemType$contentItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemType model
   */ 
  interface ItemTypeFieldRefs {
    readonly id: FieldRef<"ItemType", 'String'>
    readonly name: FieldRef<"ItemType", 'String'>
    readonly description: FieldRef<"ItemType", 'String'>
    readonly isActive: FieldRef<"ItemType", 'Boolean'>
    readonly isDeleted: FieldRef<"ItemType", 'Boolean'>
    readonly createdAt: FieldRef<"ItemType", 'DateTime'>
    readonly updatedAt: FieldRef<"ItemType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemType findUnique
   */
  export type ItemTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where: ItemTypeWhereUniqueInput
  }

  /**
   * ItemType findUniqueOrThrow
   */
  export type ItemTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where: ItemTypeWhereUniqueInput
  }

  /**
   * ItemType findFirst
   */
  export type ItemTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTypes.
     */
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }

  /**
   * ItemType findFirstOrThrow
   */
  export type ItemTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemType to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemTypes.
     */
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }

  /**
   * ItemType findMany
   */
  export type ItemTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which ItemTypes to fetch.
     */
    where?: ItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemTypes to fetch.
     */
    orderBy?: ItemTypeOrderByWithRelationInput | ItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemTypes.
     */
    cursor?: ItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemTypes.
     */
    skip?: number
    distinct?: ItemTypeScalarFieldEnum | ItemTypeScalarFieldEnum[]
  }

  /**
   * ItemType create
   */
  export type ItemTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemType.
     */
    data: XOR<ItemTypeCreateInput, ItemTypeUncheckedCreateInput>
  }

  /**
   * ItemType createMany
   */
  export type ItemTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemTypes.
     */
    data: ItemTypeCreateManyInput | ItemTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemType createManyAndReturn
   */
  export type ItemTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ItemTypes.
     */
    data: ItemTypeCreateManyInput | ItemTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemType update
   */
  export type ItemTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemType.
     */
    data: XOR<ItemTypeUpdateInput, ItemTypeUncheckedUpdateInput>
    /**
     * Choose, which ItemType to update.
     */
    where: ItemTypeWhereUniqueInput
  }

  /**
   * ItemType updateMany
   */
  export type ItemTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemTypes.
     */
    data: XOR<ItemTypeUpdateManyMutationInput, ItemTypeUncheckedUpdateManyInput>
    /**
     * Filter which ItemTypes to update
     */
    where?: ItemTypeWhereInput
  }

  /**
   * ItemType upsert
   */
  export type ItemTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemType to update in case it exists.
     */
    where: ItemTypeWhereUniqueInput
    /**
     * In case the ItemType found by the `where` argument doesn't exist, create a new ItemType with this data.
     */
    create: XOR<ItemTypeCreateInput, ItemTypeUncheckedCreateInput>
    /**
     * In case the ItemType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemTypeUpdateInput, ItemTypeUncheckedUpdateInput>
  }

  /**
   * ItemType delete
   */
  export type ItemTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
    /**
     * Filter which ItemType to delete.
     */
    where: ItemTypeWhereUniqueInput
  }

  /**
   * ItemType deleteMany
   */
  export type ItemTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemTypes to delete
     */
    where?: ItemTypeWhereInput
  }

  /**
   * ItemType.contentItems
   */
  export type ItemType$contentItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    where?: ContentItemWhereInput
    orderBy?: ContentItemOrderByWithRelationInput | ContentItemOrderByWithRelationInput[]
    cursor?: ContentItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentItemScalarFieldEnum | ContentItemScalarFieldEnum[]
  }

  /**
   * ItemType without action
   */
  export type ItemTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemType
     */
    select?: ItemTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemTypeInclude<ExtArgs> | null
  }


  /**
   * Model ContentItem
   */

  export type AggregateContentItem = {
    _count: ContentItemCountAggregateOutputType | null
    _avg: ContentItemAvgAggregateOutputType | null
    _sum: ContentItemSumAggregateOutputType | null
    _min: ContentItemMinAggregateOutputType | null
    _max: ContentItemMaxAggregateOutputType | null
  }

  export type ContentItemAvgAggregateOutputType = {
    order: number | null
  }

  export type ContentItemSumAggregateOutputType = {
    order: number | null
  }

  export type ContentItemMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    playlistId: string | null
    itemTypeId: string | null
    order: number | null
    isActive: boolean | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentItemMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    playlistId: string | null
    itemTypeId: string | null
    order: number | null
    isActive: boolean | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentItemCountAggregateOutputType = {
    id: number
    title: number
    description: number
    content: number
    playlistId: number
    itemTypeId: number
    order: number
    isActive: number
    isDeleted: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContentItemAvgAggregateInputType = {
    order?: true
  }

  export type ContentItemSumAggregateInputType = {
    order?: true
  }

  export type ContentItemMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    playlistId?: true
    itemTypeId?: true
    order?: true
    isActive?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentItemMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    playlistId?: true
    itemTypeId?: true
    order?: true
    isActive?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentItemCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    playlistId?: true
    itemTypeId?: true
    order?: true
    isActive?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContentItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentItem to aggregate.
     */
    where?: ContentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentItems to fetch.
     */
    orderBy?: ContentItemOrderByWithRelationInput | ContentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentItems
    **/
    _count?: true | ContentItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentItemMaxAggregateInputType
  }

  export type GetContentItemAggregateType<T extends ContentItemAggregateArgs> = {
        [P in keyof T & keyof AggregateContentItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentItem[P]>
      : GetScalarType<T[P], AggregateContentItem[P]>
  }




  export type ContentItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentItemWhereInput
    orderBy?: ContentItemOrderByWithAggregationInput | ContentItemOrderByWithAggregationInput[]
    by: ContentItemScalarFieldEnum[] | ContentItemScalarFieldEnum
    having?: ContentItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentItemCountAggregateInputType | true
    _avg?: ContentItemAvgAggregateInputType
    _sum?: ContentItemSumAggregateInputType
    _min?: ContentItemMinAggregateInputType
    _max?: ContentItemMaxAggregateInputType
  }

  export type ContentItemGroupByOutputType = {
    id: string
    title: string
    description: string | null
    content: string
    playlistId: string
    itemTypeId: string
    order: number
    isActive: boolean
    isDeleted: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ContentItemCountAggregateOutputType | null
    _avg: ContentItemAvgAggregateOutputType | null
    _sum: ContentItemSumAggregateOutputType | null
    _min: ContentItemMinAggregateOutputType | null
    _max: ContentItemMaxAggregateOutputType | null
  }

  type GetContentItemGroupByPayload<T extends ContentItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentItemGroupByOutputType[P]>
            : GetScalarType<T[P], ContentItemGroupByOutputType[P]>
        }
      >
    >


  export type ContentItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    playlistId?: boolean
    itemTypeId?: boolean
    order?: boolean
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentItem"]>

  export type ContentItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    playlistId?: boolean
    itemTypeId?: boolean
    order?: boolean
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentItem"]>

  export type ContentItemSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    playlistId?: boolean
    itemTypeId?: boolean
    order?: boolean
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContentItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
  }
  export type ContentItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemType?: boolean | ItemTypeDefaultArgs<ExtArgs>
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
  }

  export type $ContentItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentItem"
    objects: {
      itemType: Prisma.$ItemTypePayload<ExtArgs>
      playlist: Prisma.$PlaylistPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      content: string
      playlistId: string
      itemTypeId: string
      order: number
      isActive: boolean
      isDeleted: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contentItem"]>
    composites: {}
  }

  type ContentItemGetPayload<S extends boolean | null | undefined | ContentItemDefaultArgs> = $Result.GetResult<Prisma.$ContentItemPayload, S>

  type ContentItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContentItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContentItemCountAggregateInputType | true
    }

  export interface ContentItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentItem'], meta: { name: 'ContentItem' } }
    /**
     * Find zero or one ContentItem that matches the filter.
     * @param {ContentItemFindUniqueArgs} args - Arguments to find a ContentItem
     * @example
     * // Get one ContentItem
     * const contentItem = await prisma.contentItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentItemFindUniqueArgs>(args: SelectSubset<T, ContentItemFindUniqueArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContentItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContentItemFindUniqueOrThrowArgs} args - Arguments to find a ContentItem
     * @example
     * // Get one ContentItem
     * const contentItem = await prisma.contentItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContentItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemFindFirstArgs} args - Arguments to find a ContentItem
     * @example
     * // Get one ContentItem
     * const contentItem = await prisma.contentItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentItemFindFirstArgs>(args?: SelectSubset<T, ContentItemFindFirstArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContentItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemFindFirstOrThrowArgs} args - Arguments to find a ContentItem
     * @example
     * // Get one ContentItem
     * const contentItem = await prisma.contentItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContentItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentItems
     * const contentItems = await prisma.contentItem.findMany()
     * 
     * // Get first 10 ContentItems
     * const contentItems = await prisma.contentItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentItemWithIdOnly = await prisma.contentItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentItemFindManyArgs>(args?: SelectSubset<T, ContentItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContentItem.
     * @param {ContentItemCreateArgs} args - Arguments to create a ContentItem.
     * @example
     * // Create one ContentItem
     * const ContentItem = await prisma.contentItem.create({
     *   data: {
     *     // ... data to create a ContentItem
     *   }
     * })
     * 
     */
    create<T extends ContentItemCreateArgs>(args: SelectSubset<T, ContentItemCreateArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContentItems.
     * @param {ContentItemCreateManyArgs} args - Arguments to create many ContentItems.
     * @example
     * // Create many ContentItems
     * const contentItem = await prisma.contentItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentItemCreateManyArgs>(args?: SelectSubset<T, ContentItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentItems and returns the data saved in the database.
     * @param {ContentItemCreateManyAndReturnArgs} args - Arguments to create many ContentItems.
     * @example
     * // Create many ContentItems
     * const contentItem = await prisma.contentItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentItems and only return the `id`
     * const contentItemWithIdOnly = await prisma.contentItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContentItem.
     * @param {ContentItemDeleteArgs} args - Arguments to delete one ContentItem.
     * @example
     * // Delete one ContentItem
     * const ContentItem = await prisma.contentItem.delete({
     *   where: {
     *     // ... filter to delete one ContentItem
     *   }
     * })
     * 
     */
    delete<T extends ContentItemDeleteArgs>(args: SelectSubset<T, ContentItemDeleteArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContentItem.
     * @param {ContentItemUpdateArgs} args - Arguments to update one ContentItem.
     * @example
     * // Update one ContentItem
     * const contentItem = await prisma.contentItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentItemUpdateArgs>(args: SelectSubset<T, ContentItemUpdateArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContentItems.
     * @param {ContentItemDeleteManyArgs} args - Arguments to filter ContentItems to delete.
     * @example
     * // Delete a few ContentItems
     * const { count } = await prisma.contentItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentItemDeleteManyArgs>(args?: SelectSubset<T, ContentItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentItems
     * const contentItem = await prisma.contentItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentItemUpdateManyArgs>(args: SelectSubset<T, ContentItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContentItem.
     * @param {ContentItemUpsertArgs} args - Arguments to update or create a ContentItem.
     * @example
     * // Update or create a ContentItem
     * const contentItem = await prisma.contentItem.upsert({
     *   create: {
     *     // ... data to create a ContentItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentItem we want to update
     *   }
     * })
     */
    upsert<T extends ContentItemUpsertArgs>(args: SelectSubset<T, ContentItemUpsertArgs<ExtArgs>>): Prisma__ContentItemClient<$Result.GetResult<Prisma.$ContentItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemCountArgs} args - Arguments to filter ContentItems to count.
     * @example
     * // Count the number of ContentItems
     * const count = await prisma.contentItem.count({
     *   where: {
     *     // ... the filter for the ContentItems we want to count
     *   }
     * })
    **/
    count<T extends ContentItemCountArgs>(
      args?: Subset<T, ContentItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentItemAggregateArgs>(args: Subset<T, ContentItemAggregateArgs>): Prisma.PrismaPromise<GetContentItemAggregateType<T>>

    /**
     * Group by ContentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentItemGroupByArgs['orderBy'] }
        : { orderBy?: ContentItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentItem model
   */
  readonly fields: ContentItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itemType<T extends ItemTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemTypeDefaultArgs<ExtArgs>>): Prisma__ItemTypeClient<$Result.GetResult<Prisma.$ItemTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    playlist<T extends PlaylistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaylistDefaultArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentItem model
   */ 
  interface ContentItemFieldRefs {
    readonly id: FieldRef<"ContentItem", 'String'>
    readonly title: FieldRef<"ContentItem", 'String'>
    readonly description: FieldRef<"ContentItem", 'String'>
    readonly content: FieldRef<"ContentItem", 'String'>
    readonly playlistId: FieldRef<"ContentItem", 'String'>
    readonly itemTypeId: FieldRef<"ContentItem", 'String'>
    readonly order: FieldRef<"ContentItem", 'Int'>
    readonly isActive: FieldRef<"ContentItem", 'Boolean'>
    readonly isDeleted: FieldRef<"ContentItem", 'Boolean'>
    readonly deletedAt: FieldRef<"ContentItem", 'DateTime'>
    readonly createdAt: FieldRef<"ContentItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ContentItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentItem findUnique
   */
  export type ContentItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * Filter, which ContentItem to fetch.
     */
    where: ContentItemWhereUniqueInput
  }

  /**
   * ContentItem findUniqueOrThrow
   */
  export type ContentItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * Filter, which ContentItem to fetch.
     */
    where: ContentItemWhereUniqueInput
  }

  /**
   * ContentItem findFirst
   */
  export type ContentItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * Filter, which ContentItem to fetch.
     */
    where?: ContentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentItems to fetch.
     */
    orderBy?: ContentItemOrderByWithRelationInput | ContentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentItems.
     */
    cursor?: ContentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentItems.
     */
    distinct?: ContentItemScalarFieldEnum | ContentItemScalarFieldEnum[]
  }

  /**
   * ContentItem findFirstOrThrow
   */
  export type ContentItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * Filter, which ContentItem to fetch.
     */
    where?: ContentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentItems to fetch.
     */
    orderBy?: ContentItemOrderByWithRelationInput | ContentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentItems.
     */
    cursor?: ContentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentItems.
     */
    distinct?: ContentItemScalarFieldEnum | ContentItemScalarFieldEnum[]
  }

  /**
   * ContentItem findMany
   */
  export type ContentItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * Filter, which ContentItems to fetch.
     */
    where?: ContentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentItems to fetch.
     */
    orderBy?: ContentItemOrderByWithRelationInput | ContentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentItems.
     */
    cursor?: ContentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentItems.
     */
    skip?: number
    distinct?: ContentItemScalarFieldEnum | ContentItemScalarFieldEnum[]
  }

  /**
   * ContentItem create
   */
  export type ContentItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentItem.
     */
    data: XOR<ContentItemCreateInput, ContentItemUncheckedCreateInput>
  }

  /**
   * ContentItem createMany
   */
  export type ContentItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentItems.
     */
    data: ContentItemCreateManyInput | ContentItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentItem createManyAndReturn
   */
  export type ContentItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContentItems.
     */
    data: ContentItemCreateManyInput | ContentItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentItem update
   */
  export type ContentItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentItem.
     */
    data: XOR<ContentItemUpdateInput, ContentItemUncheckedUpdateInput>
    /**
     * Choose, which ContentItem to update.
     */
    where: ContentItemWhereUniqueInput
  }

  /**
   * ContentItem updateMany
   */
  export type ContentItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentItems.
     */
    data: XOR<ContentItemUpdateManyMutationInput, ContentItemUncheckedUpdateManyInput>
    /**
     * Filter which ContentItems to update
     */
    where?: ContentItemWhereInput
  }

  /**
   * ContentItem upsert
   */
  export type ContentItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentItem to update in case it exists.
     */
    where: ContentItemWhereUniqueInput
    /**
     * In case the ContentItem found by the `where` argument doesn't exist, create a new ContentItem with this data.
     */
    create: XOR<ContentItemCreateInput, ContentItemUncheckedCreateInput>
    /**
     * In case the ContentItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentItemUpdateInput, ContentItemUncheckedUpdateInput>
  }

  /**
   * ContentItem delete
   */
  export type ContentItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
    /**
     * Filter which ContentItem to delete.
     */
    where: ContentItemWhereUniqueInput
  }

  /**
   * ContentItem deleteMany
   */
  export type ContentItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentItems to delete
     */
    where?: ContentItemWhereInput
  }

  /**
   * ContentItem without action
   */
  export type ContentItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentItem
     */
    select?: ContentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentItemInclude<ExtArgs> | null
  }


  /**
   * Model Challenge
   */

  export type AggregateChallenge = {
    _count: ChallengeCountAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  export type ChallengeMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    config: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChallengeMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    config: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChallengeCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    status: number
    startDate: number
    endDate: number
    config: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChallengeMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    startDate?: true
    endDate?: true
    config?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChallengeMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    startDate?: true
    endDate?: true
    config?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChallengeCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    startDate?: true
    endDate?: true
    config?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenge to aggregate.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Challenges
    **/
    _count?: true | ChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeMaxAggregateInputType
  }

  export type GetChallengeAggregateType<T extends ChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallenge[P]>
      : GetScalarType<T[P], AggregateChallenge[P]>
  }




  export type ChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithAggregationInput | ChallengeOrderByWithAggregationInput[]
    by: ChallengeScalarFieldEnum[] | ChallengeScalarFieldEnum
    having?: ChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeCountAggregateInputType | true
    _min?: ChallengeMinAggregateInputType
    _max?: ChallengeMaxAggregateInputType
  }

  export type ChallengeGroupByOutputType = {
    id: string
    title: string
    description: string | null
    type: string
    status: string
    startDate: Date
    endDate: Date
    config: string
    createdAt: Date
    updatedAt: Date
    _count: ChallengeCountAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  type GetChallengeGroupByPayload<T extends ChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rewards?: boolean | Challenge$rewardsArgs<ExtArgs>
    userChallenges?: boolean | Challenge$userChallengesArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["challenge"]>

  export type ChallengeSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rewards?: boolean | Challenge$rewardsArgs<ExtArgs>
    userChallenges?: boolean | Challenge$userChallengesArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Challenge"
    objects: {
      rewards: Prisma.$ChallengeRewardPayload<ExtArgs>[]
      userChallenges: Prisma.$UserChallengePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      type: string
      status: string
      startDate: Date
      endDate: Date
      config: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["challenge"]>
    composites: {}
  }

  type ChallengeGetPayload<S extends boolean | null | undefined | ChallengeDefaultArgs> = $Result.GetResult<Prisma.$ChallengePayload, S>

  type ChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChallengeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChallengeCountAggregateInputType | true
    }

  export interface ChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Challenge'], meta: { name: 'Challenge' } }
    /**
     * Find zero or one Challenge that matches the filter.
     * @param {ChallengeFindUniqueArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeFindUniqueArgs>(args: SelectSubset<T, ChallengeFindUniqueArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Challenge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChallengeFindUniqueOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Challenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeFindFirstArgs>(args?: SelectSubset<T, ChallengeFindFirstArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Challenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Challenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Challenges
     * const challenges = await prisma.challenge.findMany()
     * 
     * // Get first 10 Challenges
     * const challenges = await prisma.challenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeWithIdOnly = await prisma.challenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeFindManyArgs>(args?: SelectSubset<T, ChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Challenge.
     * @param {ChallengeCreateArgs} args - Arguments to create a Challenge.
     * @example
     * // Create one Challenge
     * const Challenge = await prisma.challenge.create({
     *   data: {
     *     // ... data to create a Challenge
     *   }
     * })
     * 
     */
    create<T extends ChallengeCreateArgs>(args: SelectSubset<T, ChallengeCreateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Challenges.
     * @param {ChallengeCreateManyArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeCreateManyArgs>(args?: SelectSubset<T, ChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Challenges and returns the data saved in the database.
     * @param {ChallengeCreateManyAndReturnArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Challenges and only return the `id`
     * const challengeWithIdOnly = await prisma.challenge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Challenge.
     * @param {ChallengeDeleteArgs} args - Arguments to delete one Challenge.
     * @example
     * // Delete one Challenge
     * const Challenge = await prisma.challenge.delete({
     *   where: {
     *     // ... filter to delete one Challenge
     *   }
     * })
     * 
     */
    delete<T extends ChallengeDeleteArgs>(args: SelectSubset<T, ChallengeDeleteArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Challenge.
     * @param {ChallengeUpdateArgs} args - Arguments to update one Challenge.
     * @example
     * // Update one Challenge
     * const challenge = await prisma.challenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeUpdateArgs>(args: SelectSubset<T, ChallengeUpdateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Challenges.
     * @param {ChallengeDeleteManyArgs} args - Arguments to filter Challenges to delete.
     * @example
     * // Delete a few Challenges
     * const { count } = await prisma.challenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeDeleteManyArgs>(args?: SelectSubset<T, ChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Challenges
     * const challenge = await prisma.challenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeUpdateManyArgs>(args: SelectSubset<T, ChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Challenge.
     * @param {ChallengeUpsertArgs} args - Arguments to update or create a Challenge.
     * @example
     * // Update or create a Challenge
     * const challenge = await prisma.challenge.upsert({
     *   create: {
     *     // ... data to create a Challenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Challenge we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeUpsertArgs>(args: SelectSubset<T, ChallengeUpsertArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeCountArgs} args - Arguments to filter Challenges to count.
     * @example
     * // Count the number of Challenges
     * const count = await prisma.challenge.count({
     *   where: {
     *     // ... the filter for the Challenges we want to count
     *   }
     * })
    **/
    count<T extends ChallengeCountArgs>(
      args?: Subset<T, ChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeAggregateArgs>(args: Subset<T, ChallengeAggregateArgs>): Prisma.PrismaPromise<GetChallengeAggregateType<T>>

    /**
     * Group by Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Challenge model
   */
  readonly fields: ChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Challenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rewards<T extends Challenge$rewardsArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$rewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeRewardPayload<ExtArgs>, T, "findMany"> | Null>
    userChallenges<T extends Challenge$userChallengesArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$userChallengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Challenge model
   */ 
  interface ChallengeFieldRefs {
    readonly id: FieldRef<"Challenge", 'String'>
    readonly title: FieldRef<"Challenge", 'String'>
    readonly description: FieldRef<"Challenge", 'String'>
    readonly type: FieldRef<"Challenge", 'String'>
    readonly status: FieldRef<"Challenge", 'String'>
    readonly startDate: FieldRef<"Challenge", 'DateTime'>
    readonly endDate: FieldRef<"Challenge", 'DateTime'>
    readonly config: FieldRef<"Challenge", 'String'>
    readonly createdAt: FieldRef<"Challenge", 'DateTime'>
    readonly updatedAt: FieldRef<"Challenge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Challenge findUnique
   */
  export type ChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findUniqueOrThrow
   */
  export type ChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findFirst
   */
  export type ChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findFirstOrThrow
   */
  export type ChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findMany
   */
  export type ChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenges to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge create
   */
  export type ChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a Challenge.
     */
    data: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
  }

  /**
   * Challenge createMany
   */
  export type ChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Challenge createManyAndReturn
   */
  export type ChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Challenge update
   */
  export type ChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a Challenge.
     */
    data: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
    /**
     * Choose, which Challenge to update.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge updateMany
   */
  export type ChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Challenges.
     */
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyInput>
    /**
     * Filter which Challenges to update
     */
    where?: ChallengeWhereInput
  }

  /**
   * Challenge upsert
   */
  export type ChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the Challenge to update in case it exists.
     */
    where: ChallengeWhereUniqueInput
    /**
     * In case the Challenge found by the `where` argument doesn't exist, create a new Challenge with this data.
     */
    create: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
    /**
     * In case the Challenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
  }

  /**
   * Challenge delete
   */
  export type ChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter which Challenge to delete.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge deleteMany
   */
  export type ChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenges to delete
     */
    where?: ChallengeWhereInput
  }

  /**
   * Challenge.rewards
   */
  export type Challenge$rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReward
     */
    select?: ChallengeRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRewardInclude<ExtArgs> | null
    where?: ChallengeRewardWhereInput
    orderBy?: ChallengeRewardOrderByWithRelationInput | ChallengeRewardOrderByWithRelationInput[]
    cursor?: ChallengeRewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeRewardScalarFieldEnum | ChallengeRewardScalarFieldEnum[]
  }

  /**
   * Challenge.userChallenges
   */
  export type Challenge$userChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    where?: UserChallengeWhereInput
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    cursor?: UserChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserChallengeScalarFieldEnum | UserChallengeScalarFieldEnum[]
  }

  /**
   * Challenge without action
   */
  export type ChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeReward
   */

  export type AggregateChallengeReward = {
    _count: ChallengeRewardCountAggregateOutputType | null
    _avg: ChallengeRewardAvgAggregateOutputType | null
    _sum: ChallengeRewardSumAggregateOutputType | null
    _min: ChallengeRewardMinAggregateOutputType | null
    _max: ChallengeRewardMaxAggregateOutputType | null
  }

  export type ChallengeRewardAvgAggregateOutputType = {
    amount: number | null
  }

  export type ChallengeRewardSumAggregateOutputType = {
    amount: number | null
  }

  export type ChallengeRewardMinAggregateOutputType = {
    id: string | null
    challengeId: string | null
    type: string | null
    amount: number | null
    description: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type ChallengeRewardMaxAggregateOutputType = {
    id: string | null
    challengeId: string | null
    type: string | null
    amount: number | null
    description: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type ChallengeRewardCountAggregateOutputType = {
    id: number
    challengeId: number
    type: number
    amount: number
    description: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ChallengeRewardAvgAggregateInputType = {
    amount?: true
  }

  export type ChallengeRewardSumAggregateInputType = {
    amount?: true
  }

  export type ChallengeRewardMinAggregateInputType = {
    id?: true
    challengeId?: true
    type?: true
    amount?: true
    description?: true
    metadata?: true
    createdAt?: true
  }

  export type ChallengeRewardMaxAggregateInputType = {
    id?: true
    challengeId?: true
    type?: true
    amount?: true
    description?: true
    metadata?: true
    createdAt?: true
  }

  export type ChallengeRewardCountAggregateInputType = {
    id?: true
    challengeId?: true
    type?: true
    amount?: true
    description?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ChallengeRewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeReward to aggregate.
     */
    where?: ChallengeRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeRewards to fetch.
     */
    orderBy?: ChallengeRewardOrderByWithRelationInput | ChallengeRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeRewards
    **/
    _count?: true | ChallengeRewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeRewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeRewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeRewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeRewardMaxAggregateInputType
  }

  export type GetChallengeRewardAggregateType<T extends ChallengeRewardAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeReward[P]>
      : GetScalarType<T[P], AggregateChallengeReward[P]>
  }




  export type ChallengeRewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeRewardWhereInput
    orderBy?: ChallengeRewardOrderByWithAggregationInput | ChallengeRewardOrderByWithAggregationInput[]
    by: ChallengeRewardScalarFieldEnum[] | ChallengeRewardScalarFieldEnum
    having?: ChallengeRewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeRewardCountAggregateInputType | true
    _avg?: ChallengeRewardAvgAggregateInputType
    _sum?: ChallengeRewardSumAggregateInputType
    _min?: ChallengeRewardMinAggregateInputType
    _max?: ChallengeRewardMaxAggregateInputType
  }

  export type ChallengeRewardGroupByOutputType = {
    id: string
    challengeId: string
    type: string
    amount: number | null
    description: string | null
    metadata: string | null
    createdAt: Date
    _count: ChallengeRewardCountAggregateOutputType | null
    _avg: ChallengeRewardAvgAggregateOutputType | null
    _sum: ChallengeRewardSumAggregateOutputType | null
    _min: ChallengeRewardMinAggregateOutputType | null
    _max: ChallengeRewardMaxAggregateOutputType | null
  }

  type GetChallengeRewardGroupByPayload<T extends ChallengeRewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeRewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeRewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeRewardGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeRewardGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeRewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeReward"]>

  export type ChallengeRewardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeReward"]>

  export type ChallengeRewardSelectScalar = {
    id?: boolean
    challengeId?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ChallengeRewardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }
  export type ChallengeRewardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $ChallengeRewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeReward"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challengeId: string
      type: string
      amount: number | null
      description: string | null
      metadata: string | null
      createdAt: Date
    }, ExtArgs["result"]["challengeReward"]>
    composites: {}
  }

  type ChallengeRewardGetPayload<S extends boolean | null | undefined | ChallengeRewardDefaultArgs> = $Result.GetResult<Prisma.$ChallengeRewardPayload, S>

  type ChallengeRewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChallengeRewardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChallengeRewardCountAggregateInputType | true
    }

  export interface ChallengeRewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeReward'], meta: { name: 'ChallengeReward' } }
    /**
     * Find zero or one ChallengeReward that matches the filter.
     * @param {ChallengeRewardFindUniqueArgs} args - Arguments to find a ChallengeReward
     * @example
     * // Get one ChallengeReward
     * const challengeReward = await prisma.challengeReward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeRewardFindUniqueArgs>(args: SelectSubset<T, ChallengeRewardFindUniqueArgs<ExtArgs>>): Prisma__ChallengeRewardClient<$Result.GetResult<Prisma.$ChallengeRewardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChallengeReward that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChallengeRewardFindUniqueOrThrowArgs} args - Arguments to find a ChallengeReward
     * @example
     * // Get one ChallengeReward
     * const challengeReward = await prisma.challengeReward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeRewardFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeRewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeRewardClient<$Result.GetResult<Prisma.$ChallengeRewardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChallengeReward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRewardFindFirstArgs} args - Arguments to find a ChallengeReward
     * @example
     * // Get one ChallengeReward
     * const challengeReward = await prisma.challengeReward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeRewardFindFirstArgs>(args?: SelectSubset<T, ChallengeRewardFindFirstArgs<ExtArgs>>): Prisma__ChallengeRewardClient<$Result.GetResult<Prisma.$ChallengeRewardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChallengeReward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRewardFindFirstOrThrowArgs} args - Arguments to find a ChallengeReward
     * @example
     * // Get one ChallengeReward
     * const challengeReward = await prisma.challengeReward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeRewardFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeRewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeRewardClient<$Result.GetResult<Prisma.$ChallengeRewardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChallengeRewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeRewards
     * const challengeRewards = await prisma.challengeReward.findMany()
     * 
     * // Get first 10 ChallengeRewards
     * const challengeRewards = await prisma.challengeReward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeRewardWithIdOnly = await prisma.challengeReward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeRewardFindManyArgs>(args?: SelectSubset<T, ChallengeRewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeRewardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChallengeReward.
     * @param {ChallengeRewardCreateArgs} args - Arguments to create a ChallengeReward.
     * @example
     * // Create one ChallengeReward
     * const ChallengeReward = await prisma.challengeReward.create({
     *   data: {
     *     // ... data to create a ChallengeReward
     *   }
     * })
     * 
     */
    create<T extends ChallengeRewardCreateArgs>(args: SelectSubset<T, ChallengeRewardCreateArgs<ExtArgs>>): Prisma__ChallengeRewardClient<$Result.GetResult<Prisma.$ChallengeRewardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChallengeRewards.
     * @param {ChallengeRewardCreateManyArgs} args - Arguments to create many ChallengeRewards.
     * @example
     * // Create many ChallengeRewards
     * const challengeReward = await prisma.challengeReward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeRewardCreateManyArgs>(args?: SelectSubset<T, ChallengeRewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeRewards and returns the data saved in the database.
     * @param {ChallengeRewardCreateManyAndReturnArgs} args - Arguments to create many ChallengeRewards.
     * @example
     * // Create many ChallengeRewards
     * const challengeReward = await prisma.challengeReward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeRewards and only return the `id`
     * const challengeRewardWithIdOnly = await prisma.challengeReward.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeRewardCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeRewardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeRewardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChallengeReward.
     * @param {ChallengeRewardDeleteArgs} args - Arguments to delete one ChallengeReward.
     * @example
     * // Delete one ChallengeReward
     * const ChallengeReward = await prisma.challengeReward.delete({
     *   where: {
     *     // ... filter to delete one ChallengeReward
     *   }
     * })
     * 
     */
    delete<T extends ChallengeRewardDeleteArgs>(args: SelectSubset<T, ChallengeRewardDeleteArgs<ExtArgs>>): Prisma__ChallengeRewardClient<$Result.GetResult<Prisma.$ChallengeRewardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChallengeReward.
     * @param {ChallengeRewardUpdateArgs} args - Arguments to update one ChallengeReward.
     * @example
     * // Update one ChallengeReward
     * const challengeReward = await prisma.challengeReward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeRewardUpdateArgs>(args: SelectSubset<T, ChallengeRewardUpdateArgs<ExtArgs>>): Prisma__ChallengeRewardClient<$Result.GetResult<Prisma.$ChallengeRewardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChallengeRewards.
     * @param {ChallengeRewardDeleteManyArgs} args - Arguments to filter ChallengeRewards to delete.
     * @example
     * // Delete a few ChallengeRewards
     * const { count } = await prisma.challengeReward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeRewardDeleteManyArgs>(args?: SelectSubset<T, ChallengeRewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeRewards
     * const challengeReward = await prisma.challengeReward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeRewardUpdateManyArgs>(args: SelectSubset<T, ChallengeRewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChallengeReward.
     * @param {ChallengeRewardUpsertArgs} args - Arguments to update or create a ChallengeReward.
     * @example
     * // Update or create a ChallengeReward
     * const challengeReward = await prisma.challengeReward.upsert({
     *   create: {
     *     // ... data to create a ChallengeReward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeReward we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeRewardUpsertArgs>(args: SelectSubset<T, ChallengeRewardUpsertArgs<ExtArgs>>): Prisma__ChallengeRewardClient<$Result.GetResult<Prisma.$ChallengeRewardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChallengeRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRewardCountArgs} args - Arguments to filter ChallengeRewards to count.
     * @example
     * // Count the number of ChallengeRewards
     * const count = await prisma.challengeReward.count({
     *   where: {
     *     // ... the filter for the ChallengeRewards we want to count
     *   }
     * })
    **/
    count<T extends ChallengeRewardCountArgs>(
      args?: Subset<T, ChallengeRewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeRewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeRewardAggregateArgs>(args: Subset<T, ChallengeRewardAggregateArgs>): Prisma.PrismaPromise<GetChallengeRewardAggregateType<T>>

    /**
     * Group by ChallengeReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeRewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeRewardGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeRewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeRewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeReward model
   */
  readonly fields: ChallengeRewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeReward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeRewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeReward model
   */ 
  interface ChallengeRewardFieldRefs {
    readonly id: FieldRef<"ChallengeReward", 'String'>
    readonly challengeId: FieldRef<"ChallengeReward", 'String'>
    readonly type: FieldRef<"ChallengeReward", 'String'>
    readonly amount: FieldRef<"ChallengeReward", 'Float'>
    readonly description: FieldRef<"ChallengeReward", 'String'>
    readonly metadata: FieldRef<"ChallengeReward", 'String'>
    readonly createdAt: FieldRef<"ChallengeReward", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeReward findUnique
   */
  export type ChallengeRewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReward
     */
    select?: ChallengeRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRewardInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeReward to fetch.
     */
    where: ChallengeRewardWhereUniqueInput
  }

  /**
   * ChallengeReward findUniqueOrThrow
   */
  export type ChallengeRewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReward
     */
    select?: ChallengeRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRewardInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeReward to fetch.
     */
    where: ChallengeRewardWhereUniqueInput
  }

  /**
   * ChallengeReward findFirst
   */
  export type ChallengeRewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReward
     */
    select?: ChallengeRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRewardInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeReward to fetch.
     */
    where?: ChallengeRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeRewards to fetch.
     */
    orderBy?: ChallengeRewardOrderByWithRelationInput | ChallengeRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeRewards.
     */
    cursor?: ChallengeRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeRewards.
     */
    distinct?: ChallengeRewardScalarFieldEnum | ChallengeRewardScalarFieldEnum[]
  }

  /**
   * ChallengeReward findFirstOrThrow
   */
  export type ChallengeRewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReward
     */
    select?: ChallengeRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRewardInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeReward to fetch.
     */
    where?: ChallengeRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeRewards to fetch.
     */
    orderBy?: ChallengeRewardOrderByWithRelationInput | ChallengeRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeRewards.
     */
    cursor?: ChallengeRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeRewards.
     */
    distinct?: ChallengeRewardScalarFieldEnum | ChallengeRewardScalarFieldEnum[]
  }

  /**
   * ChallengeReward findMany
   */
  export type ChallengeRewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReward
     */
    select?: ChallengeRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRewardInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeRewards to fetch.
     */
    where?: ChallengeRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeRewards to fetch.
     */
    orderBy?: ChallengeRewardOrderByWithRelationInput | ChallengeRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeRewards.
     */
    cursor?: ChallengeRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeRewards.
     */
    skip?: number
    distinct?: ChallengeRewardScalarFieldEnum | ChallengeRewardScalarFieldEnum[]
  }

  /**
   * ChallengeReward create
   */
  export type ChallengeRewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReward
     */
    select?: ChallengeRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRewardInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeReward.
     */
    data: XOR<ChallengeRewardCreateInput, ChallengeRewardUncheckedCreateInput>
  }

  /**
   * ChallengeReward createMany
   */
  export type ChallengeRewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeRewards.
     */
    data: ChallengeRewardCreateManyInput | ChallengeRewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeReward createManyAndReturn
   */
  export type ChallengeRewardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReward
     */
    select?: ChallengeRewardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChallengeRewards.
     */
    data: ChallengeRewardCreateManyInput | ChallengeRewardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRewardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChallengeReward update
   */
  export type ChallengeRewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReward
     */
    select?: ChallengeRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRewardInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeReward.
     */
    data: XOR<ChallengeRewardUpdateInput, ChallengeRewardUncheckedUpdateInput>
    /**
     * Choose, which ChallengeReward to update.
     */
    where: ChallengeRewardWhereUniqueInput
  }

  /**
   * ChallengeReward updateMany
   */
  export type ChallengeRewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeRewards.
     */
    data: XOR<ChallengeRewardUpdateManyMutationInput, ChallengeRewardUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeRewards to update
     */
    where?: ChallengeRewardWhereInput
  }

  /**
   * ChallengeReward upsert
   */
  export type ChallengeRewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReward
     */
    select?: ChallengeRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRewardInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeReward to update in case it exists.
     */
    where: ChallengeRewardWhereUniqueInput
    /**
     * In case the ChallengeReward found by the `where` argument doesn't exist, create a new ChallengeReward with this data.
     */
    create: XOR<ChallengeRewardCreateInput, ChallengeRewardUncheckedCreateInput>
    /**
     * In case the ChallengeReward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeRewardUpdateInput, ChallengeRewardUncheckedUpdateInput>
  }

  /**
   * ChallengeReward delete
   */
  export type ChallengeRewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReward
     */
    select?: ChallengeRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRewardInclude<ExtArgs> | null
    /**
     * Filter which ChallengeReward to delete.
     */
    where: ChallengeRewardWhereUniqueInput
  }

  /**
   * ChallengeReward deleteMany
   */
  export type ChallengeRewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeRewards to delete
     */
    where?: ChallengeRewardWhereInput
  }

  /**
   * ChallengeReward without action
   */
  export type ChallengeRewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeReward
     */
    select?: ChallengeRewardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRewardInclude<ExtArgs> | null
  }


  /**
   * Model UserChallenge
   */

  export type AggregateUserChallenge = {
    _count: UserChallengeCountAggregateOutputType | null
    _avg: UserChallengeAvgAggregateOutputType | null
    _sum: UserChallengeSumAggregateOutputType | null
    _min: UserChallengeMinAggregateOutputType | null
    _max: UserChallengeMaxAggregateOutputType | null
  }

  export type UserChallengeAvgAggregateOutputType = {
    progress: number | null
  }

  export type UserChallengeSumAggregateOutputType = {
    progress: number | null
  }

  export type UserChallengeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    challengeId: string | null
    status: string | null
    progress: number | null
    startedAt: Date | null
    completedAt: Date | null
    metadata: string | null
  }

  export type UserChallengeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    challengeId: string | null
    status: string | null
    progress: number | null
    startedAt: Date | null
    completedAt: Date | null
    metadata: string | null
  }

  export type UserChallengeCountAggregateOutputType = {
    id: number
    userId: number
    challengeId: number
    status: number
    progress: number
    startedAt: number
    completedAt: number
    metadata: number
    _all: number
  }


  export type UserChallengeAvgAggregateInputType = {
    progress?: true
  }

  export type UserChallengeSumAggregateInputType = {
    progress?: true
  }

  export type UserChallengeMinAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    status?: true
    progress?: true
    startedAt?: true
    completedAt?: true
    metadata?: true
  }

  export type UserChallengeMaxAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    status?: true
    progress?: true
    startedAt?: true
    completedAt?: true
    metadata?: true
  }

  export type UserChallengeCountAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    status?: true
    progress?: true
    startedAt?: true
    completedAt?: true
    metadata?: true
    _all?: true
  }

  export type UserChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserChallenge to aggregate.
     */
    where?: UserChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChallenges to fetch.
     */
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserChallenges
    **/
    _count?: true | UserChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserChallengeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserChallengeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserChallengeMaxAggregateInputType
  }

  export type GetUserChallengeAggregateType<T extends UserChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserChallenge[P]>
      : GetScalarType<T[P], AggregateUserChallenge[P]>
  }




  export type UserChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserChallengeWhereInput
    orderBy?: UserChallengeOrderByWithAggregationInput | UserChallengeOrderByWithAggregationInput[]
    by: UserChallengeScalarFieldEnum[] | UserChallengeScalarFieldEnum
    having?: UserChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserChallengeCountAggregateInputType | true
    _avg?: UserChallengeAvgAggregateInputType
    _sum?: UserChallengeSumAggregateInputType
    _min?: UserChallengeMinAggregateInputType
    _max?: UserChallengeMaxAggregateInputType
  }

  export type UserChallengeGroupByOutputType = {
    id: string
    userId: string
    challengeId: string
    status: string
    progress: number
    startedAt: Date
    completedAt: Date | null
    metadata: string | null
    _count: UserChallengeCountAggregateOutputType | null
    _avg: UserChallengeAvgAggregateOutputType | null
    _sum: UserChallengeSumAggregateOutputType | null
    _min: UserChallengeMinAggregateOutputType | null
    _max: UserChallengeMaxAggregateOutputType | null
  }

  type GetUserChallengeGroupByPayload<T extends UserChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], UserChallengeGroupByOutputType[P]>
        }
      >
    >


  export type UserChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    status?: boolean
    progress?: boolean
    startedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userChallenge"]>

  export type UserChallengeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    status?: boolean
    progress?: boolean
    startedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userChallenge"]>

  export type UserChallengeSelectScalar = {
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    status?: boolean
    progress?: boolean
    startedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
  }

  export type UserChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserChallengeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserChallenge"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      challengeId: string
      status: string
      progress: number
      startedAt: Date
      completedAt: Date | null
      metadata: string | null
    }, ExtArgs["result"]["userChallenge"]>
    composites: {}
  }

  type UserChallengeGetPayload<S extends boolean | null | undefined | UserChallengeDefaultArgs> = $Result.GetResult<Prisma.$UserChallengePayload, S>

  type UserChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserChallengeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserChallengeCountAggregateInputType | true
    }

  export interface UserChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserChallenge'], meta: { name: 'UserChallenge' } }
    /**
     * Find zero or one UserChallenge that matches the filter.
     * @param {UserChallengeFindUniqueArgs} args - Arguments to find a UserChallenge
     * @example
     * // Get one UserChallenge
     * const userChallenge = await prisma.userChallenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserChallengeFindUniqueArgs>(args: SelectSubset<T, UserChallengeFindUniqueArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserChallenge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserChallengeFindUniqueOrThrowArgs} args - Arguments to find a UserChallenge
     * @example
     * // Get one UserChallenge
     * const userChallenge = await prisma.userChallenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserChallenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeFindFirstArgs} args - Arguments to find a UserChallenge
     * @example
     * // Get one UserChallenge
     * const userChallenge = await prisma.userChallenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserChallengeFindFirstArgs>(args?: SelectSubset<T, UserChallengeFindFirstArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserChallenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeFindFirstOrThrowArgs} args - Arguments to find a UserChallenge
     * @example
     * // Get one UserChallenge
     * const userChallenge = await prisma.userChallenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserChallenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserChallenges
     * const userChallenges = await prisma.userChallenge.findMany()
     * 
     * // Get first 10 UserChallenges
     * const userChallenges = await prisma.userChallenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userChallengeWithIdOnly = await prisma.userChallenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserChallengeFindManyArgs>(args?: SelectSubset<T, UserChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserChallenge.
     * @param {UserChallengeCreateArgs} args - Arguments to create a UserChallenge.
     * @example
     * // Create one UserChallenge
     * const UserChallenge = await prisma.userChallenge.create({
     *   data: {
     *     // ... data to create a UserChallenge
     *   }
     * })
     * 
     */
    create<T extends UserChallengeCreateArgs>(args: SelectSubset<T, UserChallengeCreateArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserChallenges.
     * @param {UserChallengeCreateManyArgs} args - Arguments to create many UserChallenges.
     * @example
     * // Create many UserChallenges
     * const userChallenge = await prisma.userChallenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserChallengeCreateManyArgs>(args?: SelectSubset<T, UserChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserChallenges and returns the data saved in the database.
     * @param {UserChallengeCreateManyAndReturnArgs} args - Arguments to create many UserChallenges.
     * @example
     * // Create many UserChallenges
     * const userChallenge = await prisma.userChallenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserChallenges and only return the `id`
     * const userChallengeWithIdOnly = await prisma.userChallenge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserChallengeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserChallengeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserChallenge.
     * @param {UserChallengeDeleteArgs} args - Arguments to delete one UserChallenge.
     * @example
     * // Delete one UserChallenge
     * const UserChallenge = await prisma.userChallenge.delete({
     *   where: {
     *     // ... filter to delete one UserChallenge
     *   }
     * })
     * 
     */
    delete<T extends UserChallengeDeleteArgs>(args: SelectSubset<T, UserChallengeDeleteArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserChallenge.
     * @param {UserChallengeUpdateArgs} args - Arguments to update one UserChallenge.
     * @example
     * // Update one UserChallenge
     * const userChallenge = await prisma.userChallenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserChallengeUpdateArgs>(args: SelectSubset<T, UserChallengeUpdateArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserChallenges.
     * @param {UserChallengeDeleteManyArgs} args - Arguments to filter UserChallenges to delete.
     * @example
     * // Delete a few UserChallenges
     * const { count } = await prisma.userChallenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserChallengeDeleteManyArgs>(args?: SelectSubset<T, UserChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserChallenges
     * const userChallenge = await prisma.userChallenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserChallengeUpdateManyArgs>(args: SelectSubset<T, UserChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserChallenge.
     * @param {UserChallengeUpsertArgs} args - Arguments to update or create a UserChallenge.
     * @example
     * // Update or create a UserChallenge
     * const userChallenge = await prisma.userChallenge.upsert({
     *   create: {
     *     // ... data to create a UserChallenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserChallenge we want to update
     *   }
     * })
     */
    upsert<T extends UserChallengeUpsertArgs>(args: SelectSubset<T, UserChallengeUpsertArgs<ExtArgs>>): Prisma__UserChallengeClient<$Result.GetResult<Prisma.$UserChallengePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeCountArgs} args - Arguments to filter UserChallenges to count.
     * @example
     * // Count the number of UserChallenges
     * const count = await prisma.userChallenge.count({
     *   where: {
     *     // ... the filter for the UserChallenges we want to count
     *   }
     * })
    **/
    count<T extends UserChallengeCountArgs>(
      args?: Subset<T, UserChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserChallengeAggregateArgs>(args: Subset<T, UserChallengeAggregateArgs>): Prisma.PrismaPromise<GetUserChallengeAggregateType<T>>

    /**
     * Group by UserChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserChallengeGroupByArgs['orderBy'] }
        : { orderBy?: UserChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserChallenge model
   */
  readonly fields: UserChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserChallenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserChallenge model
   */ 
  interface UserChallengeFieldRefs {
    readonly id: FieldRef<"UserChallenge", 'String'>
    readonly userId: FieldRef<"UserChallenge", 'String'>
    readonly challengeId: FieldRef<"UserChallenge", 'String'>
    readonly status: FieldRef<"UserChallenge", 'String'>
    readonly progress: FieldRef<"UserChallenge", 'Float'>
    readonly startedAt: FieldRef<"UserChallenge", 'DateTime'>
    readonly completedAt: FieldRef<"UserChallenge", 'DateTime'>
    readonly metadata: FieldRef<"UserChallenge", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserChallenge findUnique
   */
  export type UserChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter, which UserChallenge to fetch.
     */
    where: UserChallengeWhereUniqueInput
  }

  /**
   * UserChallenge findUniqueOrThrow
   */
  export type UserChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter, which UserChallenge to fetch.
     */
    where: UserChallengeWhereUniqueInput
  }

  /**
   * UserChallenge findFirst
   */
  export type UserChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter, which UserChallenge to fetch.
     */
    where?: UserChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChallenges to fetch.
     */
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserChallenges.
     */
    cursor?: UserChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserChallenges.
     */
    distinct?: UserChallengeScalarFieldEnum | UserChallengeScalarFieldEnum[]
  }

  /**
   * UserChallenge findFirstOrThrow
   */
  export type UserChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter, which UserChallenge to fetch.
     */
    where?: UserChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChallenges to fetch.
     */
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserChallenges.
     */
    cursor?: UserChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserChallenges.
     */
    distinct?: UserChallengeScalarFieldEnum | UserChallengeScalarFieldEnum[]
  }

  /**
   * UserChallenge findMany
   */
  export type UserChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter, which UserChallenges to fetch.
     */
    where?: UserChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChallenges to fetch.
     */
    orderBy?: UserChallengeOrderByWithRelationInput | UserChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserChallenges.
     */
    cursor?: UserChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChallenges.
     */
    skip?: number
    distinct?: UserChallengeScalarFieldEnum | UserChallengeScalarFieldEnum[]
  }

  /**
   * UserChallenge create
   */
  export type UserChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserChallenge.
     */
    data: XOR<UserChallengeCreateInput, UserChallengeUncheckedCreateInput>
  }

  /**
   * UserChallenge createMany
   */
  export type UserChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserChallenges.
     */
    data: UserChallengeCreateManyInput | UserChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserChallenge createManyAndReturn
   */
  export type UserChallengeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserChallenges.
     */
    data: UserChallengeCreateManyInput | UserChallengeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserChallenge update
   */
  export type UserChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserChallenge.
     */
    data: XOR<UserChallengeUpdateInput, UserChallengeUncheckedUpdateInput>
    /**
     * Choose, which UserChallenge to update.
     */
    where: UserChallengeWhereUniqueInput
  }

  /**
   * UserChallenge updateMany
   */
  export type UserChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserChallenges.
     */
    data: XOR<UserChallengeUpdateManyMutationInput, UserChallengeUncheckedUpdateManyInput>
    /**
     * Filter which UserChallenges to update
     */
    where?: UserChallengeWhereInput
  }

  /**
   * UserChallenge upsert
   */
  export type UserChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserChallenge to update in case it exists.
     */
    where: UserChallengeWhereUniqueInput
    /**
     * In case the UserChallenge found by the `where` argument doesn't exist, create a new UserChallenge with this data.
     */
    create: XOR<UserChallengeCreateInput, UserChallengeUncheckedCreateInput>
    /**
     * In case the UserChallenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserChallengeUpdateInput, UserChallengeUncheckedUpdateInput>
  }

  /**
   * UserChallenge delete
   */
  export type UserChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
    /**
     * Filter which UserChallenge to delete.
     */
    where: UserChallengeWhereUniqueInput
  }

  /**
   * UserChallenge deleteMany
   */
  export type UserChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserChallenges to delete
     */
    where?: UserChallengeWhereInput
  }

  /**
   * UserChallenge without action
   */
  export type UserChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallenge
     */
    select?: UserChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeInclude<ExtArgs> | null
  }


  /**
   * Model MarketplaceItem
   */

  export type AggregateMarketplaceItem = {
    _count: MarketplaceItemCountAggregateOutputType | null
    _avg: MarketplaceItemAvgAggregateOutputType | null
    _sum: MarketplaceItemSumAggregateOutputType | null
    _min: MarketplaceItemMinAggregateOutputType | null
    _max: MarketplaceItemMaxAggregateOutputType | null
  }

  export type MarketplaceItemAvgAggregateOutputType = {
    price: number | null
    priceToins: number | null
    stock: number | null
    rating: number | null
    reviewCount: number | null
    viewCount: number | null
    favoriteCount: number | null
  }

  export type MarketplaceItemSumAggregateOutputType = {
    price: number | null
    priceToins: number | null
    stock: number | null
    rating: number | null
    reviewCount: number | null
    viewCount: number | null
    favoriteCount: number | null
  }

  export type MarketplaceItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    fullDescription: string | null
    itemType: $Enums.MarketplaceItemType | null
    price: number | null
    priceToins: number | null
    currency: $Enums.Currency | null
    category: string | null
    stock: number | null
    rating: number | null
    reviewCount: number | null
    location: string | null
    status: $Enums.MarketplaceItemStatus | null
    isActive: boolean | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    viewCount: number | null
    favoriteCount: number | null
    sellerId: string | null
    metadata: string | null
  }

  export type MarketplaceItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    fullDescription: string | null
    itemType: $Enums.MarketplaceItemType | null
    price: number | null
    priceToins: number | null
    currency: $Enums.Currency | null
    category: string | null
    stock: number | null
    rating: number | null
    reviewCount: number | null
    location: string | null
    status: $Enums.MarketplaceItemStatus | null
    isActive: boolean | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    viewCount: number | null
    favoriteCount: number | null
    sellerId: string | null
    metadata: string | null
  }

  export type MarketplaceItemCountAggregateOutputType = {
    id: number
    name: number
    description: number
    fullDescription: number
    itemType: number
    price: number
    priceToins: number
    currency: number
    category: number
    tags: number
    images: number
    stock: number
    rating: number
    reviewCount: number
    location: number
    status: number
    isActive: number
    isDeleted: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    viewCount: number
    favoriteCount: number
    sellerId: number
    metadata: number
    _all: number
  }


  export type MarketplaceItemAvgAggregateInputType = {
    price?: true
    priceToins?: true
    stock?: true
    rating?: true
    reviewCount?: true
    viewCount?: true
    favoriteCount?: true
  }

  export type MarketplaceItemSumAggregateInputType = {
    price?: true
    priceToins?: true
    stock?: true
    rating?: true
    reviewCount?: true
    viewCount?: true
    favoriteCount?: true
  }

  export type MarketplaceItemMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    itemType?: true
    price?: true
    priceToins?: true
    currency?: true
    category?: true
    stock?: true
    rating?: true
    reviewCount?: true
    location?: true
    status?: true
    isActive?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    viewCount?: true
    favoriteCount?: true
    sellerId?: true
    metadata?: true
  }

  export type MarketplaceItemMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    itemType?: true
    price?: true
    priceToins?: true
    currency?: true
    category?: true
    stock?: true
    rating?: true
    reviewCount?: true
    location?: true
    status?: true
    isActive?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    viewCount?: true
    favoriteCount?: true
    sellerId?: true
    metadata?: true
  }

  export type MarketplaceItemCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    fullDescription?: true
    itemType?: true
    price?: true
    priceToins?: true
    currency?: true
    category?: true
    tags?: true
    images?: true
    stock?: true
    rating?: true
    reviewCount?: true
    location?: true
    status?: true
    isActive?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    viewCount?: true
    favoriteCount?: true
    sellerId?: true
    metadata?: true
    _all?: true
  }

  export type MarketplaceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceItem to aggregate.
     */
    where?: MarketplaceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceItems to fetch.
     */
    orderBy?: MarketplaceItemOrderByWithRelationInput | MarketplaceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketplaceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketplaceItems
    **/
    _count?: true | MarketplaceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketplaceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketplaceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketplaceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketplaceItemMaxAggregateInputType
  }

  export type GetMarketplaceItemAggregateType<T extends MarketplaceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketplaceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketplaceItem[P]>
      : GetScalarType<T[P], AggregateMarketplaceItem[P]>
  }




  export type MarketplaceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceItemWhereInput
    orderBy?: MarketplaceItemOrderByWithAggregationInput | MarketplaceItemOrderByWithAggregationInput[]
    by: MarketplaceItemScalarFieldEnum[] | MarketplaceItemScalarFieldEnum
    having?: MarketplaceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketplaceItemCountAggregateInputType | true
    _avg?: MarketplaceItemAvgAggregateInputType
    _sum?: MarketplaceItemSumAggregateInputType
    _min?: MarketplaceItemMinAggregateInputType
    _max?: MarketplaceItemMaxAggregateInputType
  }

  export type MarketplaceItemGroupByOutputType = {
    id: string
    name: string
    description: string | null
    fullDescription: string | null
    itemType: $Enums.MarketplaceItemType
    price: number
    priceToins: number
    currency: $Enums.Currency
    category: string | null
    tags: string[]
    images: string[]
    stock: number
    rating: number
    reviewCount: number
    location: string | null
    status: $Enums.MarketplaceItemStatus
    isActive: boolean
    isDeleted: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    viewCount: number
    favoriteCount: number
    sellerId: string
    metadata: string | null
    _count: MarketplaceItemCountAggregateOutputType | null
    _avg: MarketplaceItemAvgAggregateOutputType | null
    _sum: MarketplaceItemSumAggregateOutputType | null
    _min: MarketplaceItemMinAggregateOutputType | null
    _max: MarketplaceItemMaxAggregateOutputType | null
  }

  type GetMarketplaceItemGroupByPayload<T extends MarketplaceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketplaceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketplaceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketplaceItemGroupByOutputType[P]>
            : GetScalarType<T[P], MarketplaceItemGroupByOutputType[P]>
        }
      >
    >


  export type MarketplaceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    itemType?: boolean
    price?: boolean
    priceToins?: boolean
    currency?: boolean
    category?: boolean
    tags?: boolean
    images?: boolean
    stock?: boolean
    rating?: boolean
    reviewCount?: boolean
    location?: boolean
    status?: boolean
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    viewCount?: boolean
    favoriteCount?: boolean
    sellerId?: boolean
    metadata?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
    reviews?: boolean | MarketplaceItem$reviewsArgs<ExtArgs>
    matches?: boolean | MarketplaceItem$matchesArgs<ExtArgs>
    _count?: boolean | MarketplaceItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceItem"]>

  export type MarketplaceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    itemType?: boolean
    price?: boolean
    priceToins?: boolean
    currency?: boolean
    category?: boolean
    tags?: boolean
    images?: boolean
    stock?: boolean
    rating?: boolean
    reviewCount?: boolean
    location?: boolean
    status?: boolean
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    viewCount?: boolean
    favoriteCount?: boolean
    sellerId?: boolean
    metadata?: boolean
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceItem"]>

  export type MarketplaceItemSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    fullDescription?: boolean
    itemType?: boolean
    price?: boolean
    priceToins?: boolean
    currency?: boolean
    category?: boolean
    tags?: boolean
    images?: boolean
    stock?: boolean
    rating?: boolean
    reviewCount?: boolean
    location?: boolean
    status?: boolean
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    viewCount?: boolean
    favoriteCount?: boolean
    sellerId?: boolean
    metadata?: boolean
  }

  export type MarketplaceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
    reviews?: boolean | MarketplaceItem$reviewsArgs<ExtArgs>
    matches?: boolean | MarketplaceItem$matchesArgs<ExtArgs>
    _count?: boolean | MarketplaceItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MarketplaceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MarketplaceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketplaceItem"
    objects: {
      seller: Prisma.$UserPayload<ExtArgs>
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      matches: Prisma.$MarketplaceMatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      fullDescription: string | null
      itemType: $Enums.MarketplaceItemType
      price: number
      priceToins: number
      currency: $Enums.Currency
      category: string | null
      tags: string[]
      images: string[]
      stock: number
      rating: number
      reviewCount: number
      location: string | null
      status: $Enums.MarketplaceItemStatus
      isActive: boolean
      isDeleted: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
      viewCount: number
      favoriteCount: number
      sellerId: string
      metadata: string | null
    }, ExtArgs["result"]["marketplaceItem"]>
    composites: {}
  }

  type MarketplaceItemGetPayload<S extends boolean | null | undefined | MarketplaceItemDefaultArgs> = $Result.GetResult<Prisma.$MarketplaceItemPayload, S>

  type MarketplaceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MarketplaceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarketplaceItemCountAggregateInputType | true
    }

  export interface MarketplaceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketplaceItem'], meta: { name: 'MarketplaceItem' } }
    /**
     * Find zero or one MarketplaceItem that matches the filter.
     * @param {MarketplaceItemFindUniqueArgs} args - Arguments to find a MarketplaceItem
     * @example
     * // Get one MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketplaceItemFindUniqueArgs>(args: SelectSubset<T, MarketplaceItemFindUniqueArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MarketplaceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MarketplaceItemFindUniqueOrThrowArgs} args - Arguments to find a MarketplaceItem
     * @example
     * // Get one MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketplaceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketplaceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MarketplaceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemFindFirstArgs} args - Arguments to find a MarketplaceItem
     * @example
     * // Get one MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketplaceItemFindFirstArgs>(args?: SelectSubset<T, MarketplaceItemFindFirstArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MarketplaceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemFindFirstOrThrowArgs} args - Arguments to find a MarketplaceItem
     * @example
     * // Get one MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketplaceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketplaceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MarketplaceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketplaceItems
     * const marketplaceItems = await prisma.marketplaceItem.findMany()
     * 
     * // Get first 10 MarketplaceItems
     * const marketplaceItems = await prisma.marketplaceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketplaceItemWithIdOnly = await prisma.marketplaceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketplaceItemFindManyArgs>(args?: SelectSubset<T, MarketplaceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MarketplaceItem.
     * @param {MarketplaceItemCreateArgs} args - Arguments to create a MarketplaceItem.
     * @example
     * // Create one MarketplaceItem
     * const MarketplaceItem = await prisma.marketplaceItem.create({
     *   data: {
     *     // ... data to create a MarketplaceItem
     *   }
     * })
     * 
     */
    create<T extends MarketplaceItemCreateArgs>(args: SelectSubset<T, MarketplaceItemCreateArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MarketplaceItems.
     * @param {MarketplaceItemCreateManyArgs} args - Arguments to create many MarketplaceItems.
     * @example
     * // Create many MarketplaceItems
     * const marketplaceItem = await prisma.marketplaceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketplaceItemCreateManyArgs>(args?: SelectSubset<T, MarketplaceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketplaceItems and returns the data saved in the database.
     * @param {MarketplaceItemCreateManyAndReturnArgs} args - Arguments to create many MarketplaceItems.
     * @example
     * // Create many MarketplaceItems
     * const marketplaceItem = await prisma.marketplaceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketplaceItems and only return the `id`
     * const marketplaceItemWithIdOnly = await prisma.marketplaceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketplaceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketplaceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MarketplaceItem.
     * @param {MarketplaceItemDeleteArgs} args - Arguments to delete one MarketplaceItem.
     * @example
     * // Delete one MarketplaceItem
     * const MarketplaceItem = await prisma.marketplaceItem.delete({
     *   where: {
     *     // ... filter to delete one MarketplaceItem
     *   }
     * })
     * 
     */
    delete<T extends MarketplaceItemDeleteArgs>(args: SelectSubset<T, MarketplaceItemDeleteArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MarketplaceItem.
     * @param {MarketplaceItemUpdateArgs} args - Arguments to update one MarketplaceItem.
     * @example
     * // Update one MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketplaceItemUpdateArgs>(args: SelectSubset<T, MarketplaceItemUpdateArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MarketplaceItems.
     * @param {MarketplaceItemDeleteManyArgs} args - Arguments to filter MarketplaceItems to delete.
     * @example
     * // Delete a few MarketplaceItems
     * const { count } = await prisma.marketplaceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketplaceItemDeleteManyArgs>(args?: SelectSubset<T, MarketplaceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketplaceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketplaceItems
     * const marketplaceItem = await prisma.marketplaceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketplaceItemUpdateManyArgs>(args: SelectSubset<T, MarketplaceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketplaceItem.
     * @param {MarketplaceItemUpsertArgs} args - Arguments to update or create a MarketplaceItem.
     * @example
     * // Update or create a MarketplaceItem
     * const marketplaceItem = await prisma.marketplaceItem.upsert({
     *   create: {
     *     // ... data to create a MarketplaceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketplaceItem we want to update
     *   }
     * })
     */
    upsert<T extends MarketplaceItemUpsertArgs>(args: SelectSubset<T, MarketplaceItemUpsertArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MarketplaceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemCountArgs} args - Arguments to filter MarketplaceItems to count.
     * @example
     * // Count the number of MarketplaceItems
     * const count = await prisma.marketplaceItem.count({
     *   where: {
     *     // ... the filter for the MarketplaceItems we want to count
     *   }
     * })
    **/
    count<T extends MarketplaceItemCountArgs>(
      args?: Subset<T, MarketplaceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketplaceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketplaceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketplaceItemAggregateArgs>(args: Subset<T, MarketplaceItemAggregateArgs>): Prisma.PrismaPromise<GetMarketplaceItemAggregateType<T>>

    /**
     * Group by MarketplaceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketplaceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketplaceItemGroupByArgs['orderBy'] }
        : { orderBy?: MarketplaceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketplaceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketplaceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketplaceItem model
   */
  readonly fields: MarketplaceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketplaceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketplaceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reviews<T extends MarketplaceItem$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceItem$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    matches<T extends MarketplaceItem$matchesArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceItem$matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceMatchPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketplaceItem model
   */ 
  interface MarketplaceItemFieldRefs {
    readonly id: FieldRef<"MarketplaceItem", 'String'>
    readonly name: FieldRef<"MarketplaceItem", 'String'>
    readonly description: FieldRef<"MarketplaceItem", 'String'>
    readonly fullDescription: FieldRef<"MarketplaceItem", 'String'>
    readonly itemType: FieldRef<"MarketplaceItem", 'MarketplaceItemType'>
    readonly price: FieldRef<"MarketplaceItem", 'Float'>
    readonly priceToins: FieldRef<"MarketplaceItem", 'Float'>
    readonly currency: FieldRef<"MarketplaceItem", 'Currency'>
    readonly category: FieldRef<"MarketplaceItem", 'String'>
    readonly tags: FieldRef<"MarketplaceItem", 'String[]'>
    readonly images: FieldRef<"MarketplaceItem", 'String[]'>
    readonly stock: FieldRef<"MarketplaceItem", 'Int'>
    readonly rating: FieldRef<"MarketplaceItem", 'Float'>
    readonly reviewCount: FieldRef<"MarketplaceItem", 'Int'>
    readonly location: FieldRef<"MarketplaceItem", 'String'>
    readonly status: FieldRef<"MarketplaceItem", 'MarketplaceItemStatus'>
    readonly isActive: FieldRef<"MarketplaceItem", 'Boolean'>
    readonly isDeleted: FieldRef<"MarketplaceItem", 'Boolean'>
    readonly deletedAt: FieldRef<"MarketplaceItem", 'DateTime'>
    readonly createdAt: FieldRef<"MarketplaceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketplaceItem", 'DateTime'>
    readonly viewCount: FieldRef<"MarketplaceItem", 'Int'>
    readonly favoriteCount: FieldRef<"MarketplaceItem", 'Int'>
    readonly sellerId: FieldRef<"MarketplaceItem", 'String'>
    readonly metadata: FieldRef<"MarketplaceItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MarketplaceItem findUnique
   */
  export type MarketplaceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceItem to fetch.
     */
    where: MarketplaceItemWhereUniqueInput
  }

  /**
   * MarketplaceItem findUniqueOrThrow
   */
  export type MarketplaceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceItem to fetch.
     */
    where: MarketplaceItemWhereUniqueInput
  }

  /**
   * MarketplaceItem findFirst
   */
  export type MarketplaceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceItem to fetch.
     */
    where?: MarketplaceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceItems to fetch.
     */
    orderBy?: MarketplaceItemOrderByWithRelationInput | MarketplaceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceItems.
     */
    cursor?: MarketplaceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceItems.
     */
    distinct?: MarketplaceItemScalarFieldEnum | MarketplaceItemScalarFieldEnum[]
  }

  /**
   * MarketplaceItem findFirstOrThrow
   */
  export type MarketplaceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceItem to fetch.
     */
    where?: MarketplaceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceItems to fetch.
     */
    orderBy?: MarketplaceItemOrderByWithRelationInput | MarketplaceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceItems.
     */
    cursor?: MarketplaceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceItems.
     */
    distinct?: MarketplaceItemScalarFieldEnum | MarketplaceItemScalarFieldEnum[]
  }

  /**
   * MarketplaceItem findMany
   */
  export type MarketplaceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceItems to fetch.
     */
    where?: MarketplaceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceItems to fetch.
     */
    orderBy?: MarketplaceItemOrderByWithRelationInput | MarketplaceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketplaceItems.
     */
    cursor?: MarketplaceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceItems.
     */
    skip?: number
    distinct?: MarketplaceItemScalarFieldEnum | MarketplaceItemScalarFieldEnum[]
  }

  /**
   * MarketplaceItem create
   */
  export type MarketplaceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketplaceItem.
     */
    data: XOR<MarketplaceItemCreateInput, MarketplaceItemUncheckedCreateInput>
  }

  /**
   * MarketplaceItem createMany
   */
  export type MarketplaceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketplaceItems.
     */
    data: MarketplaceItemCreateManyInput | MarketplaceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketplaceItem createManyAndReturn
   */
  export type MarketplaceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MarketplaceItems.
     */
    data: MarketplaceItemCreateManyInput | MarketplaceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketplaceItem update
   */
  export type MarketplaceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketplaceItem.
     */
    data: XOR<MarketplaceItemUpdateInput, MarketplaceItemUncheckedUpdateInput>
    /**
     * Choose, which MarketplaceItem to update.
     */
    where: MarketplaceItemWhereUniqueInput
  }

  /**
   * MarketplaceItem updateMany
   */
  export type MarketplaceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketplaceItems.
     */
    data: XOR<MarketplaceItemUpdateManyMutationInput, MarketplaceItemUncheckedUpdateManyInput>
    /**
     * Filter which MarketplaceItems to update
     */
    where?: MarketplaceItemWhereInput
  }

  /**
   * MarketplaceItem upsert
   */
  export type MarketplaceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketplaceItem to update in case it exists.
     */
    where: MarketplaceItemWhereUniqueInput
    /**
     * In case the MarketplaceItem found by the `where` argument doesn't exist, create a new MarketplaceItem with this data.
     */
    create: XOR<MarketplaceItemCreateInput, MarketplaceItemUncheckedCreateInput>
    /**
     * In case the MarketplaceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketplaceItemUpdateInput, MarketplaceItemUncheckedUpdateInput>
  }

  /**
   * MarketplaceItem delete
   */
  export type MarketplaceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
    /**
     * Filter which MarketplaceItem to delete.
     */
    where: MarketplaceItemWhereUniqueInput
  }

  /**
   * MarketplaceItem deleteMany
   */
  export type MarketplaceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceItems to delete
     */
    where?: MarketplaceItemWhereInput
  }

  /**
   * MarketplaceItem.reviews
   */
  export type MarketplaceItem$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * MarketplaceItem.matches
   */
  export type MarketplaceItem$matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceMatch
     */
    select?: MarketplaceMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceMatchInclude<ExtArgs> | null
    where?: MarketplaceMatchWhereInput
    orderBy?: MarketplaceMatchOrderByWithRelationInput | MarketplaceMatchOrderByWithRelationInput[]
    cursor?: MarketplaceMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketplaceMatchScalarFieldEnum | MarketplaceMatchScalarFieldEnum[]
  }

  /**
   * MarketplaceItem without action
   */
  export type MarketplaceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceItem
     */
    select?: MarketplaceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceItemInclude<ExtArgs> | null
  }


  /**
   * Model StudyRoom
   */

  export type AggregateStudyRoom = {
    _count: StudyRoomCountAggregateOutputType | null
    _avg: StudyRoomAvgAggregateOutputType | null
    _sum: StudyRoomSumAggregateOutputType | null
    _min: StudyRoomMinAggregateOutputType | null
    _max: StudyRoomMaxAggregateOutputType | null
  }

  export type StudyRoomAvgAggregateOutputType = {
    videoId: number | null
    maxParticipants: number | null
    currentTime: number | null
  }

  export type StudyRoomSumAggregateOutputType = {
    videoId: number | null
    maxParticipants: number | null
    currentTime: number | null
  }

  export type StudyRoomMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    videoId: number | null
    hostId: string | null
    maxParticipants: number | null
    status: $Enums.StudyRoomStatus | null
    currentTime: number | null
    isPaused: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudyRoomMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    videoId: number | null
    hostId: string | null
    maxParticipants: number | null
    status: $Enums.StudyRoomStatus | null
    currentTime: number | null
    isPaused: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudyRoomCountAggregateOutputType = {
    id: number
    name: number
    description: number
    videoId: number
    hostId: number
    maxParticipants: number
    status: number
    currentTime: number
    isPaused: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudyRoomAvgAggregateInputType = {
    videoId?: true
    maxParticipants?: true
    currentTime?: true
  }

  export type StudyRoomSumAggregateInputType = {
    videoId?: true
    maxParticipants?: true
    currentTime?: true
  }

  export type StudyRoomMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    videoId?: true
    hostId?: true
    maxParticipants?: true
    status?: true
    currentTime?: true
    isPaused?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudyRoomMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    videoId?: true
    hostId?: true
    maxParticipants?: true
    status?: true
    currentTime?: true
    isPaused?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudyRoomCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    videoId?: true
    hostId?: true
    maxParticipants?: true
    status?: true
    currentTime?: true
    isPaused?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudyRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyRoom to aggregate.
     */
    where?: StudyRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyRooms to fetch.
     */
    orderBy?: StudyRoomOrderByWithRelationInput | StudyRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudyRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudyRooms
    **/
    _count?: true | StudyRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudyRoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudyRoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudyRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudyRoomMaxAggregateInputType
  }

  export type GetStudyRoomAggregateType<T extends StudyRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateStudyRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudyRoom[P]>
      : GetScalarType<T[P], AggregateStudyRoom[P]>
  }




  export type StudyRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyRoomWhereInput
    orderBy?: StudyRoomOrderByWithAggregationInput | StudyRoomOrderByWithAggregationInput[]
    by: StudyRoomScalarFieldEnum[] | StudyRoomScalarFieldEnum
    having?: StudyRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudyRoomCountAggregateInputType | true
    _avg?: StudyRoomAvgAggregateInputType
    _sum?: StudyRoomSumAggregateInputType
    _min?: StudyRoomMinAggregateInputType
    _max?: StudyRoomMaxAggregateInputType
  }

  export type StudyRoomGroupByOutputType = {
    id: string
    name: string
    description: string | null
    videoId: number
    hostId: string
    maxParticipants: number
    status: $Enums.StudyRoomStatus
    currentTime: number
    isPaused: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StudyRoomCountAggregateOutputType | null
    _avg: StudyRoomAvgAggregateOutputType | null
    _sum: StudyRoomSumAggregateOutputType | null
    _min: StudyRoomMinAggregateOutputType | null
    _max: StudyRoomMaxAggregateOutputType | null
  }

  type GetStudyRoomGroupByPayload<T extends StudyRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudyRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudyRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudyRoomGroupByOutputType[P]>
            : GetScalarType<T[P], StudyRoomGroupByOutputType[P]>
        }
      >
    >


  export type StudyRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    videoId?: boolean
    hostId?: boolean
    maxParticipants?: boolean
    status?: boolean
    currentTime?: boolean
    isPaused?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    video?: boolean | VideoItemDefaultArgs<ExtArgs>
    host?: boolean | UserDefaultArgs<ExtArgs>
    participants?: boolean | StudyRoom$participantsArgs<ExtArgs>
    messages?: boolean | StudyRoom$messagesArgs<ExtArgs>
    _count?: boolean | StudyRoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyRoom"]>

  export type StudyRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    videoId?: boolean
    hostId?: boolean
    maxParticipants?: boolean
    status?: boolean
    currentTime?: boolean
    isPaused?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    video?: boolean | VideoItemDefaultArgs<ExtArgs>
    host?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyRoom"]>

  export type StudyRoomSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    videoId?: boolean
    hostId?: boolean
    maxParticipants?: boolean
    status?: boolean
    currentTime?: boolean
    isPaused?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudyRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoItemDefaultArgs<ExtArgs>
    host?: boolean | UserDefaultArgs<ExtArgs>
    participants?: boolean | StudyRoom$participantsArgs<ExtArgs>
    messages?: boolean | StudyRoom$messagesArgs<ExtArgs>
    _count?: boolean | StudyRoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudyRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoItemDefaultArgs<ExtArgs>
    host?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StudyRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudyRoom"
    objects: {
      video: Prisma.$VideoItemPayload<ExtArgs>
      host: Prisma.$UserPayload<ExtArgs>
      participants: Prisma.$StudyRoomParticipantPayload<ExtArgs>[]
      messages: Prisma.$StudyRoomMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      videoId: number
      hostId: string
      maxParticipants: number
      status: $Enums.StudyRoomStatus
      currentTime: number
      isPaused: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studyRoom"]>
    composites: {}
  }

  type StudyRoomGetPayload<S extends boolean | null | undefined | StudyRoomDefaultArgs> = $Result.GetResult<Prisma.$StudyRoomPayload, S>

  type StudyRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudyRoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudyRoomCountAggregateInputType | true
    }

  export interface StudyRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudyRoom'], meta: { name: 'StudyRoom' } }
    /**
     * Find zero or one StudyRoom that matches the filter.
     * @param {StudyRoomFindUniqueArgs} args - Arguments to find a StudyRoom
     * @example
     * // Get one StudyRoom
     * const studyRoom = await prisma.studyRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudyRoomFindUniqueArgs>(args: SelectSubset<T, StudyRoomFindUniqueArgs<ExtArgs>>): Prisma__StudyRoomClient<$Result.GetResult<Prisma.$StudyRoomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudyRoom that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudyRoomFindUniqueOrThrowArgs} args - Arguments to find a StudyRoom
     * @example
     * // Get one StudyRoom
     * const studyRoom = await prisma.studyRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudyRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, StudyRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudyRoomClient<$Result.GetResult<Prisma.$StudyRoomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudyRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomFindFirstArgs} args - Arguments to find a StudyRoom
     * @example
     * // Get one StudyRoom
     * const studyRoom = await prisma.studyRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudyRoomFindFirstArgs>(args?: SelectSubset<T, StudyRoomFindFirstArgs<ExtArgs>>): Prisma__StudyRoomClient<$Result.GetResult<Prisma.$StudyRoomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudyRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomFindFirstOrThrowArgs} args - Arguments to find a StudyRoom
     * @example
     * // Get one StudyRoom
     * const studyRoom = await prisma.studyRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudyRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, StudyRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudyRoomClient<$Result.GetResult<Prisma.$StudyRoomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudyRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudyRooms
     * const studyRooms = await prisma.studyRoom.findMany()
     * 
     * // Get first 10 StudyRooms
     * const studyRooms = await prisma.studyRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studyRoomWithIdOnly = await prisma.studyRoom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudyRoomFindManyArgs>(args?: SelectSubset<T, StudyRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyRoomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudyRoom.
     * @param {StudyRoomCreateArgs} args - Arguments to create a StudyRoom.
     * @example
     * // Create one StudyRoom
     * const StudyRoom = await prisma.studyRoom.create({
     *   data: {
     *     // ... data to create a StudyRoom
     *   }
     * })
     * 
     */
    create<T extends StudyRoomCreateArgs>(args: SelectSubset<T, StudyRoomCreateArgs<ExtArgs>>): Prisma__StudyRoomClient<$Result.GetResult<Prisma.$StudyRoomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudyRooms.
     * @param {StudyRoomCreateManyArgs} args - Arguments to create many StudyRooms.
     * @example
     * // Create many StudyRooms
     * const studyRoom = await prisma.studyRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudyRoomCreateManyArgs>(args?: SelectSubset<T, StudyRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudyRooms and returns the data saved in the database.
     * @param {StudyRoomCreateManyAndReturnArgs} args - Arguments to create many StudyRooms.
     * @example
     * // Create many StudyRooms
     * const studyRoom = await prisma.studyRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudyRooms and only return the `id`
     * const studyRoomWithIdOnly = await prisma.studyRoom.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudyRoomCreateManyAndReturnArgs>(args?: SelectSubset<T, StudyRoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyRoomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudyRoom.
     * @param {StudyRoomDeleteArgs} args - Arguments to delete one StudyRoom.
     * @example
     * // Delete one StudyRoom
     * const StudyRoom = await prisma.studyRoom.delete({
     *   where: {
     *     // ... filter to delete one StudyRoom
     *   }
     * })
     * 
     */
    delete<T extends StudyRoomDeleteArgs>(args: SelectSubset<T, StudyRoomDeleteArgs<ExtArgs>>): Prisma__StudyRoomClient<$Result.GetResult<Prisma.$StudyRoomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudyRoom.
     * @param {StudyRoomUpdateArgs} args - Arguments to update one StudyRoom.
     * @example
     * // Update one StudyRoom
     * const studyRoom = await prisma.studyRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudyRoomUpdateArgs>(args: SelectSubset<T, StudyRoomUpdateArgs<ExtArgs>>): Prisma__StudyRoomClient<$Result.GetResult<Prisma.$StudyRoomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudyRooms.
     * @param {StudyRoomDeleteManyArgs} args - Arguments to filter StudyRooms to delete.
     * @example
     * // Delete a few StudyRooms
     * const { count } = await prisma.studyRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudyRoomDeleteManyArgs>(args?: SelectSubset<T, StudyRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudyRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudyRooms
     * const studyRoom = await prisma.studyRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudyRoomUpdateManyArgs>(args: SelectSubset<T, StudyRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudyRoom.
     * @param {StudyRoomUpsertArgs} args - Arguments to update or create a StudyRoom.
     * @example
     * // Update or create a StudyRoom
     * const studyRoom = await prisma.studyRoom.upsert({
     *   create: {
     *     // ... data to create a StudyRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudyRoom we want to update
     *   }
     * })
     */
    upsert<T extends StudyRoomUpsertArgs>(args: SelectSubset<T, StudyRoomUpsertArgs<ExtArgs>>): Prisma__StudyRoomClient<$Result.GetResult<Prisma.$StudyRoomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudyRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomCountArgs} args - Arguments to filter StudyRooms to count.
     * @example
     * // Count the number of StudyRooms
     * const count = await prisma.studyRoom.count({
     *   where: {
     *     // ... the filter for the StudyRooms we want to count
     *   }
     * })
    **/
    count<T extends StudyRoomCountArgs>(
      args?: Subset<T, StudyRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudyRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudyRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudyRoomAggregateArgs>(args: Subset<T, StudyRoomAggregateArgs>): Prisma.PrismaPromise<GetStudyRoomAggregateType<T>>

    /**
     * Group by StudyRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudyRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudyRoomGroupByArgs['orderBy'] }
        : { orderBy?: StudyRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudyRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudyRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudyRoom model
   */
  readonly fields: StudyRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudyRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudyRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    video<T extends VideoItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoItemDefaultArgs<ExtArgs>>): Prisma__VideoItemClient<$Result.GetResult<Prisma.$VideoItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    host<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    participants<T extends StudyRoom$participantsArgs<ExtArgs> = {}>(args?: Subset<T, StudyRoom$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyRoomParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends StudyRoom$messagesArgs<ExtArgs> = {}>(args?: Subset<T, StudyRoom$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyRoomMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudyRoom model
   */ 
  interface StudyRoomFieldRefs {
    readonly id: FieldRef<"StudyRoom", 'String'>
    readonly name: FieldRef<"StudyRoom", 'String'>
    readonly description: FieldRef<"StudyRoom", 'String'>
    readonly videoId: FieldRef<"StudyRoom", 'Int'>
    readonly hostId: FieldRef<"StudyRoom", 'String'>
    readonly maxParticipants: FieldRef<"StudyRoom", 'Int'>
    readonly status: FieldRef<"StudyRoom", 'StudyRoomStatus'>
    readonly currentTime: FieldRef<"StudyRoom", 'Float'>
    readonly isPaused: FieldRef<"StudyRoom", 'Boolean'>
    readonly isActive: FieldRef<"StudyRoom", 'Boolean'>
    readonly createdAt: FieldRef<"StudyRoom", 'DateTime'>
    readonly updatedAt: FieldRef<"StudyRoom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudyRoom findUnique
   */
  export type StudyRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoom
     */
    select?: StudyRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomInclude<ExtArgs> | null
    /**
     * Filter, which StudyRoom to fetch.
     */
    where: StudyRoomWhereUniqueInput
  }

  /**
   * StudyRoom findUniqueOrThrow
   */
  export type StudyRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoom
     */
    select?: StudyRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomInclude<ExtArgs> | null
    /**
     * Filter, which StudyRoom to fetch.
     */
    where: StudyRoomWhereUniqueInput
  }

  /**
   * StudyRoom findFirst
   */
  export type StudyRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoom
     */
    select?: StudyRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomInclude<ExtArgs> | null
    /**
     * Filter, which StudyRoom to fetch.
     */
    where?: StudyRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyRooms to fetch.
     */
    orderBy?: StudyRoomOrderByWithRelationInput | StudyRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyRooms.
     */
    cursor?: StudyRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyRooms.
     */
    distinct?: StudyRoomScalarFieldEnum | StudyRoomScalarFieldEnum[]
  }

  /**
   * StudyRoom findFirstOrThrow
   */
  export type StudyRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoom
     */
    select?: StudyRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomInclude<ExtArgs> | null
    /**
     * Filter, which StudyRoom to fetch.
     */
    where?: StudyRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyRooms to fetch.
     */
    orderBy?: StudyRoomOrderByWithRelationInput | StudyRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyRooms.
     */
    cursor?: StudyRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyRooms.
     */
    distinct?: StudyRoomScalarFieldEnum | StudyRoomScalarFieldEnum[]
  }

  /**
   * StudyRoom findMany
   */
  export type StudyRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoom
     */
    select?: StudyRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomInclude<ExtArgs> | null
    /**
     * Filter, which StudyRooms to fetch.
     */
    where?: StudyRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyRooms to fetch.
     */
    orderBy?: StudyRoomOrderByWithRelationInput | StudyRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudyRooms.
     */
    cursor?: StudyRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyRooms.
     */
    skip?: number
    distinct?: StudyRoomScalarFieldEnum | StudyRoomScalarFieldEnum[]
  }

  /**
   * StudyRoom create
   */
  export type StudyRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoom
     */
    select?: StudyRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a StudyRoom.
     */
    data: XOR<StudyRoomCreateInput, StudyRoomUncheckedCreateInput>
  }

  /**
   * StudyRoom createMany
   */
  export type StudyRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudyRooms.
     */
    data: StudyRoomCreateManyInput | StudyRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudyRoom createManyAndReturn
   */
  export type StudyRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoom
     */
    select?: StudyRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudyRooms.
     */
    data: StudyRoomCreateManyInput | StudyRoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudyRoom update
   */
  export type StudyRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoom
     */
    select?: StudyRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a StudyRoom.
     */
    data: XOR<StudyRoomUpdateInput, StudyRoomUncheckedUpdateInput>
    /**
     * Choose, which StudyRoom to update.
     */
    where: StudyRoomWhereUniqueInput
  }

  /**
   * StudyRoom updateMany
   */
  export type StudyRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudyRooms.
     */
    data: XOR<StudyRoomUpdateManyMutationInput, StudyRoomUncheckedUpdateManyInput>
    /**
     * Filter which StudyRooms to update
     */
    where?: StudyRoomWhereInput
  }

  /**
   * StudyRoom upsert
   */
  export type StudyRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoom
     */
    select?: StudyRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the StudyRoom to update in case it exists.
     */
    where: StudyRoomWhereUniqueInput
    /**
     * In case the StudyRoom found by the `where` argument doesn't exist, create a new StudyRoom with this data.
     */
    create: XOR<StudyRoomCreateInput, StudyRoomUncheckedCreateInput>
    /**
     * In case the StudyRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudyRoomUpdateInput, StudyRoomUncheckedUpdateInput>
  }

  /**
   * StudyRoom delete
   */
  export type StudyRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoom
     */
    select?: StudyRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomInclude<ExtArgs> | null
    /**
     * Filter which StudyRoom to delete.
     */
    where: StudyRoomWhereUniqueInput
  }

  /**
   * StudyRoom deleteMany
   */
  export type StudyRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyRooms to delete
     */
    where?: StudyRoomWhereInput
  }

  /**
   * StudyRoom.participants
   */
  export type StudyRoom$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomParticipant
     */
    select?: StudyRoomParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomParticipantInclude<ExtArgs> | null
    where?: StudyRoomParticipantWhereInput
    orderBy?: StudyRoomParticipantOrderByWithRelationInput | StudyRoomParticipantOrderByWithRelationInput[]
    cursor?: StudyRoomParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudyRoomParticipantScalarFieldEnum | StudyRoomParticipantScalarFieldEnum[]
  }

  /**
   * StudyRoom.messages
   */
  export type StudyRoom$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomMessage
     */
    select?: StudyRoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomMessageInclude<ExtArgs> | null
    where?: StudyRoomMessageWhereInput
    orderBy?: StudyRoomMessageOrderByWithRelationInput | StudyRoomMessageOrderByWithRelationInput[]
    cursor?: StudyRoomMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudyRoomMessageScalarFieldEnum | StudyRoomMessageScalarFieldEnum[]
  }

  /**
   * StudyRoom without action
   */
  export type StudyRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoom
     */
    select?: StudyRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomInclude<ExtArgs> | null
  }


  /**
   * Model StudyRoomParticipant
   */

  export type AggregateStudyRoomParticipant = {
    _count: StudyRoomParticipantCountAggregateOutputType | null
    _min: StudyRoomParticipantMinAggregateOutputType | null
    _max: StudyRoomParticipantMaxAggregateOutputType | null
  }

  export type StudyRoomParticipantMinAggregateOutputType = {
    id: string | null
    studyRoomId: string | null
    userId: string | null
    isHost: boolean | null
    joinedAt: Date | null
    leftAt: Date | null
    isActive: boolean | null
  }

  export type StudyRoomParticipantMaxAggregateOutputType = {
    id: string | null
    studyRoomId: string | null
    userId: string | null
    isHost: boolean | null
    joinedAt: Date | null
    leftAt: Date | null
    isActive: boolean | null
  }

  export type StudyRoomParticipantCountAggregateOutputType = {
    id: number
    studyRoomId: number
    userId: number
    isHost: number
    joinedAt: number
    leftAt: number
    isActive: number
    _all: number
  }


  export type StudyRoomParticipantMinAggregateInputType = {
    id?: true
    studyRoomId?: true
    userId?: true
    isHost?: true
    joinedAt?: true
    leftAt?: true
    isActive?: true
  }

  export type StudyRoomParticipantMaxAggregateInputType = {
    id?: true
    studyRoomId?: true
    userId?: true
    isHost?: true
    joinedAt?: true
    leftAt?: true
    isActive?: true
  }

  export type StudyRoomParticipantCountAggregateInputType = {
    id?: true
    studyRoomId?: true
    userId?: true
    isHost?: true
    joinedAt?: true
    leftAt?: true
    isActive?: true
    _all?: true
  }

  export type StudyRoomParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyRoomParticipant to aggregate.
     */
    where?: StudyRoomParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyRoomParticipants to fetch.
     */
    orderBy?: StudyRoomParticipantOrderByWithRelationInput | StudyRoomParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudyRoomParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyRoomParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyRoomParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudyRoomParticipants
    **/
    _count?: true | StudyRoomParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudyRoomParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudyRoomParticipantMaxAggregateInputType
  }

  export type GetStudyRoomParticipantAggregateType<T extends StudyRoomParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateStudyRoomParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudyRoomParticipant[P]>
      : GetScalarType<T[P], AggregateStudyRoomParticipant[P]>
  }




  export type StudyRoomParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyRoomParticipantWhereInput
    orderBy?: StudyRoomParticipantOrderByWithAggregationInput | StudyRoomParticipantOrderByWithAggregationInput[]
    by: StudyRoomParticipantScalarFieldEnum[] | StudyRoomParticipantScalarFieldEnum
    having?: StudyRoomParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudyRoomParticipantCountAggregateInputType | true
    _min?: StudyRoomParticipantMinAggregateInputType
    _max?: StudyRoomParticipantMaxAggregateInputType
  }

  export type StudyRoomParticipantGroupByOutputType = {
    id: string
    studyRoomId: string
    userId: string
    isHost: boolean
    joinedAt: Date
    leftAt: Date | null
    isActive: boolean
    _count: StudyRoomParticipantCountAggregateOutputType | null
    _min: StudyRoomParticipantMinAggregateOutputType | null
    _max: StudyRoomParticipantMaxAggregateOutputType | null
  }

  type GetStudyRoomParticipantGroupByPayload<T extends StudyRoomParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudyRoomParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudyRoomParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudyRoomParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], StudyRoomParticipantGroupByOutputType[P]>
        }
      >
    >


  export type StudyRoomParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studyRoomId?: boolean
    userId?: boolean
    isHost?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    isActive?: boolean
    studyRoom?: boolean | StudyRoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyRoomParticipant"]>

  export type StudyRoomParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studyRoomId?: boolean
    userId?: boolean
    isHost?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    isActive?: boolean
    studyRoom?: boolean | StudyRoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyRoomParticipant"]>

  export type StudyRoomParticipantSelectScalar = {
    id?: boolean
    studyRoomId?: boolean
    userId?: boolean
    isHost?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    isActive?: boolean
  }

  export type StudyRoomParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studyRoom?: boolean | StudyRoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StudyRoomParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studyRoom?: boolean | StudyRoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StudyRoomParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudyRoomParticipant"
    objects: {
      studyRoom: Prisma.$StudyRoomPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studyRoomId: string
      userId: string
      isHost: boolean
      joinedAt: Date
      leftAt: Date | null
      isActive: boolean
    }, ExtArgs["result"]["studyRoomParticipant"]>
    composites: {}
  }

  type StudyRoomParticipantGetPayload<S extends boolean | null | undefined | StudyRoomParticipantDefaultArgs> = $Result.GetResult<Prisma.$StudyRoomParticipantPayload, S>

  type StudyRoomParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudyRoomParticipantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudyRoomParticipantCountAggregateInputType | true
    }

  export interface StudyRoomParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudyRoomParticipant'], meta: { name: 'StudyRoomParticipant' } }
    /**
     * Find zero or one StudyRoomParticipant that matches the filter.
     * @param {StudyRoomParticipantFindUniqueArgs} args - Arguments to find a StudyRoomParticipant
     * @example
     * // Get one StudyRoomParticipant
     * const studyRoomParticipant = await prisma.studyRoomParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudyRoomParticipantFindUniqueArgs>(args: SelectSubset<T, StudyRoomParticipantFindUniqueArgs<ExtArgs>>): Prisma__StudyRoomParticipantClient<$Result.GetResult<Prisma.$StudyRoomParticipantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudyRoomParticipant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudyRoomParticipantFindUniqueOrThrowArgs} args - Arguments to find a StudyRoomParticipant
     * @example
     * // Get one StudyRoomParticipant
     * const studyRoomParticipant = await prisma.studyRoomParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudyRoomParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, StudyRoomParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudyRoomParticipantClient<$Result.GetResult<Prisma.$StudyRoomParticipantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudyRoomParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomParticipantFindFirstArgs} args - Arguments to find a StudyRoomParticipant
     * @example
     * // Get one StudyRoomParticipant
     * const studyRoomParticipant = await prisma.studyRoomParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudyRoomParticipantFindFirstArgs>(args?: SelectSubset<T, StudyRoomParticipantFindFirstArgs<ExtArgs>>): Prisma__StudyRoomParticipantClient<$Result.GetResult<Prisma.$StudyRoomParticipantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudyRoomParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomParticipantFindFirstOrThrowArgs} args - Arguments to find a StudyRoomParticipant
     * @example
     * // Get one StudyRoomParticipant
     * const studyRoomParticipant = await prisma.studyRoomParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudyRoomParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, StudyRoomParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudyRoomParticipantClient<$Result.GetResult<Prisma.$StudyRoomParticipantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudyRoomParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudyRoomParticipants
     * const studyRoomParticipants = await prisma.studyRoomParticipant.findMany()
     * 
     * // Get first 10 StudyRoomParticipants
     * const studyRoomParticipants = await prisma.studyRoomParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studyRoomParticipantWithIdOnly = await prisma.studyRoomParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudyRoomParticipantFindManyArgs>(args?: SelectSubset<T, StudyRoomParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyRoomParticipantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudyRoomParticipant.
     * @param {StudyRoomParticipantCreateArgs} args - Arguments to create a StudyRoomParticipant.
     * @example
     * // Create one StudyRoomParticipant
     * const StudyRoomParticipant = await prisma.studyRoomParticipant.create({
     *   data: {
     *     // ... data to create a StudyRoomParticipant
     *   }
     * })
     * 
     */
    create<T extends StudyRoomParticipantCreateArgs>(args: SelectSubset<T, StudyRoomParticipantCreateArgs<ExtArgs>>): Prisma__StudyRoomParticipantClient<$Result.GetResult<Prisma.$StudyRoomParticipantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudyRoomParticipants.
     * @param {StudyRoomParticipantCreateManyArgs} args - Arguments to create many StudyRoomParticipants.
     * @example
     * // Create many StudyRoomParticipants
     * const studyRoomParticipant = await prisma.studyRoomParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudyRoomParticipantCreateManyArgs>(args?: SelectSubset<T, StudyRoomParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudyRoomParticipants and returns the data saved in the database.
     * @param {StudyRoomParticipantCreateManyAndReturnArgs} args - Arguments to create many StudyRoomParticipants.
     * @example
     * // Create many StudyRoomParticipants
     * const studyRoomParticipant = await prisma.studyRoomParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudyRoomParticipants and only return the `id`
     * const studyRoomParticipantWithIdOnly = await prisma.studyRoomParticipant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudyRoomParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, StudyRoomParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyRoomParticipantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudyRoomParticipant.
     * @param {StudyRoomParticipantDeleteArgs} args - Arguments to delete one StudyRoomParticipant.
     * @example
     * // Delete one StudyRoomParticipant
     * const StudyRoomParticipant = await prisma.studyRoomParticipant.delete({
     *   where: {
     *     // ... filter to delete one StudyRoomParticipant
     *   }
     * })
     * 
     */
    delete<T extends StudyRoomParticipantDeleteArgs>(args: SelectSubset<T, StudyRoomParticipantDeleteArgs<ExtArgs>>): Prisma__StudyRoomParticipantClient<$Result.GetResult<Prisma.$StudyRoomParticipantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudyRoomParticipant.
     * @param {StudyRoomParticipantUpdateArgs} args - Arguments to update one StudyRoomParticipant.
     * @example
     * // Update one StudyRoomParticipant
     * const studyRoomParticipant = await prisma.studyRoomParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudyRoomParticipantUpdateArgs>(args: SelectSubset<T, StudyRoomParticipantUpdateArgs<ExtArgs>>): Prisma__StudyRoomParticipantClient<$Result.GetResult<Prisma.$StudyRoomParticipantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudyRoomParticipants.
     * @param {StudyRoomParticipantDeleteManyArgs} args - Arguments to filter StudyRoomParticipants to delete.
     * @example
     * // Delete a few StudyRoomParticipants
     * const { count } = await prisma.studyRoomParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudyRoomParticipantDeleteManyArgs>(args?: SelectSubset<T, StudyRoomParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudyRoomParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudyRoomParticipants
     * const studyRoomParticipant = await prisma.studyRoomParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudyRoomParticipantUpdateManyArgs>(args: SelectSubset<T, StudyRoomParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudyRoomParticipant.
     * @param {StudyRoomParticipantUpsertArgs} args - Arguments to update or create a StudyRoomParticipant.
     * @example
     * // Update or create a StudyRoomParticipant
     * const studyRoomParticipant = await prisma.studyRoomParticipant.upsert({
     *   create: {
     *     // ... data to create a StudyRoomParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudyRoomParticipant we want to update
     *   }
     * })
     */
    upsert<T extends StudyRoomParticipantUpsertArgs>(args: SelectSubset<T, StudyRoomParticipantUpsertArgs<ExtArgs>>): Prisma__StudyRoomParticipantClient<$Result.GetResult<Prisma.$StudyRoomParticipantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudyRoomParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomParticipantCountArgs} args - Arguments to filter StudyRoomParticipants to count.
     * @example
     * // Count the number of StudyRoomParticipants
     * const count = await prisma.studyRoomParticipant.count({
     *   where: {
     *     // ... the filter for the StudyRoomParticipants we want to count
     *   }
     * })
    **/
    count<T extends StudyRoomParticipantCountArgs>(
      args?: Subset<T, StudyRoomParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudyRoomParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudyRoomParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudyRoomParticipantAggregateArgs>(args: Subset<T, StudyRoomParticipantAggregateArgs>): Prisma.PrismaPromise<GetStudyRoomParticipantAggregateType<T>>

    /**
     * Group by StudyRoomParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudyRoomParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudyRoomParticipantGroupByArgs['orderBy'] }
        : { orderBy?: StudyRoomParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudyRoomParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudyRoomParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudyRoomParticipant model
   */
  readonly fields: StudyRoomParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudyRoomParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudyRoomParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    studyRoom<T extends StudyRoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudyRoomDefaultArgs<ExtArgs>>): Prisma__StudyRoomClient<$Result.GetResult<Prisma.$StudyRoomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudyRoomParticipant model
   */ 
  interface StudyRoomParticipantFieldRefs {
    readonly id: FieldRef<"StudyRoomParticipant", 'String'>
    readonly studyRoomId: FieldRef<"StudyRoomParticipant", 'String'>
    readonly userId: FieldRef<"StudyRoomParticipant", 'String'>
    readonly isHost: FieldRef<"StudyRoomParticipant", 'Boolean'>
    readonly joinedAt: FieldRef<"StudyRoomParticipant", 'DateTime'>
    readonly leftAt: FieldRef<"StudyRoomParticipant", 'DateTime'>
    readonly isActive: FieldRef<"StudyRoomParticipant", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * StudyRoomParticipant findUnique
   */
  export type StudyRoomParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomParticipant
     */
    select?: StudyRoomParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomParticipantInclude<ExtArgs> | null
    /**
     * Filter, which StudyRoomParticipant to fetch.
     */
    where: StudyRoomParticipantWhereUniqueInput
  }

  /**
   * StudyRoomParticipant findUniqueOrThrow
   */
  export type StudyRoomParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomParticipant
     */
    select?: StudyRoomParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomParticipantInclude<ExtArgs> | null
    /**
     * Filter, which StudyRoomParticipant to fetch.
     */
    where: StudyRoomParticipantWhereUniqueInput
  }

  /**
   * StudyRoomParticipant findFirst
   */
  export type StudyRoomParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomParticipant
     */
    select?: StudyRoomParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomParticipantInclude<ExtArgs> | null
    /**
     * Filter, which StudyRoomParticipant to fetch.
     */
    where?: StudyRoomParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyRoomParticipants to fetch.
     */
    orderBy?: StudyRoomParticipantOrderByWithRelationInput | StudyRoomParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyRoomParticipants.
     */
    cursor?: StudyRoomParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyRoomParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyRoomParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyRoomParticipants.
     */
    distinct?: StudyRoomParticipantScalarFieldEnum | StudyRoomParticipantScalarFieldEnum[]
  }

  /**
   * StudyRoomParticipant findFirstOrThrow
   */
  export type StudyRoomParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomParticipant
     */
    select?: StudyRoomParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomParticipantInclude<ExtArgs> | null
    /**
     * Filter, which StudyRoomParticipant to fetch.
     */
    where?: StudyRoomParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyRoomParticipants to fetch.
     */
    orderBy?: StudyRoomParticipantOrderByWithRelationInput | StudyRoomParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyRoomParticipants.
     */
    cursor?: StudyRoomParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyRoomParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyRoomParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyRoomParticipants.
     */
    distinct?: StudyRoomParticipantScalarFieldEnum | StudyRoomParticipantScalarFieldEnum[]
  }

  /**
   * StudyRoomParticipant findMany
   */
  export type StudyRoomParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomParticipant
     */
    select?: StudyRoomParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomParticipantInclude<ExtArgs> | null
    /**
     * Filter, which StudyRoomParticipants to fetch.
     */
    where?: StudyRoomParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyRoomParticipants to fetch.
     */
    orderBy?: StudyRoomParticipantOrderByWithRelationInput | StudyRoomParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudyRoomParticipants.
     */
    cursor?: StudyRoomParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyRoomParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyRoomParticipants.
     */
    skip?: number
    distinct?: StudyRoomParticipantScalarFieldEnum | StudyRoomParticipantScalarFieldEnum[]
  }

  /**
   * StudyRoomParticipant create
   */
  export type StudyRoomParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomParticipant
     */
    select?: StudyRoomParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a StudyRoomParticipant.
     */
    data: XOR<StudyRoomParticipantCreateInput, StudyRoomParticipantUncheckedCreateInput>
  }

  /**
   * StudyRoomParticipant createMany
   */
  export type StudyRoomParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudyRoomParticipants.
     */
    data: StudyRoomParticipantCreateManyInput | StudyRoomParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudyRoomParticipant createManyAndReturn
   */
  export type StudyRoomParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomParticipant
     */
    select?: StudyRoomParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudyRoomParticipants.
     */
    data: StudyRoomParticipantCreateManyInput | StudyRoomParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudyRoomParticipant update
   */
  export type StudyRoomParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomParticipant
     */
    select?: StudyRoomParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a StudyRoomParticipant.
     */
    data: XOR<StudyRoomParticipantUpdateInput, StudyRoomParticipantUncheckedUpdateInput>
    /**
     * Choose, which StudyRoomParticipant to update.
     */
    where: StudyRoomParticipantWhereUniqueInput
  }

  /**
   * StudyRoomParticipant updateMany
   */
  export type StudyRoomParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudyRoomParticipants.
     */
    data: XOR<StudyRoomParticipantUpdateManyMutationInput, StudyRoomParticipantUncheckedUpdateManyInput>
    /**
     * Filter which StudyRoomParticipants to update
     */
    where?: StudyRoomParticipantWhereInput
  }

  /**
   * StudyRoomParticipant upsert
   */
  export type StudyRoomParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomParticipant
     */
    select?: StudyRoomParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the StudyRoomParticipant to update in case it exists.
     */
    where: StudyRoomParticipantWhereUniqueInput
    /**
     * In case the StudyRoomParticipant found by the `where` argument doesn't exist, create a new StudyRoomParticipant with this data.
     */
    create: XOR<StudyRoomParticipantCreateInput, StudyRoomParticipantUncheckedCreateInput>
    /**
     * In case the StudyRoomParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudyRoomParticipantUpdateInput, StudyRoomParticipantUncheckedUpdateInput>
  }

  /**
   * StudyRoomParticipant delete
   */
  export type StudyRoomParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomParticipant
     */
    select?: StudyRoomParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomParticipantInclude<ExtArgs> | null
    /**
     * Filter which StudyRoomParticipant to delete.
     */
    where: StudyRoomParticipantWhereUniqueInput
  }

  /**
   * StudyRoomParticipant deleteMany
   */
  export type StudyRoomParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyRoomParticipants to delete
     */
    where?: StudyRoomParticipantWhereInput
  }

  /**
   * StudyRoomParticipant without action
   */
  export type StudyRoomParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomParticipant
     */
    select?: StudyRoomParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomParticipantInclude<ExtArgs> | null
  }


  /**
   * Model StudyRoomMessage
   */

  export type AggregateStudyRoomMessage = {
    _count: StudyRoomMessageCountAggregateOutputType | null
    _min: StudyRoomMessageMinAggregateOutputType | null
    _max: StudyRoomMessageMaxAggregateOutputType | null
  }

  export type StudyRoomMessageMinAggregateOutputType = {
    id: string | null
    studyRoomId: string | null
    userId: string | null
    message: string | null
    messageType: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type StudyRoomMessageMaxAggregateOutputType = {
    id: string | null
    studyRoomId: string | null
    userId: string | null
    message: string | null
    messageType: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type StudyRoomMessageCountAggregateOutputType = {
    id: number
    studyRoomId: number
    userId: number
    message: number
    messageType: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type StudyRoomMessageMinAggregateInputType = {
    id?: true
    studyRoomId?: true
    userId?: true
    message?: true
    messageType?: true
    metadata?: true
    createdAt?: true
  }

  export type StudyRoomMessageMaxAggregateInputType = {
    id?: true
    studyRoomId?: true
    userId?: true
    message?: true
    messageType?: true
    metadata?: true
    createdAt?: true
  }

  export type StudyRoomMessageCountAggregateInputType = {
    id?: true
    studyRoomId?: true
    userId?: true
    message?: true
    messageType?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type StudyRoomMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyRoomMessage to aggregate.
     */
    where?: StudyRoomMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyRoomMessages to fetch.
     */
    orderBy?: StudyRoomMessageOrderByWithRelationInput | StudyRoomMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudyRoomMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyRoomMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyRoomMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudyRoomMessages
    **/
    _count?: true | StudyRoomMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudyRoomMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudyRoomMessageMaxAggregateInputType
  }

  export type GetStudyRoomMessageAggregateType<T extends StudyRoomMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateStudyRoomMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudyRoomMessage[P]>
      : GetScalarType<T[P], AggregateStudyRoomMessage[P]>
  }




  export type StudyRoomMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyRoomMessageWhereInput
    orderBy?: StudyRoomMessageOrderByWithAggregationInput | StudyRoomMessageOrderByWithAggregationInput[]
    by: StudyRoomMessageScalarFieldEnum[] | StudyRoomMessageScalarFieldEnum
    having?: StudyRoomMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudyRoomMessageCountAggregateInputType | true
    _min?: StudyRoomMessageMinAggregateInputType
    _max?: StudyRoomMessageMaxAggregateInputType
  }

  export type StudyRoomMessageGroupByOutputType = {
    id: string
    studyRoomId: string
    userId: string
    message: string
    messageType: string
    metadata: string | null
    createdAt: Date
    _count: StudyRoomMessageCountAggregateOutputType | null
    _min: StudyRoomMessageMinAggregateOutputType | null
    _max: StudyRoomMessageMaxAggregateOutputType | null
  }

  type GetStudyRoomMessageGroupByPayload<T extends StudyRoomMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudyRoomMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudyRoomMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudyRoomMessageGroupByOutputType[P]>
            : GetScalarType<T[P], StudyRoomMessageGroupByOutputType[P]>
        }
      >
    >


  export type StudyRoomMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studyRoomId?: boolean
    userId?: boolean
    message?: boolean
    messageType?: boolean
    metadata?: boolean
    createdAt?: boolean
    studyRoom?: boolean | StudyRoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyRoomMessage"]>

  export type StudyRoomMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studyRoomId?: boolean
    userId?: boolean
    message?: boolean
    messageType?: boolean
    metadata?: boolean
    createdAt?: boolean
    studyRoom?: boolean | StudyRoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyRoomMessage"]>

  export type StudyRoomMessageSelectScalar = {
    id?: boolean
    studyRoomId?: boolean
    userId?: boolean
    message?: boolean
    messageType?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type StudyRoomMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studyRoom?: boolean | StudyRoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StudyRoomMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studyRoom?: boolean | StudyRoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StudyRoomMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudyRoomMessage"
    objects: {
      studyRoom: Prisma.$StudyRoomPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studyRoomId: string
      userId: string
      message: string
      messageType: string
      metadata: string | null
      createdAt: Date
    }, ExtArgs["result"]["studyRoomMessage"]>
    composites: {}
  }

  type StudyRoomMessageGetPayload<S extends boolean | null | undefined | StudyRoomMessageDefaultArgs> = $Result.GetResult<Prisma.$StudyRoomMessagePayload, S>

  type StudyRoomMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudyRoomMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudyRoomMessageCountAggregateInputType | true
    }

  export interface StudyRoomMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudyRoomMessage'], meta: { name: 'StudyRoomMessage' } }
    /**
     * Find zero or one StudyRoomMessage that matches the filter.
     * @param {StudyRoomMessageFindUniqueArgs} args - Arguments to find a StudyRoomMessage
     * @example
     * // Get one StudyRoomMessage
     * const studyRoomMessage = await prisma.studyRoomMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudyRoomMessageFindUniqueArgs>(args: SelectSubset<T, StudyRoomMessageFindUniqueArgs<ExtArgs>>): Prisma__StudyRoomMessageClient<$Result.GetResult<Prisma.$StudyRoomMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudyRoomMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudyRoomMessageFindUniqueOrThrowArgs} args - Arguments to find a StudyRoomMessage
     * @example
     * // Get one StudyRoomMessage
     * const studyRoomMessage = await prisma.studyRoomMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudyRoomMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, StudyRoomMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudyRoomMessageClient<$Result.GetResult<Prisma.$StudyRoomMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudyRoomMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomMessageFindFirstArgs} args - Arguments to find a StudyRoomMessage
     * @example
     * // Get one StudyRoomMessage
     * const studyRoomMessage = await prisma.studyRoomMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudyRoomMessageFindFirstArgs>(args?: SelectSubset<T, StudyRoomMessageFindFirstArgs<ExtArgs>>): Prisma__StudyRoomMessageClient<$Result.GetResult<Prisma.$StudyRoomMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudyRoomMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomMessageFindFirstOrThrowArgs} args - Arguments to find a StudyRoomMessage
     * @example
     * // Get one StudyRoomMessage
     * const studyRoomMessage = await prisma.studyRoomMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudyRoomMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, StudyRoomMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudyRoomMessageClient<$Result.GetResult<Prisma.$StudyRoomMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudyRoomMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudyRoomMessages
     * const studyRoomMessages = await prisma.studyRoomMessage.findMany()
     * 
     * // Get first 10 StudyRoomMessages
     * const studyRoomMessages = await prisma.studyRoomMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studyRoomMessageWithIdOnly = await prisma.studyRoomMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudyRoomMessageFindManyArgs>(args?: SelectSubset<T, StudyRoomMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyRoomMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudyRoomMessage.
     * @param {StudyRoomMessageCreateArgs} args - Arguments to create a StudyRoomMessage.
     * @example
     * // Create one StudyRoomMessage
     * const StudyRoomMessage = await prisma.studyRoomMessage.create({
     *   data: {
     *     // ... data to create a StudyRoomMessage
     *   }
     * })
     * 
     */
    create<T extends StudyRoomMessageCreateArgs>(args: SelectSubset<T, StudyRoomMessageCreateArgs<ExtArgs>>): Prisma__StudyRoomMessageClient<$Result.GetResult<Prisma.$StudyRoomMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudyRoomMessages.
     * @param {StudyRoomMessageCreateManyArgs} args - Arguments to create many StudyRoomMessages.
     * @example
     * // Create many StudyRoomMessages
     * const studyRoomMessage = await prisma.studyRoomMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudyRoomMessageCreateManyArgs>(args?: SelectSubset<T, StudyRoomMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudyRoomMessages and returns the data saved in the database.
     * @param {StudyRoomMessageCreateManyAndReturnArgs} args - Arguments to create many StudyRoomMessages.
     * @example
     * // Create many StudyRoomMessages
     * const studyRoomMessage = await prisma.studyRoomMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudyRoomMessages and only return the `id`
     * const studyRoomMessageWithIdOnly = await prisma.studyRoomMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudyRoomMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, StudyRoomMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyRoomMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudyRoomMessage.
     * @param {StudyRoomMessageDeleteArgs} args - Arguments to delete one StudyRoomMessage.
     * @example
     * // Delete one StudyRoomMessage
     * const StudyRoomMessage = await prisma.studyRoomMessage.delete({
     *   where: {
     *     // ... filter to delete one StudyRoomMessage
     *   }
     * })
     * 
     */
    delete<T extends StudyRoomMessageDeleteArgs>(args: SelectSubset<T, StudyRoomMessageDeleteArgs<ExtArgs>>): Prisma__StudyRoomMessageClient<$Result.GetResult<Prisma.$StudyRoomMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudyRoomMessage.
     * @param {StudyRoomMessageUpdateArgs} args - Arguments to update one StudyRoomMessage.
     * @example
     * // Update one StudyRoomMessage
     * const studyRoomMessage = await prisma.studyRoomMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudyRoomMessageUpdateArgs>(args: SelectSubset<T, StudyRoomMessageUpdateArgs<ExtArgs>>): Prisma__StudyRoomMessageClient<$Result.GetResult<Prisma.$StudyRoomMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudyRoomMessages.
     * @param {StudyRoomMessageDeleteManyArgs} args - Arguments to filter StudyRoomMessages to delete.
     * @example
     * // Delete a few StudyRoomMessages
     * const { count } = await prisma.studyRoomMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudyRoomMessageDeleteManyArgs>(args?: SelectSubset<T, StudyRoomMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudyRoomMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudyRoomMessages
     * const studyRoomMessage = await prisma.studyRoomMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudyRoomMessageUpdateManyArgs>(args: SelectSubset<T, StudyRoomMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudyRoomMessage.
     * @param {StudyRoomMessageUpsertArgs} args - Arguments to update or create a StudyRoomMessage.
     * @example
     * // Update or create a StudyRoomMessage
     * const studyRoomMessage = await prisma.studyRoomMessage.upsert({
     *   create: {
     *     // ... data to create a StudyRoomMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudyRoomMessage we want to update
     *   }
     * })
     */
    upsert<T extends StudyRoomMessageUpsertArgs>(args: SelectSubset<T, StudyRoomMessageUpsertArgs<ExtArgs>>): Prisma__StudyRoomMessageClient<$Result.GetResult<Prisma.$StudyRoomMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudyRoomMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomMessageCountArgs} args - Arguments to filter StudyRoomMessages to count.
     * @example
     * // Count the number of StudyRoomMessages
     * const count = await prisma.studyRoomMessage.count({
     *   where: {
     *     // ... the filter for the StudyRoomMessages we want to count
     *   }
     * })
    **/
    count<T extends StudyRoomMessageCountArgs>(
      args?: Subset<T, StudyRoomMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudyRoomMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudyRoomMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudyRoomMessageAggregateArgs>(args: Subset<T, StudyRoomMessageAggregateArgs>): Prisma.PrismaPromise<GetStudyRoomMessageAggregateType<T>>

    /**
     * Group by StudyRoomMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyRoomMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudyRoomMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudyRoomMessageGroupByArgs['orderBy'] }
        : { orderBy?: StudyRoomMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudyRoomMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudyRoomMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudyRoomMessage model
   */
  readonly fields: StudyRoomMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudyRoomMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudyRoomMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    studyRoom<T extends StudyRoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudyRoomDefaultArgs<ExtArgs>>): Prisma__StudyRoomClient<$Result.GetResult<Prisma.$StudyRoomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudyRoomMessage model
   */ 
  interface StudyRoomMessageFieldRefs {
    readonly id: FieldRef<"StudyRoomMessage", 'String'>
    readonly studyRoomId: FieldRef<"StudyRoomMessage", 'String'>
    readonly userId: FieldRef<"StudyRoomMessage", 'String'>
    readonly message: FieldRef<"StudyRoomMessage", 'String'>
    readonly messageType: FieldRef<"StudyRoomMessage", 'String'>
    readonly metadata: FieldRef<"StudyRoomMessage", 'String'>
    readonly createdAt: FieldRef<"StudyRoomMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudyRoomMessage findUnique
   */
  export type StudyRoomMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomMessage
     */
    select?: StudyRoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomMessageInclude<ExtArgs> | null
    /**
     * Filter, which StudyRoomMessage to fetch.
     */
    where: StudyRoomMessageWhereUniqueInput
  }

  /**
   * StudyRoomMessage findUniqueOrThrow
   */
  export type StudyRoomMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomMessage
     */
    select?: StudyRoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomMessageInclude<ExtArgs> | null
    /**
     * Filter, which StudyRoomMessage to fetch.
     */
    where: StudyRoomMessageWhereUniqueInput
  }

  /**
   * StudyRoomMessage findFirst
   */
  export type StudyRoomMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomMessage
     */
    select?: StudyRoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomMessageInclude<ExtArgs> | null
    /**
     * Filter, which StudyRoomMessage to fetch.
     */
    where?: StudyRoomMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyRoomMessages to fetch.
     */
    orderBy?: StudyRoomMessageOrderByWithRelationInput | StudyRoomMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyRoomMessages.
     */
    cursor?: StudyRoomMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyRoomMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyRoomMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyRoomMessages.
     */
    distinct?: StudyRoomMessageScalarFieldEnum | StudyRoomMessageScalarFieldEnum[]
  }

  /**
   * StudyRoomMessage findFirstOrThrow
   */
  export type StudyRoomMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomMessage
     */
    select?: StudyRoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomMessageInclude<ExtArgs> | null
    /**
     * Filter, which StudyRoomMessage to fetch.
     */
    where?: StudyRoomMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyRoomMessages to fetch.
     */
    orderBy?: StudyRoomMessageOrderByWithRelationInput | StudyRoomMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyRoomMessages.
     */
    cursor?: StudyRoomMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyRoomMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyRoomMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyRoomMessages.
     */
    distinct?: StudyRoomMessageScalarFieldEnum | StudyRoomMessageScalarFieldEnum[]
  }

  /**
   * StudyRoomMessage findMany
   */
  export type StudyRoomMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomMessage
     */
    select?: StudyRoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomMessageInclude<ExtArgs> | null
    /**
     * Filter, which StudyRoomMessages to fetch.
     */
    where?: StudyRoomMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyRoomMessages to fetch.
     */
    orderBy?: StudyRoomMessageOrderByWithRelationInput | StudyRoomMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudyRoomMessages.
     */
    cursor?: StudyRoomMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyRoomMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyRoomMessages.
     */
    skip?: number
    distinct?: StudyRoomMessageScalarFieldEnum | StudyRoomMessageScalarFieldEnum[]
  }

  /**
   * StudyRoomMessage create
   */
  export type StudyRoomMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomMessage
     */
    select?: StudyRoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a StudyRoomMessage.
     */
    data: XOR<StudyRoomMessageCreateInput, StudyRoomMessageUncheckedCreateInput>
  }

  /**
   * StudyRoomMessage createMany
   */
  export type StudyRoomMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudyRoomMessages.
     */
    data: StudyRoomMessageCreateManyInput | StudyRoomMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudyRoomMessage createManyAndReturn
   */
  export type StudyRoomMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomMessage
     */
    select?: StudyRoomMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudyRoomMessages.
     */
    data: StudyRoomMessageCreateManyInput | StudyRoomMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudyRoomMessage update
   */
  export type StudyRoomMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomMessage
     */
    select?: StudyRoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a StudyRoomMessage.
     */
    data: XOR<StudyRoomMessageUpdateInput, StudyRoomMessageUncheckedUpdateInput>
    /**
     * Choose, which StudyRoomMessage to update.
     */
    where: StudyRoomMessageWhereUniqueInput
  }

  /**
   * StudyRoomMessage updateMany
   */
  export type StudyRoomMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudyRoomMessages.
     */
    data: XOR<StudyRoomMessageUpdateManyMutationInput, StudyRoomMessageUncheckedUpdateManyInput>
    /**
     * Filter which StudyRoomMessages to update
     */
    where?: StudyRoomMessageWhereInput
  }

  /**
   * StudyRoomMessage upsert
   */
  export type StudyRoomMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomMessage
     */
    select?: StudyRoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the StudyRoomMessage to update in case it exists.
     */
    where: StudyRoomMessageWhereUniqueInput
    /**
     * In case the StudyRoomMessage found by the `where` argument doesn't exist, create a new StudyRoomMessage with this data.
     */
    create: XOR<StudyRoomMessageCreateInput, StudyRoomMessageUncheckedCreateInput>
    /**
     * In case the StudyRoomMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudyRoomMessageUpdateInput, StudyRoomMessageUncheckedUpdateInput>
  }

  /**
   * StudyRoomMessage delete
   */
  export type StudyRoomMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomMessage
     */
    select?: StudyRoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomMessageInclude<ExtArgs> | null
    /**
     * Filter which StudyRoomMessage to delete.
     */
    where: StudyRoomMessageWhereUniqueInput
  }

  /**
   * StudyRoomMessage deleteMany
   */
  export type StudyRoomMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyRoomMessages to delete
     */
    where?: StudyRoomMessageWhereInput
  }

  /**
   * StudyRoomMessage without action
   */
  export type StudyRoomMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyRoomMessage
     */
    select?: StudyRoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyRoomMessageInclude<ExtArgs> | null
  }


  /**
   * Model FeedbackReport
   */

  export type AggregateFeedbackReport = {
    _count: FeedbackReportCountAggregateOutputType | null
    _avg: FeedbackReportAvgAggregateOutputType | null
    _sum: FeedbackReportSumAggregateOutputType | null
    _min: FeedbackReportMinAggregateOutputType | null
    _max: FeedbackReportMaxAggregateOutputType | null
  }

  export type FeedbackReportAvgAggregateOutputType = {
    upvotes: number | null
    downvotes: number | null
  }

  export type FeedbackReportSumAggregateOutputType = {
    upvotes: number | null
    downvotes: number | null
  }

  export type FeedbackReportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.FeedbackType | null
    title: string | null
    description: string | null
    priority: $Enums.FeedbackPriority | null
    category: string | null
    status: $Enums.FeedbackStatus | null
    adminResponse: string | null
    adminUserId: string | null
    resolvedAt: Date | null
    upvotes: number | null
    downvotes: number | null
    duplicateOf: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedbackReportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.FeedbackType | null
    title: string | null
    description: string | null
    priority: $Enums.FeedbackPriority | null
    category: string | null
    status: $Enums.FeedbackStatus | null
    adminResponse: string | null
    adminUserId: string | null
    resolvedAt: Date | null
    upvotes: number | null
    downvotes: number | null
    duplicateOf: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedbackReportCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    description: number
    priority: number
    category: number
    status: number
    elementContext: number
    technicalContext: number
    codeAnalysis: number
    aiSuggestions: number
    adminResponse: number
    adminUserId: number
    resolvedAt: number
    upvotes: number
    downvotes: number
    duplicateOf: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeedbackReportAvgAggregateInputType = {
    upvotes?: true
    downvotes?: true
  }

  export type FeedbackReportSumAggregateInputType = {
    upvotes?: true
    downvotes?: true
  }

  export type FeedbackReportMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    priority?: true
    category?: true
    status?: true
    adminResponse?: true
    adminUserId?: true
    resolvedAt?: true
    upvotes?: true
    downvotes?: true
    duplicateOf?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedbackReportMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    priority?: true
    category?: true
    status?: true
    adminResponse?: true
    adminUserId?: true
    resolvedAt?: true
    upvotes?: true
    downvotes?: true
    duplicateOf?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedbackReportCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    description?: true
    priority?: true
    category?: true
    status?: true
    elementContext?: true
    technicalContext?: true
    codeAnalysis?: true
    aiSuggestions?: true
    adminResponse?: true
    adminUserId?: true
    resolvedAt?: true
    upvotes?: true
    downvotes?: true
    duplicateOf?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeedbackReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackReport to aggregate.
     */
    where?: FeedbackReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackReports to fetch.
     */
    orderBy?: FeedbackReportOrderByWithRelationInput | FeedbackReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedbackReports
    **/
    _count?: true | FeedbackReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackReportMaxAggregateInputType
  }

  export type GetFeedbackReportAggregateType<T extends FeedbackReportAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedbackReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedbackReport[P]>
      : GetScalarType<T[P], AggregateFeedbackReport[P]>
  }




  export type FeedbackReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackReportWhereInput
    orderBy?: FeedbackReportOrderByWithAggregationInput | FeedbackReportOrderByWithAggregationInput[]
    by: FeedbackReportScalarFieldEnum[] | FeedbackReportScalarFieldEnum
    having?: FeedbackReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackReportCountAggregateInputType | true
    _avg?: FeedbackReportAvgAggregateInputType
    _sum?: FeedbackReportSumAggregateInputType
    _min?: FeedbackReportMinAggregateInputType
    _max?: FeedbackReportMaxAggregateInputType
  }

  export type FeedbackReportGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.FeedbackType
    title: string
    description: string
    priority: $Enums.FeedbackPriority
    category: string
    status: $Enums.FeedbackStatus
    elementContext: JsonValue
    technicalContext: JsonValue
    codeAnalysis: JsonValue | null
    aiSuggestions: JsonValue | null
    adminResponse: string | null
    adminUserId: string | null
    resolvedAt: Date | null
    upvotes: number
    downvotes: number
    duplicateOf: string | null
    createdAt: Date
    updatedAt: Date
    _count: FeedbackReportCountAggregateOutputType | null
    _avg: FeedbackReportAvgAggregateOutputType | null
    _sum: FeedbackReportSumAggregateOutputType | null
    _min: FeedbackReportMinAggregateOutputType | null
    _max: FeedbackReportMaxAggregateOutputType | null
  }

  type GetFeedbackReportGroupByPayload<T extends FeedbackReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackReportGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackReportGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    category?: boolean
    status?: boolean
    elementContext?: boolean
    technicalContext?: boolean
    codeAnalysis?: boolean
    aiSuggestions?: boolean
    adminResponse?: boolean
    adminUserId?: boolean
    resolvedAt?: boolean
    upvotes?: boolean
    downvotes?: boolean
    duplicateOf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminUser?: boolean | FeedbackReport$adminUserArgs<ExtArgs>
  }, ExtArgs["result"]["feedbackReport"]>

  export type FeedbackReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    category?: boolean
    status?: boolean
    elementContext?: boolean
    technicalContext?: boolean
    codeAnalysis?: boolean
    aiSuggestions?: boolean
    adminResponse?: boolean
    adminUserId?: boolean
    resolvedAt?: boolean
    upvotes?: boolean
    downvotes?: boolean
    duplicateOf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminUser?: boolean | FeedbackReport$adminUserArgs<ExtArgs>
  }, ExtArgs["result"]["feedbackReport"]>

  export type FeedbackReportSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    category?: boolean
    status?: boolean
    elementContext?: boolean
    technicalContext?: boolean
    codeAnalysis?: boolean
    aiSuggestions?: boolean
    adminResponse?: boolean
    adminUserId?: boolean
    resolvedAt?: boolean
    upvotes?: boolean
    downvotes?: boolean
    duplicateOf?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeedbackReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminUser?: boolean | FeedbackReport$adminUserArgs<ExtArgs>
  }
  export type FeedbackReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    adminUser?: boolean | FeedbackReport$adminUserArgs<ExtArgs>
  }

  export type $FeedbackReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedbackReport"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      adminUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.FeedbackType
      title: string
      description: string
      priority: $Enums.FeedbackPriority
      category: string
      status: $Enums.FeedbackStatus
      elementContext: Prisma.JsonValue
      technicalContext: Prisma.JsonValue
      codeAnalysis: Prisma.JsonValue | null
      aiSuggestions: Prisma.JsonValue | null
      adminResponse: string | null
      adminUserId: string | null
      resolvedAt: Date | null
      upvotes: number
      downvotes: number
      duplicateOf: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feedbackReport"]>
    composites: {}
  }

  type FeedbackReportGetPayload<S extends boolean | null | undefined | FeedbackReportDefaultArgs> = $Result.GetResult<Prisma.$FeedbackReportPayload, S>

  type FeedbackReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedbackReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeedbackReportCountAggregateInputType | true
    }

  export interface FeedbackReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedbackReport'], meta: { name: 'FeedbackReport' } }
    /**
     * Find zero or one FeedbackReport that matches the filter.
     * @param {FeedbackReportFindUniqueArgs} args - Arguments to find a FeedbackReport
     * @example
     * // Get one FeedbackReport
     * const feedbackReport = await prisma.feedbackReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackReportFindUniqueArgs>(args: SelectSubset<T, FeedbackReportFindUniqueArgs<ExtArgs>>): Prisma__FeedbackReportClient<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FeedbackReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeedbackReportFindUniqueOrThrowArgs} args - Arguments to find a FeedbackReport
     * @example
     * // Get one FeedbackReport
     * const feedbackReport = await prisma.feedbackReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackReportFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackReportClient<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FeedbackReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackReportFindFirstArgs} args - Arguments to find a FeedbackReport
     * @example
     * // Get one FeedbackReport
     * const feedbackReport = await prisma.feedbackReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackReportFindFirstArgs>(args?: SelectSubset<T, FeedbackReportFindFirstArgs<ExtArgs>>): Prisma__FeedbackReportClient<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FeedbackReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackReportFindFirstOrThrowArgs} args - Arguments to find a FeedbackReport
     * @example
     * // Get one FeedbackReport
     * const feedbackReport = await prisma.feedbackReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackReportFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackReportClient<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FeedbackReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedbackReports
     * const feedbackReports = await prisma.feedbackReport.findMany()
     * 
     * // Get first 10 FeedbackReports
     * const feedbackReports = await prisma.feedbackReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackReportWithIdOnly = await prisma.feedbackReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackReportFindManyArgs>(args?: SelectSubset<T, FeedbackReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FeedbackReport.
     * @param {FeedbackReportCreateArgs} args - Arguments to create a FeedbackReport.
     * @example
     * // Create one FeedbackReport
     * const FeedbackReport = await prisma.feedbackReport.create({
     *   data: {
     *     // ... data to create a FeedbackReport
     *   }
     * })
     * 
     */
    create<T extends FeedbackReportCreateArgs>(args: SelectSubset<T, FeedbackReportCreateArgs<ExtArgs>>): Prisma__FeedbackReportClient<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FeedbackReports.
     * @param {FeedbackReportCreateManyArgs} args - Arguments to create many FeedbackReports.
     * @example
     * // Create many FeedbackReports
     * const feedbackReport = await prisma.feedbackReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackReportCreateManyArgs>(args?: SelectSubset<T, FeedbackReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeedbackReports and returns the data saved in the database.
     * @param {FeedbackReportCreateManyAndReturnArgs} args - Arguments to create many FeedbackReports.
     * @example
     * // Create many FeedbackReports
     * const feedbackReport = await prisma.feedbackReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeedbackReports and only return the `id`
     * const feedbackReportWithIdOnly = await prisma.feedbackReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedbackReportCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedbackReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FeedbackReport.
     * @param {FeedbackReportDeleteArgs} args - Arguments to delete one FeedbackReport.
     * @example
     * // Delete one FeedbackReport
     * const FeedbackReport = await prisma.feedbackReport.delete({
     *   where: {
     *     // ... filter to delete one FeedbackReport
     *   }
     * })
     * 
     */
    delete<T extends FeedbackReportDeleteArgs>(args: SelectSubset<T, FeedbackReportDeleteArgs<ExtArgs>>): Prisma__FeedbackReportClient<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FeedbackReport.
     * @param {FeedbackReportUpdateArgs} args - Arguments to update one FeedbackReport.
     * @example
     * // Update one FeedbackReport
     * const feedbackReport = await prisma.feedbackReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackReportUpdateArgs>(args: SelectSubset<T, FeedbackReportUpdateArgs<ExtArgs>>): Prisma__FeedbackReportClient<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FeedbackReports.
     * @param {FeedbackReportDeleteManyArgs} args - Arguments to filter FeedbackReports to delete.
     * @example
     * // Delete a few FeedbackReports
     * const { count } = await prisma.feedbackReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackReportDeleteManyArgs>(args?: SelectSubset<T, FeedbackReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedbackReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedbackReports
     * const feedbackReport = await prisma.feedbackReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackReportUpdateManyArgs>(args: SelectSubset<T, FeedbackReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeedbackReport.
     * @param {FeedbackReportUpsertArgs} args - Arguments to update or create a FeedbackReport.
     * @example
     * // Update or create a FeedbackReport
     * const feedbackReport = await prisma.feedbackReport.upsert({
     *   create: {
     *     // ... data to create a FeedbackReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedbackReport we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackReportUpsertArgs>(args: SelectSubset<T, FeedbackReportUpsertArgs<ExtArgs>>): Prisma__FeedbackReportClient<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FeedbackReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackReportCountArgs} args - Arguments to filter FeedbackReports to count.
     * @example
     * // Count the number of FeedbackReports
     * const count = await prisma.feedbackReport.count({
     *   where: {
     *     // ... the filter for the FeedbackReports we want to count
     *   }
     * })
    **/
    count<T extends FeedbackReportCountArgs>(
      args?: Subset<T, FeedbackReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedbackReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackReportAggregateArgs>(args: Subset<T, FeedbackReportAggregateArgs>): Prisma.PrismaPromise<GetFeedbackReportAggregateType<T>>

    /**
     * Group by FeedbackReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackReportGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedbackReport model
   */
  readonly fields: FeedbackReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedbackReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    adminUser<T extends FeedbackReport$adminUserArgs<ExtArgs> = {}>(args?: Subset<T, FeedbackReport$adminUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeedbackReport model
   */ 
  interface FeedbackReportFieldRefs {
    readonly id: FieldRef<"FeedbackReport", 'String'>
    readonly userId: FieldRef<"FeedbackReport", 'String'>
    readonly type: FieldRef<"FeedbackReport", 'FeedbackType'>
    readonly title: FieldRef<"FeedbackReport", 'String'>
    readonly description: FieldRef<"FeedbackReport", 'String'>
    readonly priority: FieldRef<"FeedbackReport", 'FeedbackPriority'>
    readonly category: FieldRef<"FeedbackReport", 'String'>
    readonly status: FieldRef<"FeedbackReport", 'FeedbackStatus'>
    readonly elementContext: FieldRef<"FeedbackReport", 'Json'>
    readonly technicalContext: FieldRef<"FeedbackReport", 'Json'>
    readonly codeAnalysis: FieldRef<"FeedbackReport", 'Json'>
    readonly aiSuggestions: FieldRef<"FeedbackReport", 'Json'>
    readonly adminResponse: FieldRef<"FeedbackReport", 'String'>
    readonly adminUserId: FieldRef<"FeedbackReport", 'String'>
    readonly resolvedAt: FieldRef<"FeedbackReport", 'DateTime'>
    readonly upvotes: FieldRef<"FeedbackReport", 'Int'>
    readonly downvotes: FieldRef<"FeedbackReport", 'Int'>
    readonly duplicateOf: FieldRef<"FeedbackReport", 'String'>
    readonly createdAt: FieldRef<"FeedbackReport", 'DateTime'>
    readonly updatedAt: FieldRef<"FeedbackReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeedbackReport findUnique
   */
  export type FeedbackReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackReport to fetch.
     */
    where: FeedbackReportWhereUniqueInput
  }

  /**
   * FeedbackReport findUniqueOrThrow
   */
  export type FeedbackReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackReport to fetch.
     */
    where: FeedbackReportWhereUniqueInput
  }

  /**
   * FeedbackReport findFirst
   */
  export type FeedbackReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackReport to fetch.
     */
    where?: FeedbackReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackReports to fetch.
     */
    orderBy?: FeedbackReportOrderByWithRelationInput | FeedbackReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackReports.
     */
    cursor?: FeedbackReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackReports.
     */
    distinct?: FeedbackReportScalarFieldEnum | FeedbackReportScalarFieldEnum[]
  }

  /**
   * FeedbackReport findFirstOrThrow
   */
  export type FeedbackReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackReport to fetch.
     */
    where?: FeedbackReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackReports to fetch.
     */
    orderBy?: FeedbackReportOrderByWithRelationInput | FeedbackReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackReports.
     */
    cursor?: FeedbackReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackReports.
     */
    distinct?: FeedbackReportScalarFieldEnum | FeedbackReportScalarFieldEnum[]
  }

  /**
   * FeedbackReport findMany
   */
  export type FeedbackReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackReports to fetch.
     */
    where?: FeedbackReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackReports to fetch.
     */
    orderBy?: FeedbackReportOrderByWithRelationInput | FeedbackReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedbackReports.
     */
    cursor?: FeedbackReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackReports.
     */
    skip?: number
    distinct?: FeedbackReportScalarFieldEnum | FeedbackReportScalarFieldEnum[]
  }

  /**
   * FeedbackReport create
   */
  export type FeedbackReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * The data needed to create a FeedbackReport.
     */
    data: XOR<FeedbackReportCreateInput, FeedbackReportUncheckedCreateInput>
  }

  /**
   * FeedbackReport createMany
   */
  export type FeedbackReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedbackReports.
     */
    data: FeedbackReportCreateManyInput | FeedbackReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeedbackReport createManyAndReturn
   */
  export type FeedbackReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FeedbackReports.
     */
    data: FeedbackReportCreateManyInput | FeedbackReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeedbackReport update
   */
  export type FeedbackReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * The data needed to update a FeedbackReport.
     */
    data: XOR<FeedbackReportUpdateInput, FeedbackReportUncheckedUpdateInput>
    /**
     * Choose, which FeedbackReport to update.
     */
    where: FeedbackReportWhereUniqueInput
  }

  /**
   * FeedbackReport updateMany
   */
  export type FeedbackReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedbackReports.
     */
    data: XOR<FeedbackReportUpdateManyMutationInput, FeedbackReportUncheckedUpdateManyInput>
    /**
     * Filter which FeedbackReports to update
     */
    where?: FeedbackReportWhereInput
  }

  /**
   * FeedbackReport upsert
   */
  export type FeedbackReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * The filter to search for the FeedbackReport to update in case it exists.
     */
    where: FeedbackReportWhereUniqueInput
    /**
     * In case the FeedbackReport found by the `where` argument doesn't exist, create a new FeedbackReport with this data.
     */
    create: XOR<FeedbackReportCreateInput, FeedbackReportUncheckedCreateInput>
    /**
     * In case the FeedbackReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackReportUpdateInput, FeedbackReportUncheckedUpdateInput>
  }

  /**
   * FeedbackReport delete
   */
  export type FeedbackReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * Filter which FeedbackReport to delete.
     */
    where: FeedbackReportWhereUniqueInput
  }

  /**
   * FeedbackReport deleteMany
   */
  export type FeedbackReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackReports to delete
     */
    where?: FeedbackReportWhereInput
  }

  /**
   * FeedbackReport.adminUser
   */
  export type FeedbackReport$adminUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * FeedbackReport without action
   */
  export type FeedbackReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    avatar: string | null
    bio: string | null
    location: string | null
    website: string | null
    isEmprendedorConfiable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    avatar: string | null
    bio: string | null
    location: string | null
    website: string | null
    isEmprendedorConfiable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    avatar: number
    bio: number
    location: number
    website: number
    skills: number
    interests: number
    isEmprendedorConfiable: number
    socialLinks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    avatar?: true
    bio?: true
    location?: true
    website?: true
    isEmprendedorConfiable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    avatar?: true
    bio?: true
    location?: true
    website?: true
    isEmprendedorConfiable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    avatar?: true
    bio?: true
    location?: true
    website?: true
    skills?: true
    interests?: true
    isEmprendedorConfiable?: true
    socialLinks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    avatar: string | null
    bio: string | null
    location: string | null
    website: string | null
    skills: string[]
    interests: string[]
    isEmprendedorConfiable: boolean
    socialLinks: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    avatar?: boolean
    bio?: boolean
    location?: boolean
    website?: boolean
    skills?: boolean
    interests?: boolean
    isEmprendedorConfiable?: boolean
    socialLinks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    avatar?: boolean
    bio?: boolean
    location?: boolean
    website?: boolean
    skills?: boolean
    interests?: boolean
    isEmprendedorConfiable?: boolean
    socialLinks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    avatar?: boolean
    bio?: boolean
    location?: boolean
    website?: boolean
    skills?: boolean
    interests?: boolean
    isEmprendedorConfiable?: boolean
    socialLinks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      avatar: string | null
      bio: string | null
      location: string | null
      website: string | null
      skills: string[]
      interests: string[]
      isEmprendedorConfiable: boolean
      socialLinks: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly avatar: FieldRef<"Profile", 'String'>
    readonly bio: FieldRef<"Profile", 'String'>
    readonly location: FieldRef<"Profile", 'String'>
    readonly website: FieldRef<"Profile", 'String'>
    readonly skills: FieldRef<"Profile", 'String[]'>
    readonly interests: FieldRef<"Profile", 'String[]'>
    readonly isEmprendedorConfiable: FieldRef<"Profile", 'Boolean'>
    readonly socialLinks: FieldRef<"Profile", 'Json'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
    communication: number | null
    quality: number | null
    delivery: number | null
    value: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
    communication: number | null
    quality: number | null
    delivery: number | null
    value: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    marketplaceItemId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    communication: number | null
    quality: number | null
    delivery: number | null
    value: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    marketplaceItemId: string | null
    userId: string | null
    rating: number | null
    comment: string | null
    communication: number | null
    quality: number | null
    delivery: number | null
    value: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    marketplaceItemId: number
    userId: number
    rating: number
    comment: number
    communication: number
    quality: number
    delivery: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
    communication?: true
    quality?: true
    delivery?: true
    value?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
    communication?: true
    quality?: true
    delivery?: true
    value?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    marketplaceItemId?: true
    userId?: true
    rating?: true
    comment?: true
    communication?: true
    quality?: true
    delivery?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    marketplaceItemId?: true
    userId?: true
    rating?: true
    comment?: true
    communication?: true
    quality?: true
    delivery?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    marketplaceItemId?: true
    userId?: true
    rating?: true
    comment?: true
    communication?: true
    quality?: true
    delivery?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    marketplaceItemId: string
    userId: string
    rating: number
    comment: string | null
    communication: number | null
    quality: number | null
    delivery: number | null
    value: number | null
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketplaceItemId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    communication?: boolean
    quality?: boolean
    delivery?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    marketplaceItem?: boolean | MarketplaceItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketplaceItemId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    communication?: boolean
    quality?: boolean
    delivery?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    marketplaceItem?: boolean | MarketplaceItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    marketplaceItemId?: boolean
    userId?: boolean
    rating?: boolean
    comment?: boolean
    communication?: boolean
    quality?: boolean
    delivery?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marketplaceItem?: boolean | MarketplaceItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marketplaceItem?: boolean | MarketplaceItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      marketplaceItem: Prisma.$MarketplaceItemPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      marketplaceItemId: string
      userId: string
      rating: number
      comment: string | null
      communication: number | null
      quality: number | null
      delivery: number | null
      value: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    marketplaceItem<T extends MarketplaceItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceItemDefaultArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly marketplaceItemId: FieldRef<"Review", 'String'>
    readonly userId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly communication: FieldRef<"Review", 'Int'>
    readonly quality: FieldRef<"Review", 'Int'>
    readonly delivery: FieldRef<"Review", 'Int'>
    readonly value: FieldRef<"Review", 'Int'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model MarketplaceMatch
   */

  export type AggregateMarketplaceMatch = {
    _count: MarketplaceMatchCountAggregateOutputType | null
    _min: MarketplaceMatchMinAggregateOutputType | null
    _max: MarketplaceMatchMaxAggregateOutputType | null
  }

  export type MarketplaceMatchMinAggregateOutputType = {
    id: string | null
    itemId: string | null
    buyerId: string | null
    sellerId: string | null
    buyerConfirmed: boolean | null
    sellerConfirmed: boolean | null
    status: $Enums.MatchStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketplaceMatchMaxAggregateOutputType = {
    id: string | null
    itemId: string | null
    buyerId: string | null
    sellerId: string | null
    buyerConfirmed: boolean | null
    sellerConfirmed: boolean | null
    status: $Enums.MatchStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketplaceMatchCountAggregateOutputType = {
    id: number
    itemId: number
    buyerId: number
    sellerId: number
    buyerConfirmed: number
    sellerConfirmed: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketplaceMatchMinAggregateInputType = {
    id?: true
    itemId?: true
    buyerId?: true
    sellerId?: true
    buyerConfirmed?: true
    sellerConfirmed?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketplaceMatchMaxAggregateInputType = {
    id?: true
    itemId?: true
    buyerId?: true
    sellerId?: true
    buyerConfirmed?: true
    sellerConfirmed?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketplaceMatchCountAggregateInputType = {
    id?: true
    itemId?: true
    buyerId?: true
    sellerId?: true
    buyerConfirmed?: true
    sellerConfirmed?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketplaceMatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceMatch to aggregate.
     */
    where?: MarketplaceMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceMatches to fetch.
     */
    orderBy?: MarketplaceMatchOrderByWithRelationInput | MarketplaceMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketplaceMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketplaceMatches
    **/
    _count?: true | MarketplaceMatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketplaceMatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketplaceMatchMaxAggregateInputType
  }

  export type GetMarketplaceMatchAggregateType<T extends MarketplaceMatchAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketplaceMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketplaceMatch[P]>
      : GetScalarType<T[P], AggregateMarketplaceMatch[P]>
  }




  export type MarketplaceMatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceMatchWhereInput
    orderBy?: MarketplaceMatchOrderByWithAggregationInput | MarketplaceMatchOrderByWithAggregationInput[]
    by: MarketplaceMatchScalarFieldEnum[] | MarketplaceMatchScalarFieldEnum
    having?: MarketplaceMatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketplaceMatchCountAggregateInputType | true
    _min?: MarketplaceMatchMinAggregateInputType
    _max?: MarketplaceMatchMaxAggregateInputType
  }

  export type MarketplaceMatchGroupByOutputType = {
    id: string
    itemId: string
    buyerId: string
    sellerId: string
    buyerConfirmed: boolean
    sellerConfirmed: boolean
    status: $Enums.MatchStatus
    createdAt: Date
    updatedAt: Date
    _count: MarketplaceMatchCountAggregateOutputType | null
    _min: MarketplaceMatchMinAggregateOutputType | null
    _max: MarketplaceMatchMaxAggregateOutputType | null
  }

  type GetMarketplaceMatchGroupByPayload<T extends MarketplaceMatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketplaceMatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketplaceMatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketplaceMatchGroupByOutputType[P]>
            : GetScalarType<T[P], MarketplaceMatchGroupByOutputType[P]>
        }
      >
    >


  export type MarketplaceMatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    buyerConfirmed?: boolean
    sellerConfirmed?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    item?: boolean | MarketplaceItemDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | MarketplaceMatch$messagesArgs<ExtArgs>
    _count?: boolean | MarketplaceMatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceMatch"]>

  export type MarketplaceMatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    buyerConfirmed?: boolean
    sellerConfirmed?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    item?: boolean | MarketplaceItemDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceMatch"]>

  export type MarketplaceMatchSelectScalar = {
    id?: boolean
    itemId?: boolean
    buyerId?: boolean
    sellerId?: boolean
    buyerConfirmed?: boolean
    sellerConfirmed?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketplaceMatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | MarketplaceItemDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | MarketplaceMatch$messagesArgs<ExtArgs>
    _count?: boolean | MarketplaceMatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MarketplaceMatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | MarketplaceItemDefaultArgs<ExtArgs>
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MarketplaceMatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketplaceMatch"
    objects: {
      /**
       * Relations
       */
      item: Prisma.$MarketplaceItemPayload<ExtArgs>
      buyer: Prisma.$UserPayload<ExtArgs>
      seller: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$MatchMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      itemId: string
      buyerId: string
      sellerId: string
      buyerConfirmed: boolean
      sellerConfirmed: boolean
      status: $Enums.MatchStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketplaceMatch"]>
    composites: {}
  }

  type MarketplaceMatchGetPayload<S extends boolean | null | undefined | MarketplaceMatchDefaultArgs> = $Result.GetResult<Prisma.$MarketplaceMatchPayload, S>

  type MarketplaceMatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MarketplaceMatchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarketplaceMatchCountAggregateInputType | true
    }

  export interface MarketplaceMatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketplaceMatch'], meta: { name: 'MarketplaceMatch' } }
    /**
     * Find zero or one MarketplaceMatch that matches the filter.
     * @param {MarketplaceMatchFindUniqueArgs} args - Arguments to find a MarketplaceMatch
     * @example
     * // Get one MarketplaceMatch
     * const marketplaceMatch = await prisma.marketplaceMatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketplaceMatchFindUniqueArgs>(args: SelectSubset<T, MarketplaceMatchFindUniqueArgs<ExtArgs>>): Prisma__MarketplaceMatchClient<$Result.GetResult<Prisma.$MarketplaceMatchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MarketplaceMatch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MarketplaceMatchFindUniqueOrThrowArgs} args - Arguments to find a MarketplaceMatch
     * @example
     * // Get one MarketplaceMatch
     * const marketplaceMatch = await prisma.marketplaceMatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketplaceMatchFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketplaceMatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketplaceMatchClient<$Result.GetResult<Prisma.$MarketplaceMatchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MarketplaceMatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceMatchFindFirstArgs} args - Arguments to find a MarketplaceMatch
     * @example
     * // Get one MarketplaceMatch
     * const marketplaceMatch = await prisma.marketplaceMatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketplaceMatchFindFirstArgs>(args?: SelectSubset<T, MarketplaceMatchFindFirstArgs<ExtArgs>>): Prisma__MarketplaceMatchClient<$Result.GetResult<Prisma.$MarketplaceMatchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MarketplaceMatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceMatchFindFirstOrThrowArgs} args - Arguments to find a MarketplaceMatch
     * @example
     * // Get one MarketplaceMatch
     * const marketplaceMatch = await prisma.marketplaceMatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketplaceMatchFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketplaceMatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketplaceMatchClient<$Result.GetResult<Prisma.$MarketplaceMatchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MarketplaceMatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceMatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketplaceMatches
     * const marketplaceMatches = await prisma.marketplaceMatch.findMany()
     * 
     * // Get first 10 MarketplaceMatches
     * const marketplaceMatches = await prisma.marketplaceMatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketplaceMatchWithIdOnly = await prisma.marketplaceMatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketplaceMatchFindManyArgs>(args?: SelectSubset<T, MarketplaceMatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceMatchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MarketplaceMatch.
     * @param {MarketplaceMatchCreateArgs} args - Arguments to create a MarketplaceMatch.
     * @example
     * // Create one MarketplaceMatch
     * const MarketplaceMatch = await prisma.marketplaceMatch.create({
     *   data: {
     *     // ... data to create a MarketplaceMatch
     *   }
     * })
     * 
     */
    create<T extends MarketplaceMatchCreateArgs>(args: SelectSubset<T, MarketplaceMatchCreateArgs<ExtArgs>>): Prisma__MarketplaceMatchClient<$Result.GetResult<Prisma.$MarketplaceMatchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MarketplaceMatches.
     * @param {MarketplaceMatchCreateManyArgs} args - Arguments to create many MarketplaceMatches.
     * @example
     * // Create many MarketplaceMatches
     * const marketplaceMatch = await prisma.marketplaceMatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketplaceMatchCreateManyArgs>(args?: SelectSubset<T, MarketplaceMatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketplaceMatches and returns the data saved in the database.
     * @param {MarketplaceMatchCreateManyAndReturnArgs} args - Arguments to create many MarketplaceMatches.
     * @example
     * // Create many MarketplaceMatches
     * const marketplaceMatch = await prisma.marketplaceMatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketplaceMatches and only return the `id`
     * const marketplaceMatchWithIdOnly = await prisma.marketplaceMatch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketplaceMatchCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketplaceMatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceMatchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MarketplaceMatch.
     * @param {MarketplaceMatchDeleteArgs} args - Arguments to delete one MarketplaceMatch.
     * @example
     * // Delete one MarketplaceMatch
     * const MarketplaceMatch = await prisma.marketplaceMatch.delete({
     *   where: {
     *     // ... filter to delete one MarketplaceMatch
     *   }
     * })
     * 
     */
    delete<T extends MarketplaceMatchDeleteArgs>(args: SelectSubset<T, MarketplaceMatchDeleteArgs<ExtArgs>>): Prisma__MarketplaceMatchClient<$Result.GetResult<Prisma.$MarketplaceMatchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MarketplaceMatch.
     * @param {MarketplaceMatchUpdateArgs} args - Arguments to update one MarketplaceMatch.
     * @example
     * // Update one MarketplaceMatch
     * const marketplaceMatch = await prisma.marketplaceMatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketplaceMatchUpdateArgs>(args: SelectSubset<T, MarketplaceMatchUpdateArgs<ExtArgs>>): Prisma__MarketplaceMatchClient<$Result.GetResult<Prisma.$MarketplaceMatchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MarketplaceMatches.
     * @param {MarketplaceMatchDeleteManyArgs} args - Arguments to filter MarketplaceMatches to delete.
     * @example
     * // Delete a few MarketplaceMatches
     * const { count } = await prisma.marketplaceMatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketplaceMatchDeleteManyArgs>(args?: SelectSubset<T, MarketplaceMatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketplaceMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceMatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketplaceMatches
     * const marketplaceMatch = await prisma.marketplaceMatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketplaceMatchUpdateManyArgs>(args: SelectSubset<T, MarketplaceMatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketplaceMatch.
     * @param {MarketplaceMatchUpsertArgs} args - Arguments to update or create a MarketplaceMatch.
     * @example
     * // Update or create a MarketplaceMatch
     * const marketplaceMatch = await prisma.marketplaceMatch.upsert({
     *   create: {
     *     // ... data to create a MarketplaceMatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketplaceMatch we want to update
     *   }
     * })
     */
    upsert<T extends MarketplaceMatchUpsertArgs>(args: SelectSubset<T, MarketplaceMatchUpsertArgs<ExtArgs>>): Prisma__MarketplaceMatchClient<$Result.GetResult<Prisma.$MarketplaceMatchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MarketplaceMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceMatchCountArgs} args - Arguments to filter MarketplaceMatches to count.
     * @example
     * // Count the number of MarketplaceMatches
     * const count = await prisma.marketplaceMatch.count({
     *   where: {
     *     // ... the filter for the MarketplaceMatches we want to count
     *   }
     * })
    **/
    count<T extends MarketplaceMatchCountArgs>(
      args?: Subset<T, MarketplaceMatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketplaceMatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketplaceMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceMatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketplaceMatchAggregateArgs>(args: Subset<T, MarketplaceMatchAggregateArgs>): Prisma.PrismaPromise<GetMarketplaceMatchAggregateType<T>>

    /**
     * Group by MarketplaceMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceMatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketplaceMatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketplaceMatchGroupByArgs['orderBy'] }
        : { orderBy?: MarketplaceMatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketplaceMatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketplaceMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketplaceMatch model
   */
  readonly fields: MarketplaceMatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketplaceMatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketplaceMatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends MarketplaceItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceItemDefaultArgs<ExtArgs>>): Prisma__MarketplaceItemClient<$Result.GetResult<Prisma.$MarketplaceItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    buyer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    seller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messages<T extends MarketplaceMatch$messagesArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceMatch$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketplaceMatch model
   */ 
  interface MarketplaceMatchFieldRefs {
    readonly id: FieldRef<"MarketplaceMatch", 'String'>
    readonly itemId: FieldRef<"MarketplaceMatch", 'String'>
    readonly buyerId: FieldRef<"MarketplaceMatch", 'String'>
    readonly sellerId: FieldRef<"MarketplaceMatch", 'String'>
    readonly buyerConfirmed: FieldRef<"MarketplaceMatch", 'Boolean'>
    readonly sellerConfirmed: FieldRef<"MarketplaceMatch", 'Boolean'>
    readonly status: FieldRef<"MarketplaceMatch", 'MatchStatus'>
    readonly createdAt: FieldRef<"MarketplaceMatch", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketplaceMatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketplaceMatch findUnique
   */
  export type MarketplaceMatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceMatch
     */
    select?: MarketplaceMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceMatchInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceMatch to fetch.
     */
    where: MarketplaceMatchWhereUniqueInput
  }

  /**
   * MarketplaceMatch findUniqueOrThrow
   */
  export type MarketplaceMatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceMatch
     */
    select?: MarketplaceMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceMatchInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceMatch to fetch.
     */
    where: MarketplaceMatchWhereUniqueInput
  }

  /**
   * MarketplaceMatch findFirst
   */
  export type MarketplaceMatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceMatch
     */
    select?: MarketplaceMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceMatchInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceMatch to fetch.
     */
    where?: MarketplaceMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceMatches to fetch.
     */
    orderBy?: MarketplaceMatchOrderByWithRelationInput | MarketplaceMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceMatches.
     */
    cursor?: MarketplaceMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceMatches.
     */
    distinct?: MarketplaceMatchScalarFieldEnum | MarketplaceMatchScalarFieldEnum[]
  }

  /**
   * MarketplaceMatch findFirstOrThrow
   */
  export type MarketplaceMatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceMatch
     */
    select?: MarketplaceMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceMatchInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceMatch to fetch.
     */
    where?: MarketplaceMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceMatches to fetch.
     */
    orderBy?: MarketplaceMatchOrderByWithRelationInput | MarketplaceMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceMatches.
     */
    cursor?: MarketplaceMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceMatches.
     */
    distinct?: MarketplaceMatchScalarFieldEnum | MarketplaceMatchScalarFieldEnum[]
  }

  /**
   * MarketplaceMatch findMany
   */
  export type MarketplaceMatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceMatch
     */
    select?: MarketplaceMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceMatchInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceMatches to fetch.
     */
    where?: MarketplaceMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceMatches to fetch.
     */
    orderBy?: MarketplaceMatchOrderByWithRelationInput | MarketplaceMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketplaceMatches.
     */
    cursor?: MarketplaceMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceMatches.
     */
    skip?: number
    distinct?: MarketplaceMatchScalarFieldEnum | MarketplaceMatchScalarFieldEnum[]
  }

  /**
   * MarketplaceMatch create
   */
  export type MarketplaceMatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceMatch
     */
    select?: MarketplaceMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceMatchInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketplaceMatch.
     */
    data: XOR<MarketplaceMatchCreateInput, MarketplaceMatchUncheckedCreateInput>
  }

  /**
   * MarketplaceMatch createMany
   */
  export type MarketplaceMatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketplaceMatches.
     */
    data: MarketplaceMatchCreateManyInput | MarketplaceMatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketplaceMatch createManyAndReturn
   */
  export type MarketplaceMatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceMatch
     */
    select?: MarketplaceMatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MarketplaceMatches.
     */
    data: MarketplaceMatchCreateManyInput | MarketplaceMatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceMatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketplaceMatch update
   */
  export type MarketplaceMatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceMatch
     */
    select?: MarketplaceMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceMatchInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketplaceMatch.
     */
    data: XOR<MarketplaceMatchUpdateInput, MarketplaceMatchUncheckedUpdateInput>
    /**
     * Choose, which MarketplaceMatch to update.
     */
    where: MarketplaceMatchWhereUniqueInput
  }

  /**
   * MarketplaceMatch updateMany
   */
  export type MarketplaceMatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketplaceMatches.
     */
    data: XOR<MarketplaceMatchUpdateManyMutationInput, MarketplaceMatchUncheckedUpdateManyInput>
    /**
     * Filter which MarketplaceMatches to update
     */
    where?: MarketplaceMatchWhereInput
  }

  /**
   * MarketplaceMatch upsert
   */
  export type MarketplaceMatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceMatch
     */
    select?: MarketplaceMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceMatchInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketplaceMatch to update in case it exists.
     */
    where: MarketplaceMatchWhereUniqueInput
    /**
     * In case the MarketplaceMatch found by the `where` argument doesn't exist, create a new MarketplaceMatch with this data.
     */
    create: XOR<MarketplaceMatchCreateInput, MarketplaceMatchUncheckedCreateInput>
    /**
     * In case the MarketplaceMatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketplaceMatchUpdateInput, MarketplaceMatchUncheckedUpdateInput>
  }

  /**
   * MarketplaceMatch delete
   */
  export type MarketplaceMatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceMatch
     */
    select?: MarketplaceMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceMatchInclude<ExtArgs> | null
    /**
     * Filter which MarketplaceMatch to delete.
     */
    where: MarketplaceMatchWhereUniqueInput
  }

  /**
   * MarketplaceMatch deleteMany
   */
  export type MarketplaceMatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceMatches to delete
     */
    where?: MarketplaceMatchWhereInput
  }

  /**
   * MarketplaceMatch.messages
   */
  export type MarketplaceMatch$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMessage
     */
    select?: MatchMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMessageInclude<ExtArgs> | null
    where?: MatchMessageWhereInput
    orderBy?: MatchMessageOrderByWithRelationInput | MatchMessageOrderByWithRelationInput[]
    cursor?: MatchMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchMessageScalarFieldEnum | MatchMessageScalarFieldEnum[]
  }

  /**
   * MarketplaceMatch without action
   */
  export type MarketplaceMatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceMatch
     */
    select?: MarketplaceMatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceMatchInclude<ExtArgs> | null
  }


  /**
   * Model MatchMessage
   */

  export type AggregateMatchMessage = {
    _count: MatchMessageCountAggregateOutputType | null
    _min: MatchMessageMinAggregateOutputType | null
    _max: MatchMessageMaxAggregateOutputType | null
  }

  export type MatchMessageMinAggregateOutputType = {
    id: string | null
    matchId: string | null
    senderId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type MatchMessageMaxAggregateOutputType = {
    id: string | null
    matchId: string | null
    senderId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type MatchMessageCountAggregateOutputType = {
    id: number
    matchId: number
    senderId: number
    content: number
    createdAt: number
    _all: number
  }


  export type MatchMessageMinAggregateInputType = {
    id?: true
    matchId?: true
    senderId?: true
    content?: true
    createdAt?: true
  }

  export type MatchMessageMaxAggregateInputType = {
    id?: true
    matchId?: true
    senderId?: true
    content?: true
    createdAt?: true
  }

  export type MatchMessageCountAggregateInputType = {
    id?: true
    matchId?: true
    senderId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type MatchMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchMessage to aggregate.
     */
    where?: MatchMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchMessages to fetch.
     */
    orderBy?: MatchMessageOrderByWithRelationInput | MatchMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchMessages
    **/
    _count?: true | MatchMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchMessageMaxAggregateInputType
  }

  export type GetMatchMessageAggregateType<T extends MatchMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchMessage[P]>
      : GetScalarType<T[P], AggregateMatchMessage[P]>
  }




  export type MatchMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchMessageWhereInput
    orderBy?: MatchMessageOrderByWithAggregationInput | MatchMessageOrderByWithAggregationInput[]
    by: MatchMessageScalarFieldEnum[] | MatchMessageScalarFieldEnum
    having?: MatchMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchMessageCountAggregateInputType | true
    _min?: MatchMessageMinAggregateInputType
    _max?: MatchMessageMaxAggregateInputType
  }

  export type MatchMessageGroupByOutputType = {
    id: string
    matchId: string
    senderId: string
    content: string
    createdAt: Date
    _count: MatchMessageCountAggregateOutputType | null
    _min: MatchMessageMinAggregateOutputType | null
    _max: MatchMessageMaxAggregateOutputType | null
  }

  type GetMatchMessageGroupByPayload<T extends MatchMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchMessageGroupByOutputType[P]>
            : GetScalarType<T[P], MatchMessageGroupByOutputType[P]>
        }
      >
    >


  export type MatchMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    match?: boolean | MarketplaceMatchDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchMessage"]>

  export type MatchMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchId?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    match?: boolean | MarketplaceMatchDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchMessage"]>

  export type MatchMessageSelectScalar = {
    id?: boolean
    matchId?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type MatchMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MarketplaceMatchDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MatchMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MarketplaceMatchDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MatchMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchMessage"
    objects: {
      /**
       * Relations
       */
      match: Prisma.$MarketplaceMatchPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      matchId: string
      senderId: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["matchMessage"]>
    composites: {}
  }

  type MatchMessageGetPayload<S extends boolean | null | undefined | MatchMessageDefaultArgs> = $Result.GetResult<Prisma.$MatchMessagePayload, S>

  type MatchMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MatchMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MatchMessageCountAggregateInputType | true
    }

  export interface MatchMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchMessage'], meta: { name: 'MatchMessage' } }
    /**
     * Find zero or one MatchMessage that matches the filter.
     * @param {MatchMessageFindUniqueArgs} args - Arguments to find a MatchMessage
     * @example
     * // Get one MatchMessage
     * const matchMessage = await prisma.matchMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchMessageFindUniqueArgs>(args: SelectSubset<T, MatchMessageFindUniqueArgs<ExtArgs>>): Prisma__MatchMessageClient<$Result.GetResult<Prisma.$MatchMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MatchMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MatchMessageFindUniqueOrThrowArgs} args - Arguments to find a MatchMessage
     * @example
     * // Get one MatchMessage
     * const matchMessage = await prisma.matchMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchMessageClient<$Result.GetResult<Prisma.$MatchMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MatchMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMessageFindFirstArgs} args - Arguments to find a MatchMessage
     * @example
     * // Get one MatchMessage
     * const matchMessage = await prisma.matchMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchMessageFindFirstArgs>(args?: SelectSubset<T, MatchMessageFindFirstArgs<ExtArgs>>): Prisma__MatchMessageClient<$Result.GetResult<Prisma.$MatchMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MatchMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMessageFindFirstOrThrowArgs} args - Arguments to find a MatchMessage
     * @example
     * // Get one MatchMessage
     * const matchMessage = await prisma.matchMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchMessageClient<$Result.GetResult<Prisma.$MatchMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MatchMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchMessages
     * const matchMessages = await prisma.matchMessage.findMany()
     * 
     * // Get first 10 MatchMessages
     * const matchMessages = await prisma.matchMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchMessageWithIdOnly = await prisma.matchMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchMessageFindManyArgs>(args?: SelectSubset<T, MatchMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MatchMessage.
     * @param {MatchMessageCreateArgs} args - Arguments to create a MatchMessage.
     * @example
     * // Create one MatchMessage
     * const MatchMessage = await prisma.matchMessage.create({
     *   data: {
     *     // ... data to create a MatchMessage
     *   }
     * })
     * 
     */
    create<T extends MatchMessageCreateArgs>(args: SelectSubset<T, MatchMessageCreateArgs<ExtArgs>>): Prisma__MatchMessageClient<$Result.GetResult<Prisma.$MatchMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MatchMessages.
     * @param {MatchMessageCreateManyArgs} args - Arguments to create many MatchMessages.
     * @example
     * // Create many MatchMessages
     * const matchMessage = await prisma.matchMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchMessageCreateManyArgs>(args?: SelectSubset<T, MatchMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchMessages and returns the data saved in the database.
     * @param {MatchMessageCreateManyAndReturnArgs} args - Arguments to create many MatchMessages.
     * @example
     * // Create many MatchMessages
     * const matchMessage = await prisma.matchMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchMessages and only return the `id`
     * const matchMessageWithIdOnly = await prisma.matchMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MatchMessage.
     * @param {MatchMessageDeleteArgs} args - Arguments to delete one MatchMessage.
     * @example
     * // Delete one MatchMessage
     * const MatchMessage = await prisma.matchMessage.delete({
     *   where: {
     *     // ... filter to delete one MatchMessage
     *   }
     * })
     * 
     */
    delete<T extends MatchMessageDeleteArgs>(args: SelectSubset<T, MatchMessageDeleteArgs<ExtArgs>>): Prisma__MatchMessageClient<$Result.GetResult<Prisma.$MatchMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MatchMessage.
     * @param {MatchMessageUpdateArgs} args - Arguments to update one MatchMessage.
     * @example
     * // Update one MatchMessage
     * const matchMessage = await prisma.matchMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchMessageUpdateArgs>(args: SelectSubset<T, MatchMessageUpdateArgs<ExtArgs>>): Prisma__MatchMessageClient<$Result.GetResult<Prisma.$MatchMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MatchMessages.
     * @param {MatchMessageDeleteManyArgs} args - Arguments to filter MatchMessages to delete.
     * @example
     * // Delete a few MatchMessages
     * const { count } = await prisma.matchMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchMessageDeleteManyArgs>(args?: SelectSubset<T, MatchMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchMessages
     * const matchMessage = await prisma.matchMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchMessageUpdateManyArgs>(args: SelectSubset<T, MatchMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MatchMessage.
     * @param {MatchMessageUpsertArgs} args - Arguments to update or create a MatchMessage.
     * @example
     * // Update or create a MatchMessage
     * const matchMessage = await prisma.matchMessage.upsert({
     *   create: {
     *     // ... data to create a MatchMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchMessage we want to update
     *   }
     * })
     */
    upsert<T extends MatchMessageUpsertArgs>(args: SelectSubset<T, MatchMessageUpsertArgs<ExtArgs>>): Prisma__MatchMessageClient<$Result.GetResult<Prisma.$MatchMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MatchMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMessageCountArgs} args - Arguments to filter MatchMessages to count.
     * @example
     * // Count the number of MatchMessages
     * const count = await prisma.matchMessage.count({
     *   where: {
     *     // ... the filter for the MatchMessages we want to count
     *   }
     * })
    **/
    count<T extends MatchMessageCountArgs>(
      args?: Subset<T, MatchMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchMessageAggregateArgs>(args: Subset<T, MatchMessageAggregateArgs>): Prisma.PrismaPromise<GetMatchMessageAggregateType<T>>

    /**
     * Group by MatchMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchMessageGroupByArgs['orderBy'] }
        : { orderBy?: MatchMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchMessage model
   */
  readonly fields: MatchMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    match<T extends MarketplaceMatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceMatchDefaultArgs<ExtArgs>>): Prisma__MarketplaceMatchClient<$Result.GetResult<Prisma.$MarketplaceMatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchMessage model
   */ 
  interface MatchMessageFieldRefs {
    readonly id: FieldRef<"MatchMessage", 'String'>
    readonly matchId: FieldRef<"MatchMessage", 'String'>
    readonly senderId: FieldRef<"MatchMessage", 'String'>
    readonly content: FieldRef<"MatchMessage", 'String'>
    readonly createdAt: FieldRef<"MatchMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatchMessage findUnique
   */
  export type MatchMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMessage
     */
    select?: MatchMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMessageInclude<ExtArgs> | null
    /**
     * Filter, which MatchMessage to fetch.
     */
    where: MatchMessageWhereUniqueInput
  }

  /**
   * MatchMessage findUniqueOrThrow
   */
  export type MatchMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMessage
     */
    select?: MatchMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMessageInclude<ExtArgs> | null
    /**
     * Filter, which MatchMessage to fetch.
     */
    where: MatchMessageWhereUniqueInput
  }

  /**
   * MatchMessage findFirst
   */
  export type MatchMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMessage
     */
    select?: MatchMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMessageInclude<ExtArgs> | null
    /**
     * Filter, which MatchMessage to fetch.
     */
    where?: MatchMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchMessages to fetch.
     */
    orderBy?: MatchMessageOrderByWithRelationInput | MatchMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchMessages.
     */
    cursor?: MatchMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchMessages.
     */
    distinct?: MatchMessageScalarFieldEnum | MatchMessageScalarFieldEnum[]
  }

  /**
   * MatchMessage findFirstOrThrow
   */
  export type MatchMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMessage
     */
    select?: MatchMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMessageInclude<ExtArgs> | null
    /**
     * Filter, which MatchMessage to fetch.
     */
    where?: MatchMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchMessages to fetch.
     */
    orderBy?: MatchMessageOrderByWithRelationInput | MatchMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchMessages.
     */
    cursor?: MatchMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchMessages.
     */
    distinct?: MatchMessageScalarFieldEnum | MatchMessageScalarFieldEnum[]
  }

  /**
   * MatchMessage findMany
   */
  export type MatchMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMessage
     */
    select?: MatchMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMessageInclude<ExtArgs> | null
    /**
     * Filter, which MatchMessages to fetch.
     */
    where?: MatchMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchMessages to fetch.
     */
    orderBy?: MatchMessageOrderByWithRelationInput | MatchMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchMessages.
     */
    cursor?: MatchMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchMessages.
     */
    skip?: number
    distinct?: MatchMessageScalarFieldEnum | MatchMessageScalarFieldEnum[]
  }

  /**
   * MatchMessage create
   */
  export type MatchMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMessage
     */
    select?: MatchMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a MatchMessage.
     */
    data: XOR<MatchMessageCreateInput, MatchMessageUncheckedCreateInput>
  }

  /**
   * MatchMessage createMany
   */
  export type MatchMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchMessages.
     */
    data: MatchMessageCreateManyInput | MatchMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchMessage createManyAndReturn
   */
  export type MatchMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMessage
     */
    select?: MatchMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MatchMessages.
     */
    data: MatchMessageCreateManyInput | MatchMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchMessage update
   */
  export type MatchMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMessage
     */
    select?: MatchMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a MatchMessage.
     */
    data: XOR<MatchMessageUpdateInput, MatchMessageUncheckedUpdateInput>
    /**
     * Choose, which MatchMessage to update.
     */
    where: MatchMessageWhereUniqueInput
  }

  /**
   * MatchMessage updateMany
   */
  export type MatchMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchMessages.
     */
    data: XOR<MatchMessageUpdateManyMutationInput, MatchMessageUncheckedUpdateManyInput>
    /**
     * Filter which MatchMessages to update
     */
    where?: MatchMessageWhereInput
  }

  /**
   * MatchMessage upsert
   */
  export type MatchMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMessage
     */
    select?: MatchMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the MatchMessage to update in case it exists.
     */
    where: MatchMessageWhereUniqueInput
    /**
     * In case the MatchMessage found by the `where` argument doesn't exist, create a new MatchMessage with this data.
     */
    create: XOR<MatchMessageCreateInput, MatchMessageUncheckedCreateInput>
    /**
     * In case the MatchMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchMessageUpdateInput, MatchMessageUncheckedUpdateInput>
  }

  /**
   * MatchMessage delete
   */
  export type MatchMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMessage
     */
    select?: MatchMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMessageInclude<ExtArgs> | null
    /**
     * Filter which MatchMessage to delete.
     */
    where: MatchMessageWhereUniqueInput
  }

  /**
   * MatchMessage deleteMany
   */
  export type MatchMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchMessages to delete
     */
    where?: MatchMessageWhereInput
  }

  /**
   * MatchMessage without action
   */
  export type MatchMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchMessage
     */
    select?: MatchMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchMessageInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const MundoScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    version: 'version'
  };

  export type MundoScalarFieldEnum = (typeof MundoScalarFieldEnum)[keyof typeof MundoScalarFieldEnum]


  export const PlaylistScalarFieldEnum: {
    id: 'id',
    mundoId: 'mundoId',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    orderInMundo: 'orderInMundo',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    version: 'version'
  };

  export type PlaylistScalarFieldEnum = (typeof PlaylistScalarFieldEnum)[keyof typeof PlaylistScalarFieldEnum]


  export const VideoItemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    content: 'content',
    url: 'url',
    platform: 'platform',
    externalId: 'externalId',
    playlistId: 'playlistId',
    itemTypeId: 'itemTypeId',
    order: 'order',
    isActive: 'isActive',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    duration: 'duration',
    categories: 'categories',
    language: 'language',
    quality: 'quality',
    tags: 'tags',
    thumbnailUrl: 'thumbnailUrl'
  };

  export type VideoItemScalarFieldEnum = (typeof VideoItemScalarFieldEnum)[keyof typeof VideoItemScalarFieldEnum]


  export const SubtitleScalarFieldEnum: {
    id: 'id',
    videoItemId: 'videoItemId',
    languageCode: 'languageCode',
    format: 'format',
    content: 'content',
    contentUrl: 'contentUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubtitleScalarFieldEnum = (typeof SubtitleScalarFieldEnum)[keyof typeof SubtitleScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    videoItemId: 'videoItemId',
    timestamp: 'timestamp',
    type: 'type',
    text: 'text',
    languageCode: 'languageCode',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    endTimestamp: 'endTimestamp'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const AnswerOptionScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    text: 'text',
    isCorrect: 'isCorrect',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnswerOptionScalarFieldEnum = (typeof AnswerOptionScalarFieldEnum)[keyof typeof AnswerOptionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    avatarUrl: 'avatarUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    username: 'username',
    firstName: 'firstName',
    lastName: 'lastName',
    documentType: 'documentType',
    documentNumber: 'documentNumber',
    phone: 'phone',
    country: 'country',
    address: 'address',
    status: 'status',
    topUserCount: 'topUserCount',
    personalityId: 'personalityId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    userId: 'userId',
    roleId: 'roleId',
    assignedAt: 'assignedAt',
    assignedById: 'assignedById'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const VideoPermissionsScalarFieldEnum: {
    id: 'id',
    videoItemId: 'videoItemId',
    showWaveCount: 'showWaveCount',
    showVideos: 'showVideos',
    showVideoSubtitles: 'showVideoSubtitles',
    showComments: 'showComments',
    showPublishDate: 'showPublishDate',
    showVideoDuration: 'showVideoDuration',
    showLikeButton: 'showLikeButton',
    allowRewindForward: 'allowRewindForward',
    allowViewComments: 'allowViewComments',
    allowMakeComments: 'allowMakeComments',
    showLikeComments: 'showLikeComments',
    sortCommentsByAffinity: 'sortCommentsByAffinity',
    showCommenterName: 'showCommenterName',
    playlistPosition: 'playlistPosition',
    isDraft: 'isDraft',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type VideoPermissionsScalarFieldEnum = (typeof VideoPermissionsScalarFieldEnum)[keyof typeof VideoPermissionsScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    roleId: 'roleId',
    permissionId: 'permissionId',
    assignedAt: 'assignedAt',
    assignedById: 'assignedById'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const WorldScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    creatorId: 'creatorId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    mundoId: 'mundoId'
  };

  export type WorldScalarFieldEnum = (typeof WorldScalarFieldEnum)[keyof typeof WorldScalarFieldEnum]


  export const StageScalarFieldEnum: {
    id: 'id',
    worldId: 'worldId',
    name: 'name',
    order: 'order',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StageScalarFieldEnum = (typeof StageScalarFieldEnum)[keyof typeof StageScalarFieldEnum]


  export const ExperienceScalarFieldEnum: {
    id: 'id',
    stageId: 'stageId',
    title: 'title',
    description: 'description',
    type: 'type',
    gamificationFramework: 'gamificationFramework',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExperienceScalarFieldEnum = (typeof ExperienceScalarFieldEnum)[keyof typeof ExperienceScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    experienceId: 'experienceId',
    title: 'title',
    description: 'description',
    type: 'type',
    multimediaType: 'multimediaType',
    contentUrl: 'contentUrl',
    duration: 'duration',
    order: 'order',
    status: 'status',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    videoItemId: 'videoItemId'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const GamifiedPlaylistScalarFieldEnum: {
    id: 'id',
    activityId: 'activityId',
    playlistId: 'playlistId',
    name: 'name',
    type: 'type',
    sequenceType: 'sequenceType',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GamifiedPlaylistScalarFieldEnum = (typeof GamifiedPlaylistScalarFieldEnum)[keyof typeof GamifiedPlaylistScalarFieldEnum]


  export const ActivityQuestionScalarFieldEnum: {
    id: 'id',
    activityId: 'activityId',
    type: 'type',
    questionType: 'questionType',
    questionText: 'questionText',
    options: 'options',
    correctAnswer: 'correctAnswer',
    ondasList: 'ondasList',
    displayTimeSeconds: 'displayTimeSeconds',
    optionalDisplaySeconds: 'optionalDisplaySeconds',
    createdAt: 'createdAt'
  };

  export type ActivityQuestionScalarFieldEnum = (typeof ActivityQuestionScalarFieldEnum)[keyof typeof ActivityQuestionScalarFieldEnum]


  export const UserAnswerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    questionId: 'questionId',
    activityQuestionId: 'activityQuestionId',
    answerGiven: 'answerGiven',
    isCorrect: 'isCorrect',
    ondasEarned: 'ondasEarned',
    createdAt: 'createdAt'
  };

  export type UserAnswerScalarFieldEnum = (typeof UserAnswerScalarFieldEnum)[keyof typeof UserAnswerScalarFieldEnum]


  export const TokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    type: 'type',
    status: 'status',
    caducityDate: 'caducityDate',
    source: 'source',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const MeritScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    type: 'type',
    source: 'source',
    relatedEntityId: 'relatedEntityId',
    createdAt: 'createdAt'
  };

  export type MeritScalarFieldEnum = (typeof MeritScalarFieldEnum)[keyof typeof MeritScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    blockchainAddress: 'blockchainAddress',
    balanceUnits: 'balanceUnits',
    balanceToins: 'balanceToins',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    amount: 'amount',
    tokenType: 'tokenType',
    type: 'type',
    status: 'status',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    ownerId: 'ownerId',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const UserGroupScalarFieldEnum: {
    userId: 'userId',
    groupId: 'groupId',
    roleInGroup: 'roleInGroup',
    joinedAt: 'joinedAt'
  };

  export type UserGroupScalarFieldEnum = (typeof UserGroupScalarFieldEnum)[keyof typeof UserGroupScalarFieldEnum]


  export const PublicationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    content: 'content',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PublicationScalarFieldEnum = (typeof PublicationScalarFieldEnum)[keyof typeof PublicationScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    publicationId: 'publicationId',
    activityId: 'activityId',
    text: 'text',
    createdAt: 'createdAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const LikeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    publicationId: 'publicationId',
    createdAt: 'createdAt'
  };

  export type LikeScalarFieldEnum = (typeof LikeScalarFieldEnum)[keyof typeof LikeScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    message: 'message',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const InvitationTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    content: 'content',
    creatorId: 'creatorId',
    createdAt: 'createdAt'
  };

  export type InvitationTemplateScalarFieldEnum = (typeof InvitationTemplateScalarFieldEnum)[keyof typeof InvitationTemplateScalarFieldEnum]


  export const GiftCardScalarFieldEnum: {
    id: 'id',
    inviterId: 'inviterId',
    invitedName: 'invitedName',
    invitedEmail: 'invitedEmail',
    token: 'token',
    unitsAmount: 'unitsAmount',
    suggestions: 'suggestions',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type GiftCardScalarFieldEnum = (typeof GiftCardScalarFieldEnum)[keyof typeof GiftCardScalarFieldEnum]


  export const UserInvitationScalarFieldEnum: {
    id: 'id',
    giftCardId: 'giftCardId',
    invitedUserId: 'invitedUserId',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type UserInvitationScalarFieldEnum = (typeof UserInvitationScalarFieldEnum)[keyof typeof UserInvitationScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    parameters: 'parameters',
    generatedAt: 'generatedAt',
    data: 'data',
    creatorId: 'creatorId'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const ConfigurationScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    type: 'type',
    updatedAt: 'updatedAt'
  };

  export type ConfigurationScalarFieldEnum = (typeof ConfigurationScalarFieldEnum)[keyof typeof ConfigurationScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    level: 'level',
    message: 'message',
    context: 'context',
    timestamp: 'timestamp',
    metadata: 'metadata'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const AnalyticsDataScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    eventType: 'eventType',
    videoItemId: 'videoItemId',
    playlistId: 'playlistId',
    mundoId: 'mundoId',
    sessionId: 'sessionId',
    eventData: 'eventData',
    metadata: 'metadata',
    timestamp: 'timestamp',
    createdAt: 'createdAt'
  };

  export type AnalyticsDataScalarFieldEnum = (typeof AnalyticsDataScalarFieldEnum)[keyof typeof AnalyticsDataScalarFieldEnum]


  export const RankingScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    period: 'period',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type RankingScalarFieldEnum = (typeof RankingScalarFieldEnum)[keyof typeof RankingScalarFieldEnum]


  export const PersonalityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    traits: 'traits',
    createdAt: 'createdAt'
  };

  export type PersonalityScalarFieldEnum = (typeof PersonalityScalarFieldEnum)[keyof typeof PersonalityScalarFieldEnum]


  export const UIComponentTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    templateJson: 'templateJson',
    creatorId: 'creatorId',
    createdAt: 'createdAt'
  };

  export type UIComponentTemplateScalarFieldEnum = (typeof UIComponentTemplateScalarFieldEnum)[keyof typeof UIComponentTemplateScalarFieldEnum]


  export const ItemTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemTypeScalarFieldEnum = (typeof ItemTypeScalarFieldEnum)[keyof typeof ItemTypeScalarFieldEnum]


  export const ContentItemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    content: 'content',
    playlistId: 'playlistId',
    itemTypeId: 'itemTypeId',
    order: 'order',
    isActive: 'isActive',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContentItemScalarFieldEnum = (typeof ContentItemScalarFieldEnum)[keyof typeof ContentItemScalarFieldEnum]


  export const ChallengeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    config: 'config',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChallengeScalarFieldEnum = (typeof ChallengeScalarFieldEnum)[keyof typeof ChallengeScalarFieldEnum]


  export const ChallengeRewardScalarFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    type: 'type',
    amount: 'amount',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ChallengeRewardScalarFieldEnum = (typeof ChallengeRewardScalarFieldEnum)[keyof typeof ChallengeRewardScalarFieldEnum]


  export const UserChallengeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    challengeId: 'challengeId',
    status: 'status',
    progress: 'progress',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    metadata: 'metadata'
  };

  export type UserChallengeScalarFieldEnum = (typeof UserChallengeScalarFieldEnum)[keyof typeof UserChallengeScalarFieldEnum]


  export const MarketplaceItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    fullDescription: 'fullDescription',
    itemType: 'itemType',
    price: 'price',
    priceToins: 'priceToins',
    currency: 'currency',
    category: 'category',
    tags: 'tags',
    images: 'images',
    stock: 'stock',
    rating: 'rating',
    reviewCount: 'reviewCount',
    location: 'location',
    status: 'status',
    isActive: 'isActive',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    viewCount: 'viewCount',
    favoriteCount: 'favoriteCount',
    sellerId: 'sellerId',
    metadata: 'metadata'
  };

  export type MarketplaceItemScalarFieldEnum = (typeof MarketplaceItemScalarFieldEnum)[keyof typeof MarketplaceItemScalarFieldEnum]


  export const StudyRoomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    videoId: 'videoId',
    hostId: 'hostId',
    maxParticipants: 'maxParticipants',
    status: 'status',
    currentTime: 'currentTime',
    isPaused: 'isPaused',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudyRoomScalarFieldEnum = (typeof StudyRoomScalarFieldEnum)[keyof typeof StudyRoomScalarFieldEnum]


  export const StudyRoomParticipantScalarFieldEnum: {
    id: 'id',
    studyRoomId: 'studyRoomId',
    userId: 'userId',
    isHost: 'isHost',
    joinedAt: 'joinedAt',
    leftAt: 'leftAt',
    isActive: 'isActive'
  };

  export type StudyRoomParticipantScalarFieldEnum = (typeof StudyRoomParticipantScalarFieldEnum)[keyof typeof StudyRoomParticipantScalarFieldEnum]


  export const StudyRoomMessageScalarFieldEnum: {
    id: 'id',
    studyRoomId: 'studyRoomId',
    userId: 'userId',
    message: 'message',
    messageType: 'messageType',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type StudyRoomMessageScalarFieldEnum = (typeof StudyRoomMessageScalarFieldEnum)[keyof typeof StudyRoomMessageScalarFieldEnum]


  export const FeedbackReportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    description: 'description',
    priority: 'priority',
    category: 'category',
    status: 'status',
    elementContext: 'elementContext',
    technicalContext: 'technicalContext',
    codeAnalysis: 'codeAnalysis',
    aiSuggestions: 'aiSuggestions',
    adminResponse: 'adminResponse',
    adminUserId: 'adminUserId',
    resolvedAt: 'resolvedAt',
    upvotes: 'upvotes',
    downvotes: 'downvotes',
    duplicateOf: 'duplicateOf',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeedbackReportScalarFieldEnum = (typeof FeedbackReportScalarFieldEnum)[keyof typeof FeedbackReportScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    avatar: 'avatar',
    bio: 'bio',
    location: 'location',
    website: 'website',
    skills: 'skills',
    interests: 'interests',
    isEmprendedorConfiable: 'isEmprendedorConfiable',
    socialLinks: 'socialLinks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    marketplaceItemId: 'marketplaceItemId',
    userId: 'userId',
    rating: 'rating',
    comment: 'comment',
    communication: 'communication',
    quality: 'quality',
    delivery: 'delivery',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const MarketplaceMatchScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    buyerId: 'buyerId',
    sellerId: 'sellerId',
    buyerConfirmed: 'buyerConfirmed',
    sellerConfirmed: 'sellerConfirmed',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketplaceMatchScalarFieldEnum = (typeof MarketplaceMatchScalarFieldEnum)[keyof typeof MarketplaceMatchScalarFieldEnum]


  export const MatchMessageScalarFieldEnum: {
    id: 'id',
    matchId: 'matchId',
    senderId: 'senderId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type MatchMessageScalarFieldEnum = (typeof MatchMessageScalarFieldEnum)[keyof typeof MatchMessageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'MarketplaceItemType'
   */
  export type EnumMarketplaceItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MarketplaceItemType'>
    


  /**
   * Reference to a field of type 'MarketplaceItemType[]'
   */
  export type ListEnumMarketplaceItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MarketplaceItemType[]'>
    


  /**
   * Reference to a field of type 'Currency'
   */
  export type EnumCurrencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Currency'>
    


  /**
   * Reference to a field of type 'Currency[]'
   */
  export type ListEnumCurrencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Currency[]'>
    


  /**
   * Reference to a field of type 'MarketplaceItemStatus'
   */
  export type EnumMarketplaceItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MarketplaceItemStatus'>
    


  /**
   * Reference to a field of type 'MarketplaceItemStatus[]'
   */
  export type ListEnumMarketplaceItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MarketplaceItemStatus[]'>
    


  /**
   * Reference to a field of type 'StudyRoomStatus'
   */
  export type EnumStudyRoomStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudyRoomStatus'>
    


  /**
   * Reference to a field of type 'StudyRoomStatus[]'
   */
  export type ListEnumStudyRoomStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudyRoomStatus[]'>
    


  /**
   * Reference to a field of type 'FeedbackType'
   */
  export type EnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType'>
    


  /**
   * Reference to a field of type 'FeedbackType[]'
   */
  export type ListEnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType[]'>
    


  /**
   * Reference to a field of type 'FeedbackPriority'
   */
  export type EnumFeedbackPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackPriority'>
    


  /**
   * Reference to a field of type 'FeedbackPriority[]'
   */
  export type ListEnumFeedbackPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackPriority[]'>
    


  /**
   * Reference to a field of type 'FeedbackStatus'
   */
  export type EnumFeedbackStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackStatus'>
    


  /**
   * Reference to a field of type 'FeedbackStatus[]'
   */
  export type ListEnumFeedbackStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'MatchStatus'
   */
  export type EnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus'>
    


  /**
   * Reference to a field of type 'MatchStatus[]'
   */
  export type ListEnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type MundoWhereInput = {
    AND?: MundoWhereInput | MundoWhereInput[]
    OR?: MundoWhereInput[]
    NOT?: MundoWhereInput | MundoWhereInput[]
    id?: StringFilter<"Mundo"> | string
    name?: StringFilter<"Mundo"> | string
    description?: StringNullableFilter<"Mundo"> | string | null
    imageUrl?: StringNullableFilter<"Mundo"> | string | null
    isActive?: BoolFilter<"Mundo"> | boolean
    createdAt?: DateTimeFilter<"Mundo"> | Date | string
    updatedAt?: DateTimeFilter<"Mundo"> | Date | string
    createdById?: StringNullableFilter<"Mundo"> | string | null
    version?: IntFilter<"Mundo"> | number
    playlists?: PlaylistListRelationFilter
    worlds?: WorldListRelationFilter
  }

  export type MundoOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    version?: SortOrder
    playlists?: PlaylistOrderByRelationAggregateInput
    worlds?: WorldOrderByRelationAggregateInput
  }

  export type MundoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MundoWhereInput | MundoWhereInput[]
    OR?: MundoWhereInput[]
    NOT?: MundoWhereInput | MundoWhereInput[]
    name?: StringFilter<"Mundo"> | string
    description?: StringNullableFilter<"Mundo"> | string | null
    imageUrl?: StringNullableFilter<"Mundo"> | string | null
    isActive?: BoolFilter<"Mundo"> | boolean
    createdAt?: DateTimeFilter<"Mundo"> | Date | string
    updatedAt?: DateTimeFilter<"Mundo"> | Date | string
    createdById?: StringNullableFilter<"Mundo"> | string | null
    version?: IntFilter<"Mundo"> | number
    playlists?: PlaylistListRelationFilter
    worlds?: WorldListRelationFilter
  }, "id">

  export type MundoOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    version?: SortOrder
    _count?: MundoCountOrderByAggregateInput
    _avg?: MundoAvgOrderByAggregateInput
    _max?: MundoMaxOrderByAggregateInput
    _min?: MundoMinOrderByAggregateInput
    _sum?: MundoSumOrderByAggregateInput
  }

  export type MundoScalarWhereWithAggregatesInput = {
    AND?: MundoScalarWhereWithAggregatesInput | MundoScalarWhereWithAggregatesInput[]
    OR?: MundoScalarWhereWithAggregatesInput[]
    NOT?: MundoScalarWhereWithAggregatesInput | MundoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Mundo"> | string
    name?: StringWithAggregatesFilter<"Mundo"> | string
    description?: StringNullableWithAggregatesFilter<"Mundo"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Mundo"> | string | null
    isActive?: BoolWithAggregatesFilter<"Mundo"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Mundo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Mundo"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Mundo"> | string | null
    version?: IntWithAggregatesFilter<"Mundo"> | number
  }

  export type PlaylistWhereInput = {
    AND?: PlaylistWhereInput | PlaylistWhereInput[]
    OR?: PlaylistWhereInput[]
    NOT?: PlaylistWhereInput | PlaylistWhereInput[]
    id?: StringFilter<"Playlist"> | string
    mundoId?: StringFilter<"Playlist"> | string
    name?: StringFilter<"Playlist"> | string
    description?: StringNullableFilter<"Playlist"> | string | null
    imageUrl?: StringNullableFilter<"Playlist"> | string | null
    orderInMundo?: IntNullableFilter<"Playlist"> | number | null
    isActive?: BoolFilter<"Playlist"> | boolean
    createdAt?: DateTimeFilter<"Playlist"> | Date | string
    updatedAt?: DateTimeFilter<"Playlist"> | Date | string
    createdById?: StringNullableFilter<"Playlist"> | string | null
    version?: IntFilter<"Playlist"> | number
    contentItems?: ContentItemListRelationFilter
    gamifiedPlaylists?: GamifiedPlaylistListRelationFilter
    mundo?: XOR<MundoRelationFilter, MundoWhereInput>
    videoItems?: VideoItemListRelationFilter
  }

  export type PlaylistOrderByWithRelationInput = {
    id?: SortOrder
    mundoId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    orderInMundo?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    version?: SortOrder
    contentItems?: ContentItemOrderByRelationAggregateInput
    gamifiedPlaylists?: GamifiedPlaylistOrderByRelationAggregateInput
    mundo?: MundoOrderByWithRelationInput
    videoItems?: VideoItemOrderByRelationAggregateInput
  }

  export type PlaylistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlaylistWhereInput | PlaylistWhereInput[]
    OR?: PlaylistWhereInput[]
    NOT?: PlaylistWhereInput | PlaylistWhereInput[]
    mundoId?: StringFilter<"Playlist"> | string
    name?: StringFilter<"Playlist"> | string
    description?: StringNullableFilter<"Playlist"> | string | null
    imageUrl?: StringNullableFilter<"Playlist"> | string | null
    orderInMundo?: IntNullableFilter<"Playlist"> | number | null
    isActive?: BoolFilter<"Playlist"> | boolean
    createdAt?: DateTimeFilter<"Playlist"> | Date | string
    updatedAt?: DateTimeFilter<"Playlist"> | Date | string
    createdById?: StringNullableFilter<"Playlist"> | string | null
    version?: IntFilter<"Playlist"> | number
    contentItems?: ContentItemListRelationFilter
    gamifiedPlaylists?: GamifiedPlaylistListRelationFilter
    mundo?: XOR<MundoRelationFilter, MundoWhereInput>
    videoItems?: VideoItemListRelationFilter
  }, "id">

  export type PlaylistOrderByWithAggregationInput = {
    id?: SortOrder
    mundoId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    orderInMundo?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    version?: SortOrder
    _count?: PlaylistCountOrderByAggregateInput
    _avg?: PlaylistAvgOrderByAggregateInput
    _max?: PlaylistMaxOrderByAggregateInput
    _min?: PlaylistMinOrderByAggregateInput
    _sum?: PlaylistSumOrderByAggregateInput
  }

  export type PlaylistScalarWhereWithAggregatesInput = {
    AND?: PlaylistScalarWhereWithAggregatesInput | PlaylistScalarWhereWithAggregatesInput[]
    OR?: PlaylistScalarWhereWithAggregatesInput[]
    NOT?: PlaylistScalarWhereWithAggregatesInput | PlaylistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Playlist"> | string
    mundoId?: StringWithAggregatesFilter<"Playlist"> | string
    name?: StringWithAggregatesFilter<"Playlist"> | string
    description?: StringNullableWithAggregatesFilter<"Playlist"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Playlist"> | string | null
    orderInMundo?: IntNullableWithAggregatesFilter<"Playlist"> | number | null
    isActive?: BoolWithAggregatesFilter<"Playlist"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Playlist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Playlist"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"Playlist"> | string | null
    version?: IntWithAggregatesFilter<"Playlist"> | number
  }

  export type VideoItemWhereInput = {
    AND?: VideoItemWhereInput | VideoItemWhereInput[]
    OR?: VideoItemWhereInput[]
    NOT?: VideoItemWhereInput | VideoItemWhereInput[]
    id?: IntFilter<"VideoItem"> | number
    title?: StringFilter<"VideoItem"> | string
    description?: StringNullableFilter<"VideoItem"> | string | null
    content?: StringFilter<"VideoItem"> | string
    url?: StringNullableFilter<"VideoItem"> | string | null
    platform?: StringFilter<"VideoItem"> | string
    externalId?: StringNullableFilter<"VideoItem"> | string | null
    playlistId?: StringFilter<"VideoItem"> | string
    itemTypeId?: StringFilter<"VideoItem"> | string
    order?: IntFilter<"VideoItem"> | number
    isActive?: BoolFilter<"VideoItem"> | boolean
    isDeleted?: BoolFilter<"VideoItem"> | boolean
    deletedAt?: DateTimeNullableFilter<"VideoItem"> | Date | string | null
    createdAt?: DateTimeFilter<"VideoItem"> | Date | string
    updatedAt?: DateTimeFilter<"VideoItem"> | Date | string
    duration?: IntNullableFilter<"VideoItem"> | number | null
    categories?: StringNullableFilter<"VideoItem"> | string | null
    language?: StringNullableFilter<"VideoItem"> | string | null
    quality?: StringNullableFilter<"VideoItem"> | string | null
    tags?: StringNullableFilter<"VideoItem"> | string | null
    thumbnailUrl?: StringNullableFilter<"VideoItem"> | string | null
    activities?: ActivityListRelationFilter
    questions?: QuestionListRelationFilter
    subtitles?: SubtitleListRelationFilter
    studyRooms?: StudyRoomListRelationFilter
    playlist?: XOR<PlaylistRelationFilter, PlaylistWhereInput>
    permissions?: XOR<VideoPermissionsNullableRelationFilter, VideoPermissionsWhereInput> | null
  }

  export type VideoItemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    url?: SortOrderInput | SortOrder
    platform?: SortOrder
    externalId?: SortOrderInput | SortOrder
    playlistId?: SortOrder
    itemTypeId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    duration?: SortOrderInput | SortOrder
    categories?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    quality?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    activities?: ActivityOrderByRelationAggregateInput
    questions?: QuestionOrderByRelationAggregateInput
    subtitles?: SubtitleOrderByRelationAggregateInput
    studyRooms?: StudyRoomOrderByRelationAggregateInput
    playlist?: PlaylistOrderByWithRelationInput
    permissions?: VideoPermissionsOrderByWithRelationInput
  }

  export type VideoItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VideoItemWhereInput | VideoItemWhereInput[]
    OR?: VideoItemWhereInput[]
    NOT?: VideoItemWhereInput | VideoItemWhereInput[]
    title?: StringFilter<"VideoItem"> | string
    description?: StringNullableFilter<"VideoItem"> | string | null
    content?: StringFilter<"VideoItem"> | string
    url?: StringNullableFilter<"VideoItem"> | string | null
    platform?: StringFilter<"VideoItem"> | string
    externalId?: StringNullableFilter<"VideoItem"> | string | null
    playlistId?: StringFilter<"VideoItem"> | string
    itemTypeId?: StringFilter<"VideoItem"> | string
    order?: IntFilter<"VideoItem"> | number
    isActive?: BoolFilter<"VideoItem"> | boolean
    isDeleted?: BoolFilter<"VideoItem"> | boolean
    deletedAt?: DateTimeNullableFilter<"VideoItem"> | Date | string | null
    createdAt?: DateTimeFilter<"VideoItem"> | Date | string
    updatedAt?: DateTimeFilter<"VideoItem"> | Date | string
    duration?: IntNullableFilter<"VideoItem"> | number | null
    categories?: StringNullableFilter<"VideoItem"> | string | null
    language?: StringNullableFilter<"VideoItem"> | string | null
    quality?: StringNullableFilter<"VideoItem"> | string | null
    tags?: StringNullableFilter<"VideoItem"> | string | null
    thumbnailUrl?: StringNullableFilter<"VideoItem"> | string | null
    activities?: ActivityListRelationFilter
    questions?: QuestionListRelationFilter
    subtitles?: SubtitleListRelationFilter
    studyRooms?: StudyRoomListRelationFilter
    playlist?: XOR<PlaylistRelationFilter, PlaylistWhereInput>
    permissions?: XOR<VideoPermissionsNullableRelationFilter, VideoPermissionsWhereInput> | null
  }, "id">

  export type VideoItemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    url?: SortOrderInput | SortOrder
    platform?: SortOrder
    externalId?: SortOrderInput | SortOrder
    playlistId?: SortOrder
    itemTypeId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    duration?: SortOrderInput | SortOrder
    categories?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    quality?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    _count?: VideoItemCountOrderByAggregateInput
    _avg?: VideoItemAvgOrderByAggregateInput
    _max?: VideoItemMaxOrderByAggregateInput
    _min?: VideoItemMinOrderByAggregateInput
    _sum?: VideoItemSumOrderByAggregateInput
  }

  export type VideoItemScalarWhereWithAggregatesInput = {
    AND?: VideoItemScalarWhereWithAggregatesInput | VideoItemScalarWhereWithAggregatesInput[]
    OR?: VideoItemScalarWhereWithAggregatesInput[]
    NOT?: VideoItemScalarWhereWithAggregatesInput | VideoItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VideoItem"> | number
    title?: StringWithAggregatesFilter<"VideoItem"> | string
    description?: StringNullableWithAggregatesFilter<"VideoItem"> | string | null
    content?: StringWithAggregatesFilter<"VideoItem"> | string
    url?: StringNullableWithAggregatesFilter<"VideoItem"> | string | null
    platform?: StringWithAggregatesFilter<"VideoItem"> | string
    externalId?: StringNullableWithAggregatesFilter<"VideoItem"> | string | null
    playlistId?: StringWithAggregatesFilter<"VideoItem"> | string
    itemTypeId?: StringWithAggregatesFilter<"VideoItem"> | string
    order?: IntWithAggregatesFilter<"VideoItem"> | number
    isActive?: BoolWithAggregatesFilter<"VideoItem"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"VideoItem"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"VideoItem"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VideoItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VideoItem"> | Date | string
    duration?: IntNullableWithAggregatesFilter<"VideoItem"> | number | null
    categories?: StringNullableWithAggregatesFilter<"VideoItem"> | string | null
    language?: StringNullableWithAggregatesFilter<"VideoItem"> | string | null
    quality?: StringNullableWithAggregatesFilter<"VideoItem"> | string | null
    tags?: StringNullableWithAggregatesFilter<"VideoItem"> | string | null
    thumbnailUrl?: StringNullableWithAggregatesFilter<"VideoItem"> | string | null
  }

  export type SubtitleWhereInput = {
    AND?: SubtitleWhereInput | SubtitleWhereInput[]
    OR?: SubtitleWhereInput[]
    NOT?: SubtitleWhereInput | SubtitleWhereInput[]
    id?: IntFilter<"Subtitle"> | number
    videoItemId?: IntFilter<"Subtitle"> | number
    languageCode?: StringFilter<"Subtitle"> | string
    format?: StringFilter<"Subtitle"> | string
    content?: StringNullableFilter<"Subtitle"> | string | null
    contentUrl?: StringNullableFilter<"Subtitle"> | string | null
    isActive?: BoolFilter<"Subtitle"> | boolean
    createdAt?: DateTimeFilter<"Subtitle"> | Date | string
    updatedAt?: DateTimeFilter<"Subtitle"> | Date | string
    videoItem?: XOR<VideoItemRelationFilter, VideoItemWhereInput>
  }

  export type SubtitleOrderByWithRelationInput = {
    id?: SortOrder
    videoItemId?: SortOrder
    languageCode?: SortOrder
    format?: SortOrder
    content?: SortOrderInput | SortOrder
    contentUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    videoItem?: VideoItemOrderByWithRelationInput
  }

  export type SubtitleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SubtitleWhereInput | SubtitleWhereInput[]
    OR?: SubtitleWhereInput[]
    NOT?: SubtitleWhereInput | SubtitleWhereInput[]
    videoItemId?: IntFilter<"Subtitle"> | number
    languageCode?: StringFilter<"Subtitle"> | string
    format?: StringFilter<"Subtitle"> | string
    content?: StringNullableFilter<"Subtitle"> | string | null
    contentUrl?: StringNullableFilter<"Subtitle"> | string | null
    isActive?: BoolFilter<"Subtitle"> | boolean
    createdAt?: DateTimeFilter<"Subtitle"> | Date | string
    updatedAt?: DateTimeFilter<"Subtitle"> | Date | string
    videoItem?: XOR<VideoItemRelationFilter, VideoItemWhereInput>
  }, "id">

  export type SubtitleOrderByWithAggregationInput = {
    id?: SortOrder
    videoItemId?: SortOrder
    languageCode?: SortOrder
    format?: SortOrder
    content?: SortOrderInput | SortOrder
    contentUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubtitleCountOrderByAggregateInput
    _avg?: SubtitleAvgOrderByAggregateInput
    _max?: SubtitleMaxOrderByAggregateInput
    _min?: SubtitleMinOrderByAggregateInput
    _sum?: SubtitleSumOrderByAggregateInput
  }

  export type SubtitleScalarWhereWithAggregatesInput = {
    AND?: SubtitleScalarWhereWithAggregatesInput | SubtitleScalarWhereWithAggregatesInput[]
    OR?: SubtitleScalarWhereWithAggregatesInput[]
    NOT?: SubtitleScalarWhereWithAggregatesInput | SubtitleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subtitle"> | number
    videoItemId?: IntWithAggregatesFilter<"Subtitle"> | number
    languageCode?: StringWithAggregatesFilter<"Subtitle"> | string
    format?: StringWithAggregatesFilter<"Subtitle"> | string
    content?: StringNullableWithAggregatesFilter<"Subtitle"> | string | null
    contentUrl?: StringNullableWithAggregatesFilter<"Subtitle"> | string | null
    isActive?: BoolWithAggregatesFilter<"Subtitle"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Subtitle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subtitle"> | Date | string
  }

  export type QuestionWhereInput = {
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    id?: IntFilter<"Question"> | number
    videoItemId?: IntFilter<"Question"> | number
    timestamp?: IntFilter<"Question"> | number
    type?: StringFilter<"Question"> | string
    text?: StringFilter<"Question"> | string
    languageCode?: StringFilter<"Question"> | string
    isActive?: BoolFilter<"Question"> | boolean
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    endTimestamp?: IntNullableFilter<"Question"> | number | null
    answerOptions?: AnswerOptionListRelationFilter
    videoItem?: XOR<VideoItemRelationFilter, VideoItemWhereInput>
    userAnswers?: UserAnswerListRelationFilter
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    videoItemId?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    text?: SortOrder
    languageCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    endTimestamp?: SortOrderInput | SortOrder
    answerOptions?: AnswerOptionOrderByRelationAggregateInput
    videoItem?: VideoItemOrderByWithRelationInput
    userAnswers?: UserAnswerOrderByRelationAggregateInput
  }

  export type QuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    videoItemId?: IntFilter<"Question"> | number
    timestamp?: IntFilter<"Question"> | number
    type?: StringFilter<"Question"> | string
    text?: StringFilter<"Question"> | string
    languageCode?: StringFilter<"Question"> | string
    isActive?: BoolFilter<"Question"> | boolean
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    endTimestamp?: IntNullableFilter<"Question"> | number | null
    answerOptions?: AnswerOptionListRelationFilter
    videoItem?: XOR<VideoItemRelationFilter, VideoItemWhereInput>
    userAnswers?: UserAnswerListRelationFilter
  }, "id">

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    videoItemId?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    text?: SortOrder
    languageCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    endTimestamp?: SortOrderInput | SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _avg?: QuestionAvgOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
    _sum?: QuestionSumOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    OR?: QuestionScalarWhereWithAggregatesInput[]
    NOT?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Question"> | number
    videoItemId?: IntWithAggregatesFilter<"Question"> | number
    timestamp?: IntWithAggregatesFilter<"Question"> | number
    type?: StringWithAggregatesFilter<"Question"> | string
    text?: StringWithAggregatesFilter<"Question"> | string
    languageCode?: StringWithAggregatesFilter<"Question"> | string
    isActive?: BoolWithAggregatesFilter<"Question"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
    endTimestamp?: IntNullableWithAggregatesFilter<"Question"> | number | null
  }

  export type AnswerOptionWhereInput = {
    AND?: AnswerOptionWhereInput | AnswerOptionWhereInput[]
    OR?: AnswerOptionWhereInput[]
    NOT?: AnswerOptionWhereInput | AnswerOptionWhereInput[]
    id?: IntFilter<"AnswerOption"> | number
    questionId?: IntFilter<"AnswerOption"> | number
    text?: StringFilter<"AnswerOption"> | string
    isCorrect?: BoolFilter<"AnswerOption"> | boolean
    order?: IntFilter<"AnswerOption"> | number
    createdAt?: DateTimeFilter<"AnswerOption"> | Date | string
    updatedAt?: DateTimeFilter<"AnswerOption"> | Date | string
    question?: XOR<QuestionRelationFilter, QuestionWhereInput>
  }

  export type AnswerOptionOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: QuestionOrderByWithRelationInput
  }

  export type AnswerOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AnswerOptionWhereInput | AnswerOptionWhereInput[]
    OR?: AnswerOptionWhereInput[]
    NOT?: AnswerOptionWhereInput | AnswerOptionWhereInput[]
    questionId?: IntFilter<"AnswerOption"> | number
    text?: StringFilter<"AnswerOption"> | string
    isCorrect?: BoolFilter<"AnswerOption"> | boolean
    order?: IntFilter<"AnswerOption"> | number
    createdAt?: DateTimeFilter<"AnswerOption"> | Date | string
    updatedAt?: DateTimeFilter<"AnswerOption"> | Date | string
    question?: XOR<QuestionRelationFilter, QuestionWhereInput>
  }, "id">

  export type AnswerOptionOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnswerOptionCountOrderByAggregateInput
    _avg?: AnswerOptionAvgOrderByAggregateInput
    _max?: AnswerOptionMaxOrderByAggregateInput
    _min?: AnswerOptionMinOrderByAggregateInput
    _sum?: AnswerOptionSumOrderByAggregateInput
  }

  export type AnswerOptionScalarWhereWithAggregatesInput = {
    AND?: AnswerOptionScalarWhereWithAggregatesInput | AnswerOptionScalarWhereWithAggregatesInput[]
    OR?: AnswerOptionScalarWhereWithAggregatesInput[]
    NOT?: AnswerOptionScalarWhereWithAggregatesInput | AnswerOptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AnswerOption"> | number
    questionId?: IntWithAggregatesFilter<"AnswerOption"> | number
    text?: StringWithAggregatesFilter<"AnswerOption"> | string
    isCorrect?: BoolWithAggregatesFilter<"AnswerOption"> | boolean
    order?: IntWithAggregatesFilter<"AnswerOption"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AnswerOption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnswerOption"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    username?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    documentType?: StringNullableFilter<"User"> | string | null
    documentNumber?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
    topUserCount?: IntFilter<"User"> | number
    personalityId?: StringNullableFilter<"User"> | string | null
    createdActivities?: ActivityListRelationFilter
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    createdExperiences?: ExperienceListRelationFilter
    invitationsSent?: GiftCardListRelationFilter
    ownedGroups?: GroupListRelationFilter
    createdInvitationTemplates?: InvitationTemplateListRelationFilter
    merits?: MeritListRelationFilter
    notifications?: NotificationListRelationFilter
    publications?: PublicationListRelationFilter
    createdReports?: ReportListRelationFilter
    assignedPermissions?: RolePermissionListRelationFilter
    tokens?: TokenListRelationFilter
    transactionsTo?: TransactionListRelationFilter
    transactionsFrom?: TransactionListRelationFilter
    createdTemplates?: UIComponentTemplateListRelationFilter
    userAnswers?: UserAnswerListRelationFilter
    userChallenges?: UserChallengeListRelationFilter
    userGroups?: UserGroupListRelationFilter
    invitationsReceived?: UserInvitationListRelationFilter
    assignedRoles?: UserRoleListRelationFilter
    userRoles?: UserRoleListRelationFilter
    hostedStudyRooms?: StudyRoomListRelationFilter
    studyRoomParticipants?: StudyRoomParticipantListRelationFilter
    sentChatMessages?: StudyRoomMessageListRelationFilter
    personality?: XOR<PersonalityNullableRelationFilter, PersonalityWhereInput> | null
    videoPermissions?: VideoPermissionsListRelationFilter
    wallet?: XOR<WalletNullableRelationFilter, WalletWhereInput> | null
    createdWorlds?: WorldListRelationFilter
    marketplaceItems?: MarketplaceItemListRelationFilter
    buyerMatches?: MarketplaceMatchListRelationFilter
    sellerMatches?: MarketplaceMatchListRelationFilter
    matchMessages?: MatchMessageListRelationFilter
    feedbackReports?: FeedbackReportListRelationFilter
    adminFeedbackResponses?: FeedbackReportListRelationFilter
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    reviews?: ReviewListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    documentType?: SortOrderInput | SortOrder
    documentNumber?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    topUserCount?: SortOrder
    personalityId?: SortOrderInput | SortOrder
    createdActivities?: ActivityOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
    createdExperiences?: ExperienceOrderByRelationAggregateInput
    invitationsSent?: GiftCardOrderByRelationAggregateInput
    ownedGroups?: GroupOrderByRelationAggregateInput
    createdInvitationTemplates?: InvitationTemplateOrderByRelationAggregateInput
    merits?: MeritOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    publications?: PublicationOrderByRelationAggregateInput
    createdReports?: ReportOrderByRelationAggregateInput
    assignedPermissions?: RolePermissionOrderByRelationAggregateInput
    tokens?: TokenOrderByRelationAggregateInput
    transactionsTo?: TransactionOrderByRelationAggregateInput
    transactionsFrom?: TransactionOrderByRelationAggregateInput
    createdTemplates?: UIComponentTemplateOrderByRelationAggregateInput
    userAnswers?: UserAnswerOrderByRelationAggregateInput
    userChallenges?: UserChallengeOrderByRelationAggregateInput
    userGroups?: UserGroupOrderByRelationAggregateInput
    invitationsReceived?: UserInvitationOrderByRelationAggregateInput
    assignedRoles?: UserRoleOrderByRelationAggregateInput
    userRoles?: UserRoleOrderByRelationAggregateInput
    hostedStudyRooms?: StudyRoomOrderByRelationAggregateInput
    studyRoomParticipants?: StudyRoomParticipantOrderByRelationAggregateInput
    sentChatMessages?: StudyRoomMessageOrderByRelationAggregateInput
    personality?: PersonalityOrderByWithRelationInput
    videoPermissions?: VideoPermissionsOrderByRelationAggregateInput
    wallet?: WalletOrderByWithRelationInput
    createdWorlds?: WorldOrderByRelationAggregateInput
    marketplaceItems?: MarketplaceItemOrderByRelationAggregateInput
    buyerMatches?: MarketplaceMatchOrderByRelationAggregateInput
    sellerMatches?: MarketplaceMatchOrderByRelationAggregateInput
    matchMessages?: MatchMessageOrderByRelationAggregateInput
    feedbackReports?: FeedbackReportOrderByRelationAggregateInput
    adminFeedbackResponses?: FeedbackReportOrderByRelationAggregateInput
    profile?: ProfileOrderByWithRelationInput
    reviews?: ReviewOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    documentType?: StringNullableFilter<"User"> | string | null
    documentNumber?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
    topUserCount?: IntFilter<"User"> | number
    personalityId?: StringNullableFilter<"User"> | string | null
    createdActivities?: ActivityListRelationFilter
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    createdExperiences?: ExperienceListRelationFilter
    invitationsSent?: GiftCardListRelationFilter
    ownedGroups?: GroupListRelationFilter
    createdInvitationTemplates?: InvitationTemplateListRelationFilter
    merits?: MeritListRelationFilter
    notifications?: NotificationListRelationFilter
    publications?: PublicationListRelationFilter
    createdReports?: ReportListRelationFilter
    assignedPermissions?: RolePermissionListRelationFilter
    tokens?: TokenListRelationFilter
    transactionsTo?: TransactionListRelationFilter
    transactionsFrom?: TransactionListRelationFilter
    createdTemplates?: UIComponentTemplateListRelationFilter
    userAnswers?: UserAnswerListRelationFilter
    userChallenges?: UserChallengeListRelationFilter
    userGroups?: UserGroupListRelationFilter
    invitationsReceived?: UserInvitationListRelationFilter
    assignedRoles?: UserRoleListRelationFilter
    userRoles?: UserRoleListRelationFilter
    hostedStudyRooms?: StudyRoomListRelationFilter
    studyRoomParticipants?: StudyRoomParticipantListRelationFilter
    sentChatMessages?: StudyRoomMessageListRelationFilter
    personality?: XOR<PersonalityNullableRelationFilter, PersonalityWhereInput> | null
    videoPermissions?: VideoPermissionsListRelationFilter
    wallet?: XOR<WalletNullableRelationFilter, WalletWhereInput> | null
    createdWorlds?: WorldListRelationFilter
    marketplaceItems?: MarketplaceItemListRelationFilter
    buyerMatches?: MarketplaceMatchListRelationFilter
    sellerMatches?: MarketplaceMatchListRelationFilter
    matchMessages?: MatchMessageListRelationFilter
    feedbackReports?: FeedbackReportListRelationFilter
    adminFeedbackResponses?: FeedbackReportListRelationFilter
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    reviews?: ReviewListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    documentType?: SortOrderInput | SortOrder
    documentNumber?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    topUserCount?: SortOrder
    personalityId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    documentType?: StringNullableWithAggregatesFilter<"User"> | string | null
    documentNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    status?: StringWithAggregatesFilter<"User"> | string
    topUserCount?: IntWithAggregatesFilter<"User"> | number
    personalityId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
    userRoles?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rolePermissions?: RolePermissionOrderByRelationAggregateInput
    userRoles?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
    userRoles?: UserRoleListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    assignedById?: StringNullableFilter<"UserRole"> | string | null
    assignedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedById?: SortOrderInput | SortOrder
    assignedBy?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    assignedById?: StringNullableFilter<"UserRole"> | string | null
    assignedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedById?: SortOrderInput | SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserRole"> | string
    roleId?: StringWithAggregatesFilter<"UserRole"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
    assignedById?: StringNullableWithAggregatesFilter<"UserRole"> | string | null
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rolePermissions?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
  }, "id" | "name">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type VideoPermissionsWhereInput = {
    AND?: VideoPermissionsWhereInput | VideoPermissionsWhereInput[]
    OR?: VideoPermissionsWhereInput[]
    NOT?: VideoPermissionsWhereInput | VideoPermissionsWhereInput[]
    id?: StringFilter<"VideoPermissions"> | string
    videoItemId?: IntFilter<"VideoPermissions"> | number
    showWaveCount?: BoolFilter<"VideoPermissions"> | boolean
    showVideos?: BoolFilter<"VideoPermissions"> | boolean
    showVideoSubtitles?: BoolFilter<"VideoPermissions"> | boolean
    showComments?: BoolFilter<"VideoPermissions"> | boolean
    showPublishDate?: BoolFilter<"VideoPermissions"> | boolean
    showVideoDuration?: BoolFilter<"VideoPermissions"> | boolean
    showLikeButton?: BoolFilter<"VideoPermissions"> | boolean
    allowRewindForward?: BoolFilter<"VideoPermissions"> | boolean
    allowViewComments?: BoolFilter<"VideoPermissions"> | boolean
    allowMakeComments?: BoolFilter<"VideoPermissions"> | boolean
    showLikeComments?: BoolFilter<"VideoPermissions"> | boolean
    sortCommentsByAffinity?: BoolFilter<"VideoPermissions"> | boolean
    showCommenterName?: BoolFilter<"VideoPermissions"> | boolean
    playlistPosition?: StringFilter<"VideoPermissions"> | string
    isDraft?: BoolFilter<"VideoPermissions"> | boolean
    createdAt?: DateTimeFilter<"VideoPermissions"> | Date | string
    updatedAt?: DateTimeFilter<"VideoPermissions"> | Date | string
    createdById?: StringNullableFilter<"VideoPermissions"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    videoItem?: XOR<VideoItemRelationFilter, VideoItemWhereInput>
  }

  export type VideoPermissionsOrderByWithRelationInput = {
    id?: SortOrder
    videoItemId?: SortOrder
    showWaveCount?: SortOrder
    showVideos?: SortOrder
    showVideoSubtitles?: SortOrder
    showComments?: SortOrder
    showPublishDate?: SortOrder
    showVideoDuration?: SortOrder
    showLikeButton?: SortOrder
    allowRewindForward?: SortOrder
    allowViewComments?: SortOrder
    allowMakeComments?: SortOrder
    showLikeComments?: SortOrder
    sortCommentsByAffinity?: SortOrder
    showCommenterName?: SortOrder
    playlistPosition?: SortOrder
    isDraft?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    videoItem?: VideoItemOrderByWithRelationInput
  }

  export type VideoPermissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    videoItemId?: number
    AND?: VideoPermissionsWhereInput | VideoPermissionsWhereInput[]
    OR?: VideoPermissionsWhereInput[]
    NOT?: VideoPermissionsWhereInput | VideoPermissionsWhereInput[]
    showWaveCount?: BoolFilter<"VideoPermissions"> | boolean
    showVideos?: BoolFilter<"VideoPermissions"> | boolean
    showVideoSubtitles?: BoolFilter<"VideoPermissions"> | boolean
    showComments?: BoolFilter<"VideoPermissions"> | boolean
    showPublishDate?: BoolFilter<"VideoPermissions"> | boolean
    showVideoDuration?: BoolFilter<"VideoPermissions"> | boolean
    showLikeButton?: BoolFilter<"VideoPermissions"> | boolean
    allowRewindForward?: BoolFilter<"VideoPermissions"> | boolean
    allowViewComments?: BoolFilter<"VideoPermissions"> | boolean
    allowMakeComments?: BoolFilter<"VideoPermissions"> | boolean
    showLikeComments?: BoolFilter<"VideoPermissions"> | boolean
    sortCommentsByAffinity?: BoolFilter<"VideoPermissions"> | boolean
    showCommenterName?: BoolFilter<"VideoPermissions"> | boolean
    playlistPosition?: StringFilter<"VideoPermissions"> | string
    isDraft?: BoolFilter<"VideoPermissions"> | boolean
    createdAt?: DateTimeFilter<"VideoPermissions"> | Date | string
    updatedAt?: DateTimeFilter<"VideoPermissions"> | Date | string
    createdById?: StringNullableFilter<"VideoPermissions"> | string | null
    createdBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    videoItem?: XOR<VideoItemRelationFilter, VideoItemWhereInput>
  }, "id" | "videoItemId">

  export type VideoPermissionsOrderByWithAggregationInput = {
    id?: SortOrder
    videoItemId?: SortOrder
    showWaveCount?: SortOrder
    showVideos?: SortOrder
    showVideoSubtitles?: SortOrder
    showComments?: SortOrder
    showPublishDate?: SortOrder
    showVideoDuration?: SortOrder
    showLikeButton?: SortOrder
    allowRewindForward?: SortOrder
    allowViewComments?: SortOrder
    allowMakeComments?: SortOrder
    showLikeComments?: SortOrder
    sortCommentsByAffinity?: SortOrder
    showCommenterName?: SortOrder
    playlistPosition?: SortOrder
    isDraft?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: VideoPermissionsCountOrderByAggregateInput
    _avg?: VideoPermissionsAvgOrderByAggregateInput
    _max?: VideoPermissionsMaxOrderByAggregateInput
    _min?: VideoPermissionsMinOrderByAggregateInput
    _sum?: VideoPermissionsSumOrderByAggregateInput
  }

  export type VideoPermissionsScalarWhereWithAggregatesInput = {
    AND?: VideoPermissionsScalarWhereWithAggregatesInput | VideoPermissionsScalarWhereWithAggregatesInput[]
    OR?: VideoPermissionsScalarWhereWithAggregatesInput[]
    NOT?: VideoPermissionsScalarWhereWithAggregatesInput | VideoPermissionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoPermissions"> | string
    videoItemId?: IntWithAggregatesFilter<"VideoPermissions"> | number
    showWaveCount?: BoolWithAggregatesFilter<"VideoPermissions"> | boolean
    showVideos?: BoolWithAggregatesFilter<"VideoPermissions"> | boolean
    showVideoSubtitles?: BoolWithAggregatesFilter<"VideoPermissions"> | boolean
    showComments?: BoolWithAggregatesFilter<"VideoPermissions"> | boolean
    showPublishDate?: BoolWithAggregatesFilter<"VideoPermissions"> | boolean
    showVideoDuration?: BoolWithAggregatesFilter<"VideoPermissions"> | boolean
    showLikeButton?: BoolWithAggregatesFilter<"VideoPermissions"> | boolean
    allowRewindForward?: BoolWithAggregatesFilter<"VideoPermissions"> | boolean
    allowViewComments?: BoolWithAggregatesFilter<"VideoPermissions"> | boolean
    allowMakeComments?: BoolWithAggregatesFilter<"VideoPermissions"> | boolean
    showLikeComments?: BoolWithAggregatesFilter<"VideoPermissions"> | boolean
    sortCommentsByAffinity?: BoolWithAggregatesFilter<"VideoPermissions"> | boolean
    showCommenterName?: BoolWithAggregatesFilter<"VideoPermissions"> | boolean
    playlistPosition?: StringWithAggregatesFilter<"VideoPermissions"> | string
    isDraft?: BoolWithAggregatesFilter<"VideoPermissions"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"VideoPermissions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VideoPermissions"> | Date | string
    createdById?: StringNullableWithAggregatesFilter<"VideoPermissions"> | string | null
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    assignedAt?: DateTimeFilter<"RolePermission"> | Date | string
    assignedById?: StringNullableFilter<"RolePermission"> | string | null
    assignedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    assignedAt?: SortOrder
    assignedById?: SortOrderInput | SortOrder
    assignedBy?: UserOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    assignedAt?: DateTimeFilter<"RolePermission"> | Date | string
    assignedById?: StringNullableFilter<"RolePermission"> | string | null
    assignedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }, "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    assignedAt?: SortOrder
    assignedById?: SortOrderInput | SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    roleId?: StringWithAggregatesFilter<"RolePermission"> | string
    permissionId?: StringWithAggregatesFilter<"RolePermission"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
    assignedById?: StringNullableWithAggregatesFilter<"RolePermission"> | string | null
  }

  export type WorldWhereInput = {
    AND?: WorldWhereInput | WorldWhereInput[]
    OR?: WorldWhereInput[]
    NOT?: WorldWhereInput | WorldWhereInput[]
    id?: StringFilter<"World"> | string
    name?: StringFilter<"World"> | string
    description?: StringNullableFilter<"World"> | string | null
    type?: StringFilter<"World"> | string
    creatorId?: StringFilter<"World"> | string
    status?: StringFilter<"World"> | string
    createdAt?: DateTimeFilter<"World"> | Date | string
    updatedAt?: DateTimeFilter<"World"> | Date | string
    mundoId?: StringNullableFilter<"World"> | string | null
    stages?: StageListRelationFilter
    mundo?: XOR<MundoNullableRelationFilter, MundoWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WorldOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    creatorId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mundoId?: SortOrderInput | SortOrder
    stages?: StageOrderByRelationAggregateInput
    mundo?: MundoOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type WorldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorldWhereInput | WorldWhereInput[]
    OR?: WorldWhereInput[]
    NOT?: WorldWhereInput | WorldWhereInput[]
    name?: StringFilter<"World"> | string
    description?: StringNullableFilter<"World"> | string | null
    type?: StringFilter<"World"> | string
    creatorId?: StringFilter<"World"> | string
    status?: StringFilter<"World"> | string
    createdAt?: DateTimeFilter<"World"> | Date | string
    updatedAt?: DateTimeFilter<"World"> | Date | string
    mundoId?: StringNullableFilter<"World"> | string | null
    stages?: StageListRelationFilter
    mundo?: XOR<MundoNullableRelationFilter, MundoWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type WorldOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    creatorId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mundoId?: SortOrderInput | SortOrder
    _count?: WorldCountOrderByAggregateInput
    _max?: WorldMaxOrderByAggregateInput
    _min?: WorldMinOrderByAggregateInput
  }

  export type WorldScalarWhereWithAggregatesInput = {
    AND?: WorldScalarWhereWithAggregatesInput | WorldScalarWhereWithAggregatesInput[]
    OR?: WorldScalarWhereWithAggregatesInput[]
    NOT?: WorldScalarWhereWithAggregatesInput | WorldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"World"> | string
    name?: StringWithAggregatesFilter<"World"> | string
    description?: StringNullableWithAggregatesFilter<"World"> | string | null
    type?: StringWithAggregatesFilter<"World"> | string
    creatorId?: StringWithAggregatesFilter<"World"> | string
    status?: StringWithAggregatesFilter<"World"> | string
    createdAt?: DateTimeWithAggregatesFilter<"World"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"World"> | Date | string
    mundoId?: StringNullableWithAggregatesFilter<"World"> | string | null
  }

  export type StageWhereInput = {
    AND?: StageWhereInput | StageWhereInput[]
    OR?: StageWhereInput[]
    NOT?: StageWhereInput | StageWhereInput[]
    id?: StringFilter<"Stage"> | string
    worldId?: StringFilter<"Stage"> | string
    name?: StringFilter<"Stage"> | string
    order?: IntFilter<"Stage"> | number
    description?: StringNullableFilter<"Stage"> | string | null
    createdAt?: DateTimeFilter<"Stage"> | Date | string
    updatedAt?: DateTimeFilter<"Stage"> | Date | string
    experiences?: ExperienceListRelationFilter
    world?: XOR<WorldRelationFilter, WorldWhereInput>
  }

  export type StageOrderByWithRelationInput = {
    id?: SortOrder
    worldId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    experiences?: ExperienceOrderByRelationAggregateInput
    world?: WorldOrderByWithRelationInput
  }

  export type StageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StageWhereInput | StageWhereInput[]
    OR?: StageWhereInput[]
    NOT?: StageWhereInput | StageWhereInput[]
    worldId?: StringFilter<"Stage"> | string
    name?: StringFilter<"Stage"> | string
    order?: IntFilter<"Stage"> | number
    description?: StringNullableFilter<"Stage"> | string | null
    createdAt?: DateTimeFilter<"Stage"> | Date | string
    updatedAt?: DateTimeFilter<"Stage"> | Date | string
    experiences?: ExperienceListRelationFilter
    world?: XOR<WorldRelationFilter, WorldWhereInput>
  }, "id">

  export type StageOrderByWithAggregationInput = {
    id?: SortOrder
    worldId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StageCountOrderByAggregateInput
    _avg?: StageAvgOrderByAggregateInput
    _max?: StageMaxOrderByAggregateInput
    _min?: StageMinOrderByAggregateInput
    _sum?: StageSumOrderByAggregateInput
  }

  export type StageScalarWhereWithAggregatesInput = {
    AND?: StageScalarWhereWithAggregatesInput | StageScalarWhereWithAggregatesInput[]
    OR?: StageScalarWhereWithAggregatesInput[]
    NOT?: StageScalarWhereWithAggregatesInput | StageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Stage"> | string
    worldId?: StringWithAggregatesFilter<"Stage"> | string
    name?: StringWithAggregatesFilter<"Stage"> | string
    order?: IntWithAggregatesFilter<"Stage"> | number
    description?: StringNullableWithAggregatesFilter<"Stage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Stage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Stage"> | Date | string
  }

  export type ExperienceWhereInput = {
    AND?: ExperienceWhereInput | ExperienceWhereInput[]
    OR?: ExperienceWhereInput[]
    NOT?: ExperienceWhereInput | ExperienceWhereInput[]
    id?: StringFilter<"Experience"> | string
    stageId?: StringFilter<"Experience"> | string
    title?: StringFilter<"Experience"> | string
    description?: StringNullableFilter<"Experience"> | string | null
    type?: StringFilter<"Experience"> | string
    gamificationFramework?: StringNullableFilter<"Experience"> | string | null
    creatorId?: StringFilter<"Experience"> | string
    createdAt?: DateTimeFilter<"Experience"> | Date | string
    updatedAt?: DateTimeFilter<"Experience"> | Date | string
    activities?: ActivityListRelationFilter
    creator?: XOR<UserRelationFilter, UserWhereInput>
    stage?: XOR<StageRelationFilter, StageWhereInput>
  }

  export type ExperienceOrderByWithRelationInput = {
    id?: SortOrder
    stageId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    gamificationFramework?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    activities?: ActivityOrderByRelationAggregateInput
    creator?: UserOrderByWithRelationInput
    stage?: StageOrderByWithRelationInput
  }

  export type ExperienceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExperienceWhereInput | ExperienceWhereInput[]
    OR?: ExperienceWhereInput[]
    NOT?: ExperienceWhereInput | ExperienceWhereInput[]
    stageId?: StringFilter<"Experience"> | string
    title?: StringFilter<"Experience"> | string
    description?: StringNullableFilter<"Experience"> | string | null
    type?: StringFilter<"Experience"> | string
    gamificationFramework?: StringNullableFilter<"Experience"> | string | null
    creatorId?: StringFilter<"Experience"> | string
    createdAt?: DateTimeFilter<"Experience"> | Date | string
    updatedAt?: DateTimeFilter<"Experience"> | Date | string
    activities?: ActivityListRelationFilter
    creator?: XOR<UserRelationFilter, UserWhereInput>
    stage?: XOR<StageRelationFilter, StageWhereInput>
  }, "id">

  export type ExperienceOrderByWithAggregationInput = {
    id?: SortOrder
    stageId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    gamificationFramework?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExperienceCountOrderByAggregateInput
    _max?: ExperienceMaxOrderByAggregateInput
    _min?: ExperienceMinOrderByAggregateInput
  }

  export type ExperienceScalarWhereWithAggregatesInput = {
    AND?: ExperienceScalarWhereWithAggregatesInput | ExperienceScalarWhereWithAggregatesInput[]
    OR?: ExperienceScalarWhereWithAggregatesInput[]
    NOT?: ExperienceScalarWhereWithAggregatesInput | ExperienceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Experience"> | string
    stageId?: StringWithAggregatesFilter<"Experience"> | string
    title?: StringWithAggregatesFilter<"Experience"> | string
    description?: StringNullableWithAggregatesFilter<"Experience"> | string | null
    type?: StringWithAggregatesFilter<"Experience"> | string
    gamificationFramework?: StringNullableWithAggregatesFilter<"Experience"> | string | null
    creatorId?: StringWithAggregatesFilter<"Experience"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Experience"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Experience"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    experienceId?: StringFilter<"Activity"> | string
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    type?: StringFilter<"Activity"> | string
    multimediaType?: StringNullableFilter<"Activity"> | string | null
    contentUrl?: StringNullableFilter<"Activity"> | string | null
    duration?: IntNullableFilter<"Activity"> | number | null
    order?: IntFilter<"Activity"> | number
    status?: StringFilter<"Activity"> | string
    creatorId?: StringFilter<"Activity"> | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    videoItemId?: IntNullableFilter<"Activity"> | number | null
    videoItem?: XOR<VideoItemNullableRelationFilter, VideoItemWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    experience?: XOR<ExperienceRelationFilter, ExperienceWhereInput>
    questions?: ActivityQuestionListRelationFilter
    gamifiedPlaylists?: GamifiedPlaylistListRelationFilter
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    experienceId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    multimediaType?: SortOrderInput | SortOrder
    contentUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    order?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    videoItemId?: SortOrderInput | SortOrder
    videoItem?: VideoItemOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    experience?: ExperienceOrderByWithRelationInput
    questions?: ActivityQuestionOrderByRelationAggregateInput
    gamifiedPlaylists?: GamifiedPlaylistOrderByRelationAggregateInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    experienceId?: StringFilter<"Activity"> | string
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    type?: StringFilter<"Activity"> | string
    multimediaType?: StringNullableFilter<"Activity"> | string | null
    contentUrl?: StringNullableFilter<"Activity"> | string | null
    duration?: IntNullableFilter<"Activity"> | number | null
    order?: IntFilter<"Activity"> | number
    status?: StringFilter<"Activity"> | string
    creatorId?: StringFilter<"Activity"> | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    videoItemId?: IntNullableFilter<"Activity"> | number | null
    videoItem?: XOR<VideoItemNullableRelationFilter, VideoItemWhereInput> | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    experience?: XOR<ExperienceRelationFilter, ExperienceWhereInput>
    questions?: ActivityQuestionListRelationFilter
    gamifiedPlaylists?: GamifiedPlaylistListRelationFilter
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    experienceId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    multimediaType?: SortOrderInput | SortOrder
    contentUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    order?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    videoItemId?: SortOrderInput | SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _avg?: ActivityAvgOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
    _sum?: ActivitySumOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    experienceId?: StringWithAggregatesFilter<"Activity"> | string
    title?: StringWithAggregatesFilter<"Activity"> | string
    description?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    type?: StringWithAggregatesFilter<"Activity"> | string
    multimediaType?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    contentUrl?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    duration?: IntNullableWithAggregatesFilter<"Activity"> | number | null
    order?: IntWithAggregatesFilter<"Activity"> | number
    status?: StringWithAggregatesFilter<"Activity"> | string
    creatorId?: StringWithAggregatesFilter<"Activity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    videoItemId?: IntNullableWithAggregatesFilter<"Activity"> | number | null
  }

  export type GamifiedPlaylistWhereInput = {
    AND?: GamifiedPlaylistWhereInput | GamifiedPlaylistWhereInput[]
    OR?: GamifiedPlaylistWhereInput[]
    NOT?: GamifiedPlaylistWhereInput | GamifiedPlaylistWhereInput[]
    id?: StringFilter<"GamifiedPlaylist"> | string
    activityId?: StringNullableFilter<"GamifiedPlaylist"> | string | null
    playlistId?: StringNullableFilter<"GamifiedPlaylist"> | string | null
    name?: StringFilter<"GamifiedPlaylist"> | string
    type?: StringFilter<"GamifiedPlaylist"> | string
    sequenceType?: StringFilter<"GamifiedPlaylist"> | string
    status?: StringFilter<"GamifiedPlaylist"> | string
    createdAt?: DateTimeFilter<"GamifiedPlaylist"> | Date | string
    updatedAt?: DateTimeFilter<"GamifiedPlaylist"> | Date | string
    playlist?: XOR<PlaylistNullableRelationFilter, PlaylistWhereInput> | null
    activity?: XOR<ActivityNullableRelationFilter, ActivityWhereInput> | null
  }

  export type GamifiedPlaylistOrderByWithRelationInput = {
    id?: SortOrder
    activityId?: SortOrderInput | SortOrder
    playlistId?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    sequenceType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    playlist?: PlaylistOrderByWithRelationInput
    activity?: ActivityOrderByWithRelationInput
  }

  export type GamifiedPlaylistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GamifiedPlaylistWhereInput | GamifiedPlaylistWhereInput[]
    OR?: GamifiedPlaylistWhereInput[]
    NOT?: GamifiedPlaylistWhereInput | GamifiedPlaylistWhereInput[]
    activityId?: StringNullableFilter<"GamifiedPlaylist"> | string | null
    playlistId?: StringNullableFilter<"GamifiedPlaylist"> | string | null
    name?: StringFilter<"GamifiedPlaylist"> | string
    type?: StringFilter<"GamifiedPlaylist"> | string
    sequenceType?: StringFilter<"GamifiedPlaylist"> | string
    status?: StringFilter<"GamifiedPlaylist"> | string
    createdAt?: DateTimeFilter<"GamifiedPlaylist"> | Date | string
    updatedAt?: DateTimeFilter<"GamifiedPlaylist"> | Date | string
    playlist?: XOR<PlaylistNullableRelationFilter, PlaylistWhereInput> | null
    activity?: XOR<ActivityNullableRelationFilter, ActivityWhereInput> | null
  }, "id">

  export type GamifiedPlaylistOrderByWithAggregationInput = {
    id?: SortOrder
    activityId?: SortOrderInput | SortOrder
    playlistId?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    sequenceType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GamifiedPlaylistCountOrderByAggregateInput
    _max?: GamifiedPlaylistMaxOrderByAggregateInput
    _min?: GamifiedPlaylistMinOrderByAggregateInput
  }

  export type GamifiedPlaylistScalarWhereWithAggregatesInput = {
    AND?: GamifiedPlaylistScalarWhereWithAggregatesInput | GamifiedPlaylistScalarWhereWithAggregatesInput[]
    OR?: GamifiedPlaylistScalarWhereWithAggregatesInput[]
    NOT?: GamifiedPlaylistScalarWhereWithAggregatesInput | GamifiedPlaylistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GamifiedPlaylist"> | string
    activityId?: StringNullableWithAggregatesFilter<"GamifiedPlaylist"> | string | null
    playlistId?: StringNullableWithAggregatesFilter<"GamifiedPlaylist"> | string | null
    name?: StringWithAggregatesFilter<"GamifiedPlaylist"> | string
    type?: StringWithAggregatesFilter<"GamifiedPlaylist"> | string
    sequenceType?: StringWithAggregatesFilter<"GamifiedPlaylist"> | string
    status?: StringWithAggregatesFilter<"GamifiedPlaylist"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GamifiedPlaylist"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GamifiedPlaylist"> | Date | string
  }

  export type ActivityQuestionWhereInput = {
    AND?: ActivityQuestionWhereInput | ActivityQuestionWhereInput[]
    OR?: ActivityQuestionWhereInput[]
    NOT?: ActivityQuestionWhereInput | ActivityQuestionWhereInput[]
    id?: StringFilter<"ActivityQuestion"> | string
    activityId?: StringFilter<"ActivityQuestion"> | string
    type?: StringFilter<"ActivityQuestion"> | string
    questionType?: StringFilter<"ActivityQuestion"> | string
    questionText?: StringFilter<"ActivityQuestion"> | string
    options?: StringNullableFilter<"ActivityQuestion"> | string | null
    correctAnswer?: StringNullableFilter<"ActivityQuestion"> | string | null
    ondasList?: StringNullableFilter<"ActivityQuestion"> | string | null
    displayTimeSeconds?: IntNullableFilter<"ActivityQuestion"> | number | null
    optionalDisplaySeconds?: IntNullableFilter<"ActivityQuestion"> | number | null
    createdAt?: DateTimeFilter<"ActivityQuestion"> | Date | string
    activity?: XOR<ActivityRelationFilter, ActivityWhereInput>
    userAnswers?: UserAnswerListRelationFilter
  }

  export type ActivityQuestionOrderByWithRelationInput = {
    id?: SortOrder
    activityId?: SortOrder
    type?: SortOrder
    questionType?: SortOrder
    questionText?: SortOrder
    options?: SortOrderInput | SortOrder
    correctAnswer?: SortOrderInput | SortOrder
    ondasList?: SortOrderInput | SortOrder
    displayTimeSeconds?: SortOrderInput | SortOrder
    optionalDisplaySeconds?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    activity?: ActivityOrderByWithRelationInput
    userAnswers?: UserAnswerOrderByRelationAggregateInput
  }

  export type ActivityQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityQuestionWhereInput | ActivityQuestionWhereInput[]
    OR?: ActivityQuestionWhereInput[]
    NOT?: ActivityQuestionWhereInput | ActivityQuestionWhereInput[]
    activityId?: StringFilter<"ActivityQuestion"> | string
    type?: StringFilter<"ActivityQuestion"> | string
    questionType?: StringFilter<"ActivityQuestion"> | string
    questionText?: StringFilter<"ActivityQuestion"> | string
    options?: StringNullableFilter<"ActivityQuestion"> | string | null
    correctAnswer?: StringNullableFilter<"ActivityQuestion"> | string | null
    ondasList?: StringNullableFilter<"ActivityQuestion"> | string | null
    displayTimeSeconds?: IntNullableFilter<"ActivityQuestion"> | number | null
    optionalDisplaySeconds?: IntNullableFilter<"ActivityQuestion"> | number | null
    createdAt?: DateTimeFilter<"ActivityQuestion"> | Date | string
    activity?: XOR<ActivityRelationFilter, ActivityWhereInput>
    userAnswers?: UserAnswerListRelationFilter
  }, "id">

  export type ActivityQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    activityId?: SortOrder
    type?: SortOrder
    questionType?: SortOrder
    questionText?: SortOrder
    options?: SortOrderInput | SortOrder
    correctAnswer?: SortOrderInput | SortOrder
    ondasList?: SortOrderInput | SortOrder
    displayTimeSeconds?: SortOrderInput | SortOrder
    optionalDisplaySeconds?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityQuestionCountOrderByAggregateInput
    _avg?: ActivityQuestionAvgOrderByAggregateInput
    _max?: ActivityQuestionMaxOrderByAggregateInput
    _min?: ActivityQuestionMinOrderByAggregateInput
    _sum?: ActivityQuestionSumOrderByAggregateInput
  }

  export type ActivityQuestionScalarWhereWithAggregatesInput = {
    AND?: ActivityQuestionScalarWhereWithAggregatesInput | ActivityQuestionScalarWhereWithAggregatesInput[]
    OR?: ActivityQuestionScalarWhereWithAggregatesInput[]
    NOT?: ActivityQuestionScalarWhereWithAggregatesInput | ActivityQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityQuestion"> | string
    activityId?: StringWithAggregatesFilter<"ActivityQuestion"> | string
    type?: StringWithAggregatesFilter<"ActivityQuestion"> | string
    questionType?: StringWithAggregatesFilter<"ActivityQuestion"> | string
    questionText?: StringWithAggregatesFilter<"ActivityQuestion"> | string
    options?: StringNullableWithAggregatesFilter<"ActivityQuestion"> | string | null
    correctAnswer?: StringNullableWithAggregatesFilter<"ActivityQuestion"> | string | null
    ondasList?: StringNullableWithAggregatesFilter<"ActivityQuestion"> | string | null
    displayTimeSeconds?: IntNullableWithAggregatesFilter<"ActivityQuestion"> | number | null
    optionalDisplaySeconds?: IntNullableWithAggregatesFilter<"ActivityQuestion"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityQuestion"> | Date | string
  }

  export type UserAnswerWhereInput = {
    AND?: UserAnswerWhereInput | UserAnswerWhereInput[]
    OR?: UserAnswerWhereInput[]
    NOT?: UserAnswerWhereInput | UserAnswerWhereInput[]
    id?: StringFilter<"UserAnswer"> | string
    userId?: StringFilter<"UserAnswer"> | string
    questionId?: IntNullableFilter<"UserAnswer"> | number | null
    activityQuestionId?: StringNullableFilter<"UserAnswer"> | string | null
    answerGiven?: StringFilter<"UserAnswer"> | string
    isCorrect?: BoolNullableFilter<"UserAnswer"> | boolean | null
    ondasEarned?: IntFilter<"UserAnswer"> | number
    createdAt?: DateTimeFilter<"UserAnswer"> | Date | string
    activityQuestion?: XOR<ActivityQuestionNullableRelationFilter, ActivityQuestionWhereInput> | null
    question?: XOR<QuestionNullableRelationFilter, QuestionWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserAnswerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrderInput | SortOrder
    activityQuestionId?: SortOrderInput | SortOrder
    answerGiven?: SortOrder
    isCorrect?: SortOrderInput | SortOrder
    ondasEarned?: SortOrder
    createdAt?: SortOrder
    activityQuestion?: ActivityQuestionOrderByWithRelationInput
    question?: QuestionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserAnswerWhereInput | UserAnswerWhereInput[]
    OR?: UserAnswerWhereInput[]
    NOT?: UserAnswerWhereInput | UserAnswerWhereInput[]
    userId?: StringFilter<"UserAnswer"> | string
    questionId?: IntNullableFilter<"UserAnswer"> | number | null
    activityQuestionId?: StringNullableFilter<"UserAnswer"> | string | null
    answerGiven?: StringFilter<"UserAnswer"> | string
    isCorrect?: BoolNullableFilter<"UserAnswer"> | boolean | null
    ondasEarned?: IntFilter<"UserAnswer"> | number
    createdAt?: DateTimeFilter<"UserAnswer"> | Date | string
    activityQuestion?: XOR<ActivityQuestionNullableRelationFilter, ActivityQuestionWhereInput> | null
    question?: XOR<QuestionNullableRelationFilter, QuestionWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UserAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrderInput | SortOrder
    activityQuestionId?: SortOrderInput | SortOrder
    answerGiven?: SortOrder
    isCorrect?: SortOrderInput | SortOrder
    ondasEarned?: SortOrder
    createdAt?: SortOrder
    _count?: UserAnswerCountOrderByAggregateInput
    _avg?: UserAnswerAvgOrderByAggregateInput
    _max?: UserAnswerMaxOrderByAggregateInput
    _min?: UserAnswerMinOrderByAggregateInput
    _sum?: UserAnswerSumOrderByAggregateInput
  }

  export type UserAnswerScalarWhereWithAggregatesInput = {
    AND?: UserAnswerScalarWhereWithAggregatesInput | UserAnswerScalarWhereWithAggregatesInput[]
    OR?: UserAnswerScalarWhereWithAggregatesInput[]
    NOT?: UserAnswerScalarWhereWithAggregatesInput | UserAnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAnswer"> | string
    userId?: StringWithAggregatesFilter<"UserAnswer"> | string
    questionId?: IntNullableWithAggregatesFilter<"UserAnswer"> | number | null
    activityQuestionId?: StringNullableWithAggregatesFilter<"UserAnswer"> | string | null
    answerGiven?: StringWithAggregatesFilter<"UserAnswer"> | string
    isCorrect?: BoolNullableWithAggregatesFilter<"UserAnswer"> | boolean | null
    ondasEarned?: IntWithAggregatesFilter<"UserAnswer"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserAnswer"> | Date | string
  }

  export type TokenWhereInput = {
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    id?: StringFilter<"Token"> | string
    userId?: StringFilter<"Token"> | string
    amount?: FloatFilter<"Token"> | number
    type?: StringFilter<"Token"> | string
    status?: StringFilter<"Token"> | string
    caducityDate?: DateTimeNullableFilter<"Token"> | Date | string | null
    source?: StringFilter<"Token"> | string
    createdAt?: DateTimeFilter<"Token"> | Date | string
    updatedAt?: DateTimeFilter<"Token"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    caducityDate?: SortOrderInput | SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    userId?: StringFilter<"Token"> | string
    amount?: FloatFilter<"Token"> | number
    type?: StringFilter<"Token"> | string
    status?: StringFilter<"Token"> | string
    caducityDate?: DateTimeNullableFilter<"Token"> | Date | string | null
    source?: StringFilter<"Token"> | string
    createdAt?: DateTimeFilter<"Token"> | Date | string
    updatedAt?: DateTimeFilter<"Token"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type TokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    caducityDate?: SortOrderInput | SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TokenCountOrderByAggregateInput
    _avg?: TokenAvgOrderByAggregateInput
    _max?: TokenMaxOrderByAggregateInput
    _min?: TokenMinOrderByAggregateInput
    _sum?: TokenSumOrderByAggregateInput
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    OR?: TokenScalarWhereWithAggregatesInput[]
    NOT?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Token"> | string
    userId?: StringWithAggregatesFilter<"Token"> | string
    amount?: FloatWithAggregatesFilter<"Token"> | number
    type?: StringWithAggregatesFilter<"Token"> | string
    status?: StringWithAggregatesFilter<"Token"> | string
    caducityDate?: DateTimeNullableWithAggregatesFilter<"Token"> | Date | string | null
    source?: StringWithAggregatesFilter<"Token"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
  }

  export type MeritWhereInput = {
    AND?: MeritWhereInput | MeritWhereInput[]
    OR?: MeritWhereInput[]
    NOT?: MeritWhereInput | MeritWhereInput[]
    id?: StringFilter<"Merit"> | string
    userId?: StringFilter<"Merit"> | string
    amount?: FloatFilter<"Merit"> | number
    type?: StringFilter<"Merit"> | string
    source?: StringFilter<"Merit"> | string
    relatedEntityId?: StringNullableFilter<"Merit"> | string | null
    createdAt?: DateTimeFilter<"Merit"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MeritOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    source?: SortOrder
    relatedEntityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MeritWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MeritWhereInput | MeritWhereInput[]
    OR?: MeritWhereInput[]
    NOT?: MeritWhereInput | MeritWhereInput[]
    userId?: StringFilter<"Merit"> | string
    amount?: FloatFilter<"Merit"> | number
    type?: StringFilter<"Merit"> | string
    source?: StringFilter<"Merit"> | string
    relatedEntityId?: StringNullableFilter<"Merit"> | string | null
    createdAt?: DateTimeFilter<"Merit"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MeritOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    source?: SortOrder
    relatedEntityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MeritCountOrderByAggregateInput
    _avg?: MeritAvgOrderByAggregateInput
    _max?: MeritMaxOrderByAggregateInput
    _min?: MeritMinOrderByAggregateInput
    _sum?: MeritSumOrderByAggregateInput
  }

  export type MeritScalarWhereWithAggregatesInput = {
    AND?: MeritScalarWhereWithAggregatesInput | MeritScalarWhereWithAggregatesInput[]
    OR?: MeritScalarWhereWithAggregatesInput[]
    NOT?: MeritScalarWhereWithAggregatesInput | MeritScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Merit"> | string
    userId?: StringWithAggregatesFilter<"Merit"> | string
    amount?: FloatWithAggregatesFilter<"Merit"> | number
    type?: StringWithAggregatesFilter<"Merit"> | string
    source?: StringWithAggregatesFilter<"Merit"> | string
    relatedEntityId?: StringNullableWithAggregatesFilter<"Merit"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Merit"> | Date | string
  }

  export type WalletWhereInput = {
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    id?: StringFilter<"Wallet"> | string
    userId?: StringFilter<"Wallet"> | string
    blockchainAddress?: StringNullableFilter<"Wallet"> | string | null
    balanceUnits?: FloatFilter<"Wallet"> | number
    balanceToins?: FloatFilter<"Wallet"> | number
    status?: StringFilter<"Wallet"> | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    transactionsTo?: TransactionListRelationFilter
    transactionsFrom?: TransactionListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    blockchainAddress?: SortOrderInput | SortOrder
    balanceUnits?: SortOrder
    balanceToins?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionsTo?: TransactionOrderByRelationAggregateInput
    transactionsFrom?: TransactionOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type WalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    blockchainAddress?: string
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    balanceUnits?: FloatFilter<"Wallet"> | number
    balanceToins?: FloatFilter<"Wallet"> | number
    status?: StringFilter<"Wallet"> | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    transactionsTo?: TransactionListRelationFilter
    transactionsFrom?: TransactionListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId" | "blockchainAddress">

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    blockchainAddress?: SortOrderInput | SortOrder
    balanceUnits?: SortOrder
    balanceToins?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WalletCountOrderByAggregateInput
    _avg?: WalletAvgOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
    _sum?: WalletSumOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    OR?: WalletScalarWhereWithAggregatesInput[]
    NOT?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wallet"> | string
    userId?: StringWithAggregatesFilter<"Wallet"> | string
    blockchainAddress?: StringNullableWithAggregatesFilter<"Wallet"> | string | null
    balanceUnits?: FloatWithAggregatesFilter<"Wallet"> | number
    balanceToins?: FloatWithAggregatesFilter<"Wallet"> | number
    status?: StringWithAggregatesFilter<"Wallet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    fromUserId?: StringNullableFilter<"Transaction"> | string | null
    toUserId?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    tokenType?: StringFilter<"Transaction"> | string
    type?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    description?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    toWallet?: XOR<WalletRelationFilter, WalletWhereInput>
    fromWallet?: XOR<WalletNullableRelationFilter, WalletWhereInput> | null
    toUser?: XOR<UserRelationFilter, UserWhereInput>
    fromUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    fromUserId?: SortOrderInput | SortOrder
    toUserId?: SortOrder
    amount?: SortOrder
    tokenType?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    toWallet?: WalletOrderByWithRelationInput
    fromWallet?: WalletOrderByWithRelationInput
    toUser?: UserOrderByWithRelationInput
    fromUser?: UserOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    fromUserId?: StringNullableFilter<"Transaction"> | string | null
    toUserId?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    tokenType?: StringFilter<"Transaction"> | string
    type?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    description?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    toWallet?: XOR<WalletRelationFilter, WalletWhereInput>
    fromWallet?: XOR<WalletNullableRelationFilter, WalletWhereInput> | null
    toUser?: XOR<UserRelationFilter, UserWhereInput>
    fromUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    fromUserId?: SortOrderInput | SortOrder
    toUserId?: SortOrder
    amount?: SortOrder
    tokenType?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    fromUserId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    toUserId?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    tokenType?: StringWithAggregatesFilter<"Transaction"> | string
    type?: StringWithAggregatesFilter<"Transaction"> | string
    status?: StringWithAggregatesFilter<"Transaction"> | string
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    ownerId?: StringFilter<"Group"> | string
    type?: StringFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    userGroups?: UserGroupListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    userGroups?: UserGroupOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    ownerId?: StringFilter<"Group"> | string
    type?: StringFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    userGroups?: UserGroupListRelationFilter
  }, "id">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Group"> | string
    name?: StringWithAggregatesFilter<"Group"> | string
    description?: StringNullableWithAggregatesFilter<"Group"> | string | null
    ownerId?: StringWithAggregatesFilter<"Group"> | string
    type?: StringWithAggregatesFilter<"Group"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
  }

  export type UserGroupWhereInput = {
    AND?: UserGroupWhereInput | UserGroupWhereInput[]
    OR?: UserGroupWhereInput[]
    NOT?: UserGroupWhereInput | UserGroupWhereInput[]
    userId?: StringFilter<"UserGroup"> | string
    groupId?: StringFilter<"UserGroup"> | string
    roleInGroup?: StringFilter<"UserGroup"> | string
    joinedAt?: DateTimeFilter<"UserGroup"> | Date | string
    group?: XOR<GroupRelationFilter, GroupWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserGroupOrderByWithRelationInput = {
    userId?: SortOrder
    groupId?: SortOrder
    roleInGroup?: SortOrder
    joinedAt?: SortOrder
    group?: GroupOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserGroupWhereUniqueInput = Prisma.AtLeast<{
    userId_groupId?: UserGroupUserIdGroupIdCompoundUniqueInput
    AND?: UserGroupWhereInput | UserGroupWhereInput[]
    OR?: UserGroupWhereInput[]
    NOT?: UserGroupWhereInput | UserGroupWhereInput[]
    userId?: StringFilter<"UserGroup"> | string
    groupId?: StringFilter<"UserGroup"> | string
    roleInGroup?: StringFilter<"UserGroup"> | string
    joinedAt?: DateTimeFilter<"UserGroup"> | Date | string
    group?: XOR<GroupRelationFilter, GroupWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "userId_groupId">

  export type UserGroupOrderByWithAggregationInput = {
    userId?: SortOrder
    groupId?: SortOrder
    roleInGroup?: SortOrder
    joinedAt?: SortOrder
    _count?: UserGroupCountOrderByAggregateInput
    _max?: UserGroupMaxOrderByAggregateInput
    _min?: UserGroupMinOrderByAggregateInput
  }

  export type UserGroupScalarWhereWithAggregatesInput = {
    AND?: UserGroupScalarWhereWithAggregatesInput | UserGroupScalarWhereWithAggregatesInput[]
    OR?: UserGroupScalarWhereWithAggregatesInput[]
    NOT?: UserGroupScalarWhereWithAggregatesInput | UserGroupScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserGroup"> | string
    groupId?: StringWithAggregatesFilter<"UserGroup"> | string
    roleInGroup?: StringWithAggregatesFilter<"UserGroup"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"UserGroup"> | Date | string
  }

  export type PublicationWhereInput = {
    AND?: PublicationWhereInput | PublicationWhereInput[]
    OR?: PublicationWhereInput[]
    NOT?: PublicationWhereInput | PublicationWhereInput[]
    id?: StringFilter<"Publication"> | string
    userId?: StringFilter<"Publication"> | string
    content?: StringFilter<"Publication"> | string
    type?: StringFilter<"Publication"> | string
    createdAt?: DateTimeFilter<"Publication"> | Date | string
    updatedAt?: DateTimeFilter<"Publication"> | Date | string
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PublicationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comments?: CommentOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type PublicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PublicationWhereInput | PublicationWhereInput[]
    OR?: PublicationWhereInput[]
    NOT?: PublicationWhereInput | PublicationWhereInput[]
    userId?: StringFilter<"Publication"> | string
    content?: StringFilter<"Publication"> | string
    type?: StringFilter<"Publication"> | string
    createdAt?: DateTimeFilter<"Publication"> | Date | string
    updatedAt?: DateTimeFilter<"Publication"> | Date | string
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PublicationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PublicationCountOrderByAggregateInput
    _max?: PublicationMaxOrderByAggregateInput
    _min?: PublicationMinOrderByAggregateInput
  }

  export type PublicationScalarWhereWithAggregatesInput = {
    AND?: PublicationScalarWhereWithAggregatesInput | PublicationScalarWhereWithAggregatesInput[]
    OR?: PublicationScalarWhereWithAggregatesInput[]
    NOT?: PublicationScalarWhereWithAggregatesInput | PublicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Publication"> | string
    userId?: StringWithAggregatesFilter<"Publication"> | string
    content?: StringWithAggregatesFilter<"Publication"> | string
    type?: StringWithAggregatesFilter<"Publication"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Publication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Publication"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    publicationId?: StringNullableFilter<"Comment"> | string | null
    activityId?: StringNullableFilter<"Comment"> | string | null
    text?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    publication?: XOR<PublicationNullableRelationFilter, PublicationWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrderInput | SortOrder
    activityId?: SortOrderInput | SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    publication?: PublicationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    userId?: StringFilter<"Comment"> | string
    publicationId?: StringNullableFilter<"Comment"> | string | null
    activityId?: StringNullableFilter<"Comment"> | string | null
    text?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    publication?: XOR<PublicationNullableRelationFilter, PublicationWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrderInput | SortOrder
    activityId?: SortOrderInput | SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
    publicationId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    activityId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    text?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type LikeWhereInput = {
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    id?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    publicationId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    publication?: XOR<PublicationRelationFilter, PublicationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LikeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    createdAt?: SortOrder
    publication?: PublicationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_publicationId?: LikeUserIdPublicationIdCompoundUniqueInput
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    userId?: StringFilter<"Like"> | string
    publicationId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
    publication?: XOR<PublicationRelationFilter, PublicationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_publicationId">

  export type LikeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    createdAt?: SortOrder
    _count?: LikeCountOrderByAggregateInput
    _max?: LikeMaxOrderByAggregateInput
    _min?: LikeMinOrderByAggregateInput
  }

  export type LikeScalarWhereWithAggregatesInput = {
    AND?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    OR?: LikeScalarWhereWithAggregatesInput[]
    NOT?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Like"> | string
    userId?: StringWithAggregatesFilter<"Like"> | string
    publicationId?: StringWithAggregatesFilter<"Like"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Like"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type InvitationTemplateWhereInput = {
    AND?: InvitationTemplateWhereInput | InvitationTemplateWhereInput[]
    OR?: InvitationTemplateWhereInput[]
    NOT?: InvitationTemplateWhereInput | InvitationTemplateWhereInput[]
    id?: StringFilter<"InvitationTemplate"> | string
    name?: StringFilter<"InvitationTemplate"> | string
    content?: StringFilter<"InvitationTemplate"> | string
    creatorId?: StringFilter<"InvitationTemplate"> | string
    createdAt?: DateTimeFilter<"InvitationTemplate"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type InvitationTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type InvitationTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvitationTemplateWhereInput | InvitationTemplateWhereInput[]
    OR?: InvitationTemplateWhereInput[]
    NOT?: InvitationTemplateWhereInput | InvitationTemplateWhereInput[]
    name?: StringFilter<"InvitationTemplate"> | string
    content?: StringFilter<"InvitationTemplate"> | string
    creatorId?: StringFilter<"InvitationTemplate"> | string
    createdAt?: DateTimeFilter<"InvitationTemplate"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type InvitationTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    _count?: InvitationTemplateCountOrderByAggregateInput
    _max?: InvitationTemplateMaxOrderByAggregateInput
    _min?: InvitationTemplateMinOrderByAggregateInput
  }

  export type InvitationTemplateScalarWhereWithAggregatesInput = {
    AND?: InvitationTemplateScalarWhereWithAggregatesInput | InvitationTemplateScalarWhereWithAggregatesInput[]
    OR?: InvitationTemplateScalarWhereWithAggregatesInput[]
    NOT?: InvitationTemplateScalarWhereWithAggregatesInput | InvitationTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvitationTemplate"> | string
    name?: StringWithAggregatesFilter<"InvitationTemplate"> | string
    content?: StringWithAggregatesFilter<"InvitationTemplate"> | string
    creatorId?: StringWithAggregatesFilter<"InvitationTemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"InvitationTemplate"> | Date | string
  }

  export type GiftCardWhereInput = {
    AND?: GiftCardWhereInput | GiftCardWhereInput[]
    OR?: GiftCardWhereInput[]
    NOT?: GiftCardWhereInput | GiftCardWhereInput[]
    id?: StringFilter<"GiftCard"> | string
    inviterId?: StringFilter<"GiftCard"> | string
    invitedName?: StringFilter<"GiftCard"> | string
    invitedEmail?: StringFilter<"GiftCard"> | string
    token?: StringFilter<"GiftCard"> | string
    unitsAmount?: FloatFilter<"GiftCard"> | number
    suggestions?: StringNullableFilter<"GiftCard"> | string | null
    status?: StringFilter<"GiftCard"> | string
    createdAt?: DateTimeFilter<"GiftCard"> | Date | string
    inviter?: XOR<UserRelationFilter, UserWhereInput>
    userInvitations?: UserInvitationListRelationFilter
  }

  export type GiftCardOrderByWithRelationInput = {
    id?: SortOrder
    inviterId?: SortOrder
    invitedName?: SortOrder
    invitedEmail?: SortOrder
    token?: SortOrder
    unitsAmount?: SortOrder
    suggestions?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    inviter?: UserOrderByWithRelationInput
    userInvitations?: UserInvitationOrderByRelationAggregateInput
  }

  export type GiftCardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: GiftCardWhereInput | GiftCardWhereInput[]
    OR?: GiftCardWhereInput[]
    NOT?: GiftCardWhereInput | GiftCardWhereInput[]
    inviterId?: StringFilter<"GiftCard"> | string
    invitedName?: StringFilter<"GiftCard"> | string
    invitedEmail?: StringFilter<"GiftCard"> | string
    unitsAmount?: FloatFilter<"GiftCard"> | number
    suggestions?: StringNullableFilter<"GiftCard"> | string | null
    status?: StringFilter<"GiftCard"> | string
    createdAt?: DateTimeFilter<"GiftCard"> | Date | string
    inviter?: XOR<UserRelationFilter, UserWhereInput>
    userInvitations?: UserInvitationListRelationFilter
  }, "id" | "token">

  export type GiftCardOrderByWithAggregationInput = {
    id?: SortOrder
    inviterId?: SortOrder
    invitedName?: SortOrder
    invitedEmail?: SortOrder
    token?: SortOrder
    unitsAmount?: SortOrder
    suggestions?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: GiftCardCountOrderByAggregateInput
    _avg?: GiftCardAvgOrderByAggregateInput
    _max?: GiftCardMaxOrderByAggregateInput
    _min?: GiftCardMinOrderByAggregateInput
    _sum?: GiftCardSumOrderByAggregateInput
  }

  export type GiftCardScalarWhereWithAggregatesInput = {
    AND?: GiftCardScalarWhereWithAggregatesInput | GiftCardScalarWhereWithAggregatesInput[]
    OR?: GiftCardScalarWhereWithAggregatesInput[]
    NOT?: GiftCardScalarWhereWithAggregatesInput | GiftCardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GiftCard"> | string
    inviterId?: StringWithAggregatesFilter<"GiftCard"> | string
    invitedName?: StringWithAggregatesFilter<"GiftCard"> | string
    invitedEmail?: StringWithAggregatesFilter<"GiftCard"> | string
    token?: StringWithAggregatesFilter<"GiftCard"> | string
    unitsAmount?: FloatWithAggregatesFilter<"GiftCard"> | number
    suggestions?: StringNullableWithAggregatesFilter<"GiftCard"> | string | null
    status?: StringWithAggregatesFilter<"GiftCard"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GiftCard"> | Date | string
  }

  export type UserInvitationWhereInput = {
    AND?: UserInvitationWhereInput | UserInvitationWhereInput[]
    OR?: UserInvitationWhereInput[]
    NOT?: UserInvitationWhereInput | UserInvitationWhereInput[]
    id?: StringFilter<"UserInvitation"> | string
    giftCardId?: StringFilter<"UserInvitation"> | string
    invitedUserId?: StringNullableFilter<"UserInvitation"> | string | null
    status?: StringFilter<"UserInvitation"> | string
    createdAt?: DateTimeFilter<"UserInvitation"> | Date | string
    invitedUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    giftCard?: XOR<GiftCardRelationFilter, GiftCardWhereInput>
  }

  export type UserInvitationOrderByWithRelationInput = {
    id?: SortOrder
    giftCardId?: SortOrder
    invitedUserId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    invitedUser?: UserOrderByWithRelationInput
    giftCard?: GiftCardOrderByWithRelationInput
  }

  export type UserInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserInvitationWhereInput | UserInvitationWhereInput[]
    OR?: UserInvitationWhereInput[]
    NOT?: UserInvitationWhereInput | UserInvitationWhereInput[]
    giftCardId?: StringFilter<"UserInvitation"> | string
    invitedUserId?: StringNullableFilter<"UserInvitation"> | string | null
    status?: StringFilter<"UserInvitation"> | string
    createdAt?: DateTimeFilter<"UserInvitation"> | Date | string
    invitedUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    giftCard?: XOR<GiftCardRelationFilter, GiftCardWhereInput>
  }, "id">

  export type UserInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    giftCardId?: SortOrder
    invitedUserId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: UserInvitationCountOrderByAggregateInput
    _max?: UserInvitationMaxOrderByAggregateInput
    _min?: UserInvitationMinOrderByAggregateInput
  }

  export type UserInvitationScalarWhereWithAggregatesInput = {
    AND?: UserInvitationScalarWhereWithAggregatesInput | UserInvitationScalarWhereWithAggregatesInput[]
    OR?: UserInvitationScalarWhereWithAggregatesInput[]
    NOT?: UserInvitationScalarWhereWithAggregatesInput | UserInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserInvitation"> | string
    giftCardId?: StringWithAggregatesFilter<"UserInvitation"> | string
    invitedUserId?: StringNullableWithAggregatesFilter<"UserInvitation"> | string | null
    status?: StringWithAggregatesFilter<"UserInvitation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserInvitation"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    name?: StringFilter<"Report"> | string
    type?: StringFilter<"Report"> | string
    parameters?: StringNullableFilter<"Report"> | string | null
    generatedAt?: DateTimeFilter<"Report"> | Date | string
    data?: StringFilter<"Report"> | string
    creatorId?: StringFilter<"Report"> | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parameters?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    data?: SortOrder
    creatorId?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    name?: StringFilter<"Report"> | string
    type?: StringFilter<"Report"> | string
    parameters?: StringNullableFilter<"Report"> | string | null
    generatedAt?: DateTimeFilter<"Report"> | Date | string
    data?: StringFilter<"Report"> | string
    creatorId?: StringFilter<"Report"> | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parameters?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    data?: SortOrder
    creatorId?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    name?: StringWithAggregatesFilter<"Report"> | string
    type?: StringWithAggregatesFilter<"Report"> | string
    parameters?: StringNullableWithAggregatesFilter<"Report"> | string | null
    generatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    data?: StringWithAggregatesFilter<"Report"> | string
    creatorId?: StringWithAggregatesFilter<"Report"> | string
  }

  export type ConfigurationWhereInput = {
    AND?: ConfigurationWhereInput | ConfigurationWhereInput[]
    OR?: ConfigurationWhereInput[]
    NOT?: ConfigurationWhereInput | ConfigurationWhereInput[]
    id?: StringFilter<"Configuration"> | string
    key?: StringFilter<"Configuration"> | string
    value?: StringFilter<"Configuration"> | string
    type?: StringFilter<"Configuration"> | string
    updatedAt?: DateTimeFilter<"Configuration"> | Date | string
  }

  export type ConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: ConfigurationWhereInput | ConfigurationWhereInput[]
    OR?: ConfigurationWhereInput[]
    NOT?: ConfigurationWhereInput | ConfigurationWhereInput[]
    value?: StringFilter<"Configuration"> | string
    type?: StringFilter<"Configuration"> | string
    updatedAt?: DateTimeFilter<"Configuration"> | Date | string
  }, "id" | "key">

  export type ConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    _count?: ConfigurationCountOrderByAggregateInput
    _max?: ConfigurationMaxOrderByAggregateInput
    _min?: ConfigurationMinOrderByAggregateInput
  }

  export type ConfigurationScalarWhereWithAggregatesInput = {
    AND?: ConfigurationScalarWhereWithAggregatesInput | ConfigurationScalarWhereWithAggregatesInput[]
    OR?: ConfigurationScalarWhereWithAggregatesInput[]
    NOT?: ConfigurationScalarWhereWithAggregatesInput | ConfigurationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Configuration"> | string
    key?: StringWithAggregatesFilter<"Configuration"> | string
    value?: StringWithAggregatesFilter<"Configuration"> | string
    type?: StringWithAggregatesFilter<"Configuration"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Configuration"> | Date | string
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: StringFilter<"Log"> | string
    level?: StringFilter<"Log"> | string
    message?: StringFilter<"Log"> | string
    context?: StringNullableFilter<"Log"> | string | null
    timestamp?: DateTimeFilter<"Log"> | Date | string
    metadata?: StringNullableFilter<"Log"> | string | null
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    message?: SortOrder
    context?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    level?: StringFilter<"Log"> | string
    message?: StringFilter<"Log"> | string
    context?: StringNullableFilter<"Log"> | string | null
    timestamp?: DateTimeFilter<"Log"> | Date | string
    metadata?: StringNullableFilter<"Log"> | string | null
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    message?: SortOrder
    context?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: LogCountOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Log"> | string
    level?: StringWithAggregatesFilter<"Log"> | string
    message?: StringWithAggregatesFilter<"Log"> | string
    context?: StringNullableWithAggregatesFilter<"Log"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"Log"> | Date | string
    metadata?: StringNullableWithAggregatesFilter<"Log"> | string | null
  }

  export type AnalyticsDataWhereInput = {
    AND?: AnalyticsDataWhereInput | AnalyticsDataWhereInput[]
    OR?: AnalyticsDataWhereInput[]
    NOT?: AnalyticsDataWhereInput | AnalyticsDataWhereInput[]
    id?: StringFilter<"AnalyticsData"> | string
    userId?: StringNullableFilter<"AnalyticsData"> | string | null
    eventType?: StringFilter<"AnalyticsData"> | string
    videoItemId?: StringNullableFilter<"AnalyticsData"> | string | null
    playlistId?: StringNullableFilter<"AnalyticsData"> | string | null
    mundoId?: StringNullableFilter<"AnalyticsData"> | string | null
    sessionId?: StringNullableFilter<"AnalyticsData"> | string | null
    eventData?: StringNullableFilter<"AnalyticsData"> | string | null
    metadata?: StringNullableFilter<"AnalyticsData"> | string | null
    timestamp?: DateTimeFilter<"AnalyticsData"> | Date | string
    createdAt?: DateTimeFilter<"AnalyticsData"> | Date | string
  }

  export type AnalyticsDataOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    videoItemId?: SortOrderInput | SortOrder
    playlistId?: SortOrderInput | SortOrder
    mundoId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    eventData?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsDataWhereInput | AnalyticsDataWhereInput[]
    OR?: AnalyticsDataWhereInput[]
    NOT?: AnalyticsDataWhereInput | AnalyticsDataWhereInput[]
    userId?: StringNullableFilter<"AnalyticsData"> | string | null
    eventType?: StringFilter<"AnalyticsData"> | string
    videoItemId?: StringNullableFilter<"AnalyticsData"> | string | null
    playlistId?: StringNullableFilter<"AnalyticsData"> | string | null
    mundoId?: StringNullableFilter<"AnalyticsData"> | string | null
    sessionId?: StringNullableFilter<"AnalyticsData"> | string | null
    eventData?: StringNullableFilter<"AnalyticsData"> | string | null
    metadata?: StringNullableFilter<"AnalyticsData"> | string | null
    timestamp?: DateTimeFilter<"AnalyticsData"> | Date | string
    createdAt?: DateTimeFilter<"AnalyticsData"> | Date | string
  }, "id">

  export type AnalyticsDataOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    videoItemId?: SortOrderInput | SortOrder
    playlistId?: SortOrderInput | SortOrder
    mundoId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    eventData?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    _count?: AnalyticsDataCountOrderByAggregateInput
    _max?: AnalyticsDataMaxOrderByAggregateInput
    _min?: AnalyticsDataMinOrderByAggregateInput
  }

  export type AnalyticsDataScalarWhereWithAggregatesInput = {
    AND?: AnalyticsDataScalarWhereWithAggregatesInput | AnalyticsDataScalarWhereWithAggregatesInput[]
    OR?: AnalyticsDataScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsDataScalarWhereWithAggregatesInput | AnalyticsDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsData"> | string
    userId?: StringNullableWithAggregatesFilter<"AnalyticsData"> | string | null
    eventType?: StringWithAggregatesFilter<"AnalyticsData"> | string
    videoItemId?: StringNullableWithAggregatesFilter<"AnalyticsData"> | string | null
    playlistId?: StringNullableWithAggregatesFilter<"AnalyticsData"> | string | null
    mundoId?: StringNullableWithAggregatesFilter<"AnalyticsData"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"AnalyticsData"> | string | null
    eventData?: StringNullableWithAggregatesFilter<"AnalyticsData"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"AnalyticsData"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"AnalyticsData"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsData"> | Date | string
  }

  export type RankingWhereInput = {
    AND?: RankingWhereInput | RankingWhereInput[]
    OR?: RankingWhereInput[]
    NOT?: RankingWhereInput | RankingWhereInput[]
    id?: StringFilter<"Ranking"> | string
    name?: StringFilter<"Ranking"> | string
    type?: StringFilter<"Ranking"> | string
    period?: StringFilter<"Ranking"> | string
    data?: StringFilter<"Ranking"> | string
    createdAt?: DateTimeFilter<"Ranking"> | Date | string
  }

  export type RankingOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    period?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type RankingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RankingWhereInput | RankingWhereInput[]
    OR?: RankingWhereInput[]
    NOT?: RankingWhereInput | RankingWhereInput[]
    name?: StringFilter<"Ranking"> | string
    type?: StringFilter<"Ranking"> | string
    period?: StringFilter<"Ranking"> | string
    data?: StringFilter<"Ranking"> | string
    createdAt?: DateTimeFilter<"Ranking"> | Date | string
  }, "id">

  export type RankingOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    period?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    _count?: RankingCountOrderByAggregateInput
    _max?: RankingMaxOrderByAggregateInput
    _min?: RankingMinOrderByAggregateInput
  }

  export type RankingScalarWhereWithAggregatesInput = {
    AND?: RankingScalarWhereWithAggregatesInput | RankingScalarWhereWithAggregatesInput[]
    OR?: RankingScalarWhereWithAggregatesInput[]
    NOT?: RankingScalarWhereWithAggregatesInput | RankingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ranking"> | string
    name?: StringWithAggregatesFilter<"Ranking"> | string
    type?: StringWithAggregatesFilter<"Ranking"> | string
    period?: StringWithAggregatesFilter<"Ranking"> | string
    data?: StringWithAggregatesFilter<"Ranking"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Ranking"> | Date | string
  }

  export type PersonalityWhereInput = {
    AND?: PersonalityWhereInput | PersonalityWhereInput[]
    OR?: PersonalityWhereInput[]
    NOT?: PersonalityWhereInput | PersonalityWhereInput[]
    id?: StringFilter<"Personality"> | string
    name?: StringFilter<"Personality"> | string
    description?: StringNullableFilter<"Personality"> | string | null
    traits?: StringFilter<"Personality"> | string
    createdAt?: DateTimeFilter<"Personality"> | Date | string
    users?: UserListRelationFilter
  }

  export type PersonalityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    traits?: SortOrder
    createdAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type PersonalityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PersonalityWhereInput | PersonalityWhereInput[]
    OR?: PersonalityWhereInput[]
    NOT?: PersonalityWhereInput | PersonalityWhereInput[]
    description?: StringNullableFilter<"Personality"> | string | null
    traits?: StringFilter<"Personality"> | string
    createdAt?: DateTimeFilter<"Personality"> | Date | string
    users?: UserListRelationFilter
  }, "id" | "name">

  export type PersonalityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    traits?: SortOrder
    createdAt?: SortOrder
    _count?: PersonalityCountOrderByAggregateInput
    _max?: PersonalityMaxOrderByAggregateInput
    _min?: PersonalityMinOrderByAggregateInput
  }

  export type PersonalityScalarWhereWithAggregatesInput = {
    AND?: PersonalityScalarWhereWithAggregatesInput | PersonalityScalarWhereWithAggregatesInput[]
    OR?: PersonalityScalarWhereWithAggregatesInput[]
    NOT?: PersonalityScalarWhereWithAggregatesInput | PersonalityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Personality"> | string
    name?: StringWithAggregatesFilter<"Personality"> | string
    description?: StringNullableWithAggregatesFilter<"Personality"> | string | null
    traits?: StringWithAggregatesFilter<"Personality"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Personality"> | Date | string
  }

  export type UIComponentTemplateWhereInput = {
    AND?: UIComponentTemplateWhereInput | UIComponentTemplateWhereInput[]
    OR?: UIComponentTemplateWhereInput[]
    NOT?: UIComponentTemplateWhereInput | UIComponentTemplateWhereInput[]
    id?: StringFilter<"UIComponentTemplate"> | string
    name?: StringFilter<"UIComponentTemplate"> | string
    type?: StringFilter<"UIComponentTemplate"> | string
    templateJson?: StringFilter<"UIComponentTemplate"> | string
    creatorId?: StringFilter<"UIComponentTemplate"> | string
    createdAt?: DateTimeFilter<"UIComponentTemplate"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UIComponentTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    templateJson?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type UIComponentTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UIComponentTemplateWhereInput | UIComponentTemplateWhereInput[]
    OR?: UIComponentTemplateWhereInput[]
    NOT?: UIComponentTemplateWhereInput | UIComponentTemplateWhereInput[]
    name?: StringFilter<"UIComponentTemplate"> | string
    type?: StringFilter<"UIComponentTemplate"> | string
    templateJson?: StringFilter<"UIComponentTemplate"> | string
    creatorId?: StringFilter<"UIComponentTemplate"> | string
    createdAt?: DateTimeFilter<"UIComponentTemplate"> | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UIComponentTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    templateJson?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    _count?: UIComponentTemplateCountOrderByAggregateInput
    _max?: UIComponentTemplateMaxOrderByAggregateInput
    _min?: UIComponentTemplateMinOrderByAggregateInput
  }

  export type UIComponentTemplateScalarWhereWithAggregatesInput = {
    AND?: UIComponentTemplateScalarWhereWithAggregatesInput | UIComponentTemplateScalarWhereWithAggregatesInput[]
    OR?: UIComponentTemplateScalarWhereWithAggregatesInput[]
    NOT?: UIComponentTemplateScalarWhereWithAggregatesInput | UIComponentTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UIComponentTemplate"> | string
    name?: StringWithAggregatesFilter<"UIComponentTemplate"> | string
    type?: StringWithAggregatesFilter<"UIComponentTemplate"> | string
    templateJson?: StringWithAggregatesFilter<"UIComponentTemplate"> | string
    creatorId?: StringWithAggregatesFilter<"UIComponentTemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UIComponentTemplate"> | Date | string
  }

  export type ItemTypeWhereInput = {
    AND?: ItemTypeWhereInput | ItemTypeWhereInput[]
    OR?: ItemTypeWhereInput[]
    NOT?: ItemTypeWhereInput | ItemTypeWhereInput[]
    id?: StringFilter<"ItemType"> | string
    name?: StringFilter<"ItemType"> | string
    description?: StringNullableFilter<"ItemType"> | string | null
    isActive?: BoolFilter<"ItemType"> | boolean
    isDeleted?: BoolFilter<"ItemType"> | boolean
    createdAt?: DateTimeFilter<"ItemType"> | Date | string
    updatedAt?: DateTimeFilter<"ItemType"> | Date | string
    contentItems?: ContentItemListRelationFilter
  }

  export type ItemTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contentItems?: ContentItemOrderByRelationAggregateInput
  }

  export type ItemTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ItemTypeWhereInput | ItemTypeWhereInput[]
    OR?: ItemTypeWhereInput[]
    NOT?: ItemTypeWhereInput | ItemTypeWhereInput[]
    description?: StringNullableFilter<"ItemType"> | string | null
    isActive?: BoolFilter<"ItemType"> | boolean
    isDeleted?: BoolFilter<"ItemType"> | boolean
    createdAt?: DateTimeFilter<"ItemType"> | Date | string
    updatedAt?: DateTimeFilter<"ItemType"> | Date | string
    contentItems?: ContentItemListRelationFilter
  }, "id" | "name">

  export type ItemTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemTypeCountOrderByAggregateInput
    _max?: ItemTypeMaxOrderByAggregateInput
    _min?: ItemTypeMinOrderByAggregateInput
  }

  export type ItemTypeScalarWhereWithAggregatesInput = {
    AND?: ItemTypeScalarWhereWithAggregatesInput | ItemTypeScalarWhereWithAggregatesInput[]
    OR?: ItemTypeScalarWhereWithAggregatesInput[]
    NOT?: ItemTypeScalarWhereWithAggregatesInput | ItemTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ItemType"> | string
    name?: StringWithAggregatesFilter<"ItemType"> | string
    description?: StringNullableWithAggregatesFilter<"ItemType"> | string | null
    isActive?: BoolWithAggregatesFilter<"ItemType"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"ItemType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ItemType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItemType"> | Date | string
  }

  export type ContentItemWhereInput = {
    AND?: ContentItemWhereInput | ContentItemWhereInput[]
    OR?: ContentItemWhereInput[]
    NOT?: ContentItemWhereInput | ContentItemWhereInput[]
    id?: StringFilter<"ContentItem"> | string
    title?: StringFilter<"ContentItem"> | string
    description?: StringNullableFilter<"ContentItem"> | string | null
    content?: StringFilter<"ContentItem"> | string
    playlistId?: StringFilter<"ContentItem"> | string
    itemTypeId?: StringFilter<"ContentItem"> | string
    order?: IntFilter<"ContentItem"> | number
    isActive?: BoolFilter<"ContentItem"> | boolean
    isDeleted?: BoolFilter<"ContentItem"> | boolean
    deletedAt?: DateTimeNullableFilter<"ContentItem"> | Date | string | null
    createdAt?: DateTimeFilter<"ContentItem"> | Date | string
    updatedAt?: DateTimeFilter<"ContentItem"> | Date | string
    itemType?: XOR<ItemTypeRelationFilter, ItemTypeWhereInput>
    playlist?: XOR<PlaylistRelationFilter, PlaylistWhereInput>
  }

  export type ContentItemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    playlistId?: SortOrder
    itemTypeId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    itemType?: ItemTypeOrderByWithRelationInput
    playlist?: PlaylistOrderByWithRelationInput
  }

  export type ContentItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentItemWhereInput | ContentItemWhereInput[]
    OR?: ContentItemWhereInput[]
    NOT?: ContentItemWhereInput | ContentItemWhereInput[]
    title?: StringFilter<"ContentItem"> | string
    description?: StringNullableFilter<"ContentItem"> | string | null
    content?: StringFilter<"ContentItem"> | string
    playlistId?: StringFilter<"ContentItem"> | string
    itemTypeId?: StringFilter<"ContentItem"> | string
    order?: IntFilter<"ContentItem"> | number
    isActive?: BoolFilter<"ContentItem"> | boolean
    isDeleted?: BoolFilter<"ContentItem"> | boolean
    deletedAt?: DateTimeNullableFilter<"ContentItem"> | Date | string | null
    createdAt?: DateTimeFilter<"ContentItem"> | Date | string
    updatedAt?: DateTimeFilter<"ContentItem"> | Date | string
    itemType?: XOR<ItemTypeRelationFilter, ItemTypeWhereInput>
    playlist?: XOR<PlaylistRelationFilter, PlaylistWhereInput>
  }, "id">

  export type ContentItemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    playlistId?: SortOrder
    itemTypeId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContentItemCountOrderByAggregateInput
    _avg?: ContentItemAvgOrderByAggregateInput
    _max?: ContentItemMaxOrderByAggregateInput
    _min?: ContentItemMinOrderByAggregateInput
    _sum?: ContentItemSumOrderByAggregateInput
  }

  export type ContentItemScalarWhereWithAggregatesInput = {
    AND?: ContentItemScalarWhereWithAggregatesInput | ContentItemScalarWhereWithAggregatesInput[]
    OR?: ContentItemScalarWhereWithAggregatesInput[]
    NOT?: ContentItemScalarWhereWithAggregatesInput | ContentItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentItem"> | string
    title?: StringWithAggregatesFilter<"ContentItem"> | string
    description?: StringNullableWithAggregatesFilter<"ContentItem"> | string | null
    content?: StringWithAggregatesFilter<"ContentItem"> | string
    playlistId?: StringWithAggregatesFilter<"ContentItem"> | string
    itemTypeId?: StringWithAggregatesFilter<"ContentItem"> | string
    order?: IntWithAggregatesFilter<"ContentItem"> | number
    isActive?: BoolWithAggregatesFilter<"ContentItem"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"ContentItem"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ContentItem"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContentItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContentItem"> | Date | string
  }

  export type ChallengeWhereInput = {
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    id?: StringFilter<"Challenge"> | string
    title?: StringFilter<"Challenge"> | string
    description?: StringNullableFilter<"Challenge"> | string | null
    type?: StringFilter<"Challenge"> | string
    status?: StringFilter<"Challenge"> | string
    startDate?: DateTimeFilter<"Challenge"> | Date | string
    endDate?: DateTimeFilter<"Challenge"> | Date | string
    config?: StringFilter<"Challenge"> | string
    createdAt?: DateTimeFilter<"Challenge"> | Date | string
    updatedAt?: DateTimeFilter<"Challenge"> | Date | string
    rewards?: ChallengeRewardListRelationFilter
    userChallenges?: UserChallengeListRelationFilter
  }

  export type ChallengeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rewards?: ChallengeRewardOrderByRelationAggregateInput
    userChallenges?: UserChallengeOrderByRelationAggregateInput
  }

  export type ChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    title?: StringFilter<"Challenge"> | string
    description?: StringNullableFilter<"Challenge"> | string | null
    type?: StringFilter<"Challenge"> | string
    status?: StringFilter<"Challenge"> | string
    startDate?: DateTimeFilter<"Challenge"> | Date | string
    endDate?: DateTimeFilter<"Challenge"> | Date | string
    config?: StringFilter<"Challenge"> | string
    createdAt?: DateTimeFilter<"Challenge"> | Date | string
    updatedAt?: DateTimeFilter<"Challenge"> | Date | string
    rewards?: ChallengeRewardListRelationFilter
    userChallenges?: UserChallengeListRelationFilter
  }, "id">

  export type ChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChallengeCountOrderByAggregateInput
    _max?: ChallengeMaxOrderByAggregateInput
    _min?: ChallengeMinOrderByAggregateInput
  }

  export type ChallengeScalarWhereWithAggregatesInput = {
    AND?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    OR?: ChallengeScalarWhereWithAggregatesInput[]
    NOT?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Challenge"> | string
    title?: StringWithAggregatesFilter<"Challenge"> | string
    description?: StringNullableWithAggregatesFilter<"Challenge"> | string | null
    type?: StringWithAggregatesFilter<"Challenge"> | string
    status?: StringWithAggregatesFilter<"Challenge"> | string
    startDate?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    config?: StringWithAggregatesFilter<"Challenge"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
  }

  export type ChallengeRewardWhereInput = {
    AND?: ChallengeRewardWhereInput | ChallengeRewardWhereInput[]
    OR?: ChallengeRewardWhereInput[]
    NOT?: ChallengeRewardWhereInput | ChallengeRewardWhereInput[]
    id?: StringFilter<"ChallengeReward"> | string
    challengeId?: StringFilter<"ChallengeReward"> | string
    type?: StringFilter<"ChallengeReward"> | string
    amount?: FloatNullableFilter<"ChallengeReward"> | number | null
    description?: StringNullableFilter<"ChallengeReward"> | string | null
    metadata?: StringNullableFilter<"ChallengeReward"> | string | null
    createdAt?: DateTimeFilter<"ChallengeReward"> | Date | string
    challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>
  }

  export type ChallengeRewardOrderByWithRelationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    type?: SortOrder
    amount?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
  }

  export type ChallengeRewardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeRewardWhereInput | ChallengeRewardWhereInput[]
    OR?: ChallengeRewardWhereInput[]
    NOT?: ChallengeRewardWhereInput | ChallengeRewardWhereInput[]
    challengeId?: StringFilter<"ChallengeReward"> | string
    type?: StringFilter<"ChallengeReward"> | string
    amount?: FloatNullableFilter<"ChallengeReward"> | number | null
    description?: StringNullableFilter<"ChallengeReward"> | string | null
    metadata?: StringNullableFilter<"ChallengeReward"> | string | null
    createdAt?: DateTimeFilter<"ChallengeReward"> | Date | string
    challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>
  }, "id">

  export type ChallengeRewardOrderByWithAggregationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    type?: SortOrder
    amount?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChallengeRewardCountOrderByAggregateInput
    _avg?: ChallengeRewardAvgOrderByAggregateInput
    _max?: ChallengeRewardMaxOrderByAggregateInput
    _min?: ChallengeRewardMinOrderByAggregateInput
    _sum?: ChallengeRewardSumOrderByAggregateInput
  }

  export type ChallengeRewardScalarWhereWithAggregatesInput = {
    AND?: ChallengeRewardScalarWhereWithAggregatesInput | ChallengeRewardScalarWhereWithAggregatesInput[]
    OR?: ChallengeRewardScalarWhereWithAggregatesInput[]
    NOT?: ChallengeRewardScalarWhereWithAggregatesInput | ChallengeRewardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeReward"> | string
    challengeId?: StringWithAggregatesFilter<"ChallengeReward"> | string
    type?: StringWithAggregatesFilter<"ChallengeReward"> | string
    amount?: FloatNullableWithAggregatesFilter<"ChallengeReward"> | number | null
    description?: StringNullableWithAggregatesFilter<"ChallengeReward"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"ChallengeReward"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeReward"> | Date | string
  }

  export type UserChallengeWhereInput = {
    AND?: UserChallengeWhereInput | UserChallengeWhereInput[]
    OR?: UserChallengeWhereInput[]
    NOT?: UserChallengeWhereInput | UserChallengeWhereInput[]
    id?: StringFilter<"UserChallenge"> | string
    userId?: StringFilter<"UserChallenge"> | string
    challengeId?: StringFilter<"UserChallenge"> | string
    status?: StringFilter<"UserChallenge"> | string
    progress?: FloatFilter<"UserChallenge"> | number
    startedAt?: DateTimeFilter<"UserChallenge"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
    metadata?: StringNullableFilter<"UserChallenge"> | string | null
    challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserChallengeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_challengeId?: UserChallengeUserIdChallengeIdCompoundUniqueInput
    AND?: UserChallengeWhereInput | UserChallengeWhereInput[]
    OR?: UserChallengeWhereInput[]
    NOT?: UserChallengeWhereInput | UserChallengeWhereInput[]
    userId?: StringFilter<"UserChallenge"> | string
    challengeId?: StringFilter<"UserChallenge"> | string
    status?: StringFilter<"UserChallenge"> | string
    progress?: FloatFilter<"UserChallenge"> | number
    startedAt?: DateTimeFilter<"UserChallenge"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
    metadata?: StringNullableFilter<"UserChallenge"> | string | null
    challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_challengeId">

  export type UserChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: UserChallengeCountOrderByAggregateInput
    _avg?: UserChallengeAvgOrderByAggregateInput
    _max?: UserChallengeMaxOrderByAggregateInput
    _min?: UserChallengeMinOrderByAggregateInput
    _sum?: UserChallengeSumOrderByAggregateInput
  }

  export type UserChallengeScalarWhereWithAggregatesInput = {
    AND?: UserChallengeScalarWhereWithAggregatesInput | UserChallengeScalarWhereWithAggregatesInput[]
    OR?: UserChallengeScalarWhereWithAggregatesInput[]
    NOT?: UserChallengeScalarWhereWithAggregatesInput | UserChallengeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserChallenge"> | string
    userId?: StringWithAggregatesFilter<"UserChallenge"> | string
    challengeId?: StringWithAggregatesFilter<"UserChallenge"> | string
    status?: StringWithAggregatesFilter<"UserChallenge"> | string
    progress?: FloatWithAggregatesFilter<"UserChallenge"> | number
    startedAt?: DateTimeWithAggregatesFilter<"UserChallenge"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserChallenge"> | Date | string | null
    metadata?: StringNullableWithAggregatesFilter<"UserChallenge"> | string | null
  }

  export type MarketplaceItemWhereInput = {
    AND?: MarketplaceItemWhereInput | MarketplaceItemWhereInput[]
    OR?: MarketplaceItemWhereInput[]
    NOT?: MarketplaceItemWhereInput | MarketplaceItemWhereInput[]
    id?: StringFilter<"MarketplaceItem"> | string
    name?: StringFilter<"MarketplaceItem"> | string
    description?: StringNullableFilter<"MarketplaceItem"> | string | null
    fullDescription?: StringNullableFilter<"MarketplaceItem"> | string | null
    itemType?: EnumMarketplaceItemTypeFilter<"MarketplaceItem"> | $Enums.MarketplaceItemType
    price?: FloatFilter<"MarketplaceItem"> | number
    priceToins?: FloatFilter<"MarketplaceItem"> | number
    currency?: EnumCurrencyFilter<"MarketplaceItem"> | $Enums.Currency
    category?: StringNullableFilter<"MarketplaceItem"> | string | null
    tags?: StringNullableListFilter<"MarketplaceItem">
    images?: StringNullableListFilter<"MarketplaceItem">
    stock?: IntFilter<"MarketplaceItem"> | number
    rating?: FloatFilter<"MarketplaceItem"> | number
    reviewCount?: IntFilter<"MarketplaceItem"> | number
    location?: StringNullableFilter<"MarketplaceItem"> | string | null
    status?: EnumMarketplaceItemStatusFilter<"MarketplaceItem"> | $Enums.MarketplaceItemStatus
    isActive?: BoolFilter<"MarketplaceItem"> | boolean
    isDeleted?: BoolFilter<"MarketplaceItem"> | boolean
    deletedAt?: DateTimeNullableFilter<"MarketplaceItem"> | Date | string | null
    createdAt?: DateTimeFilter<"MarketplaceItem"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceItem"> | Date | string
    viewCount?: IntFilter<"MarketplaceItem"> | number
    favoriteCount?: IntFilter<"MarketplaceItem"> | number
    sellerId?: StringFilter<"MarketplaceItem"> | string
    metadata?: StringNullableFilter<"MarketplaceItem"> | string | null
    seller?: XOR<UserRelationFilter, UserWhereInput>
    reviews?: ReviewListRelationFilter
    matches?: MarketplaceMatchListRelationFilter
  }

  export type MarketplaceItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    fullDescription?: SortOrderInput | SortOrder
    itemType?: SortOrder
    price?: SortOrder
    priceToins?: SortOrder
    currency?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    images?: SortOrder
    stock?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    viewCount?: SortOrder
    favoriteCount?: SortOrder
    sellerId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    seller?: UserOrderByWithRelationInput
    reviews?: ReviewOrderByRelationAggregateInput
    matches?: MarketplaceMatchOrderByRelationAggregateInput
  }

  export type MarketplaceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketplaceItemWhereInput | MarketplaceItemWhereInput[]
    OR?: MarketplaceItemWhereInput[]
    NOT?: MarketplaceItemWhereInput | MarketplaceItemWhereInput[]
    name?: StringFilter<"MarketplaceItem"> | string
    description?: StringNullableFilter<"MarketplaceItem"> | string | null
    fullDescription?: StringNullableFilter<"MarketplaceItem"> | string | null
    itemType?: EnumMarketplaceItemTypeFilter<"MarketplaceItem"> | $Enums.MarketplaceItemType
    price?: FloatFilter<"MarketplaceItem"> | number
    priceToins?: FloatFilter<"MarketplaceItem"> | number
    currency?: EnumCurrencyFilter<"MarketplaceItem"> | $Enums.Currency
    category?: StringNullableFilter<"MarketplaceItem"> | string | null
    tags?: StringNullableListFilter<"MarketplaceItem">
    images?: StringNullableListFilter<"MarketplaceItem">
    stock?: IntFilter<"MarketplaceItem"> | number
    rating?: FloatFilter<"MarketplaceItem"> | number
    reviewCount?: IntFilter<"MarketplaceItem"> | number
    location?: StringNullableFilter<"MarketplaceItem"> | string | null
    status?: EnumMarketplaceItemStatusFilter<"MarketplaceItem"> | $Enums.MarketplaceItemStatus
    isActive?: BoolFilter<"MarketplaceItem"> | boolean
    isDeleted?: BoolFilter<"MarketplaceItem"> | boolean
    deletedAt?: DateTimeNullableFilter<"MarketplaceItem"> | Date | string | null
    createdAt?: DateTimeFilter<"MarketplaceItem"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceItem"> | Date | string
    viewCount?: IntFilter<"MarketplaceItem"> | number
    favoriteCount?: IntFilter<"MarketplaceItem"> | number
    sellerId?: StringFilter<"MarketplaceItem"> | string
    metadata?: StringNullableFilter<"MarketplaceItem"> | string | null
    seller?: XOR<UserRelationFilter, UserWhereInput>
    reviews?: ReviewListRelationFilter
    matches?: MarketplaceMatchListRelationFilter
  }, "id">

  export type MarketplaceItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    fullDescription?: SortOrderInput | SortOrder
    itemType?: SortOrder
    price?: SortOrder
    priceToins?: SortOrder
    currency?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    images?: SortOrder
    stock?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    viewCount?: SortOrder
    favoriteCount?: SortOrder
    sellerId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: MarketplaceItemCountOrderByAggregateInput
    _avg?: MarketplaceItemAvgOrderByAggregateInput
    _max?: MarketplaceItemMaxOrderByAggregateInput
    _min?: MarketplaceItemMinOrderByAggregateInput
    _sum?: MarketplaceItemSumOrderByAggregateInput
  }

  export type MarketplaceItemScalarWhereWithAggregatesInput = {
    AND?: MarketplaceItemScalarWhereWithAggregatesInput | MarketplaceItemScalarWhereWithAggregatesInput[]
    OR?: MarketplaceItemScalarWhereWithAggregatesInput[]
    NOT?: MarketplaceItemScalarWhereWithAggregatesInput | MarketplaceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketplaceItem"> | string
    name?: StringWithAggregatesFilter<"MarketplaceItem"> | string
    description?: StringNullableWithAggregatesFilter<"MarketplaceItem"> | string | null
    fullDescription?: StringNullableWithAggregatesFilter<"MarketplaceItem"> | string | null
    itemType?: EnumMarketplaceItemTypeWithAggregatesFilter<"MarketplaceItem"> | $Enums.MarketplaceItemType
    price?: FloatWithAggregatesFilter<"MarketplaceItem"> | number
    priceToins?: FloatWithAggregatesFilter<"MarketplaceItem"> | number
    currency?: EnumCurrencyWithAggregatesFilter<"MarketplaceItem"> | $Enums.Currency
    category?: StringNullableWithAggregatesFilter<"MarketplaceItem"> | string | null
    tags?: StringNullableListFilter<"MarketplaceItem">
    images?: StringNullableListFilter<"MarketplaceItem">
    stock?: IntWithAggregatesFilter<"MarketplaceItem"> | number
    rating?: FloatWithAggregatesFilter<"MarketplaceItem"> | number
    reviewCount?: IntWithAggregatesFilter<"MarketplaceItem"> | number
    location?: StringNullableWithAggregatesFilter<"MarketplaceItem"> | string | null
    status?: EnumMarketplaceItemStatusWithAggregatesFilter<"MarketplaceItem"> | $Enums.MarketplaceItemStatus
    isActive?: BoolWithAggregatesFilter<"MarketplaceItem"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"MarketplaceItem"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"MarketplaceItem"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MarketplaceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketplaceItem"> | Date | string
    viewCount?: IntWithAggregatesFilter<"MarketplaceItem"> | number
    favoriteCount?: IntWithAggregatesFilter<"MarketplaceItem"> | number
    sellerId?: StringWithAggregatesFilter<"MarketplaceItem"> | string
    metadata?: StringNullableWithAggregatesFilter<"MarketplaceItem"> | string | null
  }

  export type StudyRoomWhereInput = {
    AND?: StudyRoomWhereInput | StudyRoomWhereInput[]
    OR?: StudyRoomWhereInput[]
    NOT?: StudyRoomWhereInput | StudyRoomWhereInput[]
    id?: StringFilter<"StudyRoom"> | string
    name?: StringFilter<"StudyRoom"> | string
    description?: StringNullableFilter<"StudyRoom"> | string | null
    videoId?: IntFilter<"StudyRoom"> | number
    hostId?: StringFilter<"StudyRoom"> | string
    maxParticipants?: IntFilter<"StudyRoom"> | number
    status?: EnumStudyRoomStatusFilter<"StudyRoom"> | $Enums.StudyRoomStatus
    currentTime?: FloatFilter<"StudyRoom"> | number
    isPaused?: BoolFilter<"StudyRoom"> | boolean
    isActive?: BoolFilter<"StudyRoom"> | boolean
    createdAt?: DateTimeFilter<"StudyRoom"> | Date | string
    updatedAt?: DateTimeFilter<"StudyRoom"> | Date | string
    video?: XOR<VideoItemRelationFilter, VideoItemWhereInput>
    host?: XOR<UserRelationFilter, UserWhereInput>
    participants?: StudyRoomParticipantListRelationFilter
    messages?: StudyRoomMessageListRelationFilter
  }

  export type StudyRoomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    videoId?: SortOrder
    hostId?: SortOrder
    maxParticipants?: SortOrder
    status?: SortOrder
    currentTime?: SortOrder
    isPaused?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    video?: VideoItemOrderByWithRelationInput
    host?: UserOrderByWithRelationInput
    participants?: StudyRoomParticipantOrderByRelationAggregateInput
    messages?: StudyRoomMessageOrderByRelationAggregateInput
  }

  export type StudyRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudyRoomWhereInput | StudyRoomWhereInput[]
    OR?: StudyRoomWhereInput[]
    NOT?: StudyRoomWhereInput | StudyRoomWhereInput[]
    name?: StringFilter<"StudyRoom"> | string
    description?: StringNullableFilter<"StudyRoom"> | string | null
    videoId?: IntFilter<"StudyRoom"> | number
    hostId?: StringFilter<"StudyRoom"> | string
    maxParticipants?: IntFilter<"StudyRoom"> | number
    status?: EnumStudyRoomStatusFilter<"StudyRoom"> | $Enums.StudyRoomStatus
    currentTime?: FloatFilter<"StudyRoom"> | number
    isPaused?: BoolFilter<"StudyRoom"> | boolean
    isActive?: BoolFilter<"StudyRoom"> | boolean
    createdAt?: DateTimeFilter<"StudyRoom"> | Date | string
    updatedAt?: DateTimeFilter<"StudyRoom"> | Date | string
    video?: XOR<VideoItemRelationFilter, VideoItemWhereInput>
    host?: XOR<UserRelationFilter, UserWhereInput>
    participants?: StudyRoomParticipantListRelationFilter
    messages?: StudyRoomMessageListRelationFilter
  }, "id">

  export type StudyRoomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    videoId?: SortOrder
    hostId?: SortOrder
    maxParticipants?: SortOrder
    status?: SortOrder
    currentTime?: SortOrder
    isPaused?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudyRoomCountOrderByAggregateInput
    _avg?: StudyRoomAvgOrderByAggregateInput
    _max?: StudyRoomMaxOrderByAggregateInput
    _min?: StudyRoomMinOrderByAggregateInput
    _sum?: StudyRoomSumOrderByAggregateInput
  }

  export type StudyRoomScalarWhereWithAggregatesInput = {
    AND?: StudyRoomScalarWhereWithAggregatesInput | StudyRoomScalarWhereWithAggregatesInput[]
    OR?: StudyRoomScalarWhereWithAggregatesInput[]
    NOT?: StudyRoomScalarWhereWithAggregatesInput | StudyRoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudyRoom"> | string
    name?: StringWithAggregatesFilter<"StudyRoom"> | string
    description?: StringNullableWithAggregatesFilter<"StudyRoom"> | string | null
    videoId?: IntWithAggregatesFilter<"StudyRoom"> | number
    hostId?: StringWithAggregatesFilter<"StudyRoom"> | string
    maxParticipants?: IntWithAggregatesFilter<"StudyRoom"> | number
    status?: EnumStudyRoomStatusWithAggregatesFilter<"StudyRoom"> | $Enums.StudyRoomStatus
    currentTime?: FloatWithAggregatesFilter<"StudyRoom"> | number
    isPaused?: BoolWithAggregatesFilter<"StudyRoom"> | boolean
    isActive?: BoolWithAggregatesFilter<"StudyRoom"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StudyRoom"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudyRoom"> | Date | string
  }

  export type StudyRoomParticipantWhereInput = {
    AND?: StudyRoomParticipantWhereInput | StudyRoomParticipantWhereInput[]
    OR?: StudyRoomParticipantWhereInput[]
    NOT?: StudyRoomParticipantWhereInput | StudyRoomParticipantWhereInput[]
    id?: StringFilter<"StudyRoomParticipant"> | string
    studyRoomId?: StringFilter<"StudyRoomParticipant"> | string
    userId?: StringFilter<"StudyRoomParticipant"> | string
    isHost?: BoolFilter<"StudyRoomParticipant"> | boolean
    joinedAt?: DateTimeFilter<"StudyRoomParticipant"> | Date | string
    leftAt?: DateTimeNullableFilter<"StudyRoomParticipant"> | Date | string | null
    isActive?: BoolFilter<"StudyRoomParticipant"> | boolean
    studyRoom?: XOR<StudyRoomRelationFilter, StudyRoomWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type StudyRoomParticipantOrderByWithRelationInput = {
    id?: SortOrder
    studyRoomId?: SortOrder
    userId?: SortOrder
    isHost?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    studyRoom?: StudyRoomOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type StudyRoomParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studyRoomId_userId?: StudyRoomParticipantStudyRoomIdUserIdCompoundUniqueInput
    AND?: StudyRoomParticipantWhereInput | StudyRoomParticipantWhereInput[]
    OR?: StudyRoomParticipantWhereInput[]
    NOT?: StudyRoomParticipantWhereInput | StudyRoomParticipantWhereInput[]
    studyRoomId?: StringFilter<"StudyRoomParticipant"> | string
    userId?: StringFilter<"StudyRoomParticipant"> | string
    isHost?: BoolFilter<"StudyRoomParticipant"> | boolean
    joinedAt?: DateTimeFilter<"StudyRoomParticipant"> | Date | string
    leftAt?: DateTimeNullableFilter<"StudyRoomParticipant"> | Date | string | null
    isActive?: BoolFilter<"StudyRoomParticipant"> | boolean
    studyRoom?: XOR<StudyRoomRelationFilter, StudyRoomWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "studyRoomId_userId">

  export type StudyRoomParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    studyRoomId?: SortOrder
    userId?: SortOrder
    isHost?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: StudyRoomParticipantCountOrderByAggregateInput
    _max?: StudyRoomParticipantMaxOrderByAggregateInput
    _min?: StudyRoomParticipantMinOrderByAggregateInput
  }

  export type StudyRoomParticipantScalarWhereWithAggregatesInput = {
    AND?: StudyRoomParticipantScalarWhereWithAggregatesInput | StudyRoomParticipantScalarWhereWithAggregatesInput[]
    OR?: StudyRoomParticipantScalarWhereWithAggregatesInput[]
    NOT?: StudyRoomParticipantScalarWhereWithAggregatesInput | StudyRoomParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudyRoomParticipant"> | string
    studyRoomId?: StringWithAggregatesFilter<"StudyRoomParticipant"> | string
    userId?: StringWithAggregatesFilter<"StudyRoomParticipant"> | string
    isHost?: BoolWithAggregatesFilter<"StudyRoomParticipant"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"StudyRoomParticipant"> | Date | string
    leftAt?: DateTimeNullableWithAggregatesFilter<"StudyRoomParticipant"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"StudyRoomParticipant"> | boolean
  }

  export type StudyRoomMessageWhereInput = {
    AND?: StudyRoomMessageWhereInput | StudyRoomMessageWhereInput[]
    OR?: StudyRoomMessageWhereInput[]
    NOT?: StudyRoomMessageWhereInput | StudyRoomMessageWhereInput[]
    id?: StringFilter<"StudyRoomMessage"> | string
    studyRoomId?: StringFilter<"StudyRoomMessage"> | string
    userId?: StringFilter<"StudyRoomMessage"> | string
    message?: StringFilter<"StudyRoomMessage"> | string
    messageType?: StringFilter<"StudyRoomMessage"> | string
    metadata?: StringNullableFilter<"StudyRoomMessage"> | string | null
    createdAt?: DateTimeFilter<"StudyRoomMessage"> | Date | string
    studyRoom?: XOR<StudyRoomRelationFilter, StudyRoomWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type StudyRoomMessageOrderByWithRelationInput = {
    id?: SortOrder
    studyRoomId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    studyRoom?: StudyRoomOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type StudyRoomMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudyRoomMessageWhereInput | StudyRoomMessageWhereInput[]
    OR?: StudyRoomMessageWhereInput[]
    NOT?: StudyRoomMessageWhereInput | StudyRoomMessageWhereInput[]
    studyRoomId?: StringFilter<"StudyRoomMessage"> | string
    userId?: StringFilter<"StudyRoomMessage"> | string
    message?: StringFilter<"StudyRoomMessage"> | string
    messageType?: StringFilter<"StudyRoomMessage"> | string
    metadata?: StringNullableFilter<"StudyRoomMessage"> | string | null
    createdAt?: DateTimeFilter<"StudyRoomMessage"> | Date | string
    studyRoom?: XOR<StudyRoomRelationFilter, StudyRoomWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type StudyRoomMessageOrderByWithAggregationInput = {
    id?: SortOrder
    studyRoomId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StudyRoomMessageCountOrderByAggregateInput
    _max?: StudyRoomMessageMaxOrderByAggregateInput
    _min?: StudyRoomMessageMinOrderByAggregateInput
  }

  export type StudyRoomMessageScalarWhereWithAggregatesInput = {
    AND?: StudyRoomMessageScalarWhereWithAggregatesInput | StudyRoomMessageScalarWhereWithAggregatesInput[]
    OR?: StudyRoomMessageScalarWhereWithAggregatesInput[]
    NOT?: StudyRoomMessageScalarWhereWithAggregatesInput | StudyRoomMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudyRoomMessage"> | string
    studyRoomId?: StringWithAggregatesFilter<"StudyRoomMessage"> | string
    userId?: StringWithAggregatesFilter<"StudyRoomMessage"> | string
    message?: StringWithAggregatesFilter<"StudyRoomMessage"> | string
    messageType?: StringWithAggregatesFilter<"StudyRoomMessage"> | string
    metadata?: StringNullableWithAggregatesFilter<"StudyRoomMessage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StudyRoomMessage"> | Date | string
  }

  export type FeedbackReportWhereInput = {
    AND?: FeedbackReportWhereInput | FeedbackReportWhereInput[]
    OR?: FeedbackReportWhereInput[]
    NOT?: FeedbackReportWhereInput | FeedbackReportWhereInput[]
    id?: StringFilter<"FeedbackReport"> | string
    userId?: StringFilter<"FeedbackReport"> | string
    type?: EnumFeedbackTypeFilter<"FeedbackReport"> | $Enums.FeedbackType
    title?: StringFilter<"FeedbackReport"> | string
    description?: StringFilter<"FeedbackReport"> | string
    priority?: EnumFeedbackPriorityFilter<"FeedbackReport"> | $Enums.FeedbackPriority
    category?: StringFilter<"FeedbackReport"> | string
    status?: EnumFeedbackStatusFilter<"FeedbackReport"> | $Enums.FeedbackStatus
    elementContext?: JsonFilter<"FeedbackReport">
    technicalContext?: JsonFilter<"FeedbackReport">
    codeAnalysis?: JsonNullableFilter<"FeedbackReport">
    aiSuggestions?: JsonNullableFilter<"FeedbackReport">
    adminResponse?: StringNullableFilter<"FeedbackReport"> | string | null
    adminUserId?: StringNullableFilter<"FeedbackReport"> | string | null
    resolvedAt?: DateTimeNullableFilter<"FeedbackReport"> | Date | string | null
    upvotes?: IntFilter<"FeedbackReport"> | number
    downvotes?: IntFilter<"FeedbackReport"> | number
    duplicateOf?: StringNullableFilter<"FeedbackReport"> | string | null
    createdAt?: DateTimeFilter<"FeedbackReport"> | Date | string
    updatedAt?: DateTimeFilter<"FeedbackReport"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    adminUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type FeedbackReportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    status?: SortOrder
    elementContext?: SortOrder
    technicalContext?: SortOrder
    codeAnalysis?: SortOrderInput | SortOrder
    aiSuggestions?: SortOrderInput | SortOrder
    adminResponse?: SortOrderInput | SortOrder
    adminUserId?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    duplicateOf?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    adminUser?: UserOrderByWithRelationInput
  }

  export type FeedbackReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeedbackReportWhereInput | FeedbackReportWhereInput[]
    OR?: FeedbackReportWhereInput[]
    NOT?: FeedbackReportWhereInput | FeedbackReportWhereInput[]
    userId?: StringFilter<"FeedbackReport"> | string
    type?: EnumFeedbackTypeFilter<"FeedbackReport"> | $Enums.FeedbackType
    title?: StringFilter<"FeedbackReport"> | string
    description?: StringFilter<"FeedbackReport"> | string
    priority?: EnumFeedbackPriorityFilter<"FeedbackReport"> | $Enums.FeedbackPriority
    category?: StringFilter<"FeedbackReport"> | string
    status?: EnumFeedbackStatusFilter<"FeedbackReport"> | $Enums.FeedbackStatus
    elementContext?: JsonFilter<"FeedbackReport">
    technicalContext?: JsonFilter<"FeedbackReport">
    codeAnalysis?: JsonNullableFilter<"FeedbackReport">
    aiSuggestions?: JsonNullableFilter<"FeedbackReport">
    adminResponse?: StringNullableFilter<"FeedbackReport"> | string | null
    adminUserId?: StringNullableFilter<"FeedbackReport"> | string | null
    resolvedAt?: DateTimeNullableFilter<"FeedbackReport"> | Date | string | null
    upvotes?: IntFilter<"FeedbackReport"> | number
    downvotes?: IntFilter<"FeedbackReport"> | number
    duplicateOf?: StringNullableFilter<"FeedbackReport"> | string | null
    createdAt?: DateTimeFilter<"FeedbackReport"> | Date | string
    updatedAt?: DateTimeFilter<"FeedbackReport"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    adminUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type FeedbackReportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    status?: SortOrder
    elementContext?: SortOrder
    technicalContext?: SortOrder
    codeAnalysis?: SortOrderInput | SortOrder
    aiSuggestions?: SortOrderInput | SortOrder
    adminResponse?: SortOrderInput | SortOrder
    adminUserId?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    duplicateOf?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeedbackReportCountOrderByAggregateInput
    _avg?: FeedbackReportAvgOrderByAggregateInput
    _max?: FeedbackReportMaxOrderByAggregateInput
    _min?: FeedbackReportMinOrderByAggregateInput
    _sum?: FeedbackReportSumOrderByAggregateInput
  }

  export type FeedbackReportScalarWhereWithAggregatesInput = {
    AND?: FeedbackReportScalarWhereWithAggregatesInput | FeedbackReportScalarWhereWithAggregatesInput[]
    OR?: FeedbackReportScalarWhereWithAggregatesInput[]
    NOT?: FeedbackReportScalarWhereWithAggregatesInput | FeedbackReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeedbackReport"> | string
    userId?: StringWithAggregatesFilter<"FeedbackReport"> | string
    type?: EnumFeedbackTypeWithAggregatesFilter<"FeedbackReport"> | $Enums.FeedbackType
    title?: StringWithAggregatesFilter<"FeedbackReport"> | string
    description?: StringWithAggregatesFilter<"FeedbackReport"> | string
    priority?: EnumFeedbackPriorityWithAggregatesFilter<"FeedbackReport"> | $Enums.FeedbackPriority
    category?: StringWithAggregatesFilter<"FeedbackReport"> | string
    status?: EnumFeedbackStatusWithAggregatesFilter<"FeedbackReport"> | $Enums.FeedbackStatus
    elementContext?: JsonWithAggregatesFilter<"FeedbackReport">
    technicalContext?: JsonWithAggregatesFilter<"FeedbackReport">
    codeAnalysis?: JsonNullableWithAggregatesFilter<"FeedbackReport">
    aiSuggestions?: JsonNullableWithAggregatesFilter<"FeedbackReport">
    adminResponse?: StringNullableWithAggregatesFilter<"FeedbackReport"> | string | null
    adminUserId?: StringNullableWithAggregatesFilter<"FeedbackReport"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"FeedbackReport"> | Date | string | null
    upvotes?: IntWithAggregatesFilter<"FeedbackReport"> | number
    downvotes?: IntWithAggregatesFilter<"FeedbackReport"> | number
    duplicateOf?: StringNullableWithAggregatesFilter<"FeedbackReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FeedbackReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeedbackReport"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    avatar?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    location?: StringNullableFilter<"Profile"> | string | null
    website?: StringNullableFilter<"Profile"> | string | null
    skills?: StringNullableListFilter<"Profile">
    interests?: StringNullableListFilter<"Profile">
    isEmprendedorConfiable?: BoolFilter<"Profile"> | boolean
    socialLinks?: JsonNullableFilter<"Profile">
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    skills?: SortOrder
    interests?: SortOrder
    isEmprendedorConfiable?: SortOrder
    socialLinks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    avatar?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    location?: StringNullableFilter<"Profile"> | string | null
    website?: StringNullableFilter<"Profile"> | string | null
    skills?: StringNullableListFilter<"Profile">
    interests?: StringNullableListFilter<"Profile">
    isEmprendedorConfiable?: BoolFilter<"Profile"> | boolean
    socialLinks?: JsonNullableFilter<"Profile">
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    skills?: SortOrder
    interests?: SortOrder
    isEmprendedorConfiable?: SortOrder
    socialLinks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    userId?: StringWithAggregatesFilter<"Profile"> | string
    avatar?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    location?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    website?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    skills?: StringNullableListFilter<"Profile">
    interests?: StringNullableListFilter<"Profile">
    isEmprendedorConfiable?: BoolWithAggregatesFilter<"Profile"> | boolean
    socialLinks?: JsonNullableWithAggregatesFilter<"Profile">
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    marketplaceItemId?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    communication?: IntNullableFilter<"Review"> | number | null
    quality?: IntNullableFilter<"Review"> | number | null
    delivery?: IntNullableFilter<"Review"> | number | null
    value?: IntNullableFilter<"Review"> | number | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    marketplaceItem?: XOR<MarketplaceItemRelationFilter, MarketplaceItemWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    marketplaceItemId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    communication?: SortOrderInput | SortOrder
    quality?: SortOrderInput | SortOrder
    delivery?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    marketplaceItem?: MarketplaceItemOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    marketplaceItemId?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    communication?: IntNullableFilter<"Review"> | number | null
    quality?: IntNullableFilter<"Review"> | number | null
    delivery?: IntNullableFilter<"Review"> | number | null
    value?: IntNullableFilter<"Review"> | number | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    marketplaceItem?: XOR<MarketplaceItemRelationFilter, MarketplaceItemWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    marketplaceItemId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    communication?: SortOrderInput | SortOrder
    quality?: SortOrderInput | SortOrder
    delivery?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    marketplaceItemId?: StringWithAggregatesFilter<"Review"> | string
    userId?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    communication?: IntNullableWithAggregatesFilter<"Review"> | number | null
    quality?: IntNullableWithAggregatesFilter<"Review"> | number | null
    delivery?: IntNullableWithAggregatesFilter<"Review"> | number | null
    value?: IntNullableWithAggregatesFilter<"Review"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type MarketplaceMatchWhereInput = {
    AND?: MarketplaceMatchWhereInput | MarketplaceMatchWhereInput[]
    OR?: MarketplaceMatchWhereInput[]
    NOT?: MarketplaceMatchWhereInput | MarketplaceMatchWhereInput[]
    id?: StringFilter<"MarketplaceMatch"> | string
    itemId?: StringFilter<"MarketplaceMatch"> | string
    buyerId?: StringFilter<"MarketplaceMatch"> | string
    sellerId?: StringFilter<"MarketplaceMatch"> | string
    buyerConfirmed?: BoolFilter<"MarketplaceMatch"> | boolean
    sellerConfirmed?: BoolFilter<"MarketplaceMatch"> | boolean
    status?: EnumMatchStatusFilter<"MarketplaceMatch"> | $Enums.MatchStatus
    createdAt?: DateTimeFilter<"MarketplaceMatch"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceMatch"> | Date | string
    item?: XOR<MarketplaceItemRelationFilter, MarketplaceItemWhereInput>
    buyer?: XOR<UserRelationFilter, UserWhereInput>
    seller?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MatchMessageListRelationFilter
  }

  export type MarketplaceMatchOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    buyerConfirmed?: SortOrder
    sellerConfirmed?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    item?: MarketplaceItemOrderByWithRelationInput
    buyer?: UserOrderByWithRelationInput
    seller?: UserOrderByWithRelationInput
    messages?: MatchMessageOrderByRelationAggregateInput
  }

  export type MarketplaceMatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketplaceMatchWhereInput | MarketplaceMatchWhereInput[]
    OR?: MarketplaceMatchWhereInput[]
    NOT?: MarketplaceMatchWhereInput | MarketplaceMatchWhereInput[]
    itemId?: StringFilter<"MarketplaceMatch"> | string
    buyerId?: StringFilter<"MarketplaceMatch"> | string
    sellerId?: StringFilter<"MarketplaceMatch"> | string
    buyerConfirmed?: BoolFilter<"MarketplaceMatch"> | boolean
    sellerConfirmed?: BoolFilter<"MarketplaceMatch"> | boolean
    status?: EnumMatchStatusFilter<"MarketplaceMatch"> | $Enums.MatchStatus
    createdAt?: DateTimeFilter<"MarketplaceMatch"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceMatch"> | Date | string
    item?: XOR<MarketplaceItemRelationFilter, MarketplaceItemWhereInput>
    buyer?: XOR<UserRelationFilter, UserWhereInput>
    seller?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MatchMessageListRelationFilter
  }, "id">

  export type MarketplaceMatchOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    buyerConfirmed?: SortOrder
    sellerConfirmed?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketplaceMatchCountOrderByAggregateInput
    _max?: MarketplaceMatchMaxOrderByAggregateInput
    _min?: MarketplaceMatchMinOrderByAggregateInput
  }

  export type MarketplaceMatchScalarWhereWithAggregatesInput = {
    AND?: MarketplaceMatchScalarWhereWithAggregatesInput | MarketplaceMatchScalarWhereWithAggregatesInput[]
    OR?: MarketplaceMatchScalarWhereWithAggregatesInput[]
    NOT?: MarketplaceMatchScalarWhereWithAggregatesInput | MarketplaceMatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketplaceMatch"> | string
    itemId?: StringWithAggregatesFilter<"MarketplaceMatch"> | string
    buyerId?: StringWithAggregatesFilter<"MarketplaceMatch"> | string
    sellerId?: StringWithAggregatesFilter<"MarketplaceMatch"> | string
    buyerConfirmed?: BoolWithAggregatesFilter<"MarketplaceMatch"> | boolean
    sellerConfirmed?: BoolWithAggregatesFilter<"MarketplaceMatch"> | boolean
    status?: EnumMatchStatusWithAggregatesFilter<"MarketplaceMatch"> | $Enums.MatchStatus
    createdAt?: DateTimeWithAggregatesFilter<"MarketplaceMatch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketplaceMatch"> | Date | string
  }

  export type MatchMessageWhereInput = {
    AND?: MatchMessageWhereInput | MatchMessageWhereInput[]
    OR?: MatchMessageWhereInput[]
    NOT?: MatchMessageWhereInput | MatchMessageWhereInput[]
    id?: StringFilter<"MatchMessage"> | string
    matchId?: StringFilter<"MatchMessage"> | string
    senderId?: StringFilter<"MatchMessage"> | string
    content?: StringFilter<"MatchMessage"> | string
    createdAt?: DateTimeFilter<"MatchMessage"> | Date | string
    match?: XOR<MarketplaceMatchRelationFilter, MarketplaceMatchWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MatchMessageOrderByWithRelationInput = {
    id?: SortOrder
    matchId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    match?: MarketplaceMatchOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type MatchMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MatchMessageWhereInput | MatchMessageWhereInput[]
    OR?: MatchMessageWhereInput[]
    NOT?: MatchMessageWhereInput | MatchMessageWhereInput[]
    matchId?: StringFilter<"MatchMessage"> | string
    senderId?: StringFilter<"MatchMessage"> | string
    content?: StringFilter<"MatchMessage"> | string
    createdAt?: DateTimeFilter<"MatchMessage"> | Date | string
    match?: XOR<MarketplaceMatchRelationFilter, MarketplaceMatchWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MatchMessageOrderByWithAggregationInput = {
    id?: SortOrder
    matchId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: MatchMessageCountOrderByAggregateInput
    _max?: MatchMessageMaxOrderByAggregateInput
    _min?: MatchMessageMinOrderByAggregateInput
  }

  export type MatchMessageScalarWhereWithAggregatesInput = {
    AND?: MatchMessageScalarWhereWithAggregatesInput | MatchMessageScalarWhereWithAggregatesInput[]
    OR?: MatchMessageScalarWhereWithAggregatesInput[]
    NOT?: MatchMessageScalarWhereWithAggregatesInput | MatchMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MatchMessage"> | string
    matchId?: StringWithAggregatesFilter<"MatchMessage"> | string
    senderId?: StringWithAggregatesFilter<"MatchMessage"> | string
    content?: StringWithAggregatesFilter<"MatchMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MatchMessage"> | Date | string
  }

  export type MundoCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
    playlists?: PlaylistCreateNestedManyWithoutMundoInput
    worlds?: WorldCreateNestedManyWithoutMundoInput
  }

  export type MundoUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
    playlists?: PlaylistUncheckedCreateNestedManyWithoutMundoInput
    worlds?: WorldUncheckedCreateNestedManyWithoutMundoInput
  }

  export type MundoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    playlists?: PlaylistUpdateManyWithoutMundoNestedInput
    worlds?: WorldUpdateManyWithoutMundoNestedInput
  }

  export type MundoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    playlists?: PlaylistUncheckedUpdateManyWithoutMundoNestedInput
    worlds?: WorldUncheckedUpdateManyWithoutMundoNestedInput
  }

  export type MundoCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
  }

  export type MundoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type MundoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type PlaylistCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    orderInMundo?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
    contentItems?: ContentItemCreateNestedManyWithoutPlaylistInput
    gamifiedPlaylists?: GamifiedPlaylistCreateNestedManyWithoutPlaylistInput
    mundo: MundoCreateNestedOneWithoutPlaylistsInput
    videoItems?: VideoItemCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistUncheckedCreateInput = {
    id?: string
    mundoId: string
    name: string
    description?: string | null
    imageUrl?: string | null
    orderInMundo?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
    contentItems?: ContentItemUncheckedCreateNestedManyWithoutPlaylistInput
    gamifiedPlaylists?: GamifiedPlaylistUncheckedCreateNestedManyWithoutPlaylistInput
    videoItems?: VideoItemUncheckedCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orderInMundo?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    contentItems?: ContentItemUpdateManyWithoutPlaylistNestedInput
    gamifiedPlaylists?: GamifiedPlaylistUpdateManyWithoutPlaylistNestedInput
    mundo?: MundoUpdateOneRequiredWithoutPlaylistsNestedInput
    videoItems?: VideoItemUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mundoId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orderInMundo?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    contentItems?: ContentItemUncheckedUpdateManyWithoutPlaylistNestedInput
    gamifiedPlaylists?: GamifiedPlaylistUncheckedUpdateManyWithoutPlaylistNestedInput
    videoItems?: VideoItemUncheckedUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistCreateManyInput = {
    id?: string
    mundoId: string
    name: string
    description?: string | null
    imageUrl?: string | null
    orderInMundo?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
  }

  export type PlaylistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orderInMundo?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type PlaylistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mundoId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orderInMundo?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type VideoItemCreateInput = {
    title: string
    description?: string | null
    content: string
    url?: string | null
    platform?: string
    externalId?: string | null
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    duration?: number | null
    categories?: string | null
    language?: string | null
    quality?: string | null
    tags?: string | null
    thumbnailUrl?: string | null
    activities?: ActivityCreateNestedManyWithoutVideoItemInput
    questions?: QuestionCreateNestedManyWithoutVideoItemInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoItemInput
    studyRooms?: StudyRoomCreateNestedManyWithoutVideoInput
    playlist: PlaylistCreateNestedOneWithoutVideoItemsInput
    permissions?: VideoPermissionsCreateNestedOneWithoutVideoItemInput
  }

  export type VideoItemUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    content: string
    url?: string | null
    platform?: string
    externalId?: string | null
    playlistId: string
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    duration?: number | null
    categories?: string | null
    language?: string | null
    quality?: string | null
    tags?: string | null
    thumbnailUrl?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutVideoItemInput
    questions?: QuestionUncheckedCreateNestedManyWithoutVideoItemInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoItemInput
    studyRooms?: StudyRoomUncheckedCreateNestedManyWithoutVideoInput
    permissions?: VideoPermissionsUncheckedCreateNestedOneWithoutVideoItemInput
  }

  export type VideoItemUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutVideoItemNestedInput
    questions?: QuestionUpdateManyWithoutVideoItemNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoItemNestedInput
    studyRooms?: StudyRoomUpdateManyWithoutVideoNestedInput
    playlist?: PlaylistUpdateOneRequiredWithoutVideoItemsNestedInput
    permissions?: VideoPermissionsUpdateOneWithoutVideoItemNestedInput
  }

  export type VideoItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    playlistId?: StringFieldUpdateOperationsInput | string
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutVideoItemNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutVideoItemNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoItemNestedInput
    studyRooms?: StudyRoomUncheckedUpdateManyWithoutVideoNestedInput
    permissions?: VideoPermissionsUncheckedUpdateOneWithoutVideoItemNestedInput
  }

  export type VideoItemCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    content: string
    url?: string | null
    platform?: string
    externalId?: string | null
    playlistId: string
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    duration?: number | null
    categories?: string | null
    language?: string | null
    quality?: string | null
    tags?: string | null
    thumbnailUrl?: string | null
  }

  export type VideoItemUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    playlistId?: StringFieldUpdateOperationsInput | string
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubtitleCreateInput = {
    languageCode: string
    format?: string
    content?: string | null
    contentUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    videoItem: VideoItemCreateNestedOneWithoutSubtitlesInput
  }

  export type SubtitleUncheckedCreateInput = {
    id?: number
    videoItemId: number
    languageCode: string
    format?: string
    content?: string | null
    contentUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubtitleUpdateInput = {
    languageCode?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoItem?: VideoItemUpdateOneRequiredWithoutSubtitlesNestedInput
  }

  export type SubtitleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoItemId?: IntFieldUpdateOperationsInput | number
    languageCode?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtitleCreateManyInput = {
    id?: number
    videoItemId: number
    languageCode: string
    format?: string
    content?: string | null
    contentUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubtitleUpdateManyMutationInput = {
    languageCode?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtitleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoItemId?: IntFieldUpdateOperationsInput | number
    languageCode?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateInput = {
    timestamp: number
    type: string
    text: string
    languageCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    endTimestamp?: number | null
    answerOptions?: AnswerOptionCreateNestedManyWithoutQuestionInput
    videoItem: VideoItemCreateNestedOneWithoutQuestionsInput
    userAnswers?: UserAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: number
    videoItemId: number
    timestamp: number
    type: string
    text: string
    languageCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    endTimestamp?: number | null
    answerOptions?: AnswerOptionUncheckedCreateNestedManyWithoutQuestionInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUpdateInput = {
    timestamp?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    answerOptions?: AnswerOptionUpdateManyWithoutQuestionNestedInput
    videoItem?: VideoItemUpdateOneRequiredWithoutQuestionsNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoItemId?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    answerOptions?: AnswerOptionUncheckedUpdateManyWithoutQuestionNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionCreateManyInput = {
    id?: number
    videoItemId: number
    timestamp: number
    type: string
    text: string
    languageCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    endTimestamp?: number | null
  }

  export type QuestionUpdateManyMutationInput = {
    timestamp?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoItemId?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AnswerOptionCreateInput = {
    text: string
    isCorrect?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    question: QuestionCreateNestedOneWithoutAnswerOptionsInput
  }

  export type AnswerOptionUncheckedCreateInput = {
    id?: number
    questionId: number
    text: string
    isCorrect?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnswerOptionUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutAnswerOptionsNestedInput
  }

  export type AnswerOptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerOptionCreateManyInput = {
    id?: number
    questionId: number
    text: string
    isCorrect?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnswerOptionUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerOptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionCreateNestedManyWithoutRoleInput
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    assignedAt?: Date | string
    assignedBy?: UserCreateNestedOneWithoutAssignedRolesInput
    role: RoleCreateNestedOneWithoutUserRolesInput
    user: UserCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    userId: string
    roleId: string
    assignedAt?: Date | string
    assignedById?: string | null
  }

  export type UserRoleUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: UserUpdateOneWithoutAssignedRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleCreateManyInput = {
    userId: string
    roleId: string
    assignedAt?: Date | string
    assignedById?: string | null
  }

  export type UserRoleUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoPermissionsCreateInput = {
    id?: string
    showWaveCount?: boolean
    showVideos?: boolean
    showVideoSubtitles?: boolean
    showComments?: boolean
    showPublishDate?: boolean
    showVideoDuration?: boolean
    showLikeButton?: boolean
    allowRewindForward?: boolean
    allowViewComments?: boolean
    allowMakeComments?: boolean
    showLikeComments?: boolean
    sortCommentsByAffinity?: boolean
    showCommenterName?: boolean
    playlistPosition?: string
    isDraft?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutVideoPermissionsInput
    videoItem: VideoItemCreateNestedOneWithoutPermissionsInput
  }

  export type VideoPermissionsUncheckedCreateInput = {
    id?: string
    videoItemId: number
    showWaveCount?: boolean
    showVideos?: boolean
    showVideoSubtitles?: boolean
    showComments?: boolean
    showPublishDate?: boolean
    showVideoDuration?: boolean
    showLikeButton?: boolean
    allowRewindForward?: boolean
    allowViewComments?: boolean
    allowMakeComments?: boolean
    showLikeComments?: boolean
    sortCommentsByAffinity?: boolean
    showCommenterName?: boolean
    playlistPosition?: string
    isDraft?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type VideoPermissionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    showWaveCount?: BoolFieldUpdateOperationsInput | boolean
    showVideos?: BoolFieldUpdateOperationsInput | boolean
    showVideoSubtitles?: BoolFieldUpdateOperationsInput | boolean
    showComments?: BoolFieldUpdateOperationsInput | boolean
    showPublishDate?: BoolFieldUpdateOperationsInput | boolean
    showVideoDuration?: BoolFieldUpdateOperationsInput | boolean
    showLikeButton?: BoolFieldUpdateOperationsInput | boolean
    allowRewindForward?: BoolFieldUpdateOperationsInput | boolean
    allowViewComments?: BoolFieldUpdateOperationsInput | boolean
    allowMakeComments?: BoolFieldUpdateOperationsInput | boolean
    showLikeComments?: BoolFieldUpdateOperationsInput | boolean
    sortCommentsByAffinity?: BoolFieldUpdateOperationsInput | boolean
    showCommenterName?: BoolFieldUpdateOperationsInput | boolean
    playlistPosition?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutVideoPermissionsNestedInput
    videoItem?: VideoItemUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type VideoPermissionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoItemId?: IntFieldUpdateOperationsInput | number
    showWaveCount?: BoolFieldUpdateOperationsInput | boolean
    showVideos?: BoolFieldUpdateOperationsInput | boolean
    showVideoSubtitles?: BoolFieldUpdateOperationsInput | boolean
    showComments?: BoolFieldUpdateOperationsInput | boolean
    showPublishDate?: BoolFieldUpdateOperationsInput | boolean
    showVideoDuration?: BoolFieldUpdateOperationsInput | boolean
    showLikeButton?: BoolFieldUpdateOperationsInput | boolean
    allowRewindForward?: BoolFieldUpdateOperationsInput | boolean
    allowViewComments?: BoolFieldUpdateOperationsInput | boolean
    allowMakeComments?: BoolFieldUpdateOperationsInput | boolean
    showLikeComments?: BoolFieldUpdateOperationsInput | boolean
    sortCommentsByAffinity?: BoolFieldUpdateOperationsInput | boolean
    showCommenterName?: BoolFieldUpdateOperationsInput | boolean
    playlistPosition?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoPermissionsCreateManyInput = {
    id?: string
    videoItemId: number
    showWaveCount?: boolean
    showVideos?: boolean
    showVideoSubtitles?: boolean
    showComments?: boolean
    showPublishDate?: boolean
    showVideoDuration?: boolean
    showLikeButton?: boolean
    allowRewindForward?: boolean
    allowViewComments?: boolean
    allowMakeComments?: boolean
    showLikeComments?: boolean
    sortCommentsByAffinity?: boolean
    showCommenterName?: boolean
    playlistPosition?: string
    isDraft?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type VideoPermissionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    showWaveCount?: BoolFieldUpdateOperationsInput | boolean
    showVideos?: BoolFieldUpdateOperationsInput | boolean
    showVideoSubtitles?: BoolFieldUpdateOperationsInput | boolean
    showComments?: BoolFieldUpdateOperationsInput | boolean
    showPublishDate?: BoolFieldUpdateOperationsInput | boolean
    showVideoDuration?: BoolFieldUpdateOperationsInput | boolean
    showLikeButton?: BoolFieldUpdateOperationsInput | boolean
    allowRewindForward?: BoolFieldUpdateOperationsInput | boolean
    allowViewComments?: BoolFieldUpdateOperationsInput | boolean
    allowMakeComments?: BoolFieldUpdateOperationsInput | boolean
    showLikeComments?: BoolFieldUpdateOperationsInput | boolean
    sortCommentsByAffinity?: BoolFieldUpdateOperationsInput | boolean
    showCommenterName?: BoolFieldUpdateOperationsInput | boolean
    playlistPosition?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoPermissionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoItemId?: IntFieldUpdateOperationsInput | number
    showWaveCount?: BoolFieldUpdateOperationsInput | boolean
    showVideos?: BoolFieldUpdateOperationsInput | boolean
    showVideoSubtitles?: BoolFieldUpdateOperationsInput | boolean
    showComments?: BoolFieldUpdateOperationsInput | boolean
    showPublishDate?: BoolFieldUpdateOperationsInput | boolean
    showVideoDuration?: BoolFieldUpdateOperationsInput | boolean
    showLikeButton?: BoolFieldUpdateOperationsInput | boolean
    allowRewindForward?: BoolFieldUpdateOperationsInput | boolean
    allowViewComments?: BoolFieldUpdateOperationsInput | boolean
    allowMakeComments?: BoolFieldUpdateOperationsInput | boolean
    showLikeComments?: BoolFieldUpdateOperationsInput | boolean
    sortCommentsByAffinity?: BoolFieldUpdateOperationsInput | boolean
    showCommenterName?: BoolFieldUpdateOperationsInput | boolean
    playlistPosition?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionCreateInput = {
    assignedAt?: Date | string
    assignedBy?: UserCreateNestedOneWithoutAssignedPermissionsInput
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
    role: RoleCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateInput = {
    roleId: string
    permissionId: string
    assignedAt?: Date | string
    assignedById?: string | null
  }

  export type RolePermissionUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: UserUpdateOneWithoutAssignedPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
    role?: RoleUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionCreateManyInput = {
    roleId: string
    permissionId: string
    assignedAt?: Date | string
    assignedById?: string | null
  }

  export type RolePermissionUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorldCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stages?: StageCreateNestedManyWithoutWorldInput
    mundo?: MundoCreateNestedOneWithoutWorldsInput
    creator: UserCreateNestedOneWithoutCreatedWorldsInput
  }

  export type WorldUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    creatorId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mundoId?: string | null
    stages?: StageUncheckedCreateNestedManyWithoutWorldInput
  }

  export type WorldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: StageUpdateManyWithoutWorldNestedInput
    mundo?: MundoUpdateOneWithoutWorldsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorldsNestedInput
  }

  export type WorldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mundoId?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: StageUncheckedUpdateManyWithoutWorldNestedInput
  }

  export type WorldCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    creatorId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mundoId?: string | null
  }

  export type WorldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mundoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StageCreateInput = {
    id?: string
    name: string
    order: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    experiences?: ExperienceCreateNestedManyWithoutStageInput
    world: WorldCreateNestedOneWithoutStagesInput
  }

  export type StageUncheckedCreateInput = {
    id?: string
    worldId: string
    name: string
    order: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    experiences?: ExperienceUncheckedCreateNestedManyWithoutStageInput
  }

  export type StageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUpdateManyWithoutStageNestedInput
    world?: WorldUpdateOneRequiredWithoutStagesNestedInput
  }

  export type StageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    worldId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUncheckedUpdateManyWithoutStageNestedInput
  }

  export type StageCreateManyInput = {
    id?: string
    worldId: string
    name: string
    order: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    worldId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    gamificationFramework?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutExperienceInput
    creator: UserCreateNestedOneWithoutCreatedExperiencesInput
    stage: StageCreateNestedOneWithoutExperiencesInput
  }

  export type ExperienceUncheckedCreateInput = {
    id?: string
    stageId: string
    title: string
    description?: string | null
    type: string
    gamificationFramework?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutExperienceInput
  }

  export type ExperienceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    gamificationFramework?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutExperienceNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedExperiencesNestedInput
    stage?: StageUpdateOneRequiredWithoutExperiencesNestedInput
  }

  export type ExperienceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    gamificationFramework?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutExperienceNestedInput
  }

  export type ExperienceCreateManyInput = {
    id?: string
    stageId: string
    title: string
    description?: string | null
    type: string
    gamificationFramework?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExperienceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    gamificationFramework?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    gamificationFramework?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    multimediaType?: string | null
    contentUrl?: string | null
    duration?: number | null
    order?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoItem?: VideoItemCreateNestedOneWithoutActivitiesInput
    creator: UserCreateNestedOneWithoutCreatedActivitiesInput
    experience: ExperienceCreateNestedOneWithoutActivitiesInput
    questions?: ActivityQuestionCreateNestedManyWithoutActivityInput
    gamifiedPlaylists?: GamifiedPlaylistCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    experienceId: string
    title: string
    description?: string | null
    type: string
    multimediaType?: string | null
    contentUrl?: string | null
    duration?: number | null
    order?: number
    status?: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoItemId?: number | null
    questions?: ActivityQuestionUncheckedCreateNestedManyWithoutActivityInput
    gamifiedPlaylists?: GamifiedPlaylistUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    multimediaType?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoItem?: VideoItemUpdateOneWithoutActivitiesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedActivitiesNestedInput
    experience?: ExperienceUpdateOneRequiredWithoutActivitiesNestedInput
    questions?: ActivityQuestionUpdateManyWithoutActivityNestedInput
    gamifiedPlaylists?: GamifiedPlaylistUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    multimediaType?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoItemId?: NullableIntFieldUpdateOperationsInput | number | null
    questions?: ActivityQuestionUncheckedUpdateManyWithoutActivityNestedInput
    gamifiedPlaylists?: GamifiedPlaylistUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityCreateManyInput = {
    id?: string
    experienceId: string
    title: string
    description?: string | null
    type: string
    multimediaType?: string | null
    contentUrl?: string | null
    duration?: number | null
    order?: number
    status?: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoItemId?: number | null
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    multimediaType?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    multimediaType?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoItemId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GamifiedPlaylistCreateInput = {
    id?: string
    name: string
    type: string
    sequenceType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    playlist?: PlaylistCreateNestedOneWithoutGamifiedPlaylistsInput
    activity?: ActivityCreateNestedOneWithoutGamifiedPlaylistsInput
  }

  export type GamifiedPlaylistUncheckedCreateInput = {
    id?: string
    activityId?: string | null
    playlistId?: string | null
    name: string
    type: string
    sequenceType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GamifiedPlaylistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sequenceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playlist?: PlaylistUpdateOneWithoutGamifiedPlaylistsNestedInput
    activity?: ActivityUpdateOneWithoutGamifiedPlaylistsNestedInput
  }

  export type GamifiedPlaylistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    playlistId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sequenceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GamifiedPlaylistCreateManyInput = {
    id?: string
    activityId?: string | null
    playlistId?: string | null
    name: string
    type: string
    sequenceType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GamifiedPlaylistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sequenceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GamifiedPlaylistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    playlistId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sequenceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityQuestionCreateInput = {
    id?: string
    type: string
    questionType: string
    questionText: string
    options?: string | null
    correctAnswer?: string | null
    ondasList?: string | null
    displayTimeSeconds?: number | null
    optionalDisplaySeconds?: number | null
    createdAt?: Date | string
    activity: ActivityCreateNestedOneWithoutQuestionsInput
    userAnswers?: UserAnswerCreateNestedManyWithoutActivityQuestionInput
  }

  export type ActivityQuestionUncheckedCreateInput = {
    id?: string
    activityId: string
    type: string
    questionType: string
    questionText: string
    options?: string | null
    correctAnswer?: string | null
    ondasList?: string | null
    displayTimeSeconds?: number | null
    optionalDisplaySeconds?: number | null
    createdAt?: Date | string
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutActivityQuestionInput
  }

  export type ActivityQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    ondasList?: NullableStringFieldUpdateOperationsInput | string | null
    displayTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    optionalDisplaySeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutQuestionsNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutActivityQuestionNestedInput
  }

  export type ActivityQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    ondasList?: NullableStringFieldUpdateOperationsInput | string | null
    displayTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    optionalDisplaySeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutActivityQuestionNestedInput
  }

  export type ActivityQuestionCreateManyInput = {
    id?: string
    activityId: string
    type: string
    questionType: string
    questionText: string
    options?: string | null
    correctAnswer?: string | null
    ondasList?: string | null
    displayTimeSeconds?: number | null
    optionalDisplaySeconds?: number | null
    createdAt?: Date | string
  }

  export type ActivityQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    ondasList?: NullableStringFieldUpdateOperationsInput | string | null
    displayTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    optionalDisplaySeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    ondasList?: NullableStringFieldUpdateOperationsInput | string | null
    displayTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    optionalDisplaySeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnswerCreateInput = {
    id?: string
    answerGiven: string
    isCorrect?: boolean | null
    ondasEarned?: number
    createdAt?: Date | string
    activityQuestion?: ActivityQuestionCreateNestedOneWithoutUserAnswersInput
    question?: QuestionCreateNestedOneWithoutUserAnswersInput
    user: UserCreateNestedOneWithoutUserAnswersInput
  }

  export type UserAnswerUncheckedCreateInput = {
    id?: string
    userId: string
    questionId?: number | null
    activityQuestionId?: string | null
    answerGiven: string
    isCorrect?: boolean | null
    ondasEarned?: number
    createdAt?: Date | string
  }

  export type UserAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerGiven?: StringFieldUpdateOperationsInput | string
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ondasEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityQuestion?: ActivityQuestionUpdateOneWithoutUserAnswersNestedInput
    question?: QuestionUpdateOneWithoutUserAnswersNestedInput
    user?: UserUpdateOneRequiredWithoutUserAnswersNestedInput
  }

  export type UserAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    activityQuestionId?: NullableStringFieldUpdateOperationsInput | string | null
    answerGiven?: StringFieldUpdateOperationsInput | string
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ondasEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnswerCreateManyInput = {
    id?: string
    userId: string
    questionId?: number | null
    activityQuestionId?: string | null
    answerGiven: string
    isCorrect?: boolean | null
    ondasEarned?: number
    createdAt?: Date | string
  }

  export type UserAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerGiven?: StringFieldUpdateOperationsInput | string
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ondasEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    activityQuestionId?: NullableStringFieldUpdateOperationsInput | string | null
    answerGiven?: StringFieldUpdateOperationsInput | string
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ondasEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateInput = {
    id?: string
    amount: number
    type: string
    status?: string
    caducityDate?: Date | string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTokensInput
  }

  export type TokenUncheckedCreateInput = {
    id?: string
    userId: string
    amount: number
    type: string
    status?: string
    caducityDate?: Date | string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    caducityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTokensNestedInput
  }

  export type TokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    caducityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateManyInput = {
    id?: string
    userId: string
    amount: number
    type: string
    status?: string
    caducityDate?: Date | string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    caducityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    caducityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeritCreateInput = {
    id?: string
    amount: number
    type: string
    source: string
    relatedEntityId?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMeritsInput
  }

  export type MeritUncheckedCreateInput = {
    id?: string
    userId: string
    amount: number
    type: string
    source: string
    relatedEntityId?: string | null
    createdAt?: Date | string
  }

  export type MeritUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMeritsNestedInput
  }

  export type MeritUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeritCreateManyInput = {
    id?: string
    userId: string
    amount: number
    type: string
    source: string
    relatedEntityId?: string | null
    createdAt?: Date | string
  }

  export type MeritUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeritUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateInput = {
    id?: string
    blockchainAddress?: string | null
    balanceUnits?: number
    balanceToins?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionsTo?: TransactionCreateNestedManyWithoutToWalletInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromWalletInput
    user: UserCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    userId: string
    blockchainAddress?: string | null
    balanceUnits?: number
    balanceToins?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToWalletInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromWalletInput
  }

  export type WalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockchainAddress?: NullableStringFieldUpdateOperationsInput | string | null
    balanceUnits?: FloatFieldUpdateOperationsInput | number
    balanceToins?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionsTo?: TransactionUpdateManyWithoutToWalletNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromWalletNestedInput
    user?: UserUpdateOneRequiredWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    blockchainAddress?: NullableStringFieldUpdateOperationsInput | string | null
    balanceUnits?: FloatFieldUpdateOperationsInput | number
    balanceToins?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToWalletNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromWalletNestedInput
  }

  export type WalletCreateManyInput = {
    id?: string
    userId: string
    blockchainAddress?: string | null
    balanceUnits?: number
    balanceToins?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockchainAddress?: NullableStringFieldUpdateOperationsInput | string | null
    balanceUnits?: FloatFieldUpdateOperationsInput | number
    balanceToins?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    blockchainAddress?: NullableStringFieldUpdateOperationsInput | string | null
    balanceUnits?: FloatFieldUpdateOperationsInput | number
    balanceToins?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    amount: number
    tokenType: string
    type: string
    status?: string
    description?: string | null
    createdAt?: Date | string
    toWallet: WalletCreateNestedOneWithoutTransactionsToInput
    fromWallet?: WalletCreateNestedOneWithoutTransactionsFromInput
    toUser: UserCreateNestedOneWithoutTransactionsToInput
    fromUser?: UserCreateNestedOneWithoutTransactionsFromInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    fromUserId?: string | null
    toUserId: string
    amount: number
    tokenType: string
    type: string
    status?: string
    description?: string | null
    createdAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tokenType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toWallet?: WalletUpdateOneRequiredWithoutTransactionsToNestedInput
    fromWallet?: WalletUpdateOneWithoutTransactionsFromNestedInput
    toUser?: UserUpdateOneRequiredWithoutTransactionsToNestedInput
    fromUser?: UserUpdateOneWithoutTransactionsFromNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: NullableStringFieldUpdateOperationsInput | string | null
    toUserId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tokenType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    fromUserId?: string | null
    toUserId: string
    amount: number
    tokenType: string
    type: string
    status?: string
    description?: string | null
    createdAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tokenType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: NullableStringFieldUpdateOperationsInput | string | null
    toUserId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tokenType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedGroupsInput
    userGroups?: UserGroupCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedGroupsNestedInput
    userGroups?: UserGroupUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userGroups?: UserGroupUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupCreateInput = {
    roleInGroup?: string
    joinedAt?: Date | string
    group: GroupCreateNestedOneWithoutUserGroupsInput
    user: UserCreateNestedOneWithoutUserGroupsInput
  }

  export type UserGroupUncheckedCreateInput = {
    userId: string
    groupId: string
    roleInGroup?: string
    joinedAt?: Date | string
  }

  export type UserGroupUpdateInput = {
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutUserGroupsNestedInput
    user?: UserUpdateOneRequiredWithoutUserGroupsNestedInput
  }

  export type UserGroupUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupCreateManyInput = {
    userId: string
    groupId: string
    roleInGroup?: string
    joinedAt?: Date | string
  }

  export type UserGroupUpdateManyMutationInput = {
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationCreateInput = {
    id?: string
    content: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPublicationInput
    likes?: LikeCreateNestedManyWithoutPublicationInput
    user: UserCreateNestedOneWithoutPublicationsInput
  }

  export type PublicationUncheckedCreateInput = {
    id?: string
    userId: string
    content: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPublicationInput
    likes?: LikeUncheckedCreateNestedManyWithoutPublicationInput
  }

  export type PublicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPublicationNestedInput
    likes?: LikeUpdateManyWithoutPublicationNestedInput
    user?: UserUpdateOneRequiredWithoutPublicationsNestedInput
  }

  export type PublicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPublicationNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationCreateManyInput = {
    id?: string
    userId: string
    content: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    activityId?: string | null
    text: string
    createdAt?: Date | string
    publication?: PublicationCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    userId: string
    publicationId?: string | null
    activityId?: string | null
    text: string
    createdAt?: Date | string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publication?: PublicationUpdateOneWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    publicationId?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: string
    userId: string
    publicationId?: string | null
    activityId?: string | null
    text: string
    createdAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    publicationId?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateInput = {
    id?: string
    createdAt?: Date | string
    publication: PublicationCreateNestedOneWithoutLikesInput
    user: UserCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateInput = {
    id?: string
    userId: string
    publicationId: string
    createdAt?: Date | string
  }

  export type LikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publication?: PublicationUpdateOneRequiredWithoutLikesNestedInput
    user?: UserUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    publicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateManyInput = {
    id?: string
    userId: string
    publicationId: string
    createdAt?: Date | string
  }

  export type LikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    publicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationTemplateCreateInput = {
    id?: string
    name: string
    content: string
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedInvitationTemplatesInput
  }

  export type InvitationTemplateUncheckedCreateInput = {
    id?: string
    name: string
    content: string
    creatorId: string
    createdAt?: Date | string
  }

  export type InvitationTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedInvitationTemplatesNestedInput
  }

  export type InvitationTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationTemplateCreateManyInput = {
    id?: string
    name: string
    content: string
    creatorId: string
    createdAt?: Date | string
  }

  export type InvitationTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GiftCardCreateInput = {
    id?: string
    invitedName: string
    invitedEmail: string
    token: string
    unitsAmount: number
    suggestions?: string | null
    status?: string
    createdAt?: Date | string
    inviter: UserCreateNestedOneWithoutInvitationsSentInput
    userInvitations?: UserInvitationCreateNestedManyWithoutGiftCardInput
  }

  export type GiftCardUncheckedCreateInput = {
    id?: string
    inviterId: string
    invitedName: string
    invitedEmail: string
    token: string
    unitsAmount: number
    suggestions?: string | null
    status?: string
    createdAt?: Date | string
    userInvitations?: UserInvitationUncheckedCreateNestedManyWithoutGiftCardInput
  }

  export type GiftCardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitedName?: StringFieldUpdateOperationsInput | string
    invitedEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    unitsAmount?: FloatFieldUpdateOperationsInput | number
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UserUpdateOneRequiredWithoutInvitationsSentNestedInput
    userInvitations?: UserInvitationUpdateManyWithoutGiftCardNestedInput
  }

  export type GiftCardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    invitedName?: StringFieldUpdateOperationsInput | string
    invitedEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    unitsAmount?: FloatFieldUpdateOperationsInput | number
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userInvitations?: UserInvitationUncheckedUpdateManyWithoutGiftCardNestedInput
  }

  export type GiftCardCreateManyInput = {
    id?: string
    inviterId: string
    invitedName: string
    invitedEmail: string
    token: string
    unitsAmount: number
    suggestions?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type GiftCardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitedName?: StringFieldUpdateOperationsInput | string
    invitedEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    unitsAmount?: FloatFieldUpdateOperationsInput | number
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GiftCardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    invitedName?: StringFieldUpdateOperationsInput | string
    invitedEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    unitsAmount?: FloatFieldUpdateOperationsInput | number
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationCreateInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    invitedUser?: UserCreateNestedOneWithoutInvitationsReceivedInput
    giftCard: GiftCardCreateNestedOneWithoutUserInvitationsInput
  }

  export type UserInvitationUncheckedCreateInput = {
    id?: string
    giftCardId: string
    invitedUserId?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type UserInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedUser?: UserUpdateOneWithoutInvitationsReceivedNestedInput
    giftCard?: GiftCardUpdateOneRequiredWithoutUserInvitationsNestedInput
  }

  export type UserInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    giftCardId?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationCreateManyInput = {
    id?: string
    giftCardId: string
    invitedUserId?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type UserInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    giftCardId?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    name: string
    type: string
    parameters?: string | null
    generatedAt?: Date | string
    data: string
    creator: UserCreateNestedOneWithoutCreatedReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    parameters?: string | null
    generatedAt?: Date | string
    data: string
    creatorId: string
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
    creator?: UserUpdateOneRequiredWithoutCreatedReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type ReportCreateManyInput = {
    id?: string
    name: string
    type: string
    parameters?: string | null
    generatedAt?: Date | string
    data: string
    creatorId: string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type ConfigurationCreateInput = {
    id?: string
    key: string
    value: string
    type: string
    updatedAt?: Date | string
  }

  export type ConfigurationUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    type: string
    updatedAt?: Date | string
  }

  export type ConfigurationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationCreateManyInput = {
    id?: string
    key: string
    value: string
    type: string
    updatedAt?: Date | string
  }

  export type ConfigurationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogCreateInput = {
    id?: string
    level: string
    message: string
    context?: string | null
    timestamp?: Date | string
    metadata?: string | null
  }

  export type LogUncheckedCreateInput = {
    id?: string
    level: string
    message: string
    context?: string | null
    timestamp?: Date | string
    metadata?: string | null
  }

  export type LogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogCreateManyInput = {
    id?: string
    level: string
    message: string
    context?: string | null
    timestamp?: Date | string
    metadata?: string | null
  }

  export type LogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    context?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnalyticsDataCreateInput = {
    id?: string
    userId?: string | null
    eventType: string
    videoItemId?: string | null
    playlistId?: string | null
    mundoId?: string | null
    sessionId?: string | null
    eventData?: string | null
    metadata?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type AnalyticsDataUncheckedCreateInput = {
    id?: string
    userId?: string | null
    eventType: string
    videoItemId?: string | null
    playlistId?: string | null
    mundoId?: string | null
    sessionId?: string | null
    eventData?: string | null
    metadata?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type AnalyticsDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    videoItemId?: NullableStringFieldUpdateOperationsInput | string | null
    playlistId?: NullableStringFieldUpdateOperationsInput | string | null
    mundoId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    eventData?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    videoItemId?: NullableStringFieldUpdateOperationsInput | string | null
    playlistId?: NullableStringFieldUpdateOperationsInput | string | null
    mundoId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    eventData?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsDataCreateManyInput = {
    id?: string
    userId?: string | null
    eventType: string
    videoItemId?: string | null
    playlistId?: string | null
    mundoId?: string | null
    sessionId?: string | null
    eventData?: string | null
    metadata?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type AnalyticsDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    videoItemId?: NullableStringFieldUpdateOperationsInput | string | null
    playlistId?: NullableStringFieldUpdateOperationsInput | string | null
    mundoId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    eventData?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    videoItemId?: NullableStringFieldUpdateOperationsInput | string | null
    playlistId?: NullableStringFieldUpdateOperationsInput | string | null
    mundoId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    eventData?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankingCreateInput = {
    id?: string
    name: string
    type: string
    period: string
    data: string
    createdAt?: Date | string
  }

  export type RankingUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    period: string
    data: string
    createdAt?: Date | string
  }

  export type RankingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankingCreateManyInput = {
    id?: string
    name: string
    type: string
    period: string
    data: string
    createdAt?: Date | string
  }

  export type RankingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalityCreateInput = {
    id?: string
    name: string
    description?: string | null
    traits: string
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutPersonalityInput
  }

  export type PersonalityUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    traits: string
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutPersonalityInput
  }

  export type PersonalityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutPersonalityNestedInput
  }

  export type PersonalityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutPersonalityNestedInput
  }

  export type PersonalityCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    traits: string
    createdAt?: Date | string
  }

  export type PersonalityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UIComponentTemplateCreateInput = {
    id?: string
    name: string
    type: string
    templateJson: string
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedTemplatesInput
  }

  export type UIComponentTemplateUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    templateJson: string
    creatorId: string
    createdAt?: Date | string
  }

  export type UIComponentTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    templateJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedTemplatesNestedInput
  }

  export type UIComponentTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    templateJson?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UIComponentTemplateCreateManyInput = {
    id?: string
    name: string
    type: string
    templateJson: string
    creatorId: string
    createdAt?: Date | string
  }

  export type UIComponentTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    templateJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UIComponentTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    templateJson?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemTypeCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contentItems?: ContentItemCreateNestedManyWithoutItemTypeInput
  }

  export type ItemTypeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contentItems?: ContentItemUncheckedCreateNestedManyWithoutItemTypeInput
  }

  export type ItemTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentItems?: ContentItemUpdateManyWithoutItemTypeNestedInput
  }

  export type ItemTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentItems?: ContentItemUncheckedUpdateManyWithoutItemTypeNestedInput
  }

  export type ItemTypeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentItemCreateInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemType: ItemTypeCreateNestedOneWithoutContentItemsInput
    playlist: PlaylistCreateNestedOneWithoutContentItemsInput
  }

  export type ContentItemUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    playlistId: string
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemType?: ItemTypeUpdateOneRequiredWithoutContentItemsNestedInput
    playlist?: PlaylistUpdateOneRequiredWithoutContentItemsNestedInput
  }

  export type ContentItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    playlistId?: StringFieldUpdateOperationsInput | string
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentItemCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    playlistId: string
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    playlistId?: StringFieldUpdateOperationsInput | string
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    config?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rewards?: ChallengeRewardCreateNestedManyWithoutChallengeInput
    userChallenges?: UserChallengeCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    config?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rewards?: ChallengeRewardUncheckedCreateNestedManyWithoutChallengeInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    config?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewards?: ChallengeRewardUpdateManyWithoutChallengeNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    config?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewards?: ChallengeRewardUncheckedUpdateManyWithoutChallengeNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    config?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    config?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    config?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeRewardCreateInput = {
    id?: string
    type: string
    amount?: number | null
    description?: string | null
    metadata?: string | null
    createdAt?: Date | string
    challenge: ChallengeCreateNestedOneWithoutRewardsInput
  }

  export type ChallengeRewardUncheckedCreateInput = {
    id?: string
    challengeId: string
    type: string
    amount?: number | null
    description?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type ChallengeRewardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge?: ChallengeUpdateOneRequiredWithoutRewardsNestedInput
  }

  export type ChallengeRewardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeRewardCreateManyInput = {
    id?: string
    challengeId: string
    type: string
    amount?: number | null
    description?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type ChallengeRewardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeRewardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserChallengeCreateInput = {
    id?: string
    status?: string
    progress?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: string | null
    challenge: ChallengeCreateNestedOneWithoutUserChallengesInput
    user: UserCreateNestedOneWithoutUserChallengesInput
  }

  export type UserChallengeUncheckedCreateInput = {
    id?: string
    userId: string
    challengeId: string
    status?: string
    progress?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: string | null
  }

  export type UserChallengeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    challenge?: ChallengeUpdateOneRequiredWithoutUserChallengesNestedInput
    user?: UserUpdateOneRequiredWithoutUserChallengesNestedInput
  }

  export type UserChallengeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserChallengeCreateManyInput = {
    id?: string
    userId: string
    challengeId: string
    status?: string
    progress?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: string | null
  }

  export type UserChallengeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserChallengeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarketplaceItemCreateInput = {
    id?: string
    name: string
    description?: string | null
    fullDescription?: string | null
    itemType?: $Enums.MarketplaceItemType
    price?: number
    priceToins?: number
    currency?: $Enums.Currency
    category?: string | null
    tags?: MarketplaceItemCreatetagsInput | string[]
    images?: MarketplaceItemCreateimagesInput | string[]
    stock?: number
    rating?: number
    reviewCount?: number
    location?: string | null
    status?: $Enums.MarketplaceItemStatus
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    viewCount?: number
    favoriteCount?: number
    metadata?: string | null
    seller: UserCreateNestedOneWithoutMarketplaceItemsInput
    reviews?: ReviewCreateNestedManyWithoutMarketplaceItemInput
    matches?: MarketplaceMatchCreateNestedManyWithoutItemInput
  }

  export type MarketplaceItemUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    fullDescription?: string | null
    itemType?: $Enums.MarketplaceItemType
    price?: number
    priceToins?: number
    currency?: $Enums.Currency
    category?: string | null
    tags?: MarketplaceItemCreatetagsInput | string[]
    images?: MarketplaceItemCreateimagesInput | string[]
    stock?: number
    rating?: number
    reviewCount?: number
    location?: string | null
    status?: $Enums.MarketplaceItemStatus
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    viewCount?: number
    favoriteCount?: number
    sellerId: string
    metadata?: string | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutMarketplaceItemInput
    matches?: MarketplaceMatchUncheckedCreateNestedManyWithoutItemInput
  }

  export type MarketplaceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumMarketplaceItemTypeFieldUpdateOperationsInput | $Enums.MarketplaceItemType
    price?: FloatFieldUpdateOperationsInput | number
    priceToins?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MarketplaceItemUpdatetagsInput | string[]
    images?: MarketplaceItemUpdateimagesInput | string[]
    stock?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMarketplaceItemStatusFieldUpdateOperationsInput | $Enums.MarketplaceItemStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    seller?: UserUpdateOneRequiredWithoutMarketplaceItemsNestedInput
    reviews?: ReviewUpdateManyWithoutMarketplaceItemNestedInput
    matches?: MarketplaceMatchUpdateManyWithoutItemNestedInput
  }

  export type MarketplaceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumMarketplaceItemTypeFieldUpdateOperationsInput | $Enums.MarketplaceItemType
    price?: FloatFieldUpdateOperationsInput | number
    priceToins?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MarketplaceItemUpdatetagsInput | string[]
    images?: MarketplaceItemUpdateimagesInput | string[]
    stock?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMarketplaceItemStatusFieldUpdateOperationsInput | $Enums.MarketplaceItemStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: ReviewUncheckedUpdateManyWithoutMarketplaceItemNestedInput
    matches?: MarketplaceMatchUncheckedUpdateManyWithoutItemNestedInput
  }

  export type MarketplaceItemCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    fullDescription?: string | null
    itemType?: $Enums.MarketplaceItemType
    price?: number
    priceToins?: number
    currency?: $Enums.Currency
    category?: string | null
    tags?: MarketplaceItemCreatetagsInput | string[]
    images?: MarketplaceItemCreateimagesInput | string[]
    stock?: number
    rating?: number
    reviewCount?: number
    location?: string | null
    status?: $Enums.MarketplaceItemStatus
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    viewCount?: number
    favoriteCount?: number
    sellerId: string
    metadata?: string | null
  }

  export type MarketplaceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumMarketplaceItemTypeFieldUpdateOperationsInput | $Enums.MarketplaceItemType
    price?: FloatFieldUpdateOperationsInput | number
    priceToins?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MarketplaceItemUpdatetagsInput | string[]
    images?: MarketplaceItemUpdateimagesInput | string[]
    stock?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMarketplaceItemStatusFieldUpdateOperationsInput | $Enums.MarketplaceItemStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarketplaceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumMarketplaceItemTypeFieldUpdateOperationsInput | $Enums.MarketplaceItemType
    price?: FloatFieldUpdateOperationsInput | number
    priceToins?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MarketplaceItemUpdatetagsInput | string[]
    images?: MarketplaceItemUpdateimagesInput | string[]
    stock?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMarketplaceItemStatusFieldUpdateOperationsInput | $Enums.MarketplaceItemStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudyRoomCreateInput = {
    id?: string
    name: string
    description?: string | null
    maxParticipants?: number
    status?: $Enums.StudyRoomStatus
    currentTime?: number
    isPaused?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    video: VideoItemCreateNestedOneWithoutStudyRoomsInput
    host: UserCreateNestedOneWithoutHostedStudyRoomsInput
    participants?: StudyRoomParticipantCreateNestedManyWithoutStudyRoomInput
    messages?: StudyRoomMessageCreateNestedManyWithoutStudyRoomInput
  }

  export type StudyRoomUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    videoId: number
    hostId: string
    maxParticipants?: number
    status?: $Enums.StudyRoomStatus
    currentTime?: number
    isPaused?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutStudyRoomInput
    messages?: StudyRoomMessageUncheckedCreateNestedManyWithoutStudyRoomInput
  }

  export type StudyRoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    status?: EnumStudyRoomStatusFieldUpdateOperationsInput | $Enums.StudyRoomStatus
    currentTime?: FloatFieldUpdateOperationsInput | number
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoItemUpdateOneRequiredWithoutStudyRoomsNestedInput
    host?: UserUpdateOneRequiredWithoutHostedStudyRoomsNestedInput
    participants?: StudyRoomParticipantUpdateManyWithoutStudyRoomNestedInput
    messages?: StudyRoomMessageUpdateManyWithoutStudyRoomNestedInput
  }

  export type StudyRoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoId?: IntFieldUpdateOperationsInput | number
    hostId?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    status?: EnumStudyRoomStatusFieldUpdateOperationsInput | $Enums.StudyRoomStatus
    currentTime?: FloatFieldUpdateOperationsInput | number
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: StudyRoomParticipantUncheckedUpdateManyWithoutStudyRoomNestedInput
    messages?: StudyRoomMessageUncheckedUpdateManyWithoutStudyRoomNestedInput
  }

  export type StudyRoomCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    videoId: number
    hostId: string
    maxParticipants?: number
    status?: $Enums.StudyRoomStatus
    currentTime?: number
    isPaused?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudyRoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    status?: EnumStudyRoomStatusFieldUpdateOperationsInput | $Enums.StudyRoomStatus
    currentTime?: FloatFieldUpdateOperationsInput | number
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyRoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoId?: IntFieldUpdateOperationsInput | number
    hostId?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    status?: EnumStudyRoomStatusFieldUpdateOperationsInput | $Enums.StudyRoomStatus
    currentTime?: FloatFieldUpdateOperationsInput | number
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyRoomParticipantCreateInput = {
    id?: string
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isActive?: boolean
    studyRoom: StudyRoomCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutStudyRoomParticipantsInput
  }

  export type StudyRoomParticipantUncheckedCreateInput = {
    id?: string
    studyRoomId: string
    userId: string
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isActive?: boolean
  }

  export type StudyRoomParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    studyRoom?: StudyRoomUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutStudyRoomParticipantsNestedInput
  }

  export type StudyRoomParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyRoomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudyRoomParticipantCreateManyInput = {
    id?: string
    studyRoomId: string
    userId: string
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isActive?: boolean
  }

  export type StudyRoomParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudyRoomParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyRoomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudyRoomMessageCreateInput = {
    id?: string
    message: string
    messageType?: string
    metadata?: string | null
    createdAt?: Date | string
    studyRoom: StudyRoomCreateNestedOneWithoutMessagesInput
    user: UserCreateNestedOneWithoutSentChatMessagesInput
  }

  export type StudyRoomMessageUncheckedCreateInput = {
    id?: string
    studyRoomId: string
    userId: string
    message: string
    messageType?: string
    metadata?: string | null
    createdAt?: Date | string
  }

  export type StudyRoomMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyRoom?: StudyRoomUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutSentChatMessagesNestedInput
  }

  export type StudyRoomMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyRoomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyRoomMessageCreateManyInput = {
    id?: string
    studyRoomId: string
    userId: string
    message: string
    messageType?: string
    metadata?: string | null
    createdAt?: Date | string
  }

  export type StudyRoomMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyRoomMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyRoomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackReportCreateInput = {
    id?: string
    type: $Enums.FeedbackType
    title: string
    description: string
    priority?: $Enums.FeedbackPriority
    category: string
    status?: $Enums.FeedbackStatus
    elementContext: JsonNullValueInput | InputJsonValue
    technicalContext: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: string | null
    resolvedAt?: Date | string | null
    upvotes?: number
    downvotes?: number
    duplicateOf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFeedbackReportsInput
    adminUser?: UserCreateNestedOneWithoutAdminFeedbackResponsesInput
  }

  export type FeedbackReportUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.FeedbackType
    title: string
    description: string
    priority?: $Enums.FeedbackPriority
    category: string
    status?: $Enums.FeedbackStatus
    elementContext: JsonNullValueInput | InputJsonValue
    technicalContext: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: string | null
    adminUserId?: string | null
    resolvedAt?: Date | string | null
    upvotes?: number
    downvotes?: number
    duplicateOf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    elementContext?: JsonNullValueInput | InputJsonValue
    technicalContext?: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    duplicateOf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedbackReportsNestedInput
    adminUser?: UserUpdateOneWithoutAdminFeedbackResponsesNestedInput
  }

  export type FeedbackReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    elementContext?: JsonNullValueInput | InputJsonValue
    technicalContext?: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    duplicateOf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackReportCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.FeedbackType
    title: string
    description: string
    priority?: $Enums.FeedbackPriority
    category: string
    status?: $Enums.FeedbackStatus
    elementContext: JsonNullValueInput | InputJsonValue
    technicalContext: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: string | null
    adminUserId?: string | null
    resolvedAt?: Date | string | null
    upvotes?: number
    downvotes?: number
    duplicateOf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    elementContext?: JsonNullValueInput | InputJsonValue
    technicalContext?: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    duplicateOf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    elementContext?: JsonNullValueInput | InputJsonValue
    technicalContext?: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    duplicateOf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    skills?: ProfileCreateskillsInput | string[]
    interests?: ProfileCreateinterestsInput | string[]
    isEmprendedorConfiable?: boolean
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    skills?: ProfileCreateskillsInput | string[]
    interests?: ProfileCreateinterestsInput | string[]
    isEmprendedorConfiable?: boolean
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: ProfileUpdateskillsInput | string[]
    interests?: ProfileUpdateinterestsInput | string[]
    isEmprendedorConfiable?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: ProfileUpdateskillsInput | string[]
    interests?: ProfileUpdateinterestsInput | string[]
    isEmprendedorConfiable?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    skills?: ProfileCreateskillsInput | string[]
    interests?: ProfileCreateinterestsInput | string[]
    isEmprendedorConfiable?: boolean
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: ProfileUpdateskillsInput | string[]
    interests?: ProfileUpdateinterestsInput | string[]
    isEmprendedorConfiable?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: ProfileUpdateskillsInput | string[]
    interests?: ProfileUpdateinterestsInput | string[]
    isEmprendedorConfiable?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    communication?: number | null
    quality?: number | null
    delivery?: number | null
    value?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    marketplaceItem: MarketplaceItemCreateNestedOneWithoutReviewsInput
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    marketplaceItemId: string
    userId: string
    rating: number
    comment?: string | null
    communication?: number | null
    quality?: number | null
    delivery?: number | null
    value?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    delivery?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplaceItem?: MarketplaceItemUpdateOneRequiredWithoutReviewsNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketplaceItemId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    delivery?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    marketplaceItemId: string
    userId: string
    rating: number
    comment?: string | null
    communication?: number | null
    quality?: number | null
    delivery?: number | null
    value?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    delivery?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketplaceItemId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    delivery?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceMatchCreateInput = {
    id?: string
    buyerConfirmed?: boolean
    sellerConfirmed?: boolean
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    item: MarketplaceItemCreateNestedOneWithoutMatchesInput
    buyer: UserCreateNestedOneWithoutBuyerMatchesInput
    seller: UserCreateNestedOneWithoutSellerMatchesInput
    messages?: MatchMessageCreateNestedManyWithoutMatchInput
  }

  export type MarketplaceMatchUncheckedCreateInput = {
    id?: string
    itemId: string
    buyerId: string
    sellerId: string
    buyerConfirmed?: boolean
    sellerConfirmed?: boolean
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MatchMessageUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MarketplaceMatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    sellerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: MarketplaceItemUpdateOneRequiredWithoutMatchesNestedInput
    buyer?: UserUpdateOneRequiredWithoutBuyerMatchesNestedInput
    seller?: UserUpdateOneRequiredWithoutSellerMatchesNestedInput
    messages?: MatchMessageUpdateManyWithoutMatchNestedInput
  }

  export type MarketplaceMatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    sellerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MatchMessageUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MarketplaceMatchCreateManyInput = {
    id?: string
    itemId: string
    buyerId: string
    sellerId: string
    buyerConfirmed?: boolean
    sellerConfirmed?: boolean
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceMatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    sellerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceMatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    sellerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchMessageCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    match: MarketplaceMatchCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMatchMessagesInput
  }

  export type MatchMessageUncheckedCreateInput = {
    id?: string
    matchId: string
    senderId: string
    content: string
    createdAt?: Date | string
  }

  export type MatchMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MarketplaceMatchUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMatchMessagesNestedInput
  }

  export type MatchMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchMessageCreateManyInput = {
    id?: string
    matchId: string
    senderId: string
    content: string
    createdAt?: Date | string
  }

  export type MatchMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PlaylistListRelationFilter = {
    every?: PlaylistWhereInput
    some?: PlaylistWhereInput
    none?: PlaylistWhereInput
  }

  export type WorldListRelationFilter = {
    every?: WorldWhereInput
    some?: WorldWhereInput
    none?: WorldWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PlaylistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MundoCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    version?: SortOrder
  }

  export type MundoAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type MundoMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    version?: SortOrder
  }

  export type MundoMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    version?: SortOrder
  }

  export type MundoSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ContentItemListRelationFilter = {
    every?: ContentItemWhereInput
    some?: ContentItemWhereInput
    none?: ContentItemWhereInput
  }

  export type GamifiedPlaylistListRelationFilter = {
    every?: GamifiedPlaylistWhereInput
    some?: GamifiedPlaylistWhereInput
    none?: GamifiedPlaylistWhereInput
  }

  export type MundoRelationFilter = {
    is?: MundoWhereInput
    isNot?: MundoWhereInput
  }

  export type VideoItemListRelationFilter = {
    every?: VideoItemWhereInput
    some?: VideoItemWhereInput
    none?: VideoItemWhereInput
  }

  export type ContentItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GamifiedPlaylistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaylistCountOrderByAggregateInput = {
    id?: SortOrder
    mundoId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    orderInMundo?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    version?: SortOrder
  }

  export type PlaylistAvgOrderByAggregateInput = {
    orderInMundo?: SortOrder
    version?: SortOrder
  }

  export type PlaylistMaxOrderByAggregateInput = {
    id?: SortOrder
    mundoId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    orderInMundo?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    version?: SortOrder
  }

  export type PlaylistMinOrderByAggregateInput = {
    id?: SortOrder
    mundoId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    orderInMundo?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    version?: SortOrder
  }

  export type PlaylistSumOrderByAggregateInput = {
    orderInMundo?: SortOrder
    version?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput
    some?: QuestionWhereInput
    none?: QuestionWhereInput
  }

  export type SubtitleListRelationFilter = {
    every?: SubtitleWhereInput
    some?: SubtitleWhereInput
    none?: SubtitleWhereInput
  }

  export type StudyRoomListRelationFilter = {
    every?: StudyRoomWhereInput
    some?: StudyRoomWhereInput
    none?: StudyRoomWhereInput
  }

  export type PlaylistRelationFilter = {
    is?: PlaylistWhereInput
    isNot?: PlaylistWhereInput
  }

  export type VideoPermissionsNullableRelationFilter = {
    is?: VideoPermissionsWhereInput | null
    isNot?: VideoPermissionsWhereInput | null
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubtitleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudyRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoItemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    url?: SortOrder
    platform?: SortOrder
    externalId?: SortOrder
    playlistId?: SortOrder
    itemTypeId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    duration?: SortOrder
    categories?: SortOrder
    language?: SortOrder
    quality?: SortOrder
    tags?: SortOrder
    thumbnailUrl?: SortOrder
  }

  export type VideoItemAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    duration?: SortOrder
  }

  export type VideoItemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    url?: SortOrder
    platform?: SortOrder
    externalId?: SortOrder
    playlistId?: SortOrder
    itemTypeId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    duration?: SortOrder
    categories?: SortOrder
    language?: SortOrder
    quality?: SortOrder
    tags?: SortOrder
    thumbnailUrl?: SortOrder
  }

  export type VideoItemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    url?: SortOrder
    platform?: SortOrder
    externalId?: SortOrder
    playlistId?: SortOrder
    itemTypeId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    duration?: SortOrder
    categories?: SortOrder
    language?: SortOrder
    quality?: SortOrder
    tags?: SortOrder
    thumbnailUrl?: SortOrder
  }

  export type VideoItemSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    duration?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VideoItemRelationFilter = {
    is?: VideoItemWhereInput
    isNot?: VideoItemWhereInput
  }

  export type SubtitleCountOrderByAggregateInput = {
    id?: SortOrder
    videoItemId?: SortOrder
    languageCode?: SortOrder
    format?: SortOrder
    content?: SortOrder
    contentUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubtitleAvgOrderByAggregateInput = {
    id?: SortOrder
    videoItemId?: SortOrder
  }

  export type SubtitleMaxOrderByAggregateInput = {
    id?: SortOrder
    videoItemId?: SortOrder
    languageCode?: SortOrder
    format?: SortOrder
    content?: SortOrder
    contentUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubtitleMinOrderByAggregateInput = {
    id?: SortOrder
    videoItemId?: SortOrder
    languageCode?: SortOrder
    format?: SortOrder
    content?: SortOrder
    contentUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubtitleSumOrderByAggregateInput = {
    id?: SortOrder
    videoItemId?: SortOrder
  }

  export type AnswerOptionListRelationFilter = {
    every?: AnswerOptionWhereInput
    some?: AnswerOptionWhereInput
    none?: AnswerOptionWhereInput
  }

  export type UserAnswerListRelationFilter = {
    every?: UserAnswerWhereInput
    some?: UserAnswerWhereInput
    none?: UserAnswerWhereInput
  }

  export type AnswerOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    videoItemId?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    text?: SortOrder
    languageCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    endTimestamp?: SortOrder
  }

  export type QuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    videoItemId?: SortOrder
    timestamp?: SortOrder
    endTimestamp?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    videoItemId?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    text?: SortOrder
    languageCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    endTimestamp?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    videoItemId?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    text?: SortOrder
    languageCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    endTimestamp?: SortOrder
  }

  export type QuestionSumOrderByAggregateInput = {
    id?: SortOrder
    videoItemId?: SortOrder
    timestamp?: SortOrder
    endTimestamp?: SortOrder
  }

  export type QuestionRelationFilter = {
    is?: QuestionWhereInput
    isNot?: QuestionWhereInput
  }

  export type AnswerOptionCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnswerOptionAvgOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    order?: SortOrder
  }

  export type AnswerOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnswerOptionMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnswerOptionSumOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    order?: SortOrder
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type LikeListRelationFilter = {
    every?: LikeWhereInput
    some?: LikeWhereInput
    none?: LikeWhereInput
  }

  export type ExperienceListRelationFilter = {
    every?: ExperienceWhereInput
    some?: ExperienceWhereInput
    none?: ExperienceWhereInput
  }

  export type GiftCardListRelationFilter = {
    every?: GiftCardWhereInput
    some?: GiftCardWhereInput
    none?: GiftCardWhereInput
  }

  export type GroupListRelationFilter = {
    every?: GroupWhereInput
    some?: GroupWhereInput
    none?: GroupWhereInput
  }

  export type InvitationTemplateListRelationFilter = {
    every?: InvitationTemplateWhereInput
    some?: InvitationTemplateWhereInput
    none?: InvitationTemplateWhereInput
  }

  export type MeritListRelationFilter = {
    every?: MeritWhereInput
    some?: MeritWhereInput
    none?: MeritWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type PublicationListRelationFilter = {
    every?: PublicationWhereInput
    some?: PublicationWhereInput
    none?: PublicationWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type TokenListRelationFilter = {
    every?: TokenWhereInput
    some?: TokenWhereInput
    none?: TokenWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type UIComponentTemplateListRelationFilter = {
    every?: UIComponentTemplateWhereInput
    some?: UIComponentTemplateWhereInput
    none?: UIComponentTemplateWhereInput
  }

  export type UserChallengeListRelationFilter = {
    every?: UserChallengeWhereInput
    some?: UserChallengeWhereInput
    none?: UserChallengeWhereInput
  }

  export type UserGroupListRelationFilter = {
    every?: UserGroupWhereInput
    some?: UserGroupWhereInput
    none?: UserGroupWhereInput
  }

  export type UserInvitationListRelationFilter = {
    every?: UserInvitationWhereInput
    some?: UserInvitationWhereInput
    none?: UserInvitationWhereInput
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type StudyRoomParticipantListRelationFilter = {
    every?: StudyRoomParticipantWhereInput
    some?: StudyRoomParticipantWhereInput
    none?: StudyRoomParticipantWhereInput
  }

  export type StudyRoomMessageListRelationFilter = {
    every?: StudyRoomMessageWhereInput
    some?: StudyRoomMessageWhereInput
    none?: StudyRoomMessageWhereInput
  }

  export type PersonalityNullableRelationFilter = {
    is?: PersonalityWhereInput | null
    isNot?: PersonalityWhereInput | null
  }

  export type VideoPermissionsListRelationFilter = {
    every?: VideoPermissionsWhereInput
    some?: VideoPermissionsWhereInput
    none?: VideoPermissionsWhereInput
  }

  export type WalletNullableRelationFilter = {
    is?: WalletWhereInput | null
    isNot?: WalletWhereInput | null
  }

  export type MarketplaceItemListRelationFilter = {
    every?: MarketplaceItemWhereInput
    some?: MarketplaceItemWhereInput
    none?: MarketplaceItemWhereInput
  }

  export type MarketplaceMatchListRelationFilter = {
    every?: MarketplaceMatchWhereInput
    some?: MarketplaceMatchWhereInput
    none?: MarketplaceMatchWhereInput
  }

  export type MatchMessageListRelationFilter = {
    every?: MatchMessageWhereInput
    some?: MatchMessageWhereInput
    none?: MatchMessageWhereInput
  }

  export type FeedbackReportListRelationFilter = {
    every?: FeedbackReportWhereInput
    some?: FeedbackReportWhereInput
    none?: FeedbackReportWhereInput
  }

  export type ProfileNullableRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExperienceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GiftCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvitationTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeritOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PublicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UIComponentTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserChallengeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudyRoomParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudyRoomMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoPermissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketplaceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketplaceMatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    address?: SortOrder
    status?: SortOrder
    topUserCount?: SortOrder
    personalityId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    topUserCount?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    address?: SortOrder
    status?: SortOrder
    topUserCount?: SortOrder
    personalityId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    documentType?: SortOrder
    documentNumber?: SortOrder
    phone?: SortOrder
    country?: SortOrder
    address?: SortOrder
    status?: SortOrder
    topUserCount?: SortOrder
    personalityId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    topUserCount?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: string
  }

  export type UserRoleCountOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedById?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedById?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedById?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoPermissionsCountOrderByAggregateInput = {
    id?: SortOrder
    videoItemId?: SortOrder
    showWaveCount?: SortOrder
    showVideos?: SortOrder
    showVideoSubtitles?: SortOrder
    showComments?: SortOrder
    showPublishDate?: SortOrder
    showVideoDuration?: SortOrder
    showLikeButton?: SortOrder
    allowRewindForward?: SortOrder
    allowViewComments?: SortOrder
    allowMakeComments?: SortOrder
    showLikeComments?: SortOrder
    sortCommentsByAffinity?: SortOrder
    showCommenterName?: SortOrder
    playlistPosition?: SortOrder
    isDraft?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type VideoPermissionsAvgOrderByAggregateInput = {
    videoItemId?: SortOrder
  }

  export type VideoPermissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    videoItemId?: SortOrder
    showWaveCount?: SortOrder
    showVideos?: SortOrder
    showVideoSubtitles?: SortOrder
    showComments?: SortOrder
    showPublishDate?: SortOrder
    showVideoDuration?: SortOrder
    showLikeButton?: SortOrder
    allowRewindForward?: SortOrder
    allowViewComments?: SortOrder
    allowMakeComments?: SortOrder
    showLikeComments?: SortOrder
    sortCommentsByAffinity?: SortOrder
    showCommenterName?: SortOrder
    playlistPosition?: SortOrder
    isDraft?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type VideoPermissionsMinOrderByAggregateInput = {
    id?: SortOrder
    videoItemId?: SortOrder
    showWaveCount?: SortOrder
    showVideos?: SortOrder
    showVideoSubtitles?: SortOrder
    showComments?: SortOrder
    showPublishDate?: SortOrder
    showVideoDuration?: SortOrder
    showLikeButton?: SortOrder
    allowRewindForward?: SortOrder
    allowViewComments?: SortOrder
    allowMakeComments?: SortOrder
    showLikeComments?: SortOrder
    sortCommentsByAffinity?: SortOrder
    showCommenterName?: SortOrder
    playlistPosition?: SortOrder
    isDraft?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type VideoPermissionsSumOrderByAggregateInput = {
    videoItemId?: SortOrder
  }

  export type PermissionRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: string
    permissionId: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    assignedAt?: SortOrder
    assignedById?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    assignedAt?: SortOrder
    assignedById?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    assignedAt?: SortOrder
    assignedById?: SortOrder
  }

  export type StageListRelationFilter = {
    every?: StageWhereInput
    some?: StageWhereInput
    none?: StageWhereInput
  }

  export type MundoNullableRelationFilter = {
    is?: MundoWhereInput | null
    isNot?: MundoWhereInput | null
  }

  export type StageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorldCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    creatorId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mundoId?: SortOrder
  }

  export type WorldMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    creatorId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mundoId?: SortOrder
  }

  export type WorldMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    creatorId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mundoId?: SortOrder
  }

  export type WorldRelationFilter = {
    is?: WorldWhereInput
    isNot?: WorldWhereInput
  }

  export type StageCountOrderByAggregateInput = {
    id?: SortOrder
    worldId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type StageMaxOrderByAggregateInput = {
    id?: SortOrder
    worldId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageMinOrderByAggregateInput = {
    id?: SortOrder
    worldId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type StageRelationFilter = {
    is?: StageWhereInput
    isNot?: StageWhereInput
  }

  export type ExperienceCountOrderByAggregateInput = {
    id?: SortOrder
    stageId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    gamificationFramework?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExperienceMaxOrderByAggregateInput = {
    id?: SortOrder
    stageId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    gamificationFramework?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExperienceMinOrderByAggregateInput = {
    id?: SortOrder
    stageId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    gamificationFramework?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoItemNullableRelationFilter = {
    is?: VideoItemWhereInput | null
    isNot?: VideoItemWhereInput | null
  }

  export type ExperienceRelationFilter = {
    is?: ExperienceWhereInput
    isNot?: ExperienceWhereInput
  }

  export type ActivityQuestionListRelationFilter = {
    every?: ActivityQuestionWhereInput
    some?: ActivityQuestionWhereInput
    none?: ActivityQuestionWhereInput
  }

  export type ActivityQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    experienceId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    multimediaType?: SortOrder
    contentUrl?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    videoItemId?: SortOrder
  }

  export type ActivityAvgOrderByAggregateInput = {
    duration?: SortOrder
    order?: SortOrder
    videoItemId?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    experienceId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    multimediaType?: SortOrder
    contentUrl?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    videoItemId?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    experienceId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    multimediaType?: SortOrder
    contentUrl?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    status?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    videoItemId?: SortOrder
  }

  export type ActivitySumOrderByAggregateInput = {
    duration?: SortOrder
    order?: SortOrder
    videoItemId?: SortOrder
  }

  export type PlaylistNullableRelationFilter = {
    is?: PlaylistWhereInput | null
    isNot?: PlaylistWhereInput | null
  }

  export type ActivityNullableRelationFilter = {
    is?: ActivityWhereInput | null
    isNot?: ActivityWhereInput | null
  }

  export type GamifiedPlaylistCountOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    playlistId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sequenceType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GamifiedPlaylistMaxOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    playlistId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sequenceType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GamifiedPlaylistMinOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    playlistId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sequenceType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityRelationFilter = {
    is?: ActivityWhereInput
    isNot?: ActivityWhereInput
  }

  export type ActivityQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    type?: SortOrder
    questionType?: SortOrder
    questionText?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    ondasList?: SortOrder
    displayTimeSeconds?: SortOrder
    optionalDisplaySeconds?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityQuestionAvgOrderByAggregateInput = {
    displayTimeSeconds?: SortOrder
    optionalDisplaySeconds?: SortOrder
  }

  export type ActivityQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    type?: SortOrder
    questionType?: SortOrder
    questionText?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    ondasList?: SortOrder
    displayTimeSeconds?: SortOrder
    optionalDisplaySeconds?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    type?: SortOrder
    questionType?: SortOrder
    questionText?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    ondasList?: SortOrder
    displayTimeSeconds?: SortOrder
    optionalDisplaySeconds?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityQuestionSumOrderByAggregateInput = {
    displayTimeSeconds?: SortOrder
    optionalDisplaySeconds?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ActivityQuestionNullableRelationFilter = {
    is?: ActivityQuestionWhereInput | null
    isNot?: ActivityQuestionWhereInput | null
  }

  export type QuestionNullableRelationFilter = {
    is?: QuestionWhereInput | null
    isNot?: QuestionWhereInput | null
  }

  export type UserAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    activityQuestionId?: SortOrder
    answerGiven?: SortOrder
    isCorrect?: SortOrder
    ondasEarned?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAnswerAvgOrderByAggregateInput = {
    questionId?: SortOrder
    ondasEarned?: SortOrder
  }

  export type UserAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    activityQuestionId?: SortOrder
    answerGiven?: SortOrder
    isCorrect?: SortOrder
    ondasEarned?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questionId?: SortOrder
    activityQuestionId?: SortOrder
    answerGiven?: SortOrder
    isCorrect?: SortOrder
    ondasEarned?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAnswerSumOrderByAggregateInput = {
    questionId?: SortOrder
    ondasEarned?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type TokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    caducityDate?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    caducityDate?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    caducityDate?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type MeritCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    source?: SortOrder
    relatedEntityId?: SortOrder
    createdAt?: SortOrder
  }

  export type MeritAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type MeritMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    source?: SortOrder
    relatedEntityId?: SortOrder
    createdAt?: SortOrder
  }

  export type MeritMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    source?: SortOrder
    relatedEntityId?: SortOrder
    createdAt?: SortOrder
  }

  export type MeritSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    blockchainAddress?: SortOrder
    balanceUnits?: SortOrder
    balanceToins?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletAvgOrderByAggregateInput = {
    balanceUnits?: SortOrder
    balanceToins?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    blockchainAddress?: SortOrder
    balanceUnits?: SortOrder
    balanceToins?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    blockchainAddress?: SortOrder
    balanceUnits?: SortOrder
    balanceToins?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletSumOrderByAggregateInput = {
    balanceUnits?: SortOrder
    balanceToins?: SortOrder
  }

  export type WalletRelationFilter = {
    is?: WalletWhereInput
    isNot?: WalletWhereInput
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    amount?: SortOrder
    tokenType?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    amount?: SortOrder
    tokenType?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    amount?: SortOrder
    tokenType?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type UserGroupUserIdGroupIdCompoundUniqueInput = {
    userId: string
    groupId: string
  }

  export type UserGroupCountOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
    roleInGroup?: SortOrder
    joinedAt?: SortOrder
  }

  export type UserGroupMaxOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
    roleInGroup?: SortOrder
    joinedAt?: SortOrder
  }

  export type UserGroupMinOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
    roleInGroup?: SortOrder
    joinedAt?: SortOrder
  }

  export type PublicationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PublicationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PublicationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PublicationNullableRelationFilter = {
    is?: PublicationWhereInput | null
    isNot?: PublicationWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    activityId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    activityId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    activityId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type PublicationRelationFilter = {
    is?: PublicationWhereInput
    isNot?: PublicationWhereInput
  }

  export type LikeUserIdPublicationIdCompoundUniqueInput = {
    userId: string
    publicationId: string
  }

  export type LikeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    publicationId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
  }

  export type GiftCardCountOrderByAggregateInput = {
    id?: SortOrder
    inviterId?: SortOrder
    invitedName?: SortOrder
    invitedEmail?: SortOrder
    token?: SortOrder
    unitsAmount?: SortOrder
    suggestions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type GiftCardAvgOrderByAggregateInput = {
    unitsAmount?: SortOrder
  }

  export type GiftCardMaxOrderByAggregateInput = {
    id?: SortOrder
    inviterId?: SortOrder
    invitedName?: SortOrder
    invitedEmail?: SortOrder
    token?: SortOrder
    unitsAmount?: SortOrder
    suggestions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type GiftCardMinOrderByAggregateInput = {
    id?: SortOrder
    inviterId?: SortOrder
    invitedName?: SortOrder
    invitedEmail?: SortOrder
    token?: SortOrder
    unitsAmount?: SortOrder
    suggestions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type GiftCardSumOrderByAggregateInput = {
    unitsAmount?: SortOrder
  }

  export type GiftCardRelationFilter = {
    is?: GiftCardWhereInput
    isNot?: GiftCardWhereInput
  }

  export type UserInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    giftCardId?: SortOrder
    invitedUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type UserInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    giftCardId?: SortOrder
    invitedUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type UserInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    giftCardId?: SortOrder
    invitedUserId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parameters?: SortOrder
    generatedAt?: SortOrder
    data?: SortOrder
    creatorId?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parameters?: SortOrder
    generatedAt?: SortOrder
    data?: SortOrder
    creatorId?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parameters?: SortOrder
    generatedAt?: SortOrder
    data?: SortOrder
    creatorId?: SortOrder
  }

  export type ConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    message?: SortOrder
    context?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    message?: SortOrder
    context?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    message?: SortOrder
    context?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
  }

  export type AnalyticsDataCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    videoItemId?: SortOrder
    playlistId?: SortOrder
    mundoId?: SortOrder
    sessionId?: SortOrder
    eventData?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsDataMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    videoItemId?: SortOrder
    playlistId?: SortOrder
    mundoId?: SortOrder
    sessionId?: SortOrder
    eventData?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsDataMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    videoItemId?: SortOrder
    playlistId?: SortOrder
    mundoId?: SortOrder
    sessionId?: SortOrder
    eventData?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type RankingCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    period?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type RankingMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    period?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type RankingMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    period?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonalityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    traits?: SortOrder
    createdAt?: SortOrder
  }

  export type PersonalityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    traits?: SortOrder
    createdAt?: SortOrder
  }

  export type PersonalityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    traits?: SortOrder
    createdAt?: SortOrder
  }

  export type UIComponentTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    templateJson?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
  }

  export type UIComponentTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    templateJson?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
  }

  export type UIComponentTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    templateJson?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
  }

  export type ItemTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemTypeRelationFilter = {
    is?: ItemTypeWhereInput
    isNot?: ItemTypeWhereInput
  }

  export type ContentItemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    playlistId?: SortOrder
    itemTypeId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentItemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ContentItemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    playlistId?: SortOrder
    itemTypeId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentItemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    playlistId?: SortOrder
    itemTypeId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentItemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ChallengeRewardListRelationFilter = {
    every?: ChallengeRewardWhereInput
    some?: ChallengeRewardWhereInput
    none?: ChallengeRewardWhereInput
  }

  export type ChallengeRewardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ChallengeRelationFilter = {
    is?: ChallengeWhereInput
    isNot?: ChallengeWhereInput
  }

  export type ChallengeRewardCountOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ChallengeRewardAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ChallengeRewardMaxOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ChallengeRewardMinOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ChallengeRewardSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UserChallengeUserIdChallengeIdCompoundUniqueInput = {
    userId: string
    challengeId: string
  }

  export type UserChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    metadata?: SortOrder
  }

  export type UserChallengeAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type UserChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    metadata?: SortOrder
  }

  export type UserChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    metadata?: SortOrder
  }

  export type UserChallengeSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumMarketplaceItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketplaceItemType | EnumMarketplaceItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MarketplaceItemType[] | ListEnumMarketplaceItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketplaceItemType[] | ListEnumMarketplaceItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketplaceItemTypeFilter<$PrismaModel> | $Enums.MarketplaceItemType
  }

  export type EnumCurrencyFilter<$PrismaModel = never> = {
    equals?: $Enums.Currency | EnumCurrencyFieldRefInput<$PrismaModel>
    in?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyFilter<$PrismaModel> | $Enums.Currency
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumMarketplaceItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketplaceItemStatus | EnumMarketplaceItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MarketplaceItemStatus[] | ListEnumMarketplaceItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketplaceItemStatus[] | ListEnumMarketplaceItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketplaceItemStatusFilter<$PrismaModel> | $Enums.MarketplaceItemStatus
  }

  export type MarketplaceItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    itemType?: SortOrder
    price?: SortOrder
    priceToins?: SortOrder
    currency?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    images?: SortOrder
    stock?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    location?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    viewCount?: SortOrder
    favoriteCount?: SortOrder
    sellerId?: SortOrder
    metadata?: SortOrder
  }

  export type MarketplaceItemAvgOrderByAggregateInput = {
    price?: SortOrder
    priceToins?: SortOrder
    stock?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    viewCount?: SortOrder
    favoriteCount?: SortOrder
  }

  export type MarketplaceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    itemType?: SortOrder
    price?: SortOrder
    priceToins?: SortOrder
    currency?: SortOrder
    category?: SortOrder
    stock?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    location?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    viewCount?: SortOrder
    favoriteCount?: SortOrder
    sellerId?: SortOrder
    metadata?: SortOrder
  }

  export type MarketplaceItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    fullDescription?: SortOrder
    itemType?: SortOrder
    price?: SortOrder
    priceToins?: SortOrder
    currency?: SortOrder
    category?: SortOrder
    stock?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    location?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    viewCount?: SortOrder
    favoriteCount?: SortOrder
    sellerId?: SortOrder
    metadata?: SortOrder
  }

  export type MarketplaceItemSumOrderByAggregateInput = {
    price?: SortOrder
    priceToins?: SortOrder
    stock?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    viewCount?: SortOrder
    favoriteCount?: SortOrder
  }

  export type EnumMarketplaceItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketplaceItemType | EnumMarketplaceItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MarketplaceItemType[] | ListEnumMarketplaceItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketplaceItemType[] | ListEnumMarketplaceItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketplaceItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.MarketplaceItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMarketplaceItemTypeFilter<$PrismaModel>
    _max?: NestedEnumMarketplaceItemTypeFilter<$PrismaModel>
  }

  export type EnumCurrencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Currency | EnumCurrencyFieldRefInput<$PrismaModel>
    in?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyWithAggregatesFilter<$PrismaModel> | $Enums.Currency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyFilter<$PrismaModel>
    _max?: NestedEnumCurrencyFilter<$PrismaModel>
  }

  export type EnumMarketplaceItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketplaceItemStatus | EnumMarketplaceItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MarketplaceItemStatus[] | ListEnumMarketplaceItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketplaceItemStatus[] | ListEnumMarketplaceItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketplaceItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.MarketplaceItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMarketplaceItemStatusFilter<$PrismaModel>
    _max?: NestedEnumMarketplaceItemStatusFilter<$PrismaModel>
  }

  export type EnumStudyRoomStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudyRoomStatus | EnumStudyRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudyRoomStatus[] | ListEnumStudyRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudyRoomStatus[] | ListEnumStudyRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudyRoomStatusFilter<$PrismaModel> | $Enums.StudyRoomStatus
  }

  export type StudyRoomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    videoId?: SortOrder
    hostId?: SortOrder
    maxParticipants?: SortOrder
    status?: SortOrder
    currentTime?: SortOrder
    isPaused?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudyRoomAvgOrderByAggregateInput = {
    videoId?: SortOrder
    maxParticipants?: SortOrder
    currentTime?: SortOrder
  }

  export type StudyRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    videoId?: SortOrder
    hostId?: SortOrder
    maxParticipants?: SortOrder
    status?: SortOrder
    currentTime?: SortOrder
    isPaused?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudyRoomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    videoId?: SortOrder
    hostId?: SortOrder
    maxParticipants?: SortOrder
    status?: SortOrder
    currentTime?: SortOrder
    isPaused?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudyRoomSumOrderByAggregateInput = {
    videoId?: SortOrder
    maxParticipants?: SortOrder
    currentTime?: SortOrder
  }

  export type EnumStudyRoomStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudyRoomStatus | EnumStudyRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudyRoomStatus[] | ListEnumStudyRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudyRoomStatus[] | ListEnumStudyRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudyRoomStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudyRoomStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudyRoomStatusFilter<$PrismaModel>
    _max?: NestedEnumStudyRoomStatusFilter<$PrismaModel>
  }

  export type StudyRoomRelationFilter = {
    is?: StudyRoomWhereInput
    isNot?: StudyRoomWhereInput
  }

  export type StudyRoomParticipantStudyRoomIdUserIdCompoundUniqueInput = {
    studyRoomId: string
    userId: string
  }

  export type StudyRoomParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    studyRoomId?: SortOrder
    userId?: SortOrder
    isHost?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    isActive?: SortOrder
  }

  export type StudyRoomParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    studyRoomId?: SortOrder
    userId?: SortOrder
    isHost?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    isActive?: SortOrder
  }

  export type StudyRoomParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    studyRoomId?: SortOrder
    userId?: SortOrder
    isHost?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    isActive?: SortOrder
  }

  export type StudyRoomMessageCountOrderByAggregateInput = {
    id?: SortOrder
    studyRoomId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type StudyRoomMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    studyRoomId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type StudyRoomMessageMinOrderByAggregateInput = {
    id?: SortOrder
    studyRoomId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type EnumFeedbackPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackPriorityFilter<$PrismaModel> | $Enums.FeedbackPriority
  }

  export type EnumFeedbackStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackStatus | EnumFeedbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackStatusFilter<$PrismaModel> | $Enums.FeedbackStatus
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FeedbackReportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    status?: SortOrder
    elementContext?: SortOrder
    technicalContext?: SortOrder
    codeAnalysis?: SortOrder
    aiSuggestions?: SortOrder
    adminResponse?: SortOrder
    adminUserId?: SortOrder
    resolvedAt?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    duplicateOf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedbackReportAvgOrderByAggregateInput = {
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type FeedbackReportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    status?: SortOrder
    adminResponse?: SortOrder
    adminUserId?: SortOrder
    resolvedAt?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    duplicateOf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedbackReportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    status?: SortOrder
    adminResponse?: SortOrder
    adminUserId?: SortOrder
    resolvedAt?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    duplicateOf?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedbackReportSumOrderByAggregateInput = {
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type EnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type EnumFeedbackPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackPriorityWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackPriorityFilter<$PrismaModel>
    _max?: NestedEnumFeedbackPriorityFilter<$PrismaModel>
  }

  export type EnumFeedbackStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackStatus | EnumFeedbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackStatusWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackStatusFilter<$PrismaModel>
    _max?: NestedEnumFeedbackStatusFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    website?: SortOrder
    skills?: SortOrder
    interests?: SortOrder
    isEmprendedorConfiable?: SortOrder
    socialLinks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    website?: SortOrder
    isEmprendedorConfiable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    website?: SortOrder
    isEmprendedorConfiable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceItemRelationFilter = {
    is?: MarketplaceItemWhereInput
    isNot?: MarketplaceItemWhereInput
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    marketplaceItemId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    communication?: SortOrder
    quality?: SortOrder
    delivery?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
    communication?: SortOrder
    quality?: SortOrder
    delivery?: SortOrder
    value?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    marketplaceItemId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    communication?: SortOrder
    quality?: SortOrder
    delivery?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    marketplaceItemId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    communication?: SortOrder
    quality?: SortOrder
    delivery?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
    communication?: SortOrder
    quality?: SortOrder
    delivery?: SortOrder
    value?: SortOrder
  }

  export type EnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type MarketplaceMatchCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    buyerConfirmed?: SortOrder
    sellerConfirmed?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceMatchMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    buyerConfirmed?: SortOrder
    sellerConfirmed?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceMatchMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    buyerId?: SortOrder
    sellerId?: SortOrder
    buyerConfirmed?: SortOrder
    sellerConfirmed?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type MarketplaceMatchRelationFilter = {
    is?: MarketplaceMatchWhereInput
    isNot?: MarketplaceMatchWhereInput
  }

  export type MatchMessageCountOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchMessageMinOrderByAggregateInput = {
    id?: SortOrder
    matchId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type PlaylistCreateNestedManyWithoutMundoInput = {
    create?: XOR<PlaylistCreateWithoutMundoInput, PlaylistUncheckedCreateWithoutMundoInput> | PlaylistCreateWithoutMundoInput[] | PlaylistUncheckedCreateWithoutMundoInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutMundoInput | PlaylistCreateOrConnectWithoutMundoInput[]
    createMany?: PlaylistCreateManyMundoInputEnvelope
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
  }

  export type WorldCreateNestedManyWithoutMundoInput = {
    create?: XOR<WorldCreateWithoutMundoInput, WorldUncheckedCreateWithoutMundoInput> | WorldCreateWithoutMundoInput[] | WorldUncheckedCreateWithoutMundoInput[]
    connectOrCreate?: WorldCreateOrConnectWithoutMundoInput | WorldCreateOrConnectWithoutMundoInput[]
    createMany?: WorldCreateManyMundoInputEnvelope
    connect?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
  }

  export type PlaylistUncheckedCreateNestedManyWithoutMundoInput = {
    create?: XOR<PlaylistCreateWithoutMundoInput, PlaylistUncheckedCreateWithoutMundoInput> | PlaylistCreateWithoutMundoInput[] | PlaylistUncheckedCreateWithoutMundoInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutMundoInput | PlaylistCreateOrConnectWithoutMundoInput[]
    createMany?: PlaylistCreateManyMundoInputEnvelope
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
  }

  export type WorldUncheckedCreateNestedManyWithoutMundoInput = {
    create?: XOR<WorldCreateWithoutMundoInput, WorldUncheckedCreateWithoutMundoInput> | WorldCreateWithoutMundoInput[] | WorldUncheckedCreateWithoutMundoInput[]
    connectOrCreate?: WorldCreateOrConnectWithoutMundoInput | WorldCreateOrConnectWithoutMundoInput[]
    createMany?: WorldCreateManyMundoInputEnvelope
    connect?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PlaylistUpdateManyWithoutMundoNestedInput = {
    create?: XOR<PlaylistCreateWithoutMundoInput, PlaylistUncheckedCreateWithoutMundoInput> | PlaylistCreateWithoutMundoInput[] | PlaylistUncheckedCreateWithoutMundoInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutMundoInput | PlaylistCreateOrConnectWithoutMundoInput[]
    upsert?: PlaylistUpsertWithWhereUniqueWithoutMundoInput | PlaylistUpsertWithWhereUniqueWithoutMundoInput[]
    createMany?: PlaylistCreateManyMundoInputEnvelope
    set?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    disconnect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    delete?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    update?: PlaylistUpdateWithWhereUniqueWithoutMundoInput | PlaylistUpdateWithWhereUniqueWithoutMundoInput[]
    updateMany?: PlaylistUpdateManyWithWhereWithoutMundoInput | PlaylistUpdateManyWithWhereWithoutMundoInput[]
    deleteMany?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
  }

  export type WorldUpdateManyWithoutMundoNestedInput = {
    create?: XOR<WorldCreateWithoutMundoInput, WorldUncheckedCreateWithoutMundoInput> | WorldCreateWithoutMundoInput[] | WorldUncheckedCreateWithoutMundoInput[]
    connectOrCreate?: WorldCreateOrConnectWithoutMundoInput | WorldCreateOrConnectWithoutMundoInput[]
    upsert?: WorldUpsertWithWhereUniqueWithoutMundoInput | WorldUpsertWithWhereUniqueWithoutMundoInput[]
    createMany?: WorldCreateManyMundoInputEnvelope
    set?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
    disconnect?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
    delete?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
    connect?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
    update?: WorldUpdateWithWhereUniqueWithoutMundoInput | WorldUpdateWithWhereUniqueWithoutMundoInput[]
    updateMany?: WorldUpdateManyWithWhereWithoutMundoInput | WorldUpdateManyWithWhereWithoutMundoInput[]
    deleteMany?: WorldScalarWhereInput | WorldScalarWhereInput[]
  }

  export type PlaylistUncheckedUpdateManyWithoutMundoNestedInput = {
    create?: XOR<PlaylistCreateWithoutMundoInput, PlaylistUncheckedCreateWithoutMundoInput> | PlaylistCreateWithoutMundoInput[] | PlaylistUncheckedCreateWithoutMundoInput[]
    connectOrCreate?: PlaylistCreateOrConnectWithoutMundoInput | PlaylistCreateOrConnectWithoutMundoInput[]
    upsert?: PlaylistUpsertWithWhereUniqueWithoutMundoInput | PlaylistUpsertWithWhereUniqueWithoutMundoInput[]
    createMany?: PlaylistCreateManyMundoInputEnvelope
    set?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    disconnect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    delete?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    connect?: PlaylistWhereUniqueInput | PlaylistWhereUniqueInput[]
    update?: PlaylistUpdateWithWhereUniqueWithoutMundoInput | PlaylistUpdateWithWhereUniqueWithoutMundoInput[]
    updateMany?: PlaylistUpdateManyWithWhereWithoutMundoInput | PlaylistUpdateManyWithWhereWithoutMundoInput[]
    deleteMany?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
  }

  export type WorldUncheckedUpdateManyWithoutMundoNestedInput = {
    create?: XOR<WorldCreateWithoutMundoInput, WorldUncheckedCreateWithoutMundoInput> | WorldCreateWithoutMundoInput[] | WorldUncheckedCreateWithoutMundoInput[]
    connectOrCreate?: WorldCreateOrConnectWithoutMundoInput | WorldCreateOrConnectWithoutMundoInput[]
    upsert?: WorldUpsertWithWhereUniqueWithoutMundoInput | WorldUpsertWithWhereUniqueWithoutMundoInput[]
    createMany?: WorldCreateManyMundoInputEnvelope
    set?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
    disconnect?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
    delete?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
    connect?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
    update?: WorldUpdateWithWhereUniqueWithoutMundoInput | WorldUpdateWithWhereUniqueWithoutMundoInput[]
    updateMany?: WorldUpdateManyWithWhereWithoutMundoInput | WorldUpdateManyWithWhereWithoutMundoInput[]
    deleteMany?: WorldScalarWhereInput | WorldScalarWhereInput[]
  }

  export type ContentItemCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<ContentItemCreateWithoutPlaylistInput, ContentItemUncheckedCreateWithoutPlaylistInput> | ContentItemCreateWithoutPlaylistInput[] | ContentItemUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: ContentItemCreateOrConnectWithoutPlaylistInput | ContentItemCreateOrConnectWithoutPlaylistInput[]
    createMany?: ContentItemCreateManyPlaylistInputEnvelope
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
  }

  export type GamifiedPlaylistCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<GamifiedPlaylistCreateWithoutPlaylistInput, GamifiedPlaylistUncheckedCreateWithoutPlaylistInput> | GamifiedPlaylistCreateWithoutPlaylistInput[] | GamifiedPlaylistUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: GamifiedPlaylistCreateOrConnectWithoutPlaylistInput | GamifiedPlaylistCreateOrConnectWithoutPlaylistInput[]
    createMany?: GamifiedPlaylistCreateManyPlaylistInputEnvelope
    connect?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
  }

  export type MundoCreateNestedOneWithoutPlaylistsInput = {
    create?: XOR<MundoCreateWithoutPlaylistsInput, MundoUncheckedCreateWithoutPlaylistsInput>
    connectOrCreate?: MundoCreateOrConnectWithoutPlaylistsInput
    connect?: MundoWhereUniqueInput
  }

  export type VideoItemCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<VideoItemCreateWithoutPlaylistInput, VideoItemUncheckedCreateWithoutPlaylistInput> | VideoItemCreateWithoutPlaylistInput[] | VideoItemUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: VideoItemCreateOrConnectWithoutPlaylistInput | VideoItemCreateOrConnectWithoutPlaylistInput[]
    createMany?: VideoItemCreateManyPlaylistInputEnvelope
    connect?: VideoItemWhereUniqueInput | VideoItemWhereUniqueInput[]
  }

  export type ContentItemUncheckedCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<ContentItemCreateWithoutPlaylistInput, ContentItemUncheckedCreateWithoutPlaylistInput> | ContentItemCreateWithoutPlaylistInput[] | ContentItemUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: ContentItemCreateOrConnectWithoutPlaylistInput | ContentItemCreateOrConnectWithoutPlaylistInput[]
    createMany?: ContentItemCreateManyPlaylistInputEnvelope
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
  }

  export type GamifiedPlaylistUncheckedCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<GamifiedPlaylistCreateWithoutPlaylistInput, GamifiedPlaylistUncheckedCreateWithoutPlaylistInput> | GamifiedPlaylistCreateWithoutPlaylistInput[] | GamifiedPlaylistUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: GamifiedPlaylistCreateOrConnectWithoutPlaylistInput | GamifiedPlaylistCreateOrConnectWithoutPlaylistInput[]
    createMany?: GamifiedPlaylistCreateManyPlaylistInputEnvelope
    connect?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
  }

  export type VideoItemUncheckedCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<VideoItemCreateWithoutPlaylistInput, VideoItemUncheckedCreateWithoutPlaylistInput> | VideoItemCreateWithoutPlaylistInput[] | VideoItemUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: VideoItemCreateOrConnectWithoutPlaylistInput | VideoItemCreateOrConnectWithoutPlaylistInput[]
    createMany?: VideoItemCreateManyPlaylistInputEnvelope
    connect?: VideoItemWhereUniqueInput | VideoItemWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ContentItemUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<ContentItemCreateWithoutPlaylistInput, ContentItemUncheckedCreateWithoutPlaylistInput> | ContentItemCreateWithoutPlaylistInput[] | ContentItemUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: ContentItemCreateOrConnectWithoutPlaylistInput | ContentItemCreateOrConnectWithoutPlaylistInput[]
    upsert?: ContentItemUpsertWithWhereUniqueWithoutPlaylistInput | ContentItemUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: ContentItemCreateManyPlaylistInputEnvelope
    set?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    disconnect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    delete?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    update?: ContentItemUpdateWithWhereUniqueWithoutPlaylistInput | ContentItemUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: ContentItemUpdateManyWithWhereWithoutPlaylistInput | ContentItemUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[]
  }

  export type GamifiedPlaylistUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<GamifiedPlaylistCreateWithoutPlaylistInput, GamifiedPlaylistUncheckedCreateWithoutPlaylistInput> | GamifiedPlaylistCreateWithoutPlaylistInput[] | GamifiedPlaylistUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: GamifiedPlaylistCreateOrConnectWithoutPlaylistInput | GamifiedPlaylistCreateOrConnectWithoutPlaylistInput[]
    upsert?: GamifiedPlaylistUpsertWithWhereUniqueWithoutPlaylistInput | GamifiedPlaylistUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: GamifiedPlaylistCreateManyPlaylistInputEnvelope
    set?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
    disconnect?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
    delete?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
    connect?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
    update?: GamifiedPlaylistUpdateWithWhereUniqueWithoutPlaylistInput | GamifiedPlaylistUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: GamifiedPlaylistUpdateManyWithWhereWithoutPlaylistInput | GamifiedPlaylistUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: GamifiedPlaylistScalarWhereInput | GamifiedPlaylistScalarWhereInput[]
  }

  export type MundoUpdateOneRequiredWithoutPlaylistsNestedInput = {
    create?: XOR<MundoCreateWithoutPlaylistsInput, MundoUncheckedCreateWithoutPlaylistsInput>
    connectOrCreate?: MundoCreateOrConnectWithoutPlaylistsInput
    upsert?: MundoUpsertWithoutPlaylistsInput
    connect?: MundoWhereUniqueInput
    update?: XOR<XOR<MundoUpdateToOneWithWhereWithoutPlaylistsInput, MundoUpdateWithoutPlaylistsInput>, MundoUncheckedUpdateWithoutPlaylistsInput>
  }

  export type VideoItemUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<VideoItemCreateWithoutPlaylistInput, VideoItemUncheckedCreateWithoutPlaylistInput> | VideoItemCreateWithoutPlaylistInput[] | VideoItemUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: VideoItemCreateOrConnectWithoutPlaylistInput | VideoItemCreateOrConnectWithoutPlaylistInput[]
    upsert?: VideoItemUpsertWithWhereUniqueWithoutPlaylistInput | VideoItemUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: VideoItemCreateManyPlaylistInputEnvelope
    set?: VideoItemWhereUniqueInput | VideoItemWhereUniqueInput[]
    disconnect?: VideoItemWhereUniqueInput | VideoItemWhereUniqueInput[]
    delete?: VideoItemWhereUniqueInput | VideoItemWhereUniqueInput[]
    connect?: VideoItemWhereUniqueInput | VideoItemWhereUniqueInput[]
    update?: VideoItemUpdateWithWhereUniqueWithoutPlaylistInput | VideoItemUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: VideoItemUpdateManyWithWhereWithoutPlaylistInput | VideoItemUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: VideoItemScalarWhereInput | VideoItemScalarWhereInput[]
  }

  export type ContentItemUncheckedUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<ContentItemCreateWithoutPlaylistInput, ContentItemUncheckedCreateWithoutPlaylistInput> | ContentItemCreateWithoutPlaylistInput[] | ContentItemUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: ContentItemCreateOrConnectWithoutPlaylistInput | ContentItemCreateOrConnectWithoutPlaylistInput[]
    upsert?: ContentItemUpsertWithWhereUniqueWithoutPlaylistInput | ContentItemUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: ContentItemCreateManyPlaylistInputEnvelope
    set?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    disconnect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    delete?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    update?: ContentItemUpdateWithWhereUniqueWithoutPlaylistInput | ContentItemUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: ContentItemUpdateManyWithWhereWithoutPlaylistInput | ContentItemUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[]
  }

  export type GamifiedPlaylistUncheckedUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<GamifiedPlaylistCreateWithoutPlaylistInput, GamifiedPlaylistUncheckedCreateWithoutPlaylistInput> | GamifiedPlaylistCreateWithoutPlaylistInput[] | GamifiedPlaylistUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: GamifiedPlaylistCreateOrConnectWithoutPlaylistInput | GamifiedPlaylistCreateOrConnectWithoutPlaylistInput[]
    upsert?: GamifiedPlaylistUpsertWithWhereUniqueWithoutPlaylistInput | GamifiedPlaylistUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: GamifiedPlaylistCreateManyPlaylistInputEnvelope
    set?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
    disconnect?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
    delete?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
    connect?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
    update?: GamifiedPlaylistUpdateWithWhereUniqueWithoutPlaylistInput | GamifiedPlaylistUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: GamifiedPlaylistUpdateManyWithWhereWithoutPlaylistInput | GamifiedPlaylistUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: GamifiedPlaylistScalarWhereInput | GamifiedPlaylistScalarWhereInput[]
  }

  export type VideoItemUncheckedUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<VideoItemCreateWithoutPlaylistInput, VideoItemUncheckedCreateWithoutPlaylistInput> | VideoItemCreateWithoutPlaylistInput[] | VideoItemUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: VideoItemCreateOrConnectWithoutPlaylistInput | VideoItemCreateOrConnectWithoutPlaylistInput[]
    upsert?: VideoItemUpsertWithWhereUniqueWithoutPlaylistInput | VideoItemUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: VideoItemCreateManyPlaylistInputEnvelope
    set?: VideoItemWhereUniqueInput | VideoItemWhereUniqueInput[]
    disconnect?: VideoItemWhereUniqueInput | VideoItemWhereUniqueInput[]
    delete?: VideoItemWhereUniqueInput | VideoItemWhereUniqueInput[]
    connect?: VideoItemWhereUniqueInput | VideoItemWhereUniqueInput[]
    update?: VideoItemUpdateWithWhereUniqueWithoutPlaylistInput | VideoItemUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: VideoItemUpdateManyWithWhereWithoutPlaylistInput | VideoItemUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: VideoItemScalarWhereInput | VideoItemScalarWhereInput[]
  }

  export type ActivityCreateNestedManyWithoutVideoItemInput = {
    create?: XOR<ActivityCreateWithoutVideoItemInput, ActivityUncheckedCreateWithoutVideoItemInput> | ActivityCreateWithoutVideoItemInput[] | ActivityUncheckedCreateWithoutVideoItemInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutVideoItemInput | ActivityCreateOrConnectWithoutVideoItemInput[]
    createMany?: ActivityCreateManyVideoItemInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type QuestionCreateNestedManyWithoutVideoItemInput = {
    create?: XOR<QuestionCreateWithoutVideoItemInput, QuestionUncheckedCreateWithoutVideoItemInput> | QuestionCreateWithoutVideoItemInput[] | QuestionUncheckedCreateWithoutVideoItemInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutVideoItemInput | QuestionCreateOrConnectWithoutVideoItemInput[]
    createMany?: QuestionCreateManyVideoItemInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type SubtitleCreateNestedManyWithoutVideoItemInput = {
    create?: XOR<SubtitleCreateWithoutVideoItemInput, SubtitleUncheckedCreateWithoutVideoItemInput> | SubtitleCreateWithoutVideoItemInput[] | SubtitleUncheckedCreateWithoutVideoItemInput[]
    connectOrCreate?: SubtitleCreateOrConnectWithoutVideoItemInput | SubtitleCreateOrConnectWithoutVideoItemInput[]
    createMany?: SubtitleCreateManyVideoItemInputEnvelope
    connect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
  }

  export type StudyRoomCreateNestedManyWithoutVideoInput = {
    create?: XOR<StudyRoomCreateWithoutVideoInput, StudyRoomUncheckedCreateWithoutVideoInput> | StudyRoomCreateWithoutVideoInput[] | StudyRoomUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: StudyRoomCreateOrConnectWithoutVideoInput | StudyRoomCreateOrConnectWithoutVideoInput[]
    createMany?: StudyRoomCreateManyVideoInputEnvelope
    connect?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
  }

  export type PlaylistCreateNestedOneWithoutVideoItemsInput = {
    create?: XOR<PlaylistCreateWithoutVideoItemsInput, PlaylistUncheckedCreateWithoutVideoItemsInput>
    connectOrCreate?: PlaylistCreateOrConnectWithoutVideoItemsInput
    connect?: PlaylistWhereUniqueInput
  }

  export type VideoPermissionsCreateNestedOneWithoutVideoItemInput = {
    create?: XOR<VideoPermissionsCreateWithoutVideoItemInput, VideoPermissionsUncheckedCreateWithoutVideoItemInput>
    connectOrCreate?: VideoPermissionsCreateOrConnectWithoutVideoItemInput
    connect?: VideoPermissionsWhereUniqueInput
  }

  export type ActivityUncheckedCreateNestedManyWithoutVideoItemInput = {
    create?: XOR<ActivityCreateWithoutVideoItemInput, ActivityUncheckedCreateWithoutVideoItemInput> | ActivityCreateWithoutVideoItemInput[] | ActivityUncheckedCreateWithoutVideoItemInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutVideoItemInput | ActivityCreateOrConnectWithoutVideoItemInput[]
    createMany?: ActivityCreateManyVideoItemInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutVideoItemInput = {
    create?: XOR<QuestionCreateWithoutVideoItemInput, QuestionUncheckedCreateWithoutVideoItemInput> | QuestionCreateWithoutVideoItemInput[] | QuestionUncheckedCreateWithoutVideoItemInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutVideoItemInput | QuestionCreateOrConnectWithoutVideoItemInput[]
    createMany?: QuestionCreateManyVideoItemInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type SubtitleUncheckedCreateNestedManyWithoutVideoItemInput = {
    create?: XOR<SubtitleCreateWithoutVideoItemInput, SubtitleUncheckedCreateWithoutVideoItemInput> | SubtitleCreateWithoutVideoItemInput[] | SubtitleUncheckedCreateWithoutVideoItemInput[]
    connectOrCreate?: SubtitleCreateOrConnectWithoutVideoItemInput | SubtitleCreateOrConnectWithoutVideoItemInput[]
    createMany?: SubtitleCreateManyVideoItemInputEnvelope
    connect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
  }

  export type StudyRoomUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<StudyRoomCreateWithoutVideoInput, StudyRoomUncheckedCreateWithoutVideoInput> | StudyRoomCreateWithoutVideoInput[] | StudyRoomUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: StudyRoomCreateOrConnectWithoutVideoInput | StudyRoomCreateOrConnectWithoutVideoInput[]
    createMany?: StudyRoomCreateManyVideoInputEnvelope
    connect?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
  }

  export type VideoPermissionsUncheckedCreateNestedOneWithoutVideoItemInput = {
    create?: XOR<VideoPermissionsCreateWithoutVideoItemInput, VideoPermissionsUncheckedCreateWithoutVideoItemInput>
    connectOrCreate?: VideoPermissionsCreateOrConnectWithoutVideoItemInput
    connect?: VideoPermissionsWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ActivityUpdateManyWithoutVideoItemNestedInput = {
    create?: XOR<ActivityCreateWithoutVideoItemInput, ActivityUncheckedCreateWithoutVideoItemInput> | ActivityCreateWithoutVideoItemInput[] | ActivityUncheckedCreateWithoutVideoItemInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutVideoItemInput | ActivityCreateOrConnectWithoutVideoItemInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutVideoItemInput | ActivityUpsertWithWhereUniqueWithoutVideoItemInput[]
    createMany?: ActivityCreateManyVideoItemInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutVideoItemInput | ActivityUpdateWithWhereUniqueWithoutVideoItemInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutVideoItemInput | ActivityUpdateManyWithWhereWithoutVideoItemInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type QuestionUpdateManyWithoutVideoItemNestedInput = {
    create?: XOR<QuestionCreateWithoutVideoItemInput, QuestionUncheckedCreateWithoutVideoItemInput> | QuestionCreateWithoutVideoItemInput[] | QuestionUncheckedCreateWithoutVideoItemInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutVideoItemInput | QuestionCreateOrConnectWithoutVideoItemInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutVideoItemInput | QuestionUpsertWithWhereUniqueWithoutVideoItemInput[]
    createMany?: QuestionCreateManyVideoItemInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutVideoItemInput | QuestionUpdateWithWhereUniqueWithoutVideoItemInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutVideoItemInput | QuestionUpdateManyWithWhereWithoutVideoItemInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type SubtitleUpdateManyWithoutVideoItemNestedInput = {
    create?: XOR<SubtitleCreateWithoutVideoItemInput, SubtitleUncheckedCreateWithoutVideoItemInput> | SubtitleCreateWithoutVideoItemInput[] | SubtitleUncheckedCreateWithoutVideoItemInput[]
    connectOrCreate?: SubtitleCreateOrConnectWithoutVideoItemInput | SubtitleCreateOrConnectWithoutVideoItemInput[]
    upsert?: SubtitleUpsertWithWhereUniqueWithoutVideoItemInput | SubtitleUpsertWithWhereUniqueWithoutVideoItemInput[]
    createMany?: SubtitleCreateManyVideoItemInputEnvelope
    set?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    disconnect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    delete?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    connect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    update?: SubtitleUpdateWithWhereUniqueWithoutVideoItemInput | SubtitleUpdateWithWhereUniqueWithoutVideoItemInput[]
    updateMany?: SubtitleUpdateManyWithWhereWithoutVideoItemInput | SubtitleUpdateManyWithWhereWithoutVideoItemInput[]
    deleteMany?: SubtitleScalarWhereInput | SubtitleScalarWhereInput[]
  }

  export type StudyRoomUpdateManyWithoutVideoNestedInput = {
    create?: XOR<StudyRoomCreateWithoutVideoInput, StudyRoomUncheckedCreateWithoutVideoInput> | StudyRoomCreateWithoutVideoInput[] | StudyRoomUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: StudyRoomCreateOrConnectWithoutVideoInput | StudyRoomCreateOrConnectWithoutVideoInput[]
    upsert?: StudyRoomUpsertWithWhereUniqueWithoutVideoInput | StudyRoomUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: StudyRoomCreateManyVideoInputEnvelope
    set?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
    disconnect?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
    delete?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
    connect?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
    update?: StudyRoomUpdateWithWhereUniqueWithoutVideoInput | StudyRoomUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: StudyRoomUpdateManyWithWhereWithoutVideoInput | StudyRoomUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: StudyRoomScalarWhereInput | StudyRoomScalarWhereInput[]
  }

  export type PlaylistUpdateOneRequiredWithoutVideoItemsNestedInput = {
    create?: XOR<PlaylistCreateWithoutVideoItemsInput, PlaylistUncheckedCreateWithoutVideoItemsInput>
    connectOrCreate?: PlaylistCreateOrConnectWithoutVideoItemsInput
    upsert?: PlaylistUpsertWithoutVideoItemsInput
    connect?: PlaylistWhereUniqueInput
    update?: XOR<XOR<PlaylistUpdateToOneWithWhereWithoutVideoItemsInput, PlaylistUpdateWithoutVideoItemsInput>, PlaylistUncheckedUpdateWithoutVideoItemsInput>
  }

  export type VideoPermissionsUpdateOneWithoutVideoItemNestedInput = {
    create?: XOR<VideoPermissionsCreateWithoutVideoItemInput, VideoPermissionsUncheckedCreateWithoutVideoItemInput>
    connectOrCreate?: VideoPermissionsCreateOrConnectWithoutVideoItemInput
    upsert?: VideoPermissionsUpsertWithoutVideoItemInput
    disconnect?: VideoPermissionsWhereInput | boolean
    delete?: VideoPermissionsWhereInput | boolean
    connect?: VideoPermissionsWhereUniqueInput
    update?: XOR<XOR<VideoPermissionsUpdateToOneWithWhereWithoutVideoItemInput, VideoPermissionsUpdateWithoutVideoItemInput>, VideoPermissionsUncheckedUpdateWithoutVideoItemInput>
  }

  export type ActivityUncheckedUpdateManyWithoutVideoItemNestedInput = {
    create?: XOR<ActivityCreateWithoutVideoItemInput, ActivityUncheckedCreateWithoutVideoItemInput> | ActivityCreateWithoutVideoItemInput[] | ActivityUncheckedCreateWithoutVideoItemInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutVideoItemInput | ActivityCreateOrConnectWithoutVideoItemInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutVideoItemInput | ActivityUpsertWithWhereUniqueWithoutVideoItemInput[]
    createMany?: ActivityCreateManyVideoItemInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutVideoItemInput | ActivityUpdateWithWhereUniqueWithoutVideoItemInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutVideoItemInput | ActivityUpdateManyWithWhereWithoutVideoItemInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutVideoItemNestedInput = {
    create?: XOR<QuestionCreateWithoutVideoItemInput, QuestionUncheckedCreateWithoutVideoItemInput> | QuestionCreateWithoutVideoItemInput[] | QuestionUncheckedCreateWithoutVideoItemInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutVideoItemInput | QuestionCreateOrConnectWithoutVideoItemInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutVideoItemInput | QuestionUpsertWithWhereUniqueWithoutVideoItemInput[]
    createMany?: QuestionCreateManyVideoItemInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutVideoItemInput | QuestionUpdateWithWhereUniqueWithoutVideoItemInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutVideoItemInput | QuestionUpdateManyWithWhereWithoutVideoItemInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type SubtitleUncheckedUpdateManyWithoutVideoItemNestedInput = {
    create?: XOR<SubtitleCreateWithoutVideoItemInput, SubtitleUncheckedCreateWithoutVideoItemInput> | SubtitleCreateWithoutVideoItemInput[] | SubtitleUncheckedCreateWithoutVideoItemInput[]
    connectOrCreate?: SubtitleCreateOrConnectWithoutVideoItemInput | SubtitleCreateOrConnectWithoutVideoItemInput[]
    upsert?: SubtitleUpsertWithWhereUniqueWithoutVideoItemInput | SubtitleUpsertWithWhereUniqueWithoutVideoItemInput[]
    createMany?: SubtitleCreateManyVideoItemInputEnvelope
    set?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    disconnect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    delete?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    connect?: SubtitleWhereUniqueInput | SubtitleWhereUniqueInput[]
    update?: SubtitleUpdateWithWhereUniqueWithoutVideoItemInput | SubtitleUpdateWithWhereUniqueWithoutVideoItemInput[]
    updateMany?: SubtitleUpdateManyWithWhereWithoutVideoItemInput | SubtitleUpdateManyWithWhereWithoutVideoItemInput[]
    deleteMany?: SubtitleScalarWhereInput | SubtitleScalarWhereInput[]
  }

  export type StudyRoomUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<StudyRoomCreateWithoutVideoInput, StudyRoomUncheckedCreateWithoutVideoInput> | StudyRoomCreateWithoutVideoInput[] | StudyRoomUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: StudyRoomCreateOrConnectWithoutVideoInput | StudyRoomCreateOrConnectWithoutVideoInput[]
    upsert?: StudyRoomUpsertWithWhereUniqueWithoutVideoInput | StudyRoomUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: StudyRoomCreateManyVideoInputEnvelope
    set?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
    disconnect?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
    delete?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
    connect?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
    update?: StudyRoomUpdateWithWhereUniqueWithoutVideoInput | StudyRoomUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: StudyRoomUpdateManyWithWhereWithoutVideoInput | StudyRoomUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: StudyRoomScalarWhereInput | StudyRoomScalarWhereInput[]
  }

  export type VideoPermissionsUncheckedUpdateOneWithoutVideoItemNestedInput = {
    create?: XOR<VideoPermissionsCreateWithoutVideoItemInput, VideoPermissionsUncheckedCreateWithoutVideoItemInput>
    connectOrCreate?: VideoPermissionsCreateOrConnectWithoutVideoItemInput
    upsert?: VideoPermissionsUpsertWithoutVideoItemInput
    disconnect?: VideoPermissionsWhereInput | boolean
    delete?: VideoPermissionsWhereInput | boolean
    connect?: VideoPermissionsWhereUniqueInput
    update?: XOR<XOR<VideoPermissionsUpdateToOneWithWhereWithoutVideoItemInput, VideoPermissionsUpdateWithoutVideoItemInput>, VideoPermissionsUncheckedUpdateWithoutVideoItemInput>
  }

  export type VideoItemCreateNestedOneWithoutSubtitlesInput = {
    create?: XOR<VideoItemCreateWithoutSubtitlesInput, VideoItemUncheckedCreateWithoutSubtitlesInput>
    connectOrCreate?: VideoItemCreateOrConnectWithoutSubtitlesInput
    connect?: VideoItemWhereUniqueInput
  }

  export type VideoItemUpdateOneRequiredWithoutSubtitlesNestedInput = {
    create?: XOR<VideoItemCreateWithoutSubtitlesInput, VideoItemUncheckedCreateWithoutSubtitlesInput>
    connectOrCreate?: VideoItemCreateOrConnectWithoutSubtitlesInput
    upsert?: VideoItemUpsertWithoutSubtitlesInput
    connect?: VideoItemWhereUniqueInput
    update?: XOR<XOR<VideoItemUpdateToOneWithWhereWithoutSubtitlesInput, VideoItemUpdateWithoutSubtitlesInput>, VideoItemUncheckedUpdateWithoutSubtitlesInput>
  }

  export type AnswerOptionCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AnswerOptionCreateWithoutQuestionInput, AnswerOptionUncheckedCreateWithoutQuestionInput> | AnswerOptionCreateWithoutQuestionInput[] | AnswerOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerOptionCreateOrConnectWithoutQuestionInput | AnswerOptionCreateOrConnectWithoutQuestionInput[]
    createMany?: AnswerOptionCreateManyQuestionInputEnvelope
    connect?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[]
  }

  export type VideoItemCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<VideoItemCreateWithoutQuestionsInput, VideoItemUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: VideoItemCreateOrConnectWithoutQuestionsInput
    connect?: VideoItemWhereUniqueInput
  }

  export type UserAnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<UserAnswerCreateWithoutQuestionInput, UserAnswerUncheckedCreateWithoutQuestionInput> | UserAnswerCreateWithoutQuestionInput[] | UserAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutQuestionInput | UserAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: UserAnswerCreateManyQuestionInputEnvelope
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
  }

  export type AnswerOptionUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AnswerOptionCreateWithoutQuestionInput, AnswerOptionUncheckedCreateWithoutQuestionInput> | AnswerOptionCreateWithoutQuestionInput[] | AnswerOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerOptionCreateOrConnectWithoutQuestionInput | AnswerOptionCreateOrConnectWithoutQuestionInput[]
    createMany?: AnswerOptionCreateManyQuestionInputEnvelope
    connect?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[]
  }

  export type UserAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<UserAnswerCreateWithoutQuestionInput, UserAnswerUncheckedCreateWithoutQuestionInput> | UserAnswerCreateWithoutQuestionInput[] | UserAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutQuestionInput | UserAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: UserAnswerCreateManyQuestionInputEnvelope
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
  }

  export type AnswerOptionUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AnswerOptionCreateWithoutQuestionInput, AnswerOptionUncheckedCreateWithoutQuestionInput> | AnswerOptionCreateWithoutQuestionInput[] | AnswerOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerOptionCreateOrConnectWithoutQuestionInput | AnswerOptionCreateOrConnectWithoutQuestionInput[]
    upsert?: AnswerOptionUpsertWithWhereUniqueWithoutQuestionInput | AnswerOptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AnswerOptionCreateManyQuestionInputEnvelope
    set?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[]
    disconnect?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[]
    delete?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[]
    connect?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[]
    update?: AnswerOptionUpdateWithWhereUniqueWithoutQuestionInput | AnswerOptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AnswerOptionUpdateManyWithWhereWithoutQuestionInput | AnswerOptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AnswerOptionScalarWhereInput | AnswerOptionScalarWhereInput[]
  }

  export type VideoItemUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<VideoItemCreateWithoutQuestionsInput, VideoItemUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: VideoItemCreateOrConnectWithoutQuestionsInput
    upsert?: VideoItemUpsertWithoutQuestionsInput
    connect?: VideoItemWhereUniqueInput
    update?: XOR<XOR<VideoItemUpdateToOneWithWhereWithoutQuestionsInput, VideoItemUpdateWithoutQuestionsInput>, VideoItemUncheckedUpdateWithoutQuestionsInput>
  }

  export type UserAnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<UserAnswerCreateWithoutQuestionInput, UserAnswerUncheckedCreateWithoutQuestionInput> | UserAnswerCreateWithoutQuestionInput[] | UserAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutQuestionInput | UserAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: UserAnswerUpsertWithWhereUniqueWithoutQuestionInput | UserAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: UserAnswerCreateManyQuestionInputEnvelope
    set?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    disconnect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    delete?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    update?: UserAnswerUpdateWithWhereUniqueWithoutQuestionInput | UserAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: UserAnswerUpdateManyWithWhereWithoutQuestionInput | UserAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: UserAnswerScalarWhereInput | UserAnswerScalarWhereInput[]
  }

  export type AnswerOptionUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AnswerOptionCreateWithoutQuestionInput, AnswerOptionUncheckedCreateWithoutQuestionInput> | AnswerOptionCreateWithoutQuestionInput[] | AnswerOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerOptionCreateOrConnectWithoutQuestionInput | AnswerOptionCreateOrConnectWithoutQuestionInput[]
    upsert?: AnswerOptionUpsertWithWhereUniqueWithoutQuestionInput | AnswerOptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AnswerOptionCreateManyQuestionInputEnvelope
    set?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[]
    disconnect?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[]
    delete?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[]
    connect?: AnswerOptionWhereUniqueInput | AnswerOptionWhereUniqueInput[]
    update?: AnswerOptionUpdateWithWhereUniqueWithoutQuestionInput | AnswerOptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AnswerOptionUpdateManyWithWhereWithoutQuestionInput | AnswerOptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AnswerOptionScalarWhereInput | AnswerOptionScalarWhereInput[]
  }

  export type UserAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<UserAnswerCreateWithoutQuestionInput, UserAnswerUncheckedCreateWithoutQuestionInput> | UserAnswerCreateWithoutQuestionInput[] | UserAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutQuestionInput | UserAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: UserAnswerUpsertWithWhereUniqueWithoutQuestionInput | UserAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: UserAnswerCreateManyQuestionInputEnvelope
    set?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    disconnect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    delete?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    update?: UserAnswerUpdateWithWhereUniqueWithoutQuestionInput | UserAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: UserAnswerUpdateManyWithWhereWithoutQuestionInput | UserAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: UserAnswerScalarWhereInput | UserAnswerScalarWhereInput[]
  }

  export type QuestionCreateNestedOneWithoutAnswerOptionsInput = {
    create?: XOR<QuestionCreateWithoutAnswerOptionsInput, QuestionUncheckedCreateWithoutAnswerOptionsInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAnswerOptionsInput
    connect?: QuestionWhereUniqueInput
  }

  export type QuestionUpdateOneRequiredWithoutAnswerOptionsNestedInput = {
    create?: XOR<QuestionCreateWithoutAnswerOptionsInput, QuestionUncheckedCreateWithoutAnswerOptionsInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAnswerOptionsInput
    upsert?: QuestionUpsertWithoutAnswerOptionsInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutAnswerOptionsInput, QuestionUpdateWithoutAnswerOptionsInput>, QuestionUncheckedUpdateWithoutAnswerOptionsInput>
  }

  export type ActivityCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ActivityCreateWithoutCreatorInput, ActivityUncheckedCreateWithoutCreatorInput> | ActivityCreateWithoutCreatorInput[] | ActivityUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutCreatorInput | ActivityCreateOrConnectWithoutCreatorInput[]
    createMany?: ActivityCreateManyCreatorInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type ExperienceCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ExperienceCreateWithoutCreatorInput, ExperienceUncheckedCreateWithoutCreatorInput> | ExperienceCreateWithoutCreatorInput[] | ExperienceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExperienceCreateOrConnectWithoutCreatorInput | ExperienceCreateOrConnectWithoutCreatorInput[]
    createMany?: ExperienceCreateManyCreatorInputEnvelope
    connect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
  }

  export type GiftCardCreateNestedManyWithoutInviterInput = {
    create?: XOR<GiftCardCreateWithoutInviterInput, GiftCardUncheckedCreateWithoutInviterInput> | GiftCardCreateWithoutInviterInput[] | GiftCardUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: GiftCardCreateOrConnectWithoutInviterInput | GiftCardCreateOrConnectWithoutInviterInput[]
    createMany?: GiftCardCreateManyInviterInputEnvelope
    connect?: GiftCardWhereUniqueInput | GiftCardWhereUniqueInput[]
  }

  export type GroupCreateNestedManyWithoutOwnerInput = {
    create?: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput> | GroupCreateWithoutOwnerInput[] | GroupUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutOwnerInput | GroupCreateOrConnectWithoutOwnerInput[]
    createMany?: GroupCreateManyOwnerInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type InvitationTemplateCreateNestedManyWithoutCreatorInput = {
    create?: XOR<InvitationTemplateCreateWithoutCreatorInput, InvitationTemplateUncheckedCreateWithoutCreatorInput> | InvitationTemplateCreateWithoutCreatorInput[] | InvitationTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InvitationTemplateCreateOrConnectWithoutCreatorInput | InvitationTemplateCreateOrConnectWithoutCreatorInput[]
    createMany?: InvitationTemplateCreateManyCreatorInputEnvelope
    connect?: InvitationTemplateWhereUniqueInput | InvitationTemplateWhereUniqueInput[]
  }

  export type MeritCreateNestedManyWithoutUserInput = {
    create?: XOR<MeritCreateWithoutUserInput, MeritUncheckedCreateWithoutUserInput> | MeritCreateWithoutUserInput[] | MeritUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeritCreateOrConnectWithoutUserInput | MeritCreateOrConnectWithoutUserInput[]
    createMany?: MeritCreateManyUserInputEnvelope
    connect?: MeritWhereUniqueInput | MeritWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PublicationCreateNestedManyWithoutUserInput = {
    create?: XOR<PublicationCreateWithoutUserInput, PublicationUncheckedCreateWithoutUserInput> | PublicationCreateWithoutUserInput[] | PublicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutUserInput | PublicationCreateOrConnectWithoutUserInput[]
    createMany?: PublicationCreateManyUserInputEnvelope
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ReportCreateWithoutCreatorInput, ReportUncheckedCreateWithoutCreatorInput> | ReportCreateWithoutCreatorInput[] | ReportUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCreatorInput | ReportCreateOrConnectWithoutCreatorInput[]
    createMany?: ReportCreateManyCreatorInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type RolePermissionCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<RolePermissionCreateWithoutAssignedByInput, RolePermissionUncheckedCreateWithoutAssignedByInput> | RolePermissionCreateWithoutAssignedByInput[] | RolePermissionUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutAssignedByInput | RolePermissionCreateOrConnectWithoutAssignedByInput[]
    createMany?: RolePermissionCreateManyAssignedByInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type TokenCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutToUserInput = {
    create?: XOR<TransactionCreateWithoutToUserInput, TransactionUncheckedCreateWithoutToUserInput> | TransactionCreateWithoutToUserInput[] | TransactionUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToUserInput | TransactionCreateOrConnectWithoutToUserInput[]
    createMany?: TransactionCreateManyToUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutFromUserInput = {
    create?: XOR<TransactionCreateWithoutFromUserInput, TransactionUncheckedCreateWithoutFromUserInput> | TransactionCreateWithoutFromUserInput[] | TransactionUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromUserInput | TransactionCreateOrConnectWithoutFromUserInput[]
    createMany?: TransactionCreateManyFromUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UIComponentTemplateCreateNestedManyWithoutCreatorInput = {
    create?: XOR<UIComponentTemplateCreateWithoutCreatorInput, UIComponentTemplateUncheckedCreateWithoutCreatorInput> | UIComponentTemplateCreateWithoutCreatorInput[] | UIComponentTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UIComponentTemplateCreateOrConnectWithoutCreatorInput | UIComponentTemplateCreateOrConnectWithoutCreatorInput[]
    createMany?: UIComponentTemplateCreateManyCreatorInputEnvelope
    connect?: UIComponentTemplateWhereUniqueInput | UIComponentTemplateWhereUniqueInput[]
  }

  export type UserAnswerCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAnswerCreateWithoutUserInput, UserAnswerUncheckedCreateWithoutUserInput> | UserAnswerCreateWithoutUserInput[] | UserAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutUserInput | UserAnswerCreateOrConnectWithoutUserInput[]
    createMany?: UserAnswerCreateManyUserInputEnvelope
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
  }

  export type UserChallengeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput> | UserChallengeCreateWithoutUserInput[] | UserChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutUserInput | UserChallengeCreateOrConnectWithoutUserInput[]
    createMany?: UserChallengeCreateManyUserInputEnvelope
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
  }

  export type UserGroupCreateNestedManyWithoutUserInput = {
    create?: XOR<UserGroupCreateWithoutUserInput, UserGroupUncheckedCreateWithoutUserInput> | UserGroupCreateWithoutUserInput[] | UserGroupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutUserInput | UserGroupCreateOrConnectWithoutUserInput[]
    createMany?: UserGroupCreateManyUserInputEnvelope
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
  }

  export type UserInvitationCreateNestedManyWithoutInvitedUserInput = {
    create?: XOR<UserInvitationCreateWithoutInvitedUserInput, UserInvitationUncheckedCreateWithoutInvitedUserInput> | UserInvitationCreateWithoutInvitedUserInput[] | UserInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutInvitedUserInput | UserInvitationCreateOrConnectWithoutInvitedUserInput[]
    createMany?: UserInvitationCreateManyInvitedUserInputEnvelope
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<UserRoleCreateWithoutAssignedByInput, UserRoleUncheckedCreateWithoutAssignedByInput> | UserRoleCreateWithoutAssignedByInput[] | UserRoleUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutAssignedByInput | UserRoleCreateOrConnectWithoutAssignedByInput[]
    createMany?: UserRoleCreateManyAssignedByInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type StudyRoomCreateNestedManyWithoutHostInput = {
    create?: XOR<StudyRoomCreateWithoutHostInput, StudyRoomUncheckedCreateWithoutHostInput> | StudyRoomCreateWithoutHostInput[] | StudyRoomUncheckedCreateWithoutHostInput[]
    connectOrCreate?: StudyRoomCreateOrConnectWithoutHostInput | StudyRoomCreateOrConnectWithoutHostInput[]
    createMany?: StudyRoomCreateManyHostInputEnvelope
    connect?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
  }

  export type StudyRoomParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<StudyRoomParticipantCreateWithoutUserInput, StudyRoomParticipantUncheckedCreateWithoutUserInput> | StudyRoomParticipantCreateWithoutUserInput[] | StudyRoomParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyRoomParticipantCreateOrConnectWithoutUserInput | StudyRoomParticipantCreateOrConnectWithoutUserInput[]
    createMany?: StudyRoomParticipantCreateManyUserInputEnvelope
    connect?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
  }

  export type StudyRoomMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<StudyRoomMessageCreateWithoutUserInput, StudyRoomMessageUncheckedCreateWithoutUserInput> | StudyRoomMessageCreateWithoutUserInput[] | StudyRoomMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyRoomMessageCreateOrConnectWithoutUserInput | StudyRoomMessageCreateOrConnectWithoutUserInput[]
    createMany?: StudyRoomMessageCreateManyUserInputEnvelope
    connect?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
  }

  export type PersonalityCreateNestedOneWithoutUsersInput = {
    create?: XOR<PersonalityCreateWithoutUsersInput, PersonalityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PersonalityCreateOrConnectWithoutUsersInput
    connect?: PersonalityWhereUniqueInput
  }

  export type VideoPermissionsCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<VideoPermissionsCreateWithoutCreatedByInput, VideoPermissionsUncheckedCreateWithoutCreatedByInput> | VideoPermissionsCreateWithoutCreatedByInput[] | VideoPermissionsUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: VideoPermissionsCreateOrConnectWithoutCreatedByInput | VideoPermissionsCreateOrConnectWithoutCreatedByInput[]
    createMany?: VideoPermissionsCreateManyCreatedByInputEnvelope
    connect?: VideoPermissionsWhereUniqueInput | VideoPermissionsWhereUniqueInput[]
  }

  export type WalletCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type WorldCreateNestedManyWithoutCreatorInput = {
    create?: XOR<WorldCreateWithoutCreatorInput, WorldUncheckedCreateWithoutCreatorInput> | WorldCreateWithoutCreatorInput[] | WorldUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WorldCreateOrConnectWithoutCreatorInput | WorldCreateOrConnectWithoutCreatorInput[]
    createMany?: WorldCreateManyCreatorInputEnvelope
    connect?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
  }

  export type MarketplaceItemCreateNestedManyWithoutSellerInput = {
    create?: XOR<MarketplaceItemCreateWithoutSellerInput, MarketplaceItemUncheckedCreateWithoutSellerInput> | MarketplaceItemCreateWithoutSellerInput[] | MarketplaceItemUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutSellerInput | MarketplaceItemCreateOrConnectWithoutSellerInput[]
    createMany?: MarketplaceItemCreateManySellerInputEnvelope
    connect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
  }

  export type MarketplaceMatchCreateNestedManyWithoutBuyerInput = {
    create?: XOR<MarketplaceMatchCreateWithoutBuyerInput, MarketplaceMatchUncheckedCreateWithoutBuyerInput> | MarketplaceMatchCreateWithoutBuyerInput[] | MarketplaceMatchUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: MarketplaceMatchCreateOrConnectWithoutBuyerInput | MarketplaceMatchCreateOrConnectWithoutBuyerInput[]
    createMany?: MarketplaceMatchCreateManyBuyerInputEnvelope
    connect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
  }

  export type MarketplaceMatchCreateNestedManyWithoutSellerInput = {
    create?: XOR<MarketplaceMatchCreateWithoutSellerInput, MarketplaceMatchUncheckedCreateWithoutSellerInput> | MarketplaceMatchCreateWithoutSellerInput[] | MarketplaceMatchUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: MarketplaceMatchCreateOrConnectWithoutSellerInput | MarketplaceMatchCreateOrConnectWithoutSellerInput[]
    createMany?: MarketplaceMatchCreateManySellerInputEnvelope
    connect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
  }

  export type MatchMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MatchMessageCreateWithoutSenderInput, MatchMessageUncheckedCreateWithoutSenderInput> | MatchMessageCreateWithoutSenderInput[] | MatchMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MatchMessageCreateOrConnectWithoutSenderInput | MatchMessageCreateOrConnectWithoutSenderInput[]
    createMany?: MatchMessageCreateManySenderInputEnvelope
    connect?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
  }

  export type FeedbackReportCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackReportCreateWithoutUserInput, FeedbackReportUncheckedCreateWithoutUserInput> | FeedbackReportCreateWithoutUserInput[] | FeedbackReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackReportCreateOrConnectWithoutUserInput | FeedbackReportCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackReportCreateManyUserInputEnvelope
    connect?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
  }

  export type FeedbackReportCreateNestedManyWithoutAdminUserInput = {
    create?: XOR<FeedbackReportCreateWithoutAdminUserInput, FeedbackReportUncheckedCreateWithoutAdminUserInput> | FeedbackReportCreateWithoutAdminUserInput[] | FeedbackReportUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: FeedbackReportCreateOrConnectWithoutAdminUserInput | FeedbackReportCreateOrConnectWithoutAdminUserInput[]
    createMany?: FeedbackReportCreateManyAdminUserInputEnvelope
    connect?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ActivityCreateWithoutCreatorInput, ActivityUncheckedCreateWithoutCreatorInput> | ActivityCreateWithoutCreatorInput[] | ActivityUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutCreatorInput | ActivityCreateOrConnectWithoutCreatorInput[]
    createMany?: ActivityCreateManyCreatorInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type ExperienceUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ExperienceCreateWithoutCreatorInput, ExperienceUncheckedCreateWithoutCreatorInput> | ExperienceCreateWithoutCreatorInput[] | ExperienceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExperienceCreateOrConnectWithoutCreatorInput | ExperienceCreateOrConnectWithoutCreatorInput[]
    createMany?: ExperienceCreateManyCreatorInputEnvelope
    connect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
  }

  export type GiftCardUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<GiftCardCreateWithoutInviterInput, GiftCardUncheckedCreateWithoutInviterInput> | GiftCardCreateWithoutInviterInput[] | GiftCardUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: GiftCardCreateOrConnectWithoutInviterInput | GiftCardCreateOrConnectWithoutInviterInput[]
    createMany?: GiftCardCreateManyInviterInputEnvelope
    connect?: GiftCardWhereUniqueInput | GiftCardWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput> | GroupCreateWithoutOwnerInput[] | GroupUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutOwnerInput | GroupCreateOrConnectWithoutOwnerInput[]
    createMany?: GroupCreateManyOwnerInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<InvitationTemplateCreateWithoutCreatorInput, InvitationTemplateUncheckedCreateWithoutCreatorInput> | InvitationTemplateCreateWithoutCreatorInput[] | InvitationTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InvitationTemplateCreateOrConnectWithoutCreatorInput | InvitationTemplateCreateOrConnectWithoutCreatorInput[]
    createMany?: InvitationTemplateCreateManyCreatorInputEnvelope
    connect?: InvitationTemplateWhereUniqueInput | InvitationTemplateWhereUniqueInput[]
  }

  export type MeritUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MeritCreateWithoutUserInput, MeritUncheckedCreateWithoutUserInput> | MeritCreateWithoutUserInput[] | MeritUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeritCreateOrConnectWithoutUserInput | MeritCreateOrConnectWithoutUserInput[]
    createMany?: MeritCreateManyUserInputEnvelope
    connect?: MeritWhereUniqueInput | MeritWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PublicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PublicationCreateWithoutUserInput, PublicationUncheckedCreateWithoutUserInput> | PublicationCreateWithoutUserInput[] | PublicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutUserInput | PublicationCreateOrConnectWithoutUserInput[]
    createMany?: PublicationCreateManyUserInputEnvelope
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ReportCreateWithoutCreatorInput, ReportUncheckedCreateWithoutCreatorInput> | ReportCreateWithoutCreatorInput[] | ReportUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCreatorInput | ReportCreateOrConnectWithoutCreatorInput[]
    createMany?: ReportCreateManyCreatorInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<RolePermissionCreateWithoutAssignedByInput, RolePermissionUncheckedCreateWithoutAssignedByInput> | RolePermissionCreateWithoutAssignedByInput[] | RolePermissionUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutAssignedByInput | RolePermissionCreateOrConnectWithoutAssignedByInput[]
    createMany?: RolePermissionCreateManyAssignedByInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type TokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutToUserInput = {
    create?: XOR<TransactionCreateWithoutToUserInput, TransactionUncheckedCreateWithoutToUserInput> | TransactionCreateWithoutToUserInput[] | TransactionUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToUserInput | TransactionCreateOrConnectWithoutToUserInput[]
    createMany?: TransactionCreateManyToUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutFromUserInput = {
    create?: XOR<TransactionCreateWithoutFromUserInput, TransactionUncheckedCreateWithoutFromUserInput> | TransactionCreateWithoutFromUserInput[] | TransactionUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromUserInput | TransactionCreateOrConnectWithoutFromUserInput[]
    createMany?: TransactionCreateManyFromUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<UIComponentTemplateCreateWithoutCreatorInput, UIComponentTemplateUncheckedCreateWithoutCreatorInput> | UIComponentTemplateCreateWithoutCreatorInput[] | UIComponentTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UIComponentTemplateCreateOrConnectWithoutCreatorInput | UIComponentTemplateCreateOrConnectWithoutCreatorInput[]
    createMany?: UIComponentTemplateCreateManyCreatorInputEnvelope
    connect?: UIComponentTemplateWhereUniqueInput | UIComponentTemplateWhereUniqueInput[]
  }

  export type UserAnswerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAnswerCreateWithoutUserInput, UserAnswerUncheckedCreateWithoutUserInput> | UserAnswerCreateWithoutUserInput[] | UserAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutUserInput | UserAnswerCreateOrConnectWithoutUserInput[]
    createMany?: UserAnswerCreateManyUserInputEnvelope
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
  }

  export type UserChallengeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput> | UserChallengeCreateWithoutUserInput[] | UserChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutUserInput | UserChallengeCreateOrConnectWithoutUserInput[]
    createMany?: UserChallengeCreateManyUserInputEnvelope
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
  }

  export type UserGroupUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserGroupCreateWithoutUserInput, UserGroupUncheckedCreateWithoutUserInput> | UserGroupCreateWithoutUserInput[] | UserGroupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutUserInput | UserGroupCreateOrConnectWithoutUserInput[]
    createMany?: UserGroupCreateManyUserInputEnvelope
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
  }

  export type UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput = {
    create?: XOR<UserInvitationCreateWithoutInvitedUserInput, UserInvitationUncheckedCreateWithoutInvitedUserInput> | UserInvitationCreateWithoutInvitedUserInput[] | UserInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutInvitedUserInput | UserInvitationCreateOrConnectWithoutInvitedUserInput[]
    createMany?: UserInvitationCreateManyInvitedUserInputEnvelope
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<UserRoleCreateWithoutAssignedByInput, UserRoleUncheckedCreateWithoutAssignedByInput> | UserRoleCreateWithoutAssignedByInput[] | UserRoleUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutAssignedByInput | UserRoleCreateOrConnectWithoutAssignedByInput[]
    createMany?: UserRoleCreateManyAssignedByInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type StudyRoomUncheckedCreateNestedManyWithoutHostInput = {
    create?: XOR<StudyRoomCreateWithoutHostInput, StudyRoomUncheckedCreateWithoutHostInput> | StudyRoomCreateWithoutHostInput[] | StudyRoomUncheckedCreateWithoutHostInput[]
    connectOrCreate?: StudyRoomCreateOrConnectWithoutHostInput | StudyRoomCreateOrConnectWithoutHostInput[]
    createMany?: StudyRoomCreateManyHostInputEnvelope
    connect?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
  }

  export type StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StudyRoomParticipantCreateWithoutUserInput, StudyRoomParticipantUncheckedCreateWithoutUserInput> | StudyRoomParticipantCreateWithoutUserInput[] | StudyRoomParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyRoomParticipantCreateOrConnectWithoutUserInput | StudyRoomParticipantCreateOrConnectWithoutUserInput[]
    createMany?: StudyRoomParticipantCreateManyUserInputEnvelope
    connect?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
  }

  export type StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StudyRoomMessageCreateWithoutUserInput, StudyRoomMessageUncheckedCreateWithoutUserInput> | StudyRoomMessageCreateWithoutUserInput[] | StudyRoomMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyRoomMessageCreateOrConnectWithoutUserInput | StudyRoomMessageCreateOrConnectWithoutUserInput[]
    createMany?: StudyRoomMessageCreateManyUserInputEnvelope
    connect?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
  }

  export type VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<VideoPermissionsCreateWithoutCreatedByInput, VideoPermissionsUncheckedCreateWithoutCreatedByInput> | VideoPermissionsCreateWithoutCreatedByInput[] | VideoPermissionsUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: VideoPermissionsCreateOrConnectWithoutCreatedByInput | VideoPermissionsCreateOrConnectWithoutCreatedByInput[]
    createMany?: VideoPermissionsCreateManyCreatedByInputEnvelope
    connect?: VideoPermissionsWhereUniqueInput | VideoPermissionsWhereUniqueInput[]
  }

  export type WalletUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type WorldUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<WorldCreateWithoutCreatorInput, WorldUncheckedCreateWithoutCreatorInput> | WorldCreateWithoutCreatorInput[] | WorldUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WorldCreateOrConnectWithoutCreatorInput | WorldCreateOrConnectWithoutCreatorInput[]
    createMany?: WorldCreateManyCreatorInputEnvelope
    connect?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
  }

  export type MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<MarketplaceItemCreateWithoutSellerInput, MarketplaceItemUncheckedCreateWithoutSellerInput> | MarketplaceItemCreateWithoutSellerInput[] | MarketplaceItemUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutSellerInput | MarketplaceItemCreateOrConnectWithoutSellerInput[]
    createMany?: MarketplaceItemCreateManySellerInputEnvelope
    connect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
  }

  export type MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<MarketplaceMatchCreateWithoutBuyerInput, MarketplaceMatchUncheckedCreateWithoutBuyerInput> | MarketplaceMatchCreateWithoutBuyerInput[] | MarketplaceMatchUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: MarketplaceMatchCreateOrConnectWithoutBuyerInput | MarketplaceMatchCreateOrConnectWithoutBuyerInput[]
    createMany?: MarketplaceMatchCreateManyBuyerInputEnvelope
    connect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
  }

  export type MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<MarketplaceMatchCreateWithoutSellerInput, MarketplaceMatchUncheckedCreateWithoutSellerInput> | MarketplaceMatchCreateWithoutSellerInput[] | MarketplaceMatchUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: MarketplaceMatchCreateOrConnectWithoutSellerInput | MarketplaceMatchCreateOrConnectWithoutSellerInput[]
    createMany?: MarketplaceMatchCreateManySellerInputEnvelope
    connect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
  }

  export type MatchMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MatchMessageCreateWithoutSenderInput, MatchMessageUncheckedCreateWithoutSenderInput> | MatchMessageCreateWithoutSenderInput[] | MatchMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MatchMessageCreateOrConnectWithoutSenderInput | MatchMessageCreateOrConnectWithoutSenderInput[]
    createMany?: MatchMessageCreateManySenderInputEnvelope
    connect?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
  }

  export type FeedbackReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackReportCreateWithoutUserInput, FeedbackReportUncheckedCreateWithoutUserInput> | FeedbackReportCreateWithoutUserInput[] | FeedbackReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackReportCreateOrConnectWithoutUserInput | FeedbackReportCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackReportCreateManyUserInputEnvelope
    connect?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
  }

  export type FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput = {
    create?: XOR<FeedbackReportCreateWithoutAdminUserInput, FeedbackReportUncheckedCreateWithoutAdminUserInput> | FeedbackReportCreateWithoutAdminUserInput[] | FeedbackReportUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: FeedbackReportCreateOrConnectWithoutAdminUserInput | FeedbackReportCreateOrConnectWithoutAdminUserInput[]
    createMany?: FeedbackReportCreateManyAdminUserInputEnvelope
    connect?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ActivityUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ActivityCreateWithoutCreatorInput, ActivityUncheckedCreateWithoutCreatorInput> | ActivityCreateWithoutCreatorInput[] | ActivityUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutCreatorInput | ActivityCreateOrConnectWithoutCreatorInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutCreatorInput | ActivityUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ActivityCreateManyCreatorInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutCreatorInput | ActivityUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutCreatorInput | ActivityUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutUserInput | LikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutUserInput | LikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutUserInput | LikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type ExperienceUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ExperienceCreateWithoutCreatorInput, ExperienceUncheckedCreateWithoutCreatorInput> | ExperienceCreateWithoutCreatorInput[] | ExperienceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExperienceCreateOrConnectWithoutCreatorInput | ExperienceCreateOrConnectWithoutCreatorInput[]
    upsert?: ExperienceUpsertWithWhereUniqueWithoutCreatorInput | ExperienceUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ExperienceCreateManyCreatorInputEnvelope
    set?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    disconnect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    delete?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    connect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    update?: ExperienceUpdateWithWhereUniqueWithoutCreatorInput | ExperienceUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ExperienceUpdateManyWithWhereWithoutCreatorInput | ExperienceUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ExperienceScalarWhereInput | ExperienceScalarWhereInput[]
  }

  export type GiftCardUpdateManyWithoutInviterNestedInput = {
    create?: XOR<GiftCardCreateWithoutInviterInput, GiftCardUncheckedCreateWithoutInviterInput> | GiftCardCreateWithoutInviterInput[] | GiftCardUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: GiftCardCreateOrConnectWithoutInviterInput | GiftCardCreateOrConnectWithoutInviterInput[]
    upsert?: GiftCardUpsertWithWhereUniqueWithoutInviterInput | GiftCardUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: GiftCardCreateManyInviterInputEnvelope
    set?: GiftCardWhereUniqueInput | GiftCardWhereUniqueInput[]
    disconnect?: GiftCardWhereUniqueInput | GiftCardWhereUniqueInput[]
    delete?: GiftCardWhereUniqueInput | GiftCardWhereUniqueInput[]
    connect?: GiftCardWhereUniqueInput | GiftCardWhereUniqueInput[]
    update?: GiftCardUpdateWithWhereUniqueWithoutInviterInput | GiftCardUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: GiftCardUpdateManyWithWhereWithoutInviterInput | GiftCardUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: GiftCardScalarWhereInput | GiftCardScalarWhereInput[]
  }

  export type GroupUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput> | GroupCreateWithoutOwnerInput[] | GroupUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutOwnerInput | GroupCreateOrConnectWithoutOwnerInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutOwnerInput | GroupUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: GroupCreateManyOwnerInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutOwnerInput | GroupUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutOwnerInput | GroupUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type InvitationTemplateUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<InvitationTemplateCreateWithoutCreatorInput, InvitationTemplateUncheckedCreateWithoutCreatorInput> | InvitationTemplateCreateWithoutCreatorInput[] | InvitationTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InvitationTemplateCreateOrConnectWithoutCreatorInput | InvitationTemplateCreateOrConnectWithoutCreatorInput[]
    upsert?: InvitationTemplateUpsertWithWhereUniqueWithoutCreatorInput | InvitationTemplateUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: InvitationTemplateCreateManyCreatorInputEnvelope
    set?: InvitationTemplateWhereUniqueInput | InvitationTemplateWhereUniqueInput[]
    disconnect?: InvitationTemplateWhereUniqueInput | InvitationTemplateWhereUniqueInput[]
    delete?: InvitationTemplateWhereUniqueInput | InvitationTemplateWhereUniqueInput[]
    connect?: InvitationTemplateWhereUniqueInput | InvitationTemplateWhereUniqueInput[]
    update?: InvitationTemplateUpdateWithWhereUniqueWithoutCreatorInput | InvitationTemplateUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: InvitationTemplateUpdateManyWithWhereWithoutCreatorInput | InvitationTemplateUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: InvitationTemplateScalarWhereInput | InvitationTemplateScalarWhereInput[]
  }

  export type MeritUpdateManyWithoutUserNestedInput = {
    create?: XOR<MeritCreateWithoutUserInput, MeritUncheckedCreateWithoutUserInput> | MeritCreateWithoutUserInput[] | MeritUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeritCreateOrConnectWithoutUserInput | MeritCreateOrConnectWithoutUserInput[]
    upsert?: MeritUpsertWithWhereUniqueWithoutUserInput | MeritUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MeritCreateManyUserInputEnvelope
    set?: MeritWhereUniqueInput | MeritWhereUniqueInput[]
    disconnect?: MeritWhereUniqueInput | MeritWhereUniqueInput[]
    delete?: MeritWhereUniqueInput | MeritWhereUniqueInput[]
    connect?: MeritWhereUniqueInput | MeritWhereUniqueInput[]
    update?: MeritUpdateWithWhereUniqueWithoutUserInput | MeritUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MeritUpdateManyWithWhereWithoutUserInput | MeritUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MeritScalarWhereInput | MeritScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PublicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<PublicationCreateWithoutUserInput, PublicationUncheckedCreateWithoutUserInput> | PublicationCreateWithoutUserInput[] | PublicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutUserInput | PublicationCreateOrConnectWithoutUserInput[]
    upsert?: PublicationUpsertWithWhereUniqueWithoutUserInput | PublicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PublicationCreateManyUserInputEnvelope
    set?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    disconnect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    delete?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    update?: PublicationUpdateWithWhereUniqueWithoutUserInput | PublicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PublicationUpdateManyWithWhereWithoutUserInput | PublicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ReportCreateWithoutCreatorInput, ReportUncheckedCreateWithoutCreatorInput> | ReportCreateWithoutCreatorInput[] | ReportUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCreatorInput | ReportCreateOrConnectWithoutCreatorInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutCreatorInput | ReportUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ReportCreateManyCreatorInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutCreatorInput | ReportUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutCreatorInput | ReportUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type RolePermissionUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<RolePermissionCreateWithoutAssignedByInput, RolePermissionUncheckedCreateWithoutAssignedByInput> | RolePermissionCreateWithoutAssignedByInput[] | RolePermissionUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutAssignedByInput | RolePermissionCreateOrConnectWithoutAssignedByInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutAssignedByInput | RolePermissionUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: RolePermissionCreateManyAssignedByInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutAssignedByInput | RolePermissionUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutAssignedByInput | RolePermissionUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type TokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutUserInput | TokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutUserInput | TokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutUserInput | TokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutToUserNestedInput = {
    create?: XOR<TransactionCreateWithoutToUserInput, TransactionUncheckedCreateWithoutToUserInput> | TransactionCreateWithoutToUserInput[] | TransactionUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToUserInput | TransactionCreateOrConnectWithoutToUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutToUserInput | TransactionUpsertWithWhereUniqueWithoutToUserInput[]
    createMany?: TransactionCreateManyToUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutToUserInput | TransactionUpdateWithWhereUniqueWithoutToUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutToUserInput | TransactionUpdateManyWithWhereWithoutToUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<TransactionCreateWithoutFromUserInput, TransactionUncheckedCreateWithoutFromUserInput> | TransactionCreateWithoutFromUserInput[] | TransactionUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromUserInput | TransactionCreateOrConnectWithoutFromUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutFromUserInput | TransactionUpsertWithWhereUniqueWithoutFromUserInput[]
    createMany?: TransactionCreateManyFromUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutFromUserInput | TransactionUpdateWithWhereUniqueWithoutFromUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutFromUserInput | TransactionUpdateManyWithWhereWithoutFromUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UIComponentTemplateUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<UIComponentTemplateCreateWithoutCreatorInput, UIComponentTemplateUncheckedCreateWithoutCreatorInput> | UIComponentTemplateCreateWithoutCreatorInput[] | UIComponentTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UIComponentTemplateCreateOrConnectWithoutCreatorInput | UIComponentTemplateCreateOrConnectWithoutCreatorInput[]
    upsert?: UIComponentTemplateUpsertWithWhereUniqueWithoutCreatorInput | UIComponentTemplateUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: UIComponentTemplateCreateManyCreatorInputEnvelope
    set?: UIComponentTemplateWhereUniqueInput | UIComponentTemplateWhereUniqueInput[]
    disconnect?: UIComponentTemplateWhereUniqueInput | UIComponentTemplateWhereUniqueInput[]
    delete?: UIComponentTemplateWhereUniqueInput | UIComponentTemplateWhereUniqueInput[]
    connect?: UIComponentTemplateWhereUniqueInput | UIComponentTemplateWhereUniqueInput[]
    update?: UIComponentTemplateUpdateWithWhereUniqueWithoutCreatorInput | UIComponentTemplateUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: UIComponentTemplateUpdateManyWithWhereWithoutCreatorInput | UIComponentTemplateUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: UIComponentTemplateScalarWhereInput | UIComponentTemplateScalarWhereInput[]
  }

  export type UserAnswerUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAnswerCreateWithoutUserInput, UserAnswerUncheckedCreateWithoutUserInput> | UserAnswerCreateWithoutUserInput[] | UserAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutUserInput | UserAnswerCreateOrConnectWithoutUserInput[]
    upsert?: UserAnswerUpsertWithWhereUniqueWithoutUserInput | UserAnswerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAnswerCreateManyUserInputEnvelope
    set?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    disconnect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    delete?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    update?: UserAnswerUpdateWithWhereUniqueWithoutUserInput | UserAnswerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAnswerUpdateManyWithWhereWithoutUserInput | UserAnswerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAnswerScalarWhereInput | UserAnswerScalarWhereInput[]
  }

  export type UserChallengeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput> | UserChallengeCreateWithoutUserInput[] | UserChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutUserInput | UserChallengeCreateOrConnectWithoutUserInput[]
    upsert?: UserChallengeUpsertWithWhereUniqueWithoutUserInput | UserChallengeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserChallengeCreateManyUserInputEnvelope
    set?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    disconnect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    delete?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    update?: UserChallengeUpdateWithWhereUniqueWithoutUserInput | UserChallengeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserChallengeUpdateManyWithWhereWithoutUserInput | UserChallengeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
  }

  export type UserGroupUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserGroupCreateWithoutUserInput, UserGroupUncheckedCreateWithoutUserInput> | UserGroupCreateWithoutUserInput[] | UserGroupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutUserInput | UserGroupCreateOrConnectWithoutUserInput[]
    upsert?: UserGroupUpsertWithWhereUniqueWithoutUserInput | UserGroupUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserGroupCreateManyUserInputEnvelope
    set?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    disconnect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    delete?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    update?: UserGroupUpdateWithWhereUniqueWithoutUserInput | UserGroupUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserGroupUpdateManyWithWhereWithoutUserInput | UserGroupUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
  }

  export type UserInvitationUpdateManyWithoutInvitedUserNestedInput = {
    create?: XOR<UserInvitationCreateWithoutInvitedUserInput, UserInvitationUncheckedCreateWithoutInvitedUserInput> | UserInvitationCreateWithoutInvitedUserInput[] | UserInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutInvitedUserInput | UserInvitationCreateOrConnectWithoutInvitedUserInput[]
    upsert?: UserInvitationUpsertWithWhereUniqueWithoutInvitedUserInput | UserInvitationUpsertWithWhereUniqueWithoutInvitedUserInput[]
    createMany?: UserInvitationCreateManyInvitedUserInputEnvelope
    set?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    disconnect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    delete?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    update?: UserInvitationUpdateWithWhereUniqueWithoutInvitedUserInput | UserInvitationUpdateWithWhereUniqueWithoutInvitedUserInput[]
    updateMany?: UserInvitationUpdateManyWithWhereWithoutInvitedUserInput | UserInvitationUpdateManyWithWhereWithoutInvitedUserInput[]
    deleteMany?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<UserRoleCreateWithoutAssignedByInput, UserRoleUncheckedCreateWithoutAssignedByInput> | UserRoleCreateWithoutAssignedByInput[] | UserRoleUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutAssignedByInput | UserRoleCreateOrConnectWithoutAssignedByInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutAssignedByInput | UserRoleUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: UserRoleCreateManyAssignedByInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutAssignedByInput | UserRoleUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutAssignedByInput | UserRoleUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type StudyRoomUpdateManyWithoutHostNestedInput = {
    create?: XOR<StudyRoomCreateWithoutHostInput, StudyRoomUncheckedCreateWithoutHostInput> | StudyRoomCreateWithoutHostInput[] | StudyRoomUncheckedCreateWithoutHostInput[]
    connectOrCreate?: StudyRoomCreateOrConnectWithoutHostInput | StudyRoomCreateOrConnectWithoutHostInput[]
    upsert?: StudyRoomUpsertWithWhereUniqueWithoutHostInput | StudyRoomUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: StudyRoomCreateManyHostInputEnvelope
    set?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
    disconnect?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
    delete?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
    connect?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
    update?: StudyRoomUpdateWithWhereUniqueWithoutHostInput | StudyRoomUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: StudyRoomUpdateManyWithWhereWithoutHostInput | StudyRoomUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: StudyRoomScalarWhereInput | StudyRoomScalarWhereInput[]
  }

  export type StudyRoomParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudyRoomParticipantCreateWithoutUserInput, StudyRoomParticipantUncheckedCreateWithoutUserInput> | StudyRoomParticipantCreateWithoutUserInput[] | StudyRoomParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyRoomParticipantCreateOrConnectWithoutUserInput | StudyRoomParticipantCreateOrConnectWithoutUserInput[]
    upsert?: StudyRoomParticipantUpsertWithWhereUniqueWithoutUserInput | StudyRoomParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudyRoomParticipantCreateManyUserInputEnvelope
    set?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
    disconnect?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
    delete?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
    connect?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
    update?: StudyRoomParticipantUpdateWithWhereUniqueWithoutUserInput | StudyRoomParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudyRoomParticipantUpdateManyWithWhereWithoutUserInput | StudyRoomParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudyRoomParticipantScalarWhereInput | StudyRoomParticipantScalarWhereInput[]
  }

  export type StudyRoomMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudyRoomMessageCreateWithoutUserInput, StudyRoomMessageUncheckedCreateWithoutUserInput> | StudyRoomMessageCreateWithoutUserInput[] | StudyRoomMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyRoomMessageCreateOrConnectWithoutUserInput | StudyRoomMessageCreateOrConnectWithoutUserInput[]
    upsert?: StudyRoomMessageUpsertWithWhereUniqueWithoutUserInput | StudyRoomMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudyRoomMessageCreateManyUserInputEnvelope
    set?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
    disconnect?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
    delete?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
    connect?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
    update?: StudyRoomMessageUpdateWithWhereUniqueWithoutUserInput | StudyRoomMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudyRoomMessageUpdateManyWithWhereWithoutUserInput | StudyRoomMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudyRoomMessageScalarWhereInput | StudyRoomMessageScalarWhereInput[]
  }

  export type PersonalityUpdateOneWithoutUsersNestedInput = {
    create?: XOR<PersonalityCreateWithoutUsersInput, PersonalityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PersonalityCreateOrConnectWithoutUsersInput
    upsert?: PersonalityUpsertWithoutUsersInput
    disconnect?: PersonalityWhereInput | boolean
    delete?: PersonalityWhereInput | boolean
    connect?: PersonalityWhereUniqueInput
    update?: XOR<XOR<PersonalityUpdateToOneWithWhereWithoutUsersInput, PersonalityUpdateWithoutUsersInput>, PersonalityUncheckedUpdateWithoutUsersInput>
  }

  export type VideoPermissionsUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<VideoPermissionsCreateWithoutCreatedByInput, VideoPermissionsUncheckedCreateWithoutCreatedByInput> | VideoPermissionsCreateWithoutCreatedByInput[] | VideoPermissionsUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: VideoPermissionsCreateOrConnectWithoutCreatedByInput | VideoPermissionsCreateOrConnectWithoutCreatedByInput[]
    upsert?: VideoPermissionsUpsertWithWhereUniqueWithoutCreatedByInput | VideoPermissionsUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: VideoPermissionsCreateManyCreatedByInputEnvelope
    set?: VideoPermissionsWhereUniqueInput | VideoPermissionsWhereUniqueInput[]
    disconnect?: VideoPermissionsWhereUniqueInput | VideoPermissionsWhereUniqueInput[]
    delete?: VideoPermissionsWhereUniqueInput | VideoPermissionsWhereUniqueInput[]
    connect?: VideoPermissionsWhereUniqueInput | VideoPermissionsWhereUniqueInput[]
    update?: VideoPermissionsUpdateWithWhereUniqueWithoutCreatedByInput | VideoPermissionsUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: VideoPermissionsUpdateManyWithWhereWithoutCreatedByInput | VideoPermissionsUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: VideoPermissionsScalarWhereInput | VideoPermissionsScalarWhereInput[]
  }

  export type WalletUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutUserInput, WalletUpdateWithoutUserInput>, WalletUncheckedUpdateWithoutUserInput>
  }

  export type WorldUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<WorldCreateWithoutCreatorInput, WorldUncheckedCreateWithoutCreatorInput> | WorldCreateWithoutCreatorInput[] | WorldUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WorldCreateOrConnectWithoutCreatorInput | WorldCreateOrConnectWithoutCreatorInput[]
    upsert?: WorldUpsertWithWhereUniqueWithoutCreatorInput | WorldUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: WorldCreateManyCreatorInputEnvelope
    set?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
    disconnect?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
    delete?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
    connect?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
    update?: WorldUpdateWithWhereUniqueWithoutCreatorInput | WorldUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: WorldUpdateManyWithWhereWithoutCreatorInput | WorldUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: WorldScalarWhereInput | WorldScalarWhereInput[]
  }

  export type MarketplaceItemUpdateManyWithoutSellerNestedInput = {
    create?: XOR<MarketplaceItemCreateWithoutSellerInput, MarketplaceItemUncheckedCreateWithoutSellerInput> | MarketplaceItemCreateWithoutSellerInput[] | MarketplaceItemUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutSellerInput | MarketplaceItemCreateOrConnectWithoutSellerInput[]
    upsert?: MarketplaceItemUpsertWithWhereUniqueWithoutSellerInput | MarketplaceItemUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: MarketplaceItemCreateManySellerInputEnvelope
    set?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    disconnect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    delete?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    connect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    update?: MarketplaceItemUpdateWithWhereUniqueWithoutSellerInput | MarketplaceItemUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: MarketplaceItemUpdateManyWithWhereWithoutSellerInput | MarketplaceItemUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: MarketplaceItemScalarWhereInput | MarketplaceItemScalarWhereInput[]
  }

  export type MarketplaceMatchUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<MarketplaceMatchCreateWithoutBuyerInput, MarketplaceMatchUncheckedCreateWithoutBuyerInput> | MarketplaceMatchCreateWithoutBuyerInput[] | MarketplaceMatchUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: MarketplaceMatchCreateOrConnectWithoutBuyerInput | MarketplaceMatchCreateOrConnectWithoutBuyerInput[]
    upsert?: MarketplaceMatchUpsertWithWhereUniqueWithoutBuyerInput | MarketplaceMatchUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: MarketplaceMatchCreateManyBuyerInputEnvelope
    set?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    disconnect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    delete?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    connect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    update?: MarketplaceMatchUpdateWithWhereUniqueWithoutBuyerInput | MarketplaceMatchUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: MarketplaceMatchUpdateManyWithWhereWithoutBuyerInput | MarketplaceMatchUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: MarketplaceMatchScalarWhereInput | MarketplaceMatchScalarWhereInput[]
  }

  export type MarketplaceMatchUpdateManyWithoutSellerNestedInput = {
    create?: XOR<MarketplaceMatchCreateWithoutSellerInput, MarketplaceMatchUncheckedCreateWithoutSellerInput> | MarketplaceMatchCreateWithoutSellerInput[] | MarketplaceMatchUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: MarketplaceMatchCreateOrConnectWithoutSellerInput | MarketplaceMatchCreateOrConnectWithoutSellerInput[]
    upsert?: MarketplaceMatchUpsertWithWhereUniqueWithoutSellerInput | MarketplaceMatchUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: MarketplaceMatchCreateManySellerInputEnvelope
    set?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    disconnect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    delete?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    connect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    update?: MarketplaceMatchUpdateWithWhereUniqueWithoutSellerInput | MarketplaceMatchUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: MarketplaceMatchUpdateManyWithWhereWithoutSellerInput | MarketplaceMatchUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: MarketplaceMatchScalarWhereInput | MarketplaceMatchScalarWhereInput[]
  }

  export type MatchMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MatchMessageCreateWithoutSenderInput, MatchMessageUncheckedCreateWithoutSenderInput> | MatchMessageCreateWithoutSenderInput[] | MatchMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MatchMessageCreateOrConnectWithoutSenderInput | MatchMessageCreateOrConnectWithoutSenderInput[]
    upsert?: MatchMessageUpsertWithWhereUniqueWithoutSenderInput | MatchMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MatchMessageCreateManySenderInputEnvelope
    set?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
    disconnect?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
    delete?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
    connect?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
    update?: MatchMessageUpdateWithWhereUniqueWithoutSenderInput | MatchMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MatchMessageUpdateManyWithWhereWithoutSenderInput | MatchMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MatchMessageScalarWhereInput | MatchMessageScalarWhereInput[]
  }

  export type FeedbackReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackReportCreateWithoutUserInput, FeedbackReportUncheckedCreateWithoutUserInput> | FeedbackReportCreateWithoutUserInput[] | FeedbackReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackReportCreateOrConnectWithoutUserInput | FeedbackReportCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackReportUpsertWithWhereUniqueWithoutUserInput | FeedbackReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackReportCreateManyUserInputEnvelope
    set?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
    disconnect?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
    delete?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
    connect?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
    update?: FeedbackReportUpdateWithWhereUniqueWithoutUserInput | FeedbackReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackReportUpdateManyWithWhereWithoutUserInput | FeedbackReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackReportScalarWhereInput | FeedbackReportScalarWhereInput[]
  }

  export type FeedbackReportUpdateManyWithoutAdminUserNestedInput = {
    create?: XOR<FeedbackReportCreateWithoutAdminUserInput, FeedbackReportUncheckedCreateWithoutAdminUserInput> | FeedbackReportCreateWithoutAdminUserInput[] | FeedbackReportUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: FeedbackReportCreateOrConnectWithoutAdminUserInput | FeedbackReportCreateOrConnectWithoutAdminUserInput[]
    upsert?: FeedbackReportUpsertWithWhereUniqueWithoutAdminUserInput | FeedbackReportUpsertWithWhereUniqueWithoutAdminUserInput[]
    createMany?: FeedbackReportCreateManyAdminUserInputEnvelope
    set?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
    disconnect?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
    delete?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
    connect?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
    update?: FeedbackReportUpdateWithWhereUniqueWithoutAdminUserInput | FeedbackReportUpdateWithWhereUniqueWithoutAdminUserInput[]
    updateMany?: FeedbackReportUpdateManyWithWhereWithoutAdminUserInput | FeedbackReportUpdateManyWithWhereWithoutAdminUserInput[]
    deleteMany?: FeedbackReportScalarWhereInput | FeedbackReportScalarWhereInput[]
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ActivityCreateWithoutCreatorInput, ActivityUncheckedCreateWithoutCreatorInput> | ActivityCreateWithoutCreatorInput[] | ActivityUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutCreatorInput | ActivityCreateOrConnectWithoutCreatorInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutCreatorInput | ActivityUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ActivityCreateManyCreatorInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutCreatorInput | ActivityUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutCreatorInput | ActivityUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput> | LikeCreateWithoutUserInput[] | LikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUserInput | LikeCreateOrConnectWithoutUserInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutUserInput | LikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LikeCreateManyUserInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutUserInput | LikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutUserInput | LikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type ExperienceUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ExperienceCreateWithoutCreatorInput, ExperienceUncheckedCreateWithoutCreatorInput> | ExperienceCreateWithoutCreatorInput[] | ExperienceUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExperienceCreateOrConnectWithoutCreatorInput | ExperienceCreateOrConnectWithoutCreatorInput[]
    upsert?: ExperienceUpsertWithWhereUniqueWithoutCreatorInput | ExperienceUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ExperienceCreateManyCreatorInputEnvelope
    set?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    disconnect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    delete?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    connect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    update?: ExperienceUpdateWithWhereUniqueWithoutCreatorInput | ExperienceUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ExperienceUpdateManyWithWhereWithoutCreatorInput | ExperienceUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ExperienceScalarWhereInput | ExperienceScalarWhereInput[]
  }

  export type GiftCardUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<GiftCardCreateWithoutInviterInput, GiftCardUncheckedCreateWithoutInviterInput> | GiftCardCreateWithoutInviterInput[] | GiftCardUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: GiftCardCreateOrConnectWithoutInviterInput | GiftCardCreateOrConnectWithoutInviterInput[]
    upsert?: GiftCardUpsertWithWhereUniqueWithoutInviterInput | GiftCardUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: GiftCardCreateManyInviterInputEnvelope
    set?: GiftCardWhereUniqueInput | GiftCardWhereUniqueInput[]
    disconnect?: GiftCardWhereUniqueInput | GiftCardWhereUniqueInput[]
    delete?: GiftCardWhereUniqueInput | GiftCardWhereUniqueInput[]
    connect?: GiftCardWhereUniqueInput | GiftCardWhereUniqueInput[]
    update?: GiftCardUpdateWithWhereUniqueWithoutInviterInput | GiftCardUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: GiftCardUpdateManyWithWhereWithoutInviterInput | GiftCardUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: GiftCardScalarWhereInput | GiftCardScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput> | GroupCreateWithoutOwnerInput[] | GroupUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutOwnerInput | GroupCreateOrConnectWithoutOwnerInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutOwnerInput | GroupUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: GroupCreateManyOwnerInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutOwnerInput | GroupUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutOwnerInput | GroupUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<InvitationTemplateCreateWithoutCreatorInput, InvitationTemplateUncheckedCreateWithoutCreatorInput> | InvitationTemplateCreateWithoutCreatorInput[] | InvitationTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: InvitationTemplateCreateOrConnectWithoutCreatorInput | InvitationTemplateCreateOrConnectWithoutCreatorInput[]
    upsert?: InvitationTemplateUpsertWithWhereUniqueWithoutCreatorInput | InvitationTemplateUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: InvitationTemplateCreateManyCreatorInputEnvelope
    set?: InvitationTemplateWhereUniqueInput | InvitationTemplateWhereUniqueInput[]
    disconnect?: InvitationTemplateWhereUniqueInput | InvitationTemplateWhereUniqueInput[]
    delete?: InvitationTemplateWhereUniqueInput | InvitationTemplateWhereUniqueInput[]
    connect?: InvitationTemplateWhereUniqueInput | InvitationTemplateWhereUniqueInput[]
    update?: InvitationTemplateUpdateWithWhereUniqueWithoutCreatorInput | InvitationTemplateUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: InvitationTemplateUpdateManyWithWhereWithoutCreatorInput | InvitationTemplateUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: InvitationTemplateScalarWhereInput | InvitationTemplateScalarWhereInput[]
  }

  export type MeritUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MeritCreateWithoutUserInput, MeritUncheckedCreateWithoutUserInput> | MeritCreateWithoutUserInput[] | MeritUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeritCreateOrConnectWithoutUserInput | MeritCreateOrConnectWithoutUserInput[]
    upsert?: MeritUpsertWithWhereUniqueWithoutUserInput | MeritUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MeritCreateManyUserInputEnvelope
    set?: MeritWhereUniqueInput | MeritWhereUniqueInput[]
    disconnect?: MeritWhereUniqueInput | MeritWhereUniqueInput[]
    delete?: MeritWhereUniqueInput | MeritWhereUniqueInput[]
    connect?: MeritWhereUniqueInput | MeritWhereUniqueInput[]
    update?: MeritUpdateWithWhereUniqueWithoutUserInput | MeritUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MeritUpdateManyWithWhereWithoutUserInput | MeritUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MeritScalarWhereInput | MeritScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PublicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PublicationCreateWithoutUserInput, PublicationUncheckedCreateWithoutUserInput> | PublicationCreateWithoutUserInput[] | PublicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutUserInput | PublicationCreateOrConnectWithoutUserInput[]
    upsert?: PublicationUpsertWithWhereUniqueWithoutUserInput | PublicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PublicationCreateManyUserInputEnvelope
    set?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    disconnect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    delete?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    update?: PublicationUpdateWithWhereUniqueWithoutUserInput | PublicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PublicationUpdateManyWithWhereWithoutUserInput | PublicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ReportCreateWithoutCreatorInput, ReportUncheckedCreateWithoutCreatorInput> | ReportCreateWithoutCreatorInput[] | ReportUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCreatorInput | ReportCreateOrConnectWithoutCreatorInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutCreatorInput | ReportUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ReportCreateManyCreatorInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutCreatorInput | ReportUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutCreatorInput | ReportUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<RolePermissionCreateWithoutAssignedByInput, RolePermissionUncheckedCreateWithoutAssignedByInput> | RolePermissionCreateWithoutAssignedByInput[] | RolePermissionUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutAssignedByInput | RolePermissionCreateOrConnectWithoutAssignedByInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutAssignedByInput | RolePermissionUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: RolePermissionCreateManyAssignedByInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutAssignedByInput | RolePermissionUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutAssignedByInput | RolePermissionUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type TokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutUserInput | TokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutUserInput | TokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutUserInput | TokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutToUserNestedInput = {
    create?: XOR<TransactionCreateWithoutToUserInput, TransactionUncheckedCreateWithoutToUserInput> | TransactionCreateWithoutToUserInput[] | TransactionUncheckedCreateWithoutToUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToUserInput | TransactionCreateOrConnectWithoutToUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutToUserInput | TransactionUpsertWithWhereUniqueWithoutToUserInput[]
    createMany?: TransactionCreateManyToUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutToUserInput | TransactionUpdateWithWhereUniqueWithoutToUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutToUserInput | TransactionUpdateManyWithWhereWithoutToUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<TransactionCreateWithoutFromUserInput, TransactionUncheckedCreateWithoutFromUserInput> | TransactionCreateWithoutFromUserInput[] | TransactionUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromUserInput | TransactionCreateOrConnectWithoutFromUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutFromUserInput | TransactionUpsertWithWhereUniqueWithoutFromUserInput[]
    createMany?: TransactionCreateManyFromUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutFromUserInput | TransactionUpdateWithWhereUniqueWithoutFromUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutFromUserInput | TransactionUpdateManyWithWhereWithoutFromUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<UIComponentTemplateCreateWithoutCreatorInput, UIComponentTemplateUncheckedCreateWithoutCreatorInput> | UIComponentTemplateCreateWithoutCreatorInput[] | UIComponentTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: UIComponentTemplateCreateOrConnectWithoutCreatorInput | UIComponentTemplateCreateOrConnectWithoutCreatorInput[]
    upsert?: UIComponentTemplateUpsertWithWhereUniqueWithoutCreatorInput | UIComponentTemplateUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: UIComponentTemplateCreateManyCreatorInputEnvelope
    set?: UIComponentTemplateWhereUniqueInput | UIComponentTemplateWhereUniqueInput[]
    disconnect?: UIComponentTemplateWhereUniqueInput | UIComponentTemplateWhereUniqueInput[]
    delete?: UIComponentTemplateWhereUniqueInput | UIComponentTemplateWhereUniqueInput[]
    connect?: UIComponentTemplateWhereUniqueInput | UIComponentTemplateWhereUniqueInput[]
    update?: UIComponentTemplateUpdateWithWhereUniqueWithoutCreatorInput | UIComponentTemplateUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: UIComponentTemplateUpdateManyWithWhereWithoutCreatorInput | UIComponentTemplateUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: UIComponentTemplateScalarWhereInput | UIComponentTemplateScalarWhereInput[]
  }

  export type UserAnswerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAnswerCreateWithoutUserInput, UserAnswerUncheckedCreateWithoutUserInput> | UserAnswerCreateWithoutUserInput[] | UserAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutUserInput | UserAnswerCreateOrConnectWithoutUserInput[]
    upsert?: UserAnswerUpsertWithWhereUniqueWithoutUserInput | UserAnswerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAnswerCreateManyUserInputEnvelope
    set?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    disconnect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    delete?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    update?: UserAnswerUpdateWithWhereUniqueWithoutUserInput | UserAnswerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAnswerUpdateManyWithWhereWithoutUserInput | UserAnswerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAnswerScalarWhereInput | UserAnswerScalarWhereInput[]
  }

  export type UserChallengeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput> | UserChallengeCreateWithoutUserInput[] | UserChallengeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutUserInput | UserChallengeCreateOrConnectWithoutUserInput[]
    upsert?: UserChallengeUpsertWithWhereUniqueWithoutUserInput | UserChallengeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserChallengeCreateManyUserInputEnvelope
    set?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    disconnect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    delete?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    update?: UserChallengeUpdateWithWhereUniqueWithoutUserInput | UserChallengeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserChallengeUpdateManyWithWhereWithoutUserInput | UserChallengeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
  }

  export type UserGroupUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserGroupCreateWithoutUserInput, UserGroupUncheckedCreateWithoutUserInput> | UserGroupCreateWithoutUserInput[] | UserGroupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutUserInput | UserGroupCreateOrConnectWithoutUserInput[]
    upsert?: UserGroupUpsertWithWhereUniqueWithoutUserInput | UserGroupUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserGroupCreateManyUserInputEnvelope
    set?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    disconnect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    delete?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    update?: UserGroupUpdateWithWhereUniqueWithoutUserInput | UserGroupUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserGroupUpdateManyWithWhereWithoutUserInput | UserGroupUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
  }

  export type UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput = {
    create?: XOR<UserInvitationCreateWithoutInvitedUserInput, UserInvitationUncheckedCreateWithoutInvitedUserInput> | UserInvitationCreateWithoutInvitedUserInput[] | UserInvitationUncheckedCreateWithoutInvitedUserInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutInvitedUserInput | UserInvitationCreateOrConnectWithoutInvitedUserInput[]
    upsert?: UserInvitationUpsertWithWhereUniqueWithoutInvitedUserInput | UserInvitationUpsertWithWhereUniqueWithoutInvitedUserInput[]
    createMany?: UserInvitationCreateManyInvitedUserInputEnvelope
    set?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    disconnect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    delete?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    update?: UserInvitationUpdateWithWhereUniqueWithoutInvitedUserInput | UserInvitationUpdateWithWhereUniqueWithoutInvitedUserInput[]
    updateMany?: UserInvitationUpdateManyWithWhereWithoutInvitedUserInput | UserInvitationUpdateManyWithWhereWithoutInvitedUserInput[]
    deleteMany?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<UserRoleCreateWithoutAssignedByInput, UserRoleUncheckedCreateWithoutAssignedByInput> | UserRoleCreateWithoutAssignedByInput[] | UserRoleUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutAssignedByInput | UserRoleCreateOrConnectWithoutAssignedByInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutAssignedByInput | UserRoleUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: UserRoleCreateManyAssignedByInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutAssignedByInput | UserRoleUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutAssignedByInput | UserRoleUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type StudyRoomUncheckedUpdateManyWithoutHostNestedInput = {
    create?: XOR<StudyRoomCreateWithoutHostInput, StudyRoomUncheckedCreateWithoutHostInput> | StudyRoomCreateWithoutHostInput[] | StudyRoomUncheckedCreateWithoutHostInput[]
    connectOrCreate?: StudyRoomCreateOrConnectWithoutHostInput | StudyRoomCreateOrConnectWithoutHostInput[]
    upsert?: StudyRoomUpsertWithWhereUniqueWithoutHostInput | StudyRoomUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: StudyRoomCreateManyHostInputEnvelope
    set?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
    disconnect?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
    delete?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
    connect?: StudyRoomWhereUniqueInput | StudyRoomWhereUniqueInput[]
    update?: StudyRoomUpdateWithWhereUniqueWithoutHostInput | StudyRoomUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: StudyRoomUpdateManyWithWhereWithoutHostInput | StudyRoomUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: StudyRoomScalarWhereInput | StudyRoomScalarWhereInput[]
  }

  export type StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudyRoomParticipantCreateWithoutUserInput, StudyRoomParticipantUncheckedCreateWithoutUserInput> | StudyRoomParticipantCreateWithoutUserInput[] | StudyRoomParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyRoomParticipantCreateOrConnectWithoutUserInput | StudyRoomParticipantCreateOrConnectWithoutUserInput[]
    upsert?: StudyRoomParticipantUpsertWithWhereUniqueWithoutUserInput | StudyRoomParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudyRoomParticipantCreateManyUserInputEnvelope
    set?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
    disconnect?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
    delete?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
    connect?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
    update?: StudyRoomParticipantUpdateWithWhereUniqueWithoutUserInput | StudyRoomParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudyRoomParticipantUpdateManyWithWhereWithoutUserInput | StudyRoomParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudyRoomParticipantScalarWhereInput | StudyRoomParticipantScalarWhereInput[]
  }

  export type StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudyRoomMessageCreateWithoutUserInput, StudyRoomMessageUncheckedCreateWithoutUserInput> | StudyRoomMessageCreateWithoutUserInput[] | StudyRoomMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyRoomMessageCreateOrConnectWithoutUserInput | StudyRoomMessageCreateOrConnectWithoutUserInput[]
    upsert?: StudyRoomMessageUpsertWithWhereUniqueWithoutUserInput | StudyRoomMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudyRoomMessageCreateManyUserInputEnvelope
    set?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
    disconnect?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
    delete?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
    connect?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
    update?: StudyRoomMessageUpdateWithWhereUniqueWithoutUserInput | StudyRoomMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudyRoomMessageUpdateManyWithWhereWithoutUserInput | StudyRoomMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudyRoomMessageScalarWhereInput | StudyRoomMessageScalarWhereInput[]
  }

  export type VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<VideoPermissionsCreateWithoutCreatedByInput, VideoPermissionsUncheckedCreateWithoutCreatedByInput> | VideoPermissionsCreateWithoutCreatedByInput[] | VideoPermissionsUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: VideoPermissionsCreateOrConnectWithoutCreatedByInput | VideoPermissionsCreateOrConnectWithoutCreatedByInput[]
    upsert?: VideoPermissionsUpsertWithWhereUniqueWithoutCreatedByInput | VideoPermissionsUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: VideoPermissionsCreateManyCreatedByInputEnvelope
    set?: VideoPermissionsWhereUniqueInput | VideoPermissionsWhereUniqueInput[]
    disconnect?: VideoPermissionsWhereUniqueInput | VideoPermissionsWhereUniqueInput[]
    delete?: VideoPermissionsWhereUniqueInput | VideoPermissionsWhereUniqueInput[]
    connect?: VideoPermissionsWhereUniqueInput | VideoPermissionsWhereUniqueInput[]
    update?: VideoPermissionsUpdateWithWhereUniqueWithoutCreatedByInput | VideoPermissionsUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: VideoPermissionsUpdateManyWithWhereWithoutCreatedByInput | VideoPermissionsUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: VideoPermissionsScalarWhereInput | VideoPermissionsScalarWhereInput[]
  }

  export type WalletUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutUserInput, WalletUpdateWithoutUserInput>, WalletUncheckedUpdateWithoutUserInput>
  }

  export type WorldUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<WorldCreateWithoutCreatorInput, WorldUncheckedCreateWithoutCreatorInput> | WorldCreateWithoutCreatorInput[] | WorldUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WorldCreateOrConnectWithoutCreatorInput | WorldCreateOrConnectWithoutCreatorInput[]
    upsert?: WorldUpsertWithWhereUniqueWithoutCreatorInput | WorldUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: WorldCreateManyCreatorInputEnvelope
    set?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
    disconnect?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
    delete?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
    connect?: WorldWhereUniqueInput | WorldWhereUniqueInput[]
    update?: WorldUpdateWithWhereUniqueWithoutCreatorInput | WorldUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: WorldUpdateManyWithWhereWithoutCreatorInput | WorldUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: WorldScalarWhereInput | WorldScalarWhereInput[]
  }

  export type MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<MarketplaceItemCreateWithoutSellerInput, MarketplaceItemUncheckedCreateWithoutSellerInput> | MarketplaceItemCreateWithoutSellerInput[] | MarketplaceItemUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutSellerInput | MarketplaceItemCreateOrConnectWithoutSellerInput[]
    upsert?: MarketplaceItemUpsertWithWhereUniqueWithoutSellerInput | MarketplaceItemUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: MarketplaceItemCreateManySellerInputEnvelope
    set?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    disconnect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    delete?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    connect?: MarketplaceItemWhereUniqueInput | MarketplaceItemWhereUniqueInput[]
    update?: MarketplaceItemUpdateWithWhereUniqueWithoutSellerInput | MarketplaceItemUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: MarketplaceItemUpdateManyWithWhereWithoutSellerInput | MarketplaceItemUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: MarketplaceItemScalarWhereInput | MarketplaceItemScalarWhereInput[]
  }

  export type MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<MarketplaceMatchCreateWithoutBuyerInput, MarketplaceMatchUncheckedCreateWithoutBuyerInput> | MarketplaceMatchCreateWithoutBuyerInput[] | MarketplaceMatchUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: MarketplaceMatchCreateOrConnectWithoutBuyerInput | MarketplaceMatchCreateOrConnectWithoutBuyerInput[]
    upsert?: MarketplaceMatchUpsertWithWhereUniqueWithoutBuyerInput | MarketplaceMatchUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: MarketplaceMatchCreateManyBuyerInputEnvelope
    set?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    disconnect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    delete?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    connect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    update?: MarketplaceMatchUpdateWithWhereUniqueWithoutBuyerInput | MarketplaceMatchUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: MarketplaceMatchUpdateManyWithWhereWithoutBuyerInput | MarketplaceMatchUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: MarketplaceMatchScalarWhereInput | MarketplaceMatchScalarWhereInput[]
  }

  export type MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<MarketplaceMatchCreateWithoutSellerInput, MarketplaceMatchUncheckedCreateWithoutSellerInput> | MarketplaceMatchCreateWithoutSellerInput[] | MarketplaceMatchUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: MarketplaceMatchCreateOrConnectWithoutSellerInput | MarketplaceMatchCreateOrConnectWithoutSellerInput[]
    upsert?: MarketplaceMatchUpsertWithWhereUniqueWithoutSellerInput | MarketplaceMatchUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: MarketplaceMatchCreateManySellerInputEnvelope
    set?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    disconnect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    delete?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    connect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    update?: MarketplaceMatchUpdateWithWhereUniqueWithoutSellerInput | MarketplaceMatchUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: MarketplaceMatchUpdateManyWithWhereWithoutSellerInput | MarketplaceMatchUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: MarketplaceMatchScalarWhereInput | MarketplaceMatchScalarWhereInput[]
  }

  export type MatchMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MatchMessageCreateWithoutSenderInput, MatchMessageUncheckedCreateWithoutSenderInput> | MatchMessageCreateWithoutSenderInput[] | MatchMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MatchMessageCreateOrConnectWithoutSenderInput | MatchMessageCreateOrConnectWithoutSenderInput[]
    upsert?: MatchMessageUpsertWithWhereUniqueWithoutSenderInput | MatchMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MatchMessageCreateManySenderInputEnvelope
    set?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
    disconnect?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
    delete?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
    connect?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
    update?: MatchMessageUpdateWithWhereUniqueWithoutSenderInput | MatchMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MatchMessageUpdateManyWithWhereWithoutSenderInput | MatchMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MatchMessageScalarWhereInput | MatchMessageScalarWhereInput[]
  }

  export type FeedbackReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackReportCreateWithoutUserInput, FeedbackReportUncheckedCreateWithoutUserInput> | FeedbackReportCreateWithoutUserInput[] | FeedbackReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackReportCreateOrConnectWithoutUserInput | FeedbackReportCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackReportUpsertWithWhereUniqueWithoutUserInput | FeedbackReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackReportCreateManyUserInputEnvelope
    set?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
    disconnect?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
    delete?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
    connect?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
    update?: FeedbackReportUpdateWithWhereUniqueWithoutUserInput | FeedbackReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackReportUpdateManyWithWhereWithoutUserInput | FeedbackReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackReportScalarWhereInput | FeedbackReportScalarWhereInput[]
  }

  export type FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput = {
    create?: XOR<FeedbackReportCreateWithoutAdminUserInput, FeedbackReportUncheckedCreateWithoutAdminUserInput> | FeedbackReportCreateWithoutAdminUserInput[] | FeedbackReportUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: FeedbackReportCreateOrConnectWithoutAdminUserInput | FeedbackReportCreateOrConnectWithoutAdminUserInput[]
    upsert?: FeedbackReportUpsertWithWhereUniqueWithoutAdminUserInput | FeedbackReportUpsertWithWhereUniqueWithoutAdminUserInput[]
    createMany?: FeedbackReportCreateManyAdminUserInputEnvelope
    set?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
    disconnect?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
    delete?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
    connect?: FeedbackReportWhereUniqueInput | FeedbackReportWhereUniqueInput[]
    update?: FeedbackReportUpdateWithWhereUniqueWithoutAdminUserInput | FeedbackReportUpdateWithWhereUniqueWithoutAdminUserInput[]
    updateMany?: FeedbackReportUpdateManyWithWhereWithoutAdminUserInput | FeedbackReportUpdateManyWithWhereWithoutAdminUserInput[]
    deleteMany?: FeedbackReportScalarWhereInput | FeedbackReportScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAssignedRolesInput = {
    create?: XOR<UserCreateWithoutAssignedRolesInput, UserUncheckedCreateWithoutAssignedRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAssignedRolesNestedInput = {
    create?: XOR<UserCreateWithoutAssignedRolesInput, UserUncheckedCreateWithoutAssignedRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedRolesInput
    upsert?: UserUpsertWithoutAssignedRolesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedRolesInput, UserUpdateWithoutAssignedRolesInput>, UserUncheckedUpdateWithoutAssignedRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    upsert?: RoleUpsertWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserRolesInput, RoleUpdateWithoutUserRolesInput>, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    upsert?: UserUpsertWithoutUserRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserRolesInput, UserUpdateWithoutUserRolesInput>, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutVideoPermissionsInput = {
    create?: XOR<UserCreateWithoutVideoPermissionsInput, UserUncheckedCreateWithoutVideoPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideoPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type VideoItemCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<VideoItemCreateWithoutPermissionsInput, VideoItemUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: VideoItemCreateOrConnectWithoutPermissionsInput
    connect?: VideoItemWhereUniqueInput
  }

  export type UserUpdateOneWithoutVideoPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutVideoPermissionsInput, UserUncheckedCreateWithoutVideoPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVideoPermissionsInput
    upsert?: UserUpsertWithoutVideoPermissionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVideoPermissionsInput, UserUpdateWithoutVideoPermissionsInput>, UserUncheckedUpdateWithoutVideoPermissionsInput>
  }

  export type VideoItemUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<VideoItemCreateWithoutPermissionsInput, VideoItemUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: VideoItemCreateOrConnectWithoutPermissionsInput
    upsert?: VideoItemUpsertWithoutPermissionsInput
    connect?: VideoItemWhereUniqueInput
    update?: XOR<XOR<VideoItemUpdateToOneWithWhereWithoutPermissionsInput, VideoItemUpdateWithoutPermissionsInput>, VideoItemUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserCreateNestedOneWithoutAssignedPermissionsInput = {
    create?: XOR<UserCreateWithoutAssignedPermissionsInput, UserUncheckedCreateWithoutAssignedPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneWithoutAssignedPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedPermissionsInput, UserUncheckedCreateWithoutAssignedPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedPermissionsInput
    upsert?: UserUpsertWithoutAssignedPermissionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedPermissionsInput, UserUpdateWithoutAssignedPermissionsInput>, UserUncheckedUpdateWithoutAssignedPermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    upsert?: PermissionUpsertWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolePermissionsInput, PermissionUpdateWithoutRolePermissionsInput>, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type RoleUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionsInput
    upsert?: RoleUpsertWithoutRolePermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutRolePermissionsInput, RoleUpdateWithoutRolePermissionsInput>, RoleUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type StageCreateNestedManyWithoutWorldInput = {
    create?: XOR<StageCreateWithoutWorldInput, StageUncheckedCreateWithoutWorldInput> | StageCreateWithoutWorldInput[] | StageUncheckedCreateWithoutWorldInput[]
    connectOrCreate?: StageCreateOrConnectWithoutWorldInput | StageCreateOrConnectWithoutWorldInput[]
    createMany?: StageCreateManyWorldInputEnvelope
    connect?: StageWhereUniqueInput | StageWhereUniqueInput[]
  }

  export type MundoCreateNestedOneWithoutWorldsInput = {
    create?: XOR<MundoCreateWithoutWorldsInput, MundoUncheckedCreateWithoutWorldsInput>
    connectOrCreate?: MundoCreateOrConnectWithoutWorldsInput
    connect?: MundoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedWorldsInput = {
    create?: XOR<UserCreateWithoutCreatedWorldsInput, UserUncheckedCreateWithoutCreatedWorldsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedWorldsInput
    connect?: UserWhereUniqueInput
  }

  export type StageUncheckedCreateNestedManyWithoutWorldInput = {
    create?: XOR<StageCreateWithoutWorldInput, StageUncheckedCreateWithoutWorldInput> | StageCreateWithoutWorldInput[] | StageUncheckedCreateWithoutWorldInput[]
    connectOrCreate?: StageCreateOrConnectWithoutWorldInput | StageCreateOrConnectWithoutWorldInput[]
    createMany?: StageCreateManyWorldInputEnvelope
    connect?: StageWhereUniqueInput | StageWhereUniqueInput[]
  }

  export type StageUpdateManyWithoutWorldNestedInput = {
    create?: XOR<StageCreateWithoutWorldInput, StageUncheckedCreateWithoutWorldInput> | StageCreateWithoutWorldInput[] | StageUncheckedCreateWithoutWorldInput[]
    connectOrCreate?: StageCreateOrConnectWithoutWorldInput | StageCreateOrConnectWithoutWorldInput[]
    upsert?: StageUpsertWithWhereUniqueWithoutWorldInput | StageUpsertWithWhereUniqueWithoutWorldInput[]
    createMany?: StageCreateManyWorldInputEnvelope
    set?: StageWhereUniqueInput | StageWhereUniqueInput[]
    disconnect?: StageWhereUniqueInput | StageWhereUniqueInput[]
    delete?: StageWhereUniqueInput | StageWhereUniqueInput[]
    connect?: StageWhereUniqueInput | StageWhereUniqueInput[]
    update?: StageUpdateWithWhereUniqueWithoutWorldInput | StageUpdateWithWhereUniqueWithoutWorldInput[]
    updateMany?: StageUpdateManyWithWhereWithoutWorldInput | StageUpdateManyWithWhereWithoutWorldInput[]
    deleteMany?: StageScalarWhereInput | StageScalarWhereInput[]
  }

  export type MundoUpdateOneWithoutWorldsNestedInput = {
    create?: XOR<MundoCreateWithoutWorldsInput, MundoUncheckedCreateWithoutWorldsInput>
    connectOrCreate?: MundoCreateOrConnectWithoutWorldsInput
    upsert?: MundoUpsertWithoutWorldsInput
    disconnect?: MundoWhereInput | boolean
    delete?: MundoWhereInput | boolean
    connect?: MundoWhereUniqueInput
    update?: XOR<XOR<MundoUpdateToOneWithWhereWithoutWorldsInput, MundoUpdateWithoutWorldsInput>, MundoUncheckedUpdateWithoutWorldsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedWorldsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedWorldsInput, UserUncheckedCreateWithoutCreatedWorldsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedWorldsInput
    upsert?: UserUpsertWithoutCreatedWorldsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedWorldsInput, UserUpdateWithoutCreatedWorldsInput>, UserUncheckedUpdateWithoutCreatedWorldsInput>
  }

  export type StageUncheckedUpdateManyWithoutWorldNestedInput = {
    create?: XOR<StageCreateWithoutWorldInput, StageUncheckedCreateWithoutWorldInput> | StageCreateWithoutWorldInput[] | StageUncheckedCreateWithoutWorldInput[]
    connectOrCreate?: StageCreateOrConnectWithoutWorldInput | StageCreateOrConnectWithoutWorldInput[]
    upsert?: StageUpsertWithWhereUniqueWithoutWorldInput | StageUpsertWithWhereUniqueWithoutWorldInput[]
    createMany?: StageCreateManyWorldInputEnvelope
    set?: StageWhereUniqueInput | StageWhereUniqueInput[]
    disconnect?: StageWhereUniqueInput | StageWhereUniqueInput[]
    delete?: StageWhereUniqueInput | StageWhereUniqueInput[]
    connect?: StageWhereUniqueInput | StageWhereUniqueInput[]
    update?: StageUpdateWithWhereUniqueWithoutWorldInput | StageUpdateWithWhereUniqueWithoutWorldInput[]
    updateMany?: StageUpdateManyWithWhereWithoutWorldInput | StageUpdateManyWithWhereWithoutWorldInput[]
    deleteMany?: StageScalarWhereInput | StageScalarWhereInput[]
  }

  export type ExperienceCreateNestedManyWithoutStageInput = {
    create?: XOR<ExperienceCreateWithoutStageInput, ExperienceUncheckedCreateWithoutStageInput> | ExperienceCreateWithoutStageInput[] | ExperienceUncheckedCreateWithoutStageInput[]
    connectOrCreate?: ExperienceCreateOrConnectWithoutStageInput | ExperienceCreateOrConnectWithoutStageInput[]
    createMany?: ExperienceCreateManyStageInputEnvelope
    connect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
  }

  export type WorldCreateNestedOneWithoutStagesInput = {
    create?: XOR<WorldCreateWithoutStagesInput, WorldUncheckedCreateWithoutStagesInput>
    connectOrCreate?: WorldCreateOrConnectWithoutStagesInput
    connect?: WorldWhereUniqueInput
  }

  export type ExperienceUncheckedCreateNestedManyWithoutStageInput = {
    create?: XOR<ExperienceCreateWithoutStageInput, ExperienceUncheckedCreateWithoutStageInput> | ExperienceCreateWithoutStageInput[] | ExperienceUncheckedCreateWithoutStageInput[]
    connectOrCreate?: ExperienceCreateOrConnectWithoutStageInput | ExperienceCreateOrConnectWithoutStageInput[]
    createMany?: ExperienceCreateManyStageInputEnvelope
    connect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
  }

  export type ExperienceUpdateManyWithoutStageNestedInput = {
    create?: XOR<ExperienceCreateWithoutStageInput, ExperienceUncheckedCreateWithoutStageInput> | ExperienceCreateWithoutStageInput[] | ExperienceUncheckedCreateWithoutStageInput[]
    connectOrCreate?: ExperienceCreateOrConnectWithoutStageInput | ExperienceCreateOrConnectWithoutStageInput[]
    upsert?: ExperienceUpsertWithWhereUniqueWithoutStageInput | ExperienceUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: ExperienceCreateManyStageInputEnvelope
    set?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    disconnect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    delete?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    connect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    update?: ExperienceUpdateWithWhereUniqueWithoutStageInput | ExperienceUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: ExperienceUpdateManyWithWhereWithoutStageInput | ExperienceUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: ExperienceScalarWhereInput | ExperienceScalarWhereInput[]
  }

  export type WorldUpdateOneRequiredWithoutStagesNestedInput = {
    create?: XOR<WorldCreateWithoutStagesInput, WorldUncheckedCreateWithoutStagesInput>
    connectOrCreate?: WorldCreateOrConnectWithoutStagesInput
    upsert?: WorldUpsertWithoutStagesInput
    connect?: WorldWhereUniqueInput
    update?: XOR<XOR<WorldUpdateToOneWithWhereWithoutStagesInput, WorldUpdateWithoutStagesInput>, WorldUncheckedUpdateWithoutStagesInput>
  }

  export type ExperienceUncheckedUpdateManyWithoutStageNestedInput = {
    create?: XOR<ExperienceCreateWithoutStageInput, ExperienceUncheckedCreateWithoutStageInput> | ExperienceCreateWithoutStageInput[] | ExperienceUncheckedCreateWithoutStageInput[]
    connectOrCreate?: ExperienceCreateOrConnectWithoutStageInput | ExperienceCreateOrConnectWithoutStageInput[]
    upsert?: ExperienceUpsertWithWhereUniqueWithoutStageInput | ExperienceUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: ExperienceCreateManyStageInputEnvelope
    set?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    disconnect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    delete?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    connect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    update?: ExperienceUpdateWithWhereUniqueWithoutStageInput | ExperienceUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: ExperienceUpdateManyWithWhereWithoutStageInput | ExperienceUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: ExperienceScalarWhereInput | ExperienceScalarWhereInput[]
  }

  export type ActivityCreateNestedManyWithoutExperienceInput = {
    create?: XOR<ActivityCreateWithoutExperienceInput, ActivityUncheckedCreateWithoutExperienceInput> | ActivityCreateWithoutExperienceInput[] | ActivityUncheckedCreateWithoutExperienceInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutExperienceInput | ActivityCreateOrConnectWithoutExperienceInput[]
    createMany?: ActivityCreateManyExperienceInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedExperiencesInput = {
    create?: XOR<UserCreateWithoutCreatedExperiencesInput, UserUncheckedCreateWithoutCreatedExperiencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedExperiencesInput
    connect?: UserWhereUniqueInput
  }

  export type StageCreateNestedOneWithoutExperiencesInput = {
    create?: XOR<StageCreateWithoutExperiencesInput, StageUncheckedCreateWithoutExperiencesInput>
    connectOrCreate?: StageCreateOrConnectWithoutExperiencesInput
    connect?: StageWhereUniqueInput
  }

  export type ActivityUncheckedCreateNestedManyWithoutExperienceInput = {
    create?: XOR<ActivityCreateWithoutExperienceInput, ActivityUncheckedCreateWithoutExperienceInput> | ActivityCreateWithoutExperienceInput[] | ActivityUncheckedCreateWithoutExperienceInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutExperienceInput | ActivityCreateOrConnectWithoutExperienceInput[]
    createMany?: ActivityCreateManyExperienceInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ActivityUpdateManyWithoutExperienceNestedInput = {
    create?: XOR<ActivityCreateWithoutExperienceInput, ActivityUncheckedCreateWithoutExperienceInput> | ActivityCreateWithoutExperienceInput[] | ActivityUncheckedCreateWithoutExperienceInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutExperienceInput | ActivityCreateOrConnectWithoutExperienceInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutExperienceInput | ActivityUpsertWithWhereUniqueWithoutExperienceInput[]
    createMany?: ActivityCreateManyExperienceInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutExperienceInput | ActivityUpdateWithWhereUniqueWithoutExperienceInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutExperienceInput | ActivityUpdateManyWithWhereWithoutExperienceInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedExperiencesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedExperiencesInput, UserUncheckedCreateWithoutCreatedExperiencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedExperiencesInput
    upsert?: UserUpsertWithoutCreatedExperiencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedExperiencesInput, UserUpdateWithoutCreatedExperiencesInput>, UserUncheckedUpdateWithoutCreatedExperiencesInput>
  }

  export type StageUpdateOneRequiredWithoutExperiencesNestedInput = {
    create?: XOR<StageCreateWithoutExperiencesInput, StageUncheckedCreateWithoutExperiencesInput>
    connectOrCreate?: StageCreateOrConnectWithoutExperiencesInput
    upsert?: StageUpsertWithoutExperiencesInput
    connect?: StageWhereUniqueInput
    update?: XOR<XOR<StageUpdateToOneWithWhereWithoutExperiencesInput, StageUpdateWithoutExperiencesInput>, StageUncheckedUpdateWithoutExperiencesInput>
  }

  export type ActivityUncheckedUpdateManyWithoutExperienceNestedInput = {
    create?: XOR<ActivityCreateWithoutExperienceInput, ActivityUncheckedCreateWithoutExperienceInput> | ActivityCreateWithoutExperienceInput[] | ActivityUncheckedCreateWithoutExperienceInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutExperienceInput | ActivityCreateOrConnectWithoutExperienceInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutExperienceInput | ActivityUpsertWithWhereUniqueWithoutExperienceInput[]
    createMany?: ActivityCreateManyExperienceInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutExperienceInput | ActivityUpdateWithWhereUniqueWithoutExperienceInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutExperienceInput | ActivityUpdateManyWithWhereWithoutExperienceInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type VideoItemCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<VideoItemCreateWithoutActivitiesInput, VideoItemUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: VideoItemCreateOrConnectWithoutActivitiesInput
    connect?: VideoItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedActivitiesInput = {
    create?: XOR<UserCreateWithoutCreatedActivitiesInput, UserUncheckedCreateWithoutCreatedActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type ExperienceCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ExperienceCreateWithoutActivitiesInput, ExperienceUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ExperienceCreateOrConnectWithoutActivitiesInput
    connect?: ExperienceWhereUniqueInput
  }

  export type ActivityQuestionCreateNestedManyWithoutActivityInput = {
    create?: XOR<ActivityQuestionCreateWithoutActivityInput, ActivityQuestionUncheckedCreateWithoutActivityInput> | ActivityQuestionCreateWithoutActivityInput[] | ActivityQuestionUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityQuestionCreateOrConnectWithoutActivityInput | ActivityQuestionCreateOrConnectWithoutActivityInput[]
    createMany?: ActivityQuestionCreateManyActivityInputEnvelope
    connect?: ActivityQuestionWhereUniqueInput | ActivityQuestionWhereUniqueInput[]
  }

  export type GamifiedPlaylistCreateNestedManyWithoutActivityInput = {
    create?: XOR<GamifiedPlaylistCreateWithoutActivityInput, GamifiedPlaylistUncheckedCreateWithoutActivityInput> | GamifiedPlaylistCreateWithoutActivityInput[] | GamifiedPlaylistUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: GamifiedPlaylistCreateOrConnectWithoutActivityInput | GamifiedPlaylistCreateOrConnectWithoutActivityInput[]
    createMany?: GamifiedPlaylistCreateManyActivityInputEnvelope
    connect?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
  }

  export type ActivityQuestionUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<ActivityQuestionCreateWithoutActivityInput, ActivityQuestionUncheckedCreateWithoutActivityInput> | ActivityQuestionCreateWithoutActivityInput[] | ActivityQuestionUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityQuestionCreateOrConnectWithoutActivityInput | ActivityQuestionCreateOrConnectWithoutActivityInput[]
    createMany?: ActivityQuestionCreateManyActivityInputEnvelope
    connect?: ActivityQuestionWhereUniqueInput | ActivityQuestionWhereUniqueInput[]
  }

  export type GamifiedPlaylistUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<GamifiedPlaylistCreateWithoutActivityInput, GamifiedPlaylistUncheckedCreateWithoutActivityInput> | GamifiedPlaylistCreateWithoutActivityInput[] | GamifiedPlaylistUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: GamifiedPlaylistCreateOrConnectWithoutActivityInput | GamifiedPlaylistCreateOrConnectWithoutActivityInput[]
    createMany?: GamifiedPlaylistCreateManyActivityInputEnvelope
    connect?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
  }

  export type VideoItemUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<VideoItemCreateWithoutActivitiesInput, VideoItemUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: VideoItemCreateOrConnectWithoutActivitiesInput
    upsert?: VideoItemUpsertWithoutActivitiesInput
    disconnect?: VideoItemWhereInput | boolean
    delete?: VideoItemWhereInput | boolean
    connect?: VideoItemWhereUniqueInput
    update?: XOR<XOR<VideoItemUpdateToOneWithWhereWithoutActivitiesInput, VideoItemUpdateWithoutActivitiesInput>, VideoItemUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedActivitiesInput, UserUncheckedCreateWithoutCreatedActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedActivitiesInput
    upsert?: UserUpsertWithoutCreatedActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedActivitiesInput, UserUpdateWithoutCreatedActivitiesInput>, UserUncheckedUpdateWithoutCreatedActivitiesInput>
  }

  export type ExperienceUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<ExperienceCreateWithoutActivitiesInput, ExperienceUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ExperienceCreateOrConnectWithoutActivitiesInput
    upsert?: ExperienceUpsertWithoutActivitiesInput
    connect?: ExperienceWhereUniqueInput
    update?: XOR<XOR<ExperienceUpdateToOneWithWhereWithoutActivitiesInput, ExperienceUpdateWithoutActivitiesInput>, ExperienceUncheckedUpdateWithoutActivitiesInput>
  }

  export type ActivityQuestionUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ActivityQuestionCreateWithoutActivityInput, ActivityQuestionUncheckedCreateWithoutActivityInput> | ActivityQuestionCreateWithoutActivityInput[] | ActivityQuestionUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityQuestionCreateOrConnectWithoutActivityInput | ActivityQuestionCreateOrConnectWithoutActivityInput[]
    upsert?: ActivityQuestionUpsertWithWhereUniqueWithoutActivityInput | ActivityQuestionUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ActivityQuestionCreateManyActivityInputEnvelope
    set?: ActivityQuestionWhereUniqueInput | ActivityQuestionWhereUniqueInput[]
    disconnect?: ActivityQuestionWhereUniqueInput | ActivityQuestionWhereUniqueInput[]
    delete?: ActivityQuestionWhereUniqueInput | ActivityQuestionWhereUniqueInput[]
    connect?: ActivityQuestionWhereUniqueInput | ActivityQuestionWhereUniqueInput[]
    update?: ActivityQuestionUpdateWithWhereUniqueWithoutActivityInput | ActivityQuestionUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ActivityQuestionUpdateManyWithWhereWithoutActivityInput | ActivityQuestionUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ActivityQuestionScalarWhereInput | ActivityQuestionScalarWhereInput[]
  }

  export type GamifiedPlaylistUpdateManyWithoutActivityNestedInput = {
    create?: XOR<GamifiedPlaylistCreateWithoutActivityInput, GamifiedPlaylistUncheckedCreateWithoutActivityInput> | GamifiedPlaylistCreateWithoutActivityInput[] | GamifiedPlaylistUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: GamifiedPlaylistCreateOrConnectWithoutActivityInput | GamifiedPlaylistCreateOrConnectWithoutActivityInput[]
    upsert?: GamifiedPlaylistUpsertWithWhereUniqueWithoutActivityInput | GamifiedPlaylistUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: GamifiedPlaylistCreateManyActivityInputEnvelope
    set?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
    disconnect?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
    delete?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
    connect?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
    update?: GamifiedPlaylistUpdateWithWhereUniqueWithoutActivityInput | GamifiedPlaylistUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: GamifiedPlaylistUpdateManyWithWhereWithoutActivityInput | GamifiedPlaylistUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: GamifiedPlaylistScalarWhereInput | GamifiedPlaylistScalarWhereInput[]
  }

  export type ActivityQuestionUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ActivityQuestionCreateWithoutActivityInput, ActivityQuestionUncheckedCreateWithoutActivityInput> | ActivityQuestionCreateWithoutActivityInput[] | ActivityQuestionUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityQuestionCreateOrConnectWithoutActivityInput | ActivityQuestionCreateOrConnectWithoutActivityInput[]
    upsert?: ActivityQuestionUpsertWithWhereUniqueWithoutActivityInput | ActivityQuestionUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ActivityQuestionCreateManyActivityInputEnvelope
    set?: ActivityQuestionWhereUniqueInput | ActivityQuestionWhereUniqueInput[]
    disconnect?: ActivityQuestionWhereUniqueInput | ActivityQuestionWhereUniqueInput[]
    delete?: ActivityQuestionWhereUniqueInput | ActivityQuestionWhereUniqueInput[]
    connect?: ActivityQuestionWhereUniqueInput | ActivityQuestionWhereUniqueInput[]
    update?: ActivityQuestionUpdateWithWhereUniqueWithoutActivityInput | ActivityQuestionUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ActivityQuestionUpdateManyWithWhereWithoutActivityInput | ActivityQuestionUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ActivityQuestionScalarWhereInput | ActivityQuestionScalarWhereInput[]
  }

  export type GamifiedPlaylistUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<GamifiedPlaylistCreateWithoutActivityInput, GamifiedPlaylistUncheckedCreateWithoutActivityInput> | GamifiedPlaylistCreateWithoutActivityInput[] | GamifiedPlaylistUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: GamifiedPlaylistCreateOrConnectWithoutActivityInput | GamifiedPlaylistCreateOrConnectWithoutActivityInput[]
    upsert?: GamifiedPlaylistUpsertWithWhereUniqueWithoutActivityInput | GamifiedPlaylistUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: GamifiedPlaylistCreateManyActivityInputEnvelope
    set?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
    disconnect?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
    delete?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
    connect?: GamifiedPlaylistWhereUniqueInput | GamifiedPlaylistWhereUniqueInput[]
    update?: GamifiedPlaylistUpdateWithWhereUniqueWithoutActivityInput | GamifiedPlaylistUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: GamifiedPlaylistUpdateManyWithWhereWithoutActivityInput | GamifiedPlaylistUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: GamifiedPlaylistScalarWhereInput | GamifiedPlaylistScalarWhereInput[]
  }

  export type PlaylistCreateNestedOneWithoutGamifiedPlaylistsInput = {
    create?: XOR<PlaylistCreateWithoutGamifiedPlaylistsInput, PlaylistUncheckedCreateWithoutGamifiedPlaylistsInput>
    connectOrCreate?: PlaylistCreateOrConnectWithoutGamifiedPlaylistsInput
    connect?: PlaylistWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutGamifiedPlaylistsInput = {
    create?: XOR<ActivityCreateWithoutGamifiedPlaylistsInput, ActivityUncheckedCreateWithoutGamifiedPlaylistsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutGamifiedPlaylistsInput
    connect?: ActivityWhereUniqueInput
  }

  export type PlaylistUpdateOneWithoutGamifiedPlaylistsNestedInput = {
    create?: XOR<PlaylistCreateWithoutGamifiedPlaylistsInput, PlaylistUncheckedCreateWithoutGamifiedPlaylistsInput>
    connectOrCreate?: PlaylistCreateOrConnectWithoutGamifiedPlaylistsInput
    upsert?: PlaylistUpsertWithoutGamifiedPlaylistsInput
    disconnect?: PlaylistWhereInput | boolean
    delete?: PlaylistWhereInput | boolean
    connect?: PlaylistWhereUniqueInput
    update?: XOR<XOR<PlaylistUpdateToOneWithWhereWithoutGamifiedPlaylistsInput, PlaylistUpdateWithoutGamifiedPlaylistsInput>, PlaylistUncheckedUpdateWithoutGamifiedPlaylistsInput>
  }

  export type ActivityUpdateOneWithoutGamifiedPlaylistsNestedInput = {
    create?: XOR<ActivityCreateWithoutGamifiedPlaylistsInput, ActivityUncheckedCreateWithoutGamifiedPlaylistsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutGamifiedPlaylistsInput
    upsert?: ActivityUpsertWithoutGamifiedPlaylistsInput
    disconnect?: ActivityWhereInput | boolean
    delete?: ActivityWhereInput | boolean
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutGamifiedPlaylistsInput, ActivityUpdateWithoutGamifiedPlaylistsInput>, ActivityUncheckedUpdateWithoutGamifiedPlaylistsInput>
  }

  export type ActivityCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<ActivityCreateWithoutQuestionsInput, ActivityUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutQuestionsInput
    connect?: ActivityWhereUniqueInput
  }

  export type UserAnswerCreateNestedManyWithoutActivityQuestionInput = {
    create?: XOR<UserAnswerCreateWithoutActivityQuestionInput, UserAnswerUncheckedCreateWithoutActivityQuestionInput> | UserAnswerCreateWithoutActivityQuestionInput[] | UserAnswerUncheckedCreateWithoutActivityQuestionInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutActivityQuestionInput | UserAnswerCreateOrConnectWithoutActivityQuestionInput[]
    createMany?: UserAnswerCreateManyActivityQuestionInputEnvelope
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
  }

  export type UserAnswerUncheckedCreateNestedManyWithoutActivityQuestionInput = {
    create?: XOR<UserAnswerCreateWithoutActivityQuestionInput, UserAnswerUncheckedCreateWithoutActivityQuestionInput> | UserAnswerCreateWithoutActivityQuestionInput[] | UserAnswerUncheckedCreateWithoutActivityQuestionInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutActivityQuestionInput | UserAnswerCreateOrConnectWithoutActivityQuestionInput[]
    createMany?: UserAnswerCreateManyActivityQuestionInputEnvelope
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
  }

  export type ActivityUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<ActivityCreateWithoutQuestionsInput, ActivityUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutQuestionsInput
    upsert?: ActivityUpsertWithoutQuestionsInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutQuestionsInput, ActivityUpdateWithoutQuestionsInput>, ActivityUncheckedUpdateWithoutQuestionsInput>
  }

  export type UserAnswerUpdateManyWithoutActivityQuestionNestedInput = {
    create?: XOR<UserAnswerCreateWithoutActivityQuestionInput, UserAnswerUncheckedCreateWithoutActivityQuestionInput> | UserAnswerCreateWithoutActivityQuestionInput[] | UserAnswerUncheckedCreateWithoutActivityQuestionInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutActivityQuestionInput | UserAnswerCreateOrConnectWithoutActivityQuestionInput[]
    upsert?: UserAnswerUpsertWithWhereUniqueWithoutActivityQuestionInput | UserAnswerUpsertWithWhereUniqueWithoutActivityQuestionInput[]
    createMany?: UserAnswerCreateManyActivityQuestionInputEnvelope
    set?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    disconnect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    delete?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    update?: UserAnswerUpdateWithWhereUniqueWithoutActivityQuestionInput | UserAnswerUpdateWithWhereUniqueWithoutActivityQuestionInput[]
    updateMany?: UserAnswerUpdateManyWithWhereWithoutActivityQuestionInput | UserAnswerUpdateManyWithWhereWithoutActivityQuestionInput[]
    deleteMany?: UserAnswerScalarWhereInput | UserAnswerScalarWhereInput[]
  }

  export type UserAnswerUncheckedUpdateManyWithoutActivityQuestionNestedInput = {
    create?: XOR<UserAnswerCreateWithoutActivityQuestionInput, UserAnswerUncheckedCreateWithoutActivityQuestionInput> | UserAnswerCreateWithoutActivityQuestionInput[] | UserAnswerUncheckedCreateWithoutActivityQuestionInput[]
    connectOrCreate?: UserAnswerCreateOrConnectWithoutActivityQuestionInput | UserAnswerCreateOrConnectWithoutActivityQuestionInput[]
    upsert?: UserAnswerUpsertWithWhereUniqueWithoutActivityQuestionInput | UserAnswerUpsertWithWhereUniqueWithoutActivityQuestionInput[]
    createMany?: UserAnswerCreateManyActivityQuestionInputEnvelope
    set?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    disconnect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    delete?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    connect?: UserAnswerWhereUniqueInput | UserAnswerWhereUniqueInput[]
    update?: UserAnswerUpdateWithWhereUniqueWithoutActivityQuestionInput | UserAnswerUpdateWithWhereUniqueWithoutActivityQuestionInput[]
    updateMany?: UserAnswerUpdateManyWithWhereWithoutActivityQuestionInput | UserAnswerUpdateManyWithWhereWithoutActivityQuestionInput[]
    deleteMany?: UserAnswerScalarWhereInput | UserAnswerScalarWhereInput[]
  }

  export type ActivityQuestionCreateNestedOneWithoutUserAnswersInput = {
    create?: XOR<ActivityQuestionCreateWithoutUserAnswersInput, ActivityQuestionUncheckedCreateWithoutUserAnswersInput>
    connectOrCreate?: ActivityQuestionCreateOrConnectWithoutUserAnswersInput
    connect?: ActivityQuestionWhereUniqueInput
  }

  export type QuestionCreateNestedOneWithoutUserAnswersInput = {
    create?: XOR<QuestionCreateWithoutUserAnswersInput, QuestionUncheckedCreateWithoutUserAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutUserAnswersInput
    connect?: QuestionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserAnswersInput = {
    create?: XOR<UserCreateWithoutUserAnswersInput, UserUncheckedCreateWithoutUserAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAnswersInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ActivityQuestionUpdateOneWithoutUserAnswersNestedInput = {
    create?: XOR<ActivityQuestionCreateWithoutUserAnswersInput, ActivityQuestionUncheckedCreateWithoutUserAnswersInput>
    connectOrCreate?: ActivityQuestionCreateOrConnectWithoutUserAnswersInput
    upsert?: ActivityQuestionUpsertWithoutUserAnswersInput
    disconnect?: ActivityQuestionWhereInput | boolean
    delete?: ActivityQuestionWhereInput | boolean
    connect?: ActivityQuestionWhereUniqueInput
    update?: XOR<XOR<ActivityQuestionUpdateToOneWithWhereWithoutUserAnswersInput, ActivityQuestionUpdateWithoutUserAnswersInput>, ActivityQuestionUncheckedUpdateWithoutUserAnswersInput>
  }

  export type QuestionUpdateOneWithoutUserAnswersNestedInput = {
    create?: XOR<QuestionCreateWithoutUserAnswersInput, QuestionUncheckedCreateWithoutUserAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutUserAnswersInput
    upsert?: QuestionUpsertWithoutUserAnswersInput
    disconnect?: QuestionWhereInput | boolean
    delete?: QuestionWhereInput | boolean
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutUserAnswersInput, QuestionUpdateWithoutUserAnswersInput>, QuestionUncheckedUpdateWithoutUserAnswersInput>
  }

  export type UserUpdateOneRequiredWithoutUserAnswersNestedInput = {
    create?: XOR<UserCreateWithoutUserAnswersInput, UserUncheckedCreateWithoutUserAnswersInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAnswersInput
    upsert?: UserUpsertWithoutUserAnswersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserAnswersInput, UserUpdateWithoutUserAnswersInput>, UserUncheckedUpdateWithoutUserAnswersInput>
  }

  export type UserCreateNestedOneWithoutTokensInput = {
    create?: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokensInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutTokensNestedInput = {
    create?: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokensInput
    upsert?: UserUpsertWithoutTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTokensInput, UserUpdateWithoutTokensInput>, UserUncheckedUpdateWithoutTokensInput>
  }

  export type UserCreateNestedOneWithoutMeritsInput = {
    create?: XOR<UserCreateWithoutMeritsInput, UserUncheckedCreateWithoutMeritsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeritsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMeritsNestedInput = {
    create?: XOR<UserCreateWithoutMeritsInput, UserUncheckedCreateWithoutMeritsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeritsInput
    upsert?: UserUpsertWithoutMeritsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMeritsInput, UserUpdateWithoutMeritsInput>, UserUncheckedUpdateWithoutMeritsInput>
  }

  export type TransactionCreateNestedManyWithoutToWalletInput = {
    create?: XOR<TransactionCreateWithoutToWalletInput, TransactionUncheckedCreateWithoutToWalletInput> | TransactionCreateWithoutToWalletInput[] | TransactionUncheckedCreateWithoutToWalletInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToWalletInput | TransactionCreateOrConnectWithoutToWalletInput[]
    createMany?: TransactionCreateManyToWalletInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutFromWalletInput = {
    create?: XOR<TransactionCreateWithoutFromWalletInput, TransactionUncheckedCreateWithoutFromWalletInput> | TransactionCreateWithoutFromWalletInput[] | TransactionUncheckedCreateWithoutFromWalletInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromWalletInput | TransactionCreateOrConnectWithoutFromWalletInput[]
    createMany?: TransactionCreateManyFromWalletInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutWalletInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionUncheckedCreateNestedManyWithoutToWalletInput = {
    create?: XOR<TransactionCreateWithoutToWalletInput, TransactionUncheckedCreateWithoutToWalletInput> | TransactionCreateWithoutToWalletInput[] | TransactionUncheckedCreateWithoutToWalletInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToWalletInput | TransactionCreateOrConnectWithoutToWalletInput[]
    createMany?: TransactionCreateManyToWalletInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutFromWalletInput = {
    create?: XOR<TransactionCreateWithoutFromWalletInput, TransactionUncheckedCreateWithoutFromWalletInput> | TransactionCreateWithoutFromWalletInput[] | TransactionUncheckedCreateWithoutFromWalletInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromWalletInput | TransactionCreateOrConnectWithoutFromWalletInput[]
    createMany?: TransactionCreateManyFromWalletInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUpdateManyWithoutToWalletNestedInput = {
    create?: XOR<TransactionCreateWithoutToWalletInput, TransactionUncheckedCreateWithoutToWalletInput> | TransactionCreateWithoutToWalletInput[] | TransactionUncheckedCreateWithoutToWalletInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToWalletInput | TransactionCreateOrConnectWithoutToWalletInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutToWalletInput | TransactionUpsertWithWhereUniqueWithoutToWalletInput[]
    createMany?: TransactionCreateManyToWalletInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutToWalletInput | TransactionUpdateWithWhereUniqueWithoutToWalletInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutToWalletInput | TransactionUpdateManyWithWhereWithoutToWalletInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutFromWalletNestedInput = {
    create?: XOR<TransactionCreateWithoutFromWalletInput, TransactionUncheckedCreateWithoutFromWalletInput> | TransactionCreateWithoutFromWalletInput[] | TransactionUncheckedCreateWithoutFromWalletInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromWalletInput | TransactionCreateOrConnectWithoutFromWalletInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutFromWalletInput | TransactionUpsertWithWhereUniqueWithoutFromWalletInput[]
    createMany?: TransactionCreateManyFromWalletInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutFromWalletInput | TransactionUpdateWithWhereUniqueWithoutFromWalletInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutFromWalletInput | TransactionUpdateManyWithWhereWithoutFromWalletInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutWalletNestedInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    upsert?: UserUpsertWithoutWalletInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWalletInput, UserUpdateWithoutWalletInput>, UserUncheckedUpdateWithoutWalletInput>
  }

  export type TransactionUncheckedUpdateManyWithoutToWalletNestedInput = {
    create?: XOR<TransactionCreateWithoutToWalletInput, TransactionUncheckedCreateWithoutToWalletInput> | TransactionCreateWithoutToWalletInput[] | TransactionUncheckedCreateWithoutToWalletInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutToWalletInput | TransactionCreateOrConnectWithoutToWalletInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutToWalletInput | TransactionUpsertWithWhereUniqueWithoutToWalletInput[]
    createMany?: TransactionCreateManyToWalletInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutToWalletInput | TransactionUpdateWithWhereUniqueWithoutToWalletInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutToWalletInput | TransactionUpdateManyWithWhereWithoutToWalletInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutFromWalletNestedInput = {
    create?: XOR<TransactionCreateWithoutFromWalletInput, TransactionUncheckedCreateWithoutFromWalletInput> | TransactionCreateWithoutFromWalletInput[] | TransactionUncheckedCreateWithoutFromWalletInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutFromWalletInput | TransactionCreateOrConnectWithoutFromWalletInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutFromWalletInput | TransactionUpsertWithWhereUniqueWithoutFromWalletInput[]
    createMany?: TransactionCreateManyFromWalletInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutFromWalletInput | TransactionUpdateWithWhereUniqueWithoutFromWalletInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutFromWalletInput | TransactionUpdateManyWithWhereWithoutFromWalletInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type WalletCreateNestedOneWithoutTransactionsToInput = {
    create?: XOR<WalletCreateWithoutTransactionsToInput, WalletUncheckedCreateWithoutTransactionsToInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionsToInput
    connect?: WalletWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutTransactionsFromInput = {
    create?: XOR<WalletCreateWithoutTransactionsFromInput, WalletUncheckedCreateWithoutTransactionsFromInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionsFromInput
    connect?: WalletWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionsToInput = {
    create?: XOR<UserCreateWithoutTransactionsToInput, UserUncheckedCreateWithoutTransactionsToInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsToInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionsFromInput = {
    create?: XOR<UserCreateWithoutTransactionsFromInput, UserUncheckedCreateWithoutTransactionsFromInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsFromInput
    connect?: UserWhereUniqueInput
  }

  export type WalletUpdateOneRequiredWithoutTransactionsToNestedInput = {
    create?: XOR<WalletCreateWithoutTransactionsToInput, WalletUncheckedCreateWithoutTransactionsToInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionsToInput
    upsert?: WalletUpsertWithoutTransactionsToInput
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutTransactionsToInput, WalletUpdateWithoutTransactionsToInput>, WalletUncheckedUpdateWithoutTransactionsToInput>
  }

  export type WalletUpdateOneWithoutTransactionsFromNestedInput = {
    create?: XOR<WalletCreateWithoutTransactionsFromInput, WalletUncheckedCreateWithoutTransactionsFromInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionsFromInput
    upsert?: WalletUpsertWithoutTransactionsFromInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutTransactionsFromInput, WalletUpdateWithoutTransactionsFromInput>, WalletUncheckedUpdateWithoutTransactionsFromInput>
  }

  export type UserUpdateOneRequiredWithoutTransactionsToNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsToInput, UserUncheckedCreateWithoutTransactionsToInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsToInput
    upsert?: UserUpsertWithoutTransactionsToInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsToInput, UserUpdateWithoutTransactionsToInput>, UserUncheckedUpdateWithoutTransactionsToInput>
  }

  export type UserUpdateOneWithoutTransactionsFromNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsFromInput, UserUncheckedCreateWithoutTransactionsFromInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsFromInput
    upsert?: UserUpsertWithoutTransactionsFromInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsFromInput, UserUpdateWithoutTransactionsFromInput>, UserUncheckedUpdateWithoutTransactionsFromInput>
  }

  export type UserCreateNestedOneWithoutOwnedGroupsInput = {
    create?: XOR<UserCreateWithoutOwnedGroupsInput, UserUncheckedCreateWithoutOwnedGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type UserGroupCreateNestedManyWithoutGroupInput = {
    create?: XOR<UserGroupCreateWithoutGroupInput, UserGroupUncheckedCreateWithoutGroupInput> | UserGroupCreateWithoutGroupInput[] | UserGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutGroupInput | UserGroupCreateOrConnectWithoutGroupInput[]
    createMany?: UserGroupCreateManyGroupInputEnvelope
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
  }

  export type UserGroupUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<UserGroupCreateWithoutGroupInput, UserGroupUncheckedCreateWithoutGroupInput> | UserGroupCreateWithoutGroupInput[] | UserGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutGroupInput | UserGroupCreateOrConnectWithoutGroupInput[]
    createMany?: UserGroupCreateManyGroupInputEnvelope
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutOwnedGroupsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedGroupsInput, UserUncheckedCreateWithoutOwnedGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedGroupsInput
    upsert?: UserUpsertWithoutOwnedGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedGroupsInput, UserUpdateWithoutOwnedGroupsInput>, UserUncheckedUpdateWithoutOwnedGroupsInput>
  }

  export type UserGroupUpdateManyWithoutGroupNestedInput = {
    create?: XOR<UserGroupCreateWithoutGroupInput, UserGroupUncheckedCreateWithoutGroupInput> | UserGroupCreateWithoutGroupInput[] | UserGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutGroupInput | UserGroupCreateOrConnectWithoutGroupInput[]
    upsert?: UserGroupUpsertWithWhereUniqueWithoutGroupInput | UserGroupUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: UserGroupCreateManyGroupInputEnvelope
    set?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    disconnect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    delete?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    update?: UserGroupUpdateWithWhereUniqueWithoutGroupInput | UserGroupUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: UserGroupUpdateManyWithWhereWithoutGroupInput | UserGroupUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
  }

  export type UserGroupUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<UserGroupCreateWithoutGroupInput, UserGroupUncheckedCreateWithoutGroupInput> | UserGroupCreateWithoutGroupInput[] | UserGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutGroupInput | UserGroupCreateOrConnectWithoutGroupInput[]
    upsert?: UserGroupUpsertWithWhereUniqueWithoutGroupInput | UserGroupUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: UserGroupCreateManyGroupInputEnvelope
    set?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    disconnect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    delete?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    update?: UserGroupUpdateWithWhereUniqueWithoutGroupInput | UserGroupUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: UserGroupUpdateManyWithWhereWithoutGroupInput | UserGroupUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
  }

  export type GroupCreateNestedOneWithoutUserGroupsInput = {
    create?: XOR<GroupCreateWithoutUserGroupsInput, GroupUncheckedCreateWithoutUserGroupsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutUserGroupsInput
    connect?: GroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserGroupsInput = {
    create?: XOR<UserCreateWithoutUserGroupsInput, UserUncheckedCreateWithoutUserGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type GroupUpdateOneRequiredWithoutUserGroupsNestedInput = {
    create?: XOR<GroupCreateWithoutUserGroupsInput, GroupUncheckedCreateWithoutUserGroupsInput>
    connectOrCreate?: GroupCreateOrConnectWithoutUserGroupsInput
    upsert?: GroupUpsertWithoutUserGroupsInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutUserGroupsInput, GroupUpdateWithoutUserGroupsInput>, GroupUncheckedUpdateWithoutUserGroupsInput>
  }

  export type UserUpdateOneRequiredWithoutUserGroupsNestedInput = {
    create?: XOR<UserCreateWithoutUserGroupsInput, UserUncheckedCreateWithoutUserGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserGroupsInput
    upsert?: UserUpsertWithoutUserGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserGroupsInput, UserUpdateWithoutUserGroupsInput>, UserUncheckedUpdateWithoutUserGroupsInput>
  }

  export type CommentCreateNestedManyWithoutPublicationInput = {
    create?: XOR<CommentCreateWithoutPublicationInput, CommentUncheckedCreateWithoutPublicationInput> | CommentCreateWithoutPublicationInput[] | CommentUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPublicationInput | CommentCreateOrConnectWithoutPublicationInput[]
    createMany?: CommentCreateManyPublicationInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutPublicationInput = {
    create?: XOR<LikeCreateWithoutPublicationInput, LikeUncheckedCreateWithoutPublicationInput> | LikeCreateWithoutPublicationInput[] | LikeUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPublicationInput | LikeCreateOrConnectWithoutPublicationInput[]
    createMany?: LikeCreateManyPublicationInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPublicationsInput = {
    create?: XOR<UserCreateWithoutPublicationsInput, UserUncheckedCreateWithoutPublicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPublicationsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutPublicationInput = {
    create?: XOR<CommentCreateWithoutPublicationInput, CommentUncheckedCreateWithoutPublicationInput> | CommentCreateWithoutPublicationInput[] | CommentUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPublicationInput | CommentCreateOrConnectWithoutPublicationInput[]
    createMany?: CommentCreateManyPublicationInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutPublicationInput = {
    create?: XOR<LikeCreateWithoutPublicationInput, LikeUncheckedCreateWithoutPublicationInput> | LikeCreateWithoutPublicationInput[] | LikeUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPublicationInput | LikeCreateOrConnectWithoutPublicationInput[]
    createMany?: LikeCreateManyPublicationInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type CommentUpdateManyWithoutPublicationNestedInput = {
    create?: XOR<CommentCreateWithoutPublicationInput, CommentUncheckedCreateWithoutPublicationInput> | CommentCreateWithoutPublicationInput[] | CommentUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPublicationInput | CommentCreateOrConnectWithoutPublicationInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPublicationInput | CommentUpsertWithWhereUniqueWithoutPublicationInput[]
    createMany?: CommentCreateManyPublicationInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPublicationInput | CommentUpdateWithWhereUniqueWithoutPublicationInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPublicationInput | CommentUpdateManyWithWhereWithoutPublicationInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutPublicationNestedInput = {
    create?: XOR<LikeCreateWithoutPublicationInput, LikeUncheckedCreateWithoutPublicationInput> | LikeCreateWithoutPublicationInput[] | LikeUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPublicationInput | LikeCreateOrConnectWithoutPublicationInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPublicationInput | LikeUpsertWithWhereUniqueWithoutPublicationInput[]
    createMany?: LikeCreateManyPublicationInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPublicationInput | LikeUpdateWithWhereUniqueWithoutPublicationInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPublicationInput | LikeUpdateManyWithWhereWithoutPublicationInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutPublicationsNestedInput = {
    create?: XOR<UserCreateWithoutPublicationsInput, UserUncheckedCreateWithoutPublicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPublicationsInput
    upsert?: UserUpsertWithoutPublicationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPublicationsInput, UserUpdateWithoutPublicationsInput>, UserUncheckedUpdateWithoutPublicationsInput>
  }

  export type CommentUncheckedUpdateManyWithoutPublicationNestedInput = {
    create?: XOR<CommentCreateWithoutPublicationInput, CommentUncheckedCreateWithoutPublicationInput> | CommentCreateWithoutPublicationInput[] | CommentUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPublicationInput | CommentCreateOrConnectWithoutPublicationInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPublicationInput | CommentUpsertWithWhereUniqueWithoutPublicationInput[]
    createMany?: CommentCreateManyPublicationInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPublicationInput | CommentUpdateWithWhereUniqueWithoutPublicationInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPublicationInput | CommentUpdateManyWithWhereWithoutPublicationInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutPublicationNestedInput = {
    create?: XOR<LikeCreateWithoutPublicationInput, LikeUncheckedCreateWithoutPublicationInput> | LikeCreateWithoutPublicationInput[] | LikeUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPublicationInput | LikeCreateOrConnectWithoutPublicationInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPublicationInput | LikeUpsertWithWhereUniqueWithoutPublicationInput[]
    createMany?: LikeCreateManyPublicationInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPublicationInput | LikeUpdateWithWhereUniqueWithoutPublicationInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPublicationInput | LikeUpdateManyWithWhereWithoutPublicationInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type PublicationCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PublicationCreateWithoutCommentsInput, PublicationUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PublicationCreateOrConnectWithoutCommentsInput
    connect?: PublicationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type PublicationUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<PublicationCreateWithoutCommentsInput, PublicationUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PublicationCreateOrConnectWithoutCommentsInput
    upsert?: PublicationUpsertWithoutCommentsInput
    disconnect?: PublicationWhereInput | boolean
    delete?: PublicationWhereInput | boolean
    connect?: PublicationWhereUniqueInput
    update?: XOR<XOR<PublicationUpdateToOneWithWhereWithoutCommentsInput, PublicationUpdateWithoutCommentsInput>, PublicationUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type PublicationCreateNestedOneWithoutLikesInput = {
    create?: XOR<PublicationCreateWithoutLikesInput, PublicationUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PublicationCreateOrConnectWithoutLikesInput
    connect?: PublicationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLikesInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    connect?: UserWhereUniqueInput
  }

  export type PublicationUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<PublicationCreateWithoutLikesInput, PublicationUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PublicationCreateOrConnectWithoutLikesInput
    upsert?: PublicationUpsertWithoutLikesInput
    connect?: PublicationWhereUniqueInput
    update?: XOR<XOR<PublicationUpdateToOneWithWhereWithoutLikesInput, PublicationUpdateWithoutLikesInput>, PublicationUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikesInput
    upsert?: UserUpsertWithoutLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLikesInput, UserUpdateWithoutLikesInput>, UserUncheckedUpdateWithoutLikesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutCreatedInvitationTemplatesInput = {
    create?: XOR<UserCreateWithoutCreatedInvitationTemplatesInput, UserUncheckedCreateWithoutCreatedInvitationTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedInvitationTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCreatedInvitationTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedInvitationTemplatesInput, UserUncheckedCreateWithoutCreatedInvitationTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedInvitationTemplatesInput
    upsert?: UserUpsertWithoutCreatedInvitationTemplatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedInvitationTemplatesInput, UserUpdateWithoutCreatedInvitationTemplatesInput>, UserUncheckedUpdateWithoutCreatedInvitationTemplatesInput>
  }

  export type UserCreateNestedOneWithoutInvitationsSentInput = {
    create?: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsSentInput
    connect?: UserWhereUniqueInput
  }

  export type UserInvitationCreateNestedManyWithoutGiftCardInput = {
    create?: XOR<UserInvitationCreateWithoutGiftCardInput, UserInvitationUncheckedCreateWithoutGiftCardInput> | UserInvitationCreateWithoutGiftCardInput[] | UserInvitationUncheckedCreateWithoutGiftCardInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutGiftCardInput | UserInvitationCreateOrConnectWithoutGiftCardInput[]
    createMany?: UserInvitationCreateManyGiftCardInputEnvelope
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
  }

  export type UserInvitationUncheckedCreateNestedManyWithoutGiftCardInput = {
    create?: XOR<UserInvitationCreateWithoutGiftCardInput, UserInvitationUncheckedCreateWithoutGiftCardInput> | UserInvitationCreateWithoutGiftCardInput[] | UserInvitationUncheckedCreateWithoutGiftCardInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutGiftCardInput | UserInvitationCreateOrConnectWithoutGiftCardInput[]
    createMany?: UserInvitationCreateManyGiftCardInputEnvelope
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutInvitationsSentNestedInput = {
    create?: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsSentInput
    upsert?: UserUpsertWithoutInvitationsSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationsSentInput, UserUpdateWithoutInvitationsSentInput>, UserUncheckedUpdateWithoutInvitationsSentInput>
  }

  export type UserInvitationUpdateManyWithoutGiftCardNestedInput = {
    create?: XOR<UserInvitationCreateWithoutGiftCardInput, UserInvitationUncheckedCreateWithoutGiftCardInput> | UserInvitationCreateWithoutGiftCardInput[] | UserInvitationUncheckedCreateWithoutGiftCardInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutGiftCardInput | UserInvitationCreateOrConnectWithoutGiftCardInput[]
    upsert?: UserInvitationUpsertWithWhereUniqueWithoutGiftCardInput | UserInvitationUpsertWithWhereUniqueWithoutGiftCardInput[]
    createMany?: UserInvitationCreateManyGiftCardInputEnvelope
    set?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    disconnect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    delete?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    update?: UserInvitationUpdateWithWhereUniqueWithoutGiftCardInput | UserInvitationUpdateWithWhereUniqueWithoutGiftCardInput[]
    updateMany?: UserInvitationUpdateManyWithWhereWithoutGiftCardInput | UserInvitationUpdateManyWithWhereWithoutGiftCardInput[]
    deleteMany?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
  }

  export type UserInvitationUncheckedUpdateManyWithoutGiftCardNestedInput = {
    create?: XOR<UserInvitationCreateWithoutGiftCardInput, UserInvitationUncheckedCreateWithoutGiftCardInput> | UserInvitationCreateWithoutGiftCardInput[] | UserInvitationUncheckedCreateWithoutGiftCardInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutGiftCardInput | UserInvitationCreateOrConnectWithoutGiftCardInput[]
    upsert?: UserInvitationUpsertWithWhereUniqueWithoutGiftCardInput | UserInvitationUpsertWithWhereUniqueWithoutGiftCardInput[]
    createMany?: UserInvitationCreateManyGiftCardInputEnvelope
    set?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    disconnect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    delete?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    update?: UserInvitationUpdateWithWhereUniqueWithoutGiftCardInput | UserInvitationUpdateWithWhereUniqueWithoutGiftCardInput[]
    updateMany?: UserInvitationUpdateManyWithWhereWithoutGiftCardInput | UserInvitationUpdateManyWithWhereWithoutGiftCardInput[]
    deleteMany?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInvitationsReceivedInput = {
    create?: XOR<UserCreateWithoutInvitationsReceivedInput, UserUncheckedCreateWithoutInvitationsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type GiftCardCreateNestedOneWithoutUserInvitationsInput = {
    create?: XOR<GiftCardCreateWithoutUserInvitationsInput, GiftCardUncheckedCreateWithoutUserInvitationsInput>
    connectOrCreate?: GiftCardCreateOrConnectWithoutUserInvitationsInput
    connect?: GiftCardWhereUniqueInput
  }

  export type UserUpdateOneWithoutInvitationsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutInvitationsReceivedInput, UserUncheckedCreateWithoutInvitationsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsReceivedInput
    upsert?: UserUpsertWithoutInvitationsReceivedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationsReceivedInput, UserUpdateWithoutInvitationsReceivedInput>, UserUncheckedUpdateWithoutInvitationsReceivedInput>
  }

  export type GiftCardUpdateOneRequiredWithoutUserInvitationsNestedInput = {
    create?: XOR<GiftCardCreateWithoutUserInvitationsInput, GiftCardUncheckedCreateWithoutUserInvitationsInput>
    connectOrCreate?: GiftCardCreateOrConnectWithoutUserInvitationsInput
    upsert?: GiftCardUpsertWithoutUserInvitationsInput
    connect?: GiftCardWhereUniqueInput
    update?: XOR<XOR<GiftCardUpdateToOneWithWhereWithoutUserInvitationsInput, GiftCardUpdateWithoutUserInvitationsInput>, GiftCardUncheckedUpdateWithoutUserInvitationsInput>
  }

  export type UserCreateNestedOneWithoutCreatedReportsInput = {
    create?: XOR<UserCreateWithoutCreatedReportsInput, UserUncheckedCreateWithoutCreatedReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedReportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCreatedReportsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedReportsInput, UserUncheckedCreateWithoutCreatedReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedReportsInput
    upsert?: UserUpsertWithoutCreatedReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedReportsInput, UserUpdateWithoutCreatedReportsInput>, UserUncheckedUpdateWithoutCreatedReportsInput>
  }

  export type UserCreateNestedManyWithoutPersonalityInput = {
    create?: XOR<UserCreateWithoutPersonalityInput, UserUncheckedCreateWithoutPersonalityInput> | UserCreateWithoutPersonalityInput[] | UserUncheckedCreateWithoutPersonalityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPersonalityInput | UserCreateOrConnectWithoutPersonalityInput[]
    createMany?: UserCreateManyPersonalityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutPersonalityInput = {
    create?: XOR<UserCreateWithoutPersonalityInput, UserUncheckedCreateWithoutPersonalityInput> | UserCreateWithoutPersonalityInput[] | UserUncheckedCreateWithoutPersonalityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPersonalityInput | UserCreateOrConnectWithoutPersonalityInput[]
    createMany?: UserCreateManyPersonalityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutPersonalityNestedInput = {
    create?: XOR<UserCreateWithoutPersonalityInput, UserUncheckedCreateWithoutPersonalityInput> | UserCreateWithoutPersonalityInput[] | UserUncheckedCreateWithoutPersonalityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPersonalityInput | UserCreateOrConnectWithoutPersonalityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutPersonalityInput | UserUpsertWithWhereUniqueWithoutPersonalityInput[]
    createMany?: UserCreateManyPersonalityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutPersonalityInput | UserUpdateWithWhereUniqueWithoutPersonalityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutPersonalityInput | UserUpdateManyWithWhereWithoutPersonalityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutPersonalityNestedInput = {
    create?: XOR<UserCreateWithoutPersonalityInput, UserUncheckedCreateWithoutPersonalityInput> | UserCreateWithoutPersonalityInput[] | UserUncheckedCreateWithoutPersonalityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPersonalityInput | UserCreateOrConnectWithoutPersonalityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutPersonalityInput | UserUpsertWithWhereUniqueWithoutPersonalityInput[]
    createMany?: UserCreateManyPersonalityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutPersonalityInput | UserUpdateWithWhereUniqueWithoutPersonalityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutPersonalityInput | UserUpdateManyWithWhereWithoutPersonalityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCreatedTemplatesInput = {
    create?: XOR<UserCreateWithoutCreatedTemplatesInput, UserUncheckedCreateWithoutCreatedTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTemplatesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCreatedTemplatesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTemplatesInput, UserUncheckedCreateWithoutCreatedTemplatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTemplatesInput
    upsert?: UserUpsertWithoutCreatedTemplatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTemplatesInput, UserUpdateWithoutCreatedTemplatesInput>, UserUncheckedUpdateWithoutCreatedTemplatesInput>
  }

  export type ContentItemCreateNestedManyWithoutItemTypeInput = {
    create?: XOR<ContentItemCreateWithoutItemTypeInput, ContentItemUncheckedCreateWithoutItemTypeInput> | ContentItemCreateWithoutItemTypeInput[] | ContentItemUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: ContentItemCreateOrConnectWithoutItemTypeInput | ContentItemCreateOrConnectWithoutItemTypeInput[]
    createMany?: ContentItemCreateManyItemTypeInputEnvelope
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
  }

  export type ContentItemUncheckedCreateNestedManyWithoutItemTypeInput = {
    create?: XOR<ContentItemCreateWithoutItemTypeInput, ContentItemUncheckedCreateWithoutItemTypeInput> | ContentItemCreateWithoutItemTypeInput[] | ContentItemUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: ContentItemCreateOrConnectWithoutItemTypeInput | ContentItemCreateOrConnectWithoutItemTypeInput[]
    createMany?: ContentItemCreateManyItemTypeInputEnvelope
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
  }

  export type ContentItemUpdateManyWithoutItemTypeNestedInput = {
    create?: XOR<ContentItemCreateWithoutItemTypeInput, ContentItemUncheckedCreateWithoutItemTypeInput> | ContentItemCreateWithoutItemTypeInput[] | ContentItemUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: ContentItemCreateOrConnectWithoutItemTypeInput | ContentItemCreateOrConnectWithoutItemTypeInput[]
    upsert?: ContentItemUpsertWithWhereUniqueWithoutItemTypeInput | ContentItemUpsertWithWhereUniqueWithoutItemTypeInput[]
    createMany?: ContentItemCreateManyItemTypeInputEnvelope
    set?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    disconnect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    delete?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    update?: ContentItemUpdateWithWhereUniqueWithoutItemTypeInput | ContentItemUpdateWithWhereUniqueWithoutItemTypeInput[]
    updateMany?: ContentItemUpdateManyWithWhereWithoutItemTypeInput | ContentItemUpdateManyWithWhereWithoutItemTypeInput[]
    deleteMany?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[]
  }

  export type ContentItemUncheckedUpdateManyWithoutItemTypeNestedInput = {
    create?: XOR<ContentItemCreateWithoutItemTypeInput, ContentItemUncheckedCreateWithoutItemTypeInput> | ContentItemCreateWithoutItemTypeInput[] | ContentItemUncheckedCreateWithoutItemTypeInput[]
    connectOrCreate?: ContentItemCreateOrConnectWithoutItemTypeInput | ContentItemCreateOrConnectWithoutItemTypeInput[]
    upsert?: ContentItemUpsertWithWhereUniqueWithoutItemTypeInput | ContentItemUpsertWithWhereUniqueWithoutItemTypeInput[]
    createMany?: ContentItemCreateManyItemTypeInputEnvelope
    set?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    disconnect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    delete?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    connect?: ContentItemWhereUniqueInput | ContentItemWhereUniqueInput[]
    update?: ContentItemUpdateWithWhereUniqueWithoutItemTypeInput | ContentItemUpdateWithWhereUniqueWithoutItemTypeInput[]
    updateMany?: ContentItemUpdateManyWithWhereWithoutItemTypeInput | ContentItemUpdateManyWithWhereWithoutItemTypeInput[]
    deleteMany?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[]
  }

  export type ItemTypeCreateNestedOneWithoutContentItemsInput = {
    create?: XOR<ItemTypeCreateWithoutContentItemsInput, ItemTypeUncheckedCreateWithoutContentItemsInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutContentItemsInput
    connect?: ItemTypeWhereUniqueInput
  }

  export type PlaylistCreateNestedOneWithoutContentItemsInput = {
    create?: XOR<PlaylistCreateWithoutContentItemsInput, PlaylistUncheckedCreateWithoutContentItemsInput>
    connectOrCreate?: PlaylistCreateOrConnectWithoutContentItemsInput
    connect?: PlaylistWhereUniqueInput
  }

  export type ItemTypeUpdateOneRequiredWithoutContentItemsNestedInput = {
    create?: XOR<ItemTypeCreateWithoutContentItemsInput, ItemTypeUncheckedCreateWithoutContentItemsInput>
    connectOrCreate?: ItemTypeCreateOrConnectWithoutContentItemsInput
    upsert?: ItemTypeUpsertWithoutContentItemsInput
    connect?: ItemTypeWhereUniqueInput
    update?: XOR<XOR<ItemTypeUpdateToOneWithWhereWithoutContentItemsInput, ItemTypeUpdateWithoutContentItemsInput>, ItemTypeUncheckedUpdateWithoutContentItemsInput>
  }

  export type PlaylistUpdateOneRequiredWithoutContentItemsNestedInput = {
    create?: XOR<PlaylistCreateWithoutContentItemsInput, PlaylistUncheckedCreateWithoutContentItemsInput>
    connectOrCreate?: PlaylistCreateOrConnectWithoutContentItemsInput
    upsert?: PlaylistUpsertWithoutContentItemsInput
    connect?: PlaylistWhereUniqueInput
    update?: XOR<XOR<PlaylistUpdateToOneWithWhereWithoutContentItemsInput, PlaylistUpdateWithoutContentItemsInput>, PlaylistUncheckedUpdateWithoutContentItemsInput>
  }

  export type ChallengeRewardCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeRewardCreateWithoutChallengeInput, ChallengeRewardUncheckedCreateWithoutChallengeInput> | ChallengeRewardCreateWithoutChallengeInput[] | ChallengeRewardUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeRewardCreateOrConnectWithoutChallengeInput | ChallengeRewardCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeRewardCreateManyChallengeInputEnvelope
    connect?: ChallengeRewardWhereUniqueInput | ChallengeRewardWhereUniqueInput[]
  }

  export type UserChallengeCreateNestedManyWithoutChallengeInput = {
    create?: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput> | UserChallengeCreateWithoutChallengeInput[] | UserChallengeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutChallengeInput | UserChallengeCreateOrConnectWithoutChallengeInput[]
    createMany?: UserChallengeCreateManyChallengeInputEnvelope
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
  }

  export type ChallengeRewardUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeRewardCreateWithoutChallengeInput, ChallengeRewardUncheckedCreateWithoutChallengeInput> | ChallengeRewardCreateWithoutChallengeInput[] | ChallengeRewardUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeRewardCreateOrConnectWithoutChallengeInput | ChallengeRewardCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeRewardCreateManyChallengeInputEnvelope
    connect?: ChallengeRewardWhereUniqueInput | ChallengeRewardWhereUniqueInput[]
  }

  export type UserChallengeUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput> | UserChallengeCreateWithoutChallengeInput[] | UserChallengeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutChallengeInput | UserChallengeCreateOrConnectWithoutChallengeInput[]
    createMany?: UserChallengeCreateManyChallengeInputEnvelope
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
  }

  export type ChallengeRewardUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeRewardCreateWithoutChallengeInput, ChallengeRewardUncheckedCreateWithoutChallengeInput> | ChallengeRewardCreateWithoutChallengeInput[] | ChallengeRewardUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeRewardCreateOrConnectWithoutChallengeInput | ChallengeRewardCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeRewardUpsertWithWhereUniqueWithoutChallengeInput | ChallengeRewardUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeRewardCreateManyChallengeInputEnvelope
    set?: ChallengeRewardWhereUniqueInput | ChallengeRewardWhereUniqueInput[]
    disconnect?: ChallengeRewardWhereUniqueInput | ChallengeRewardWhereUniqueInput[]
    delete?: ChallengeRewardWhereUniqueInput | ChallengeRewardWhereUniqueInput[]
    connect?: ChallengeRewardWhereUniqueInput | ChallengeRewardWhereUniqueInput[]
    update?: ChallengeRewardUpdateWithWhereUniqueWithoutChallengeInput | ChallengeRewardUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeRewardUpdateManyWithWhereWithoutChallengeInput | ChallengeRewardUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeRewardScalarWhereInput | ChallengeRewardScalarWhereInput[]
  }

  export type UserChallengeUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput> | UserChallengeCreateWithoutChallengeInput[] | UserChallengeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutChallengeInput | UserChallengeCreateOrConnectWithoutChallengeInput[]
    upsert?: UserChallengeUpsertWithWhereUniqueWithoutChallengeInput | UserChallengeUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: UserChallengeCreateManyChallengeInputEnvelope
    set?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    disconnect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    delete?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    update?: UserChallengeUpdateWithWhereUniqueWithoutChallengeInput | UserChallengeUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: UserChallengeUpdateManyWithWhereWithoutChallengeInput | UserChallengeUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
  }

  export type ChallengeRewardUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeRewardCreateWithoutChallengeInput, ChallengeRewardUncheckedCreateWithoutChallengeInput> | ChallengeRewardCreateWithoutChallengeInput[] | ChallengeRewardUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeRewardCreateOrConnectWithoutChallengeInput | ChallengeRewardCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeRewardUpsertWithWhereUniqueWithoutChallengeInput | ChallengeRewardUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeRewardCreateManyChallengeInputEnvelope
    set?: ChallengeRewardWhereUniqueInput | ChallengeRewardWhereUniqueInput[]
    disconnect?: ChallengeRewardWhereUniqueInput | ChallengeRewardWhereUniqueInput[]
    delete?: ChallengeRewardWhereUniqueInput | ChallengeRewardWhereUniqueInput[]
    connect?: ChallengeRewardWhereUniqueInput | ChallengeRewardWhereUniqueInput[]
    update?: ChallengeRewardUpdateWithWhereUniqueWithoutChallengeInput | ChallengeRewardUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeRewardUpdateManyWithWhereWithoutChallengeInput | ChallengeRewardUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeRewardScalarWhereInput | ChallengeRewardScalarWhereInput[]
  }

  export type UserChallengeUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput> | UserChallengeCreateWithoutChallengeInput[] | UserChallengeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: UserChallengeCreateOrConnectWithoutChallengeInput | UserChallengeCreateOrConnectWithoutChallengeInput[]
    upsert?: UserChallengeUpsertWithWhereUniqueWithoutChallengeInput | UserChallengeUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: UserChallengeCreateManyChallengeInputEnvelope
    set?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    disconnect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    delete?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    connect?: UserChallengeWhereUniqueInput | UserChallengeWhereUniqueInput[]
    update?: UserChallengeUpdateWithWhereUniqueWithoutChallengeInput | UserChallengeUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: UserChallengeUpdateManyWithWhereWithoutChallengeInput | UserChallengeUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
  }

  export type ChallengeCreateNestedOneWithoutRewardsInput = {
    create?: XOR<ChallengeCreateWithoutRewardsInput, ChallengeUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutRewardsInput
    connect?: ChallengeWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ChallengeUpdateOneRequiredWithoutRewardsNestedInput = {
    create?: XOR<ChallengeCreateWithoutRewardsInput, ChallengeUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutRewardsInput
    upsert?: ChallengeUpsertWithoutRewardsInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutRewardsInput, ChallengeUpdateWithoutRewardsInput>, ChallengeUncheckedUpdateWithoutRewardsInput>
  }

  export type ChallengeCreateNestedOneWithoutUserChallengesInput = {
    create?: XOR<ChallengeCreateWithoutUserChallengesInput, ChallengeUncheckedCreateWithoutUserChallengesInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutUserChallengesInput
    connect?: ChallengeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserChallengesInput = {
    create?: XOR<UserCreateWithoutUserChallengesInput, UserUncheckedCreateWithoutUserChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserChallengesInput
    connect?: UserWhereUniqueInput
  }

  export type ChallengeUpdateOneRequiredWithoutUserChallengesNestedInput = {
    create?: XOR<ChallengeCreateWithoutUserChallengesInput, ChallengeUncheckedCreateWithoutUserChallengesInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutUserChallengesInput
    upsert?: ChallengeUpsertWithoutUserChallengesInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutUserChallengesInput, ChallengeUpdateWithoutUserChallengesInput>, ChallengeUncheckedUpdateWithoutUserChallengesInput>
  }

  export type UserUpdateOneRequiredWithoutUserChallengesNestedInput = {
    create?: XOR<UserCreateWithoutUserChallengesInput, UserUncheckedCreateWithoutUserChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserChallengesInput
    upsert?: UserUpsertWithoutUserChallengesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserChallengesInput, UserUpdateWithoutUserChallengesInput>, UserUncheckedUpdateWithoutUserChallengesInput>
  }

  export type MarketplaceItemCreatetagsInput = {
    set: string[]
  }

  export type MarketplaceItemCreateimagesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutMarketplaceItemsInput = {
    create?: XOR<UserCreateWithoutMarketplaceItemsInput, UserUncheckedCreateWithoutMarketplaceItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMarketplaceItemsInput
    connect?: UserWhereUniqueInput
  }

  export type ReviewCreateNestedManyWithoutMarketplaceItemInput = {
    create?: XOR<ReviewCreateWithoutMarketplaceItemInput, ReviewUncheckedCreateWithoutMarketplaceItemInput> | ReviewCreateWithoutMarketplaceItemInput[] | ReviewUncheckedCreateWithoutMarketplaceItemInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutMarketplaceItemInput | ReviewCreateOrConnectWithoutMarketplaceItemInput[]
    createMany?: ReviewCreateManyMarketplaceItemInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type MarketplaceMatchCreateNestedManyWithoutItemInput = {
    create?: XOR<MarketplaceMatchCreateWithoutItemInput, MarketplaceMatchUncheckedCreateWithoutItemInput> | MarketplaceMatchCreateWithoutItemInput[] | MarketplaceMatchUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MarketplaceMatchCreateOrConnectWithoutItemInput | MarketplaceMatchCreateOrConnectWithoutItemInput[]
    createMany?: MarketplaceMatchCreateManyItemInputEnvelope
    connect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutMarketplaceItemInput = {
    create?: XOR<ReviewCreateWithoutMarketplaceItemInput, ReviewUncheckedCreateWithoutMarketplaceItemInput> | ReviewCreateWithoutMarketplaceItemInput[] | ReviewUncheckedCreateWithoutMarketplaceItemInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutMarketplaceItemInput | ReviewCreateOrConnectWithoutMarketplaceItemInput[]
    createMany?: ReviewCreateManyMarketplaceItemInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type MarketplaceMatchUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<MarketplaceMatchCreateWithoutItemInput, MarketplaceMatchUncheckedCreateWithoutItemInput> | MarketplaceMatchCreateWithoutItemInput[] | MarketplaceMatchUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MarketplaceMatchCreateOrConnectWithoutItemInput | MarketplaceMatchCreateOrConnectWithoutItemInput[]
    createMany?: MarketplaceMatchCreateManyItemInputEnvelope
    connect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
  }

  export type EnumMarketplaceItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.MarketplaceItemType
  }

  export type EnumCurrencyFieldUpdateOperationsInput = {
    set?: $Enums.Currency
  }

  export type MarketplaceItemUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MarketplaceItemUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumMarketplaceItemStatusFieldUpdateOperationsInput = {
    set?: $Enums.MarketplaceItemStatus
  }

  export type UserUpdateOneRequiredWithoutMarketplaceItemsNestedInput = {
    create?: XOR<UserCreateWithoutMarketplaceItemsInput, UserUncheckedCreateWithoutMarketplaceItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMarketplaceItemsInput
    upsert?: UserUpsertWithoutMarketplaceItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMarketplaceItemsInput, UserUpdateWithoutMarketplaceItemsInput>, UserUncheckedUpdateWithoutMarketplaceItemsInput>
  }

  export type ReviewUpdateManyWithoutMarketplaceItemNestedInput = {
    create?: XOR<ReviewCreateWithoutMarketplaceItemInput, ReviewUncheckedCreateWithoutMarketplaceItemInput> | ReviewCreateWithoutMarketplaceItemInput[] | ReviewUncheckedCreateWithoutMarketplaceItemInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutMarketplaceItemInput | ReviewCreateOrConnectWithoutMarketplaceItemInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutMarketplaceItemInput | ReviewUpsertWithWhereUniqueWithoutMarketplaceItemInput[]
    createMany?: ReviewCreateManyMarketplaceItemInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutMarketplaceItemInput | ReviewUpdateWithWhereUniqueWithoutMarketplaceItemInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutMarketplaceItemInput | ReviewUpdateManyWithWhereWithoutMarketplaceItemInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type MarketplaceMatchUpdateManyWithoutItemNestedInput = {
    create?: XOR<MarketplaceMatchCreateWithoutItemInput, MarketplaceMatchUncheckedCreateWithoutItemInput> | MarketplaceMatchCreateWithoutItemInput[] | MarketplaceMatchUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MarketplaceMatchCreateOrConnectWithoutItemInput | MarketplaceMatchCreateOrConnectWithoutItemInput[]
    upsert?: MarketplaceMatchUpsertWithWhereUniqueWithoutItemInput | MarketplaceMatchUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: MarketplaceMatchCreateManyItemInputEnvelope
    set?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    disconnect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    delete?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    connect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    update?: MarketplaceMatchUpdateWithWhereUniqueWithoutItemInput | MarketplaceMatchUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: MarketplaceMatchUpdateManyWithWhereWithoutItemInput | MarketplaceMatchUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: MarketplaceMatchScalarWhereInput | MarketplaceMatchScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutMarketplaceItemNestedInput = {
    create?: XOR<ReviewCreateWithoutMarketplaceItemInput, ReviewUncheckedCreateWithoutMarketplaceItemInput> | ReviewCreateWithoutMarketplaceItemInput[] | ReviewUncheckedCreateWithoutMarketplaceItemInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutMarketplaceItemInput | ReviewCreateOrConnectWithoutMarketplaceItemInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutMarketplaceItemInput | ReviewUpsertWithWhereUniqueWithoutMarketplaceItemInput[]
    createMany?: ReviewCreateManyMarketplaceItemInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutMarketplaceItemInput | ReviewUpdateWithWhereUniqueWithoutMarketplaceItemInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutMarketplaceItemInput | ReviewUpdateManyWithWhereWithoutMarketplaceItemInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type MarketplaceMatchUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<MarketplaceMatchCreateWithoutItemInput, MarketplaceMatchUncheckedCreateWithoutItemInput> | MarketplaceMatchCreateWithoutItemInput[] | MarketplaceMatchUncheckedCreateWithoutItemInput[]
    connectOrCreate?: MarketplaceMatchCreateOrConnectWithoutItemInput | MarketplaceMatchCreateOrConnectWithoutItemInput[]
    upsert?: MarketplaceMatchUpsertWithWhereUniqueWithoutItemInput | MarketplaceMatchUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: MarketplaceMatchCreateManyItemInputEnvelope
    set?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    disconnect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    delete?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    connect?: MarketplaceMatchWhereUniqueInput | MarketplaceMatchWhereUniqueInput[]
    update?: MarketplaceMatchUpdateWithWhereUniqueWithoutItemInput | MarketplaceMatchUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: MarketplaceMatchUpdateManyWithWhereWithoutItemInput | MarketplaceMatchUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: MarketplaceMatchScalarWhereInput | MarketplaceMatchScalarWhereInput[]
  }

  export type VideoItemCreateNestedOneWithoutStudyRoomsInput = {
    create?: XOR<VideoItemCreateWithoutStudyRoomsInput, VideoItemUncheckedCreateWithoutStudyRoomsInput>
    connectOrCreate?: VideoItemCreateOrConnectWithoutStudyRoomsInput
    connect?: VideoItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutHostedStudyRoomsInput = {
    create?: XOR<UserCreateWithoutHostedStudyRoomsInput, UserUncheckedCreateWithoutHostedStudyRoomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHostedStudyRoomsInput
    connect?: UserWhereUniqueInput
  }

  export type StudyRoomParticipantCreateNestedManyWithoutStudyRoomInput = {
    create?: XOR<StudyRoomParticipantCreateWithoutStudyRoomInput, StudyRoomParticipantUncheckedCreateWithoutStudyRoomInput> | StudyRoomParticipantCreateWithoutStudyRoomInput[] | StudyRoomParticipantUncheckedCreateWithoutStudyRoomInput[]
    connectOrCreate?: StudyRoomParticipantCreateOrConnectWithoutStudyRoomInput | StudyRoomParticipantCreateOrConnectWithoutStudyRoomInput[]
    createMany?: StudyRoomParticipantCreateManyStudyRoomInputEnvelope
    connect?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
  }

  export type StudyRoomMessageCreateNestedManyWithoutStudyRoomInput = {
    create?: XOR<StudyRoomMessageCreateWithoutStudyRoomInput, StudyRoomMessageUncheckedCreateWithoutStudyRoomInput> | StudyRoomMessageCreateWithoutStudyRoomInput[] | StudyRoomMessageUncheckedCreateWithoutStudyRoomInput[]
    connectOrCreate?: StudyRoomMessageCreateOrConnectWithoutStudyRoomInput | StudyRoomMessageCreateOrConnectWithoutStudyRoomInput[]
    createMany?: StudyRoomMessageCreateManyStudyRoomInputEnvelope
    connect?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
  }

  export type StudyRoomParticipantUncheckedCreateNestedManyWithoutStudyRoomInput = {
    create?: XOR<StudyRoomParticipantCreateWithoutStudyRoomInput, StudyRoomParticipantUncheckedCreateWithoutStudyRoomInput> | StudyRoomParticipantCreateWithoutStudyRoomInput[] | StudyRoomParticipantUncheckedCreateWithoutStudyRoomInput[]
    connectOrCreate?: StudyRoomParticipantCreateOrConnectWithoutStudyRoomInput | StudyRoomParticipantCreateOrConnectWithoutStudyRoomInput[]
    createMany?: StudyRoomParticipantCreateManyStudyRoomInputEnvelope
    connect?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
  }

  export type StudyRoomMessageUncheckedCreateNestedManyWithoutStudyRoomInput = {
    create?: XOR<StudyRoomMessageCreateWithoutStudyRoomInput, StudyRoomMessageUncheckedCreateWithoutStudyRoomInput> | StudyRoomMessageCreateWithoutStudyRoomInput[] | StudyRoomMessageUncheckedCreateWithoutStudyRoomInput[]
    connectOrCreate?: StudyRoomMessageCreateOrConnectWithoutStudyRoomInput | StudyRoomMessageCreateOrConnectWithoutStudyRoomInput[]
    createMany?: StudyRoomMessageCreateManyStudyRoomInputEnvelope
    connect?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
  }

  export type EnumStudyRoomStatusFieldUpdateOperationsInput = {
    set?: $Enums.StudyRoomStatus
  }

  export type VideoItemUpdateOneRequiredWithoutStudyRoomsNestedInput = {
    create?: XOR<VideoItemCreateWithoutStudyRoomsInput, VideoItemUncheckedCreateWithoutStudyRoomsInput>
    connectOrCreate?: VideoItemCreateOrConnectWithoutStudyRoomsInput
    upsert?: VideoItemUpsertWithoutStudyRoomsInput
    connect?: VideoItemWhereUniqueInput
    update?: XOR<XOR<VideoItemUpdateToOneWithWhereWithoutStudyRoomsInput, VideoItemUpdateWithoutStudyRoomsInput>, VideoItemUncheckedUpdateWithoutStudyRoomsInput>
  }

  export type UserUpdateOneRequiredWithoutHostedStudyRoomsNestedInput = {
    create?: XOR<UserCreateWithoutHostedStudyRoomsInput, UserUncheckedCreateWithoutHostedStudyRoomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHostedStudyRoomsInput
    upsert?: UserUpsertWithoutHostedStudyRoomsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHostedStudyRoomsInput, UserUpdateWithoutHostedStudyRoomsInput>, UserUncheckedUpdateWithoutHostedStudyRoomsInput>
  }

  export type StudyRoomParticipantUpdateManyWithoutStudyRoomNestedInput = {
    create?: XOR<StudyRoomParticipantCreateWithoutStudyRoomInput, StudyRoomParticipantUncheckedCreateWithoutStudyRoomInput> | StudyRoomParticipantCreateWithoutStudyRoomInput[] | StudyRoomParticipantUncheckedCreateWithoutStudyRoomInput[]
    connectOrCreate?: StudyRoomParticipantCreateOrConnectWithoutStudyRoomInput | StudyRoomParticipantCreateOrConnectWithoutStudyRoomInput[]
    upsert?: StudyRoomParticipantUpsertWithWhereUniqueWithoutStudyRoomInput | StudyRoomParticipantUpsertWithWhereUniqueWithoutStudyRoomInput[]
    createMany?: StudyRoomParticipantCreateManyStudyRoomInputEnvelope
    set?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
    disconnect?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
    delete?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
    connect?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
    update?: StudyRoomParticipantUpdateWithWhereUniqueWithoutStudyRoomInput | StudyRoomParticipantUpdateWithWhereUniqueWithoutStudyRoomInput[]
    updateMany?: StudyRoomParticipantUpdateManyWithWhereWithoutStudyRoomInput | StudyRoomParticipantUpdateManyWithWhereWithoutStudyRoomInput[]
    deleteMany?: StudyRoomParticipantScalarWhereInput | StudyRoomParticipantScalarWhereInput[]
  }

  export type StudyRoomMessageUpdateManyWithoutStudyRoomNestedInput = {
    create?: XOR<StudyRoomMessageCreateWithoutStudyRoomInput, StudyRoomMessageUncheckedCreateWithoutStudyRoomInput> | StudyRoomMessageCreateWithoutStudyRoomInput[] | StudyRoomMessageUncheckedCreateWithoutStudyRoomInput[]
    connectOrCreate?: StudyRoomMessageCreateOrConnectWithoutStudyRoomInput | StudyRoomMessageCreateOrConnectWithoutStudyRoomInput[]
    upsert?: StudyRoomMessageUpsertWithWhereUniqueWithoutStudyRoomInput | StudyRoomMessageUpsertWithWhereUniqueWithoutStudyRoomInput[]
    createMany?: StudyRoomMessageCreateManyStudyRoomInputEnvelope
    set?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
    disconnect?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
    delete?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
    connect?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
    update?: StudyRoomMessageUpdateWithWhereUniqueWithoutStudyRoomInput | StudyRoomMessageUpdateWithWhereUniqueWithoutStudyRoomInput[]
    updateMany?: StudyRoomMessageUpdateManyWithWhereWithoutStudyRoomInput | StudyRoomMessageUpdateManyWithWhereWithoutStudyRoomInput[]
    deleteMany?: StudyRoomMessageScalarWhereInput | StudyRoomMessageScalarWhereInput[]
  }

  export type StudyRoomParticipantUncheckedUpdateManyWithoutStudyRoomNestedInput = {
    create?: XOR<StudyRoomParticipantCreateWithoutStudyRoomInput, StudyRoomParticipantUncheckedCreateWithoutStudyRoomInput> | StudyRoomParticipantCreateWithoutStudyRoomInput[] | StudyRoomParticipantUncheckedCreateWithoutStudyRoomInput[]
    connectOrCreate?: StudyRoomParticipantCreateOrConnectWithoutStudyRoomInput | StudyRoomParticipantCreateOrConnectWithoutStudyRoomInput[]
    upsert?: StudyRoomParticipantUpsertWithWhereUniqueWithoutStudyRoomInput | StudyRoomParticipantUpsertWithWhereUniqueWithoutStudyRoomInput[]
    createMany?: StudyRoomParticipantCreateManyStudyRoomInputEnvelope
    set?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
    disconnect?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
    delete?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
    connect?: StudyRoomParticipantWhereUniqueInput | StudyRoomParticipantWhereUniqueInput[]
    update?: StudyRoomParticipantUpdateWithWhereUniqueWithoutStudyRoomInput | StudyRoomParticipantUpdateWithWhereUniqueWithoutStudyRoomInput[]
    updateMany?: StudyRoomParticipantUpdateManyWithWhereWithoutStudyRoomInput | StudyRoomParticipantUpdateManyWithWhereWithoutStudyRoomInput[]
    deleteMany?: StudyRoomParticipantScalarWhereInput | StudyRoomParticipantScalarWhereInput[]
  }

  export type StudyRoomMessageUncheckedUpdateManyWithoutStudyRoomNestedInput = {
    create?: XOR<StudyRoomMessageCreateWithoutStudyRoomInput, StudyRoomMessageUncheckedCreateWithoutStudyRoomInput> | StudyRoomMessageCreateWithoutStudyRoomInput[] | StudyRoomMessageUncheckedCreateWithoutStudyRoomInput[]
    connectOrCreate?: StudyRoomMessageCreateOrConnectWithoutStudyRoomInput | StudyRoomMessageCreateOrConnectWithoutStudyRoomInput[]
    upsert?: StudyRoomMessageUpsertWithWhereUniqueWithoutStudyRoomInput | StudyRoomMessageUpsertWithWhereUniqueWithoutStudyRoomInput[]
    createMany?: StudyRoomMessageCreateManyStudyRoomInputEnvelope
    set?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
    disconnect?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
    delete?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
    connect?: StudyRoomMessageWhereUniqueInput | StudyRoomMessageWhereUniqueInput[]
    update?: StudyRoomMessageUpdateWithWhereUniqueWithoutStudyRoomInput | StudyRoomMessageUpdateWithWhereUniqueWithoutStudyRoomInput[]
    updateMany?: StudyRoomMessageUpdateManyWithWhereWithoutStudyRoomInput | StudyRoomMessageUpdateManyWithWhereWithoutStudyRoomInput[]
    deleteMany?: StudyRoomMessageScalarWhereInput | StudyRoomMessageScalarWhereInput[]
  }

  export type StudyRoomCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<StudyRoomCreateWithoutParticipantsInput, StudyRoomUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: StudyRoomCreateOrConnectWithoutParticipantsInput
    connect?: StudyRoomWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStudyRoomParticipantsInput = {
    create?: XOR<UserCreateWithoutStudyRoomParticipantsInput, UserUncheckedCreateWithoutStudyRoomParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudyRoomParticipantsInput
    connect?: UserWhereUniqueInput
  }

  export type StudyRoomUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<StudyRoomCreateWithoutParticipantsInput, StudyRoomUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: StudyRoomCreateOrConnectWithoutParticipantsInput
    upsert?: StudyRoomUpsertWithoutParticipantsInput
    connect?: StudyRoomWhereUniqueInput
    update?: XOR<XOR<StudyRoomUpdateToOneWithWhereWithoutParticipantsInput, StudyRoomUpdateWithoutParticipantsInput>, StudyRoomUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutStudyRoomParticipantsNestedInput = {
    create?: XOR<UserCreateWithoutStudyRoomParticipantsInput, UserUncheckedCreateWithoutStudyRoomParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudyRoomParticipantsInput
    upsert?: UserUpsertWithoutStudyRoomParticipantsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudyRoomParticipantsInput, UserUpdateWithoutStudyRoomParticipantsInput>, UserUncheckedUpdateWithoutStudyRoomParticipantsInput>
  }

  export type StudyRoomCreateNestedOneWithoutMessagesInput = {
    create?: XOR<StudyRoomCreateWithoutMessagesInput, StudyRoomUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: StudyRoomCreateOrConnectWithoutMessagesInput
    connect?: StudyRoomWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentChatMessagesInput = {
    create?: XOR<UserCreateWithoutSentChatMessagesInput, UserUncheckedCreateWithoutSentChatMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentChatMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type StudyRoomUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<StudyRoomCreateWithoutMessagesInput, StudyRoomUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: StudyRoomCreateOrConnectWithoutMessagesInput
    upsert?: StudyRoomUpsertWithoutMessagesInput
    connect?: StudyRoomWhereUniqueInput
    update?: XOR<XOR<StudyRoomUpdateToOneWithWhereWithoutMessagesInput, StudyRoomUpdateWithoutMessagesInput>, StudyRoomUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSentChatMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentChatMessagesInput, UserUncheckedCreateWithoutSentChatMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentChatMessagesInput
    upsert?: UserUpsertWithoutSentChatMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentChatMessagesInput, UserUpdateWithoutSentChatMessagesInput>, UserUncheckedUpdateWithoutSentChatMessagesInput>
  }

  export type UserCreateNestedOneWithoutFeedbackReportsInput = {
    create?: XOR<UserCreateWithoutFeedbackReportsInput, UserUncheckedCreateWithoutFeedbackReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackReportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdminFeedbackResponsesInput = {
    create?: XOR<UserCreateWithoutAdminFeedbackResponsesInput, UserUncheckedCreateWithoutAdminFeedbackResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminFeedbackResponsesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFeedbackTypeFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackType
  }

  export type EnumFeedbackPriorityFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackPriority
  }

  export type EnumFeedbackStatusFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackStatus
  }

  export type UserUpdateOneRequiredWithoutFeedbackReportsNestedInput = {
    create?: XOR<UserCreateWithoutFeedbackReportsInput, UserUncheckedCreateWithoutFeedbackReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackReportsInput
    upsert?: UserUpsertWithoutFeedbackReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbackReportsInput, UserUpdateWithoutFeedbackReportsInput>, UserUncheckedUpdateWithoutFeedbackReportsInput>
  }

  export type UserUpdateOneWithoutAdminFeedbackResponsesNestedInput = {
    create?: XOR<UserCreateWithoutAdminFeedbackResponsesInput, UserUncheckedCreateWithoutAdminFeedbackResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminFeedbackResponsesInput
    upsert?: UserUpsertWithoutAdminFeedbackResponsesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminFeedbackResponsesInput, UserUpdateWithoutAdminFeedbackResponsesInput>, UserUncheckedUpdateWithoutAdminFeedbackResponsesInput>
  }

  export type ProfileCreateskillsInput = {
    set: string[]
  }

  export type ProfileCreateinterestsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type ProfileUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProfileUpdateinterestsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type MarketplaceItemCreateNestedOneWithoutReviewsInput = {
    create?: XOR<MarketplaceItemCreateWithoutReviewsInput, MarketplaceItemUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutReviewsInput
    connect?: MarketplaceItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type MarketplaceItemUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<MarketplaceItemCreateWithoutReviewsInput, MarketplaceItemUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutReviewsInput
    upsert?: MarketplaceItemUpsertWithoutReviewsInput
    connect?: MarketplaceItemWhereUniqueInput
    update?: XOR<XOR<MarketplaceItemUpdateToOneWithWhereWithoutReviewsInput, MarketplaceItemUpdateWithoutReviewsInput>, MarketplaceItemUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type MarketplaceItemCreateNestedOneWithoutMatchesInput = {
    create?: XOR<MarketplaceItemCreateWithoutMatchesInput, MarketplaceItemUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutMatchesInput
    connect?: MarketplaceItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBuyerMatchesInput = {
    create?: XOR<UserCreateWithoutBuyerMatchesInput, UserUncheckedCreateWithoutBuyerMatchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuyerMatchesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSellerMatchesInput = {
    create?: XOR<UserCreateWithoutSellerMatchesInput, UserUncheckedCreateWithoutSellerMatchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellerMatchesInput
    connect?: UserWhereUniqueInput
  }

  export type MatchMessageCreateNestedManyWithoutMatchInput = {
    create?: XOR<MatchMessageCreateWithoutMatchInput, MatchMessageUncheckedCreateWithoutMatchInput> | MatchMessageCreateWithoutMatchInput[] | MatchMessageUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchMessageCreateOrConnectWithoutMatchInput | MatchMessageCreateOrConnectWithoutMatchInput[]
    createMany?: MatchMessageCreateManyMatchInputEnvelope
    connect?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
  }

  export type MatchMessageUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<MatchMessageCreateWithoutMatchInput, MatchMessageUncheckedCreateWithoutMatchInput> | MatchMessageCreateWithoutMatchInput[] | MatchMessageUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchMessageCreateOrConnectWithoutMatchInput | MatchMessageCreateOrConnectWithoutMatchInput[]
    createMany?: MatchMessageCreateManyMatchInputEnvelope
    connect?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
  }

  export type EnumMatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.MatchStatus
  }

  export type MarketplaceItemUpdateOneRequiredWithoutMatchesNestedInput = {
    create?: XOR<MarketplaceItemCreateWithoutMatchesInput, MarketplaceItemUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: MarketplaceItemCreateOrConnectWithoutMatchesInput
    upsert?: MarketplaceItemUpsertWithoutMatchesInput
    connect?: MarketplaceItemWhereUniqueInput
    update?: XOR<XOR<MarketplaceItemUpdateToOneWithWhereWithoutMatchesInput, MarketplaceItemUpdateWithoutMatchesInput>, MarketplaceItemUncheckedUpdateWithoutMatchesInput>
  }

  export type UserUpdateOneRequiredWithoutBuyerMatchesNestedInput = {
    create?: XOR<UserCreateWithoutBuyerMatchesInput, UserUncheckedCreateWithoutBuyerMatchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBuyerMatchesInput
    upsert?: UserUpsertWithoutBuyerMatchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBuyerMatchesInput, UserUpdateWithoutBuyerMatchesInput>, UserUncheckedUpdateWithoutBuyerMatchesInput>
  }

  export type UserUpdateOneRequiredWithoutSellerMatchesNestedInput = {
    create?: XOR<UserCreateWithoutSellerMatchesInput, UserUncheckedCreateWithoutSellerMatchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSellerMatchesInput
    upsert?: UserUpsertWithoutSellerMatchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSellerMatchesInput, UserUpdateWithoutSellerMatchesInput>, UserUncheckedUpdateWithoutSellerMatchesInput>
  }

  export type MatchMessageUpdateManyWithoutMatchNestedInput = {
    create?: XOR<MatchMessageCreateWithoutMatchInput, MatchMessageUncheckedCreateWithoutMatchInput> | MatchMessageCreateWithoutMatchInput[] | MatchMessageUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchMessageCreateOrConnectWithoutMatchInput | MatchMessageCreateOrConnectWithoutMatchInput[]
    upsert?: MatchMessageUpsertWithWhereUniqueWithoutMatchInput | MatchMessageUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: MatchMessageCreateManyMatchInputEnvelope
    set?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
    disconnect?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
    delete?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
    connect?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
    update?: MatchMessageUpdateWithWhereUniqueWithoutMatchInput | MatchMessageUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: MatchMessageUpdateManyWithWhereWithoutMatchInput | MatchMessageUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: MatchMessageScalarWhereInput | MatchMessageScalarWhereInput[]
  }

  export type MatchMessageUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<MatchMessageCreateWithoutMatchInput, MatchMessageUncheckedCreateWithoutMatchInput> | MatchMessageCreateWithoutMatchInput[] | MatchMessageUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchMessageCreateOrConnectWithoutMatchInput | MatchMessageCreateOrConnectWithoutMatchInput[]
    upsert?: MatchMessageUpsertWithWhereUniqueWithoutMatchInput | MatchMessageUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: MatchMessageCreateManyMatchInputEnvelope
    set?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
    disconnect?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
    delete?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
    connect?: MatchMessageWhereUniqueInput | MatchMessageWhereUniqueInput[]
    update?: MatchMessageUpdateWithWhereUniqueWithoutMatchInput | MatchMessageUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: MatchMessageUpdateManyWithWhereWithoutMatchInput | MatchMessageUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: MatchMessageScalarWhereInput | MatchMessageScalarWhereInput[]
  }

  export type MarketplaceMatchCreateNestedOneWithoutMessagesInput = {
    create?: XOR<MarketplaceMatchCreateWithoutMessagesInput, MarketplaceMatchUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: MarketplaceMatchCreateOrConnectWithoutMessagesInput
    connect?: MarketplaceMatchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMatchMessagesInput = {
    create?: XOR<UserCreateWithoutMatchMessagesInput, UserUncheckedCreateWithoutMatchMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type MarketplaceMatchUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<MarketplaceMatchCreateWithoutMessagesInput, MarketplaceMatchUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: MarketplaceMatchCreateOrConnectWithoutMessagesInput
    upsert?: MarketplaceMatchUpsertWithoutMessagesInput
    connect?: MarketplaceMatchWhereUniqueInput
    update?: XOR<XOR<MarketplaceMatchUpdateToOneWithWhereWithoutMessagesInput, MarketplaceMatchUpdateWithoutMessagesInput>, MarketplaceMatchUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMatchMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMatchMessagesInput, UserUncheckedCreateWithoutMatchMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchMessagesInput
    upsert?: UserUpsertWithoutMatchMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMatchMessagesInput, UserUpdateWithoutMatchMessagesInput>, UserUncheckedUpdateWithoutMatchMessagesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumMarketplaceItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketplaceItemType | EnumMarketplaceItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MarketplaceItemType[] | ListEnumMarketplaceItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketplaceItemType[] | ListEnumMarketplaceItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketplaceItemTypeFilter<$PrismaModel> | $Enums.MarketplaceItemType
  }

  export type NestedEnumCurrencyFilter<$PrismaModel = never> = {
    equals?: $Enums.Currency | EnumCurrencyFieldRefInput<$PrismaModel>
    in?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyFilter<$PrismaModel> | $Enums.Currency
  }

  export type NestedEnumMarketplaceItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketplaceItemStatus | EnumMarketplaceItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MarketplaceItemStatus[] | ListEnumMarketplaceItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketplaceItemStatus[] | ListEnumMarketplaceItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketplaceItemStatusFilter<$PrismaModel> | $Enums.MarketplaceItemStatus
  }

  export type NestedEnumMarketplaceItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketplaceItemType | EnumMarketplaceItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MarketplaceItemType[] | ListEnumMarketplaceItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketplaceItemType[] | ListEnumMarketplaceItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketplaceItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.MarketplaceItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMarketplaceItemTypeFilter<$PrismaModel>
    _max?: NestedEnumMarketplaceItemTypeFilter<$PrismaModel>
  }

  export type NestedEnumCurrencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Currency | EnumCurrencyFieldRefInput<$PrismaModel>
    in?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Currency[] | ListEnumCurrencyFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyWithAggregatesFilter<$PrismaModel> | $Enums.Currency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyFilter<$PrismaModel>
    _max?: NestedEnumCurrencyFilter<$PrismaModel>
  }

  export type NestedEnumMarketplaceItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketplaceItemStatus | EnumMarketplaceItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MarketplaceItemStatus[] | ListEnumMarketplaceItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketplaceItemStatus[] | ListEnumMarketplaceItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketplaceItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.MarketplaceItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMarketplaceItemStatusFilter<$PrismaModel>
    _max?: NestedEnumMarketplaceItemStatusFilter<$PrismaModel>
  }

  export type NestedEnumStudyRoomStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudyRoomStatus | EnumStudyRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudyRoomStatus[] | ListEnumStudyRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudyRoomStatus[] | ListEnumStudyRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudyRoomStatusFilter<$PrismaModel> | $Enums.StudyRoomStatus
  }

  export type NestedEnumStudyRoomStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudyRoomStatus | EnumStudyRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudyRoomStatus[] | ListEnumStudyRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudyRoomStatus[] | ListEnumStudyRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudyRoomStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudyRoomStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudyRoomStatusFilter<$PrismaModel>
    _max?: NestedEnumStudyRoomStatusFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type NestedEnumFeedbackPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackPriorityFilter<$PrismaModel> | $Enums.FeedbackPriority
  }

  export type NestedEnumFeedbackStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackStatus | EnumFeedbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackStatusFilter<$PrismaModel> | $Enums.FeedbackStatus
  }

  export type NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackPriority | EnumFeedbackPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackPriority[] | ListEnumFeedbackPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackPriorityWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackPriorityFilter<$PrismaModel>
    _max?: NestedEnumFeedbackPriorityFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackStatus | EnumFeedbackStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackStatus[] | ListEnumFeedbackStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackStatusWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackStatusFilter<$PrismaModel>
    _max?: NestedEnumFeedbackStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type PlaylistCreateWithoutMundoInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    orderInMundo?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
    contentItems?: ContentItemCreateNestedManyWithoutPlaylistInput
    gamifiedPlaylists?: GamifiedPlaylistCreateNestedManyWithoutPlaylistInput
    videoItems?: VideoItemCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistUncheckedCreateWithoutMundoInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    orderInMundo?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
    contentItems?: ContentItemUncheckedCreateNestedManyWithoutPlaylistInput
    gamifiedPlaylists?: GamifiedPlaylistUncheckedCreateNestedManyWithoutPlaylistInput
    videoItems?: VideoItemUncheckedCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistCreateOrConnectWithoutMundoInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutMundoInput, PlaylistUncheckedCreateWithoutMundoInput>
  }

  export type PlaylistCreateManyMundoInputEnvelope = {
    data: PlaylistCreateManyMundoInput | PlaylistCreateManyMundoInput[]
    skipDuplicates?: boolean
  }

  export type WorldCreateWithoutMundoInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stages?: StageCreateNestedManyWithoutWorldInput
    creator: UserCreateNestedOneWithoutCreatedWorldsInput
  }

  export type WorldUncheckedCreateWithoutMundoInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    creatorId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stages?: StageUncheckedCreateNestedManyWithoutWorldInput
  }

  export type WorldCreateOrConnectWithoutMundoInput = {
    where: WorldWhereUniqueInput
    create: XOR<WorldCreateWithoutMundoInput, WorldUncheckedCreateWithoutMundoInput>
  }

  export type WorldCreateManyMundoInputEnvelope = {
    data: WorldCreateManyMundoInput | WorldCreateManyMundoInput[]
    skipDuplicates?: boolean
  }

  export type PlaylistUpsertWithWhereUniqueWithoutMundoInput = {
    where: PlaylistWhereUniqueInput
    update: XOR<PlaylistUpdateWithoutMundoInput, PlaylistUncheckedUpdateWithoutMundoInput>
    create: XOR<PlaylistCreateWithoutMundoInput, PlaylistUncheckedCreateWithoutMundoInput>
  }

  export type PlaylistUpdateWithWhereUniqueWithoutMundoInput = {
    where: PlaylistWhereUniqueInput
    data: XOR<PlaylistUpdateWithoutMundoInput, PlaylistUncheckedUpdateWithoutMundoInput>
  }

  export type PlaylistUpdateManyWithWhereWithoutMundoInput = {
    where: PlaylistScalarWhereInput
    data: XOR<PlaylistUpdateManyMutationInput, PlaylistUncheckedUpdateManyWithoutMundoInput>
  }

  export type PlaylistScalarWhereInput = {
    AND?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
    OR?: PlaylistScalarWhereInput[]
    NOT?: PlaylistScalarWhereInput | PlaylistScalarWhereInput[]
    id?: StringFilter<"Playlist"> | string
    mundoId?: StringFilter<"Playlist"> | string
    name?: StringFilter<"Playlist"> | string
    description?: StringNullableFilter<"Playlist"> | string | null
    imageUrl?: StringNullableFilter<"Playlist"> | string | null
    orderInMundo?: IntNullableFilter<"Playlist"> | number | null
    isActive?: BoolFilter<"Playlist"> | boolean
    createdAt?: DateTimeFilter<"Playlist"> | Date | string
    updatedAt?: DateTimeFilter<"Playlist"> | Date | string
    createdById?: StringNullableFilter<"Playlist"> | string | null
    version?: IntFilter<"Playlist"> | number
  }

  export type WorldUpsertWithWhereUniqueWithoutMundoInput = {
    where: WorldWhereUniqueInput
    update: XOR<WorldUpdateWithoutMundoInput, WorldUncheckedUpdateWithoutMundoInput>
    create: XOR<WorldCreateWithoutMundoInput, WorldUncheckedCreateWithoutMundoInput>
  }

  export type WorldUpdateWithWhereUniqueWithoutMundoInput = {
    where: WorldWhereUniqueInput
    data: XOR<WorldUpdateWithoutMundoInput, WorldUncheckedUpdateWithoutMundoInput>
  }

  export type WorldUpdateManyWithWhereWithoutMundoInput = {
    where: WorldScalarWhereInput
    data: XOR<WorldUpdateManyMutationInput, WorldUncheckedUpdateManyWithoutMundoInput>
  }

  export type WorldScalarWhereInput = {
    AND?: WorldScalarWhereInput | WorldScalarWhereInput[]
    OR?: WorldScalarWhereInput[]
    NOT?: WorldScalarWhereInput | WorldScalarWhereInput[]
    id?: StringFilter<"World"> | string
    name?: StringFilter<"World"> | string
    description?: StringNullableFilter<"World"> | string | null
    type?: StringFilter<"World"> | string
    creatorId?: StringFilter<"World"> | string
    status?: StringFilter<"World"> | string
    createdAt?: DateTimeFilter<"World"> | Date | string
    updatedAt?: DateTimeFilter<"World"> | Date | string
    mundoId?: StringNullableFilter<"World"> | string | null
  }

  export type ContentItemCreateWithoutPlaylistInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemType: ItemTypeCreateNestedOneWithoutContentItemsInput
  }

  export type ContentItemUncheckedCreateWithoutPlaylistInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentItemCreateOrConnectWithoutPlaylistInput = {
    where: ContentItemWhereUniqueInput
    create: XOR<ContentItemCreateWithoutPlaylistInput, ContentItemUncheckedCreateWithoutPlaylistInput>
  }

  export type ContentItemCreateManyPlaylistInputEnvelope = {
    data: ContentItemCreateManyPlaylistInput | ContentItemCreateManyPlaylistInput[]
    skipDuplicates?: boolean
  }

  export type GamifiedPlaylistCreateWithoutPlaylistInput = {
    id?: string
    name: string
    type: string
    sequenceType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activity?: ActivityCreateNestedOneWithoutGamifiedPlaylistsInput
  }

  export type GamifiedPlaylistUncheckedCreateWithoutPlaylistInput = {
    id?: string
    activityId?: string | null
    name: string
    type: string
    sequenceType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GamifiedPlaylistCreateOrConnectWithoutPlaylistInput = {
    where: GamifiedPlaylistWhereUniqueInput
    create: XOR<GamifiedPlaylistCreateWithoutPlaylistInput, GamifiedPlaylistUncheckedCreateWithoutPlaylistInput>
  }

  export type GamifiedPlaylistCreateManyPlaylistInputEnvelope = {
    data: GamifiedPlaylistCreateManyPlaylistInput | GamifiedPlaylistCreateManyPlaylistInput[]
    skipDuplicates?: boolean
  }

  export type MundoCreateWithoutPlaylistsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
    worlds?: WorldCreateNestedManyWithoutMundoInput
  }

  export type MundoUncheckedCreateWithoutPlaylistsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
    worlds?: WorldUncheckedCreateNestedManyWithoutMundoInput
  }

  export type MundoCreateOrConnectWithoutPlaylistsInput = {
    where: MundoWhereUniqueInput
    create: XOR<MundoCreateWithoutPlaylistsInput, MundoUncheckedCreateWithoutPlaylistsInput>
  }

  export type VideoItemCreateWithoutPlaylistInput = {
    title: string
    description?: string | null
    content: string
    url?: string | null
    platform?: string
    externalId?: string | null
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    duration?: number | null
    categories?: string | null
    language?: string | null
    quality?: string | null
    tags?: string | null
    thumbnailUrl?: string | null
    activities?: ActivityCreateNestedManyWithoutVideoItemInput
    questions?: QuestionCreateNestedManyWithoutVideoItemInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoItemInput
    studyRooms?: StudyRoomCreateNestedManyWithoutVideoInput
    permissions?: VideoPermissionsCreateNestedOneWithoutVideoItemInput
  }

  export type VideoItemUncheckedCreateWithoutPlaylistInput = {
    id?: number
    title: string
    description?: string | null
    content: string
    url?: string | null
    platform?: string
    externalId?: string | null
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    duration?: number | null
    categories?: string | null
    language?: string | null
    quality?: string | null
    tags?: string | null
    thumbnailUrl?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutVideoItemInput
    questions?: QuestionUncheckedCreateNestedManyWithoutVideoItemInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoItemInput
    studyRooms?: StudyRoomUncheckedCreateNestedManyWithoutVideoInput
    permissions?: VideoPermissionsUncheckedCreateNestedOneWithoutVideoItemInput
  }

  export type VideoItemCreateOrConnectWithoutPlaylistInput = {
    where: VideoItemWhereUniqueInput
    create: XOR<VideoItemCreateWithoutPlaylistInput, VideoItemUncheckedCreateWithoutPlaylistInput>
  }

  export type VideoItemCreateManyPlaylistInputEnvelope = {
    data: VideoItemCreateManyPlaylistInput | VideoItemCreateManyPlaylistInput[]
    skipDuplicates?: boolean
  }

  export type ContentItemUpsertWithWhereUniqueWithoutPlaylistInput = {
    where: ContentItemWhereUniqueInput
    update: XOR<ContentItemUpdateWithoutPlaylistInput, ContentItemUncheckedUpdateWithoutPlaylistInput>
    create: XOR<ContentItemCreateWithoutPlaylistInput, ContentItemUncheckedCreateWithoutPlaylistInput>
  }

  export type ContentItemUpdateWithWhereUniqueWithoutPlaylistInput = {
    where: ContentItemWhereUniqueInput
    data: XOR<ContentItemUpdateWithoutPlaylistInput, ContentItemUncheckedUpdateWithoutPlaylistInput>
  }

  export type ContentItemUpdateManyWithWhereWithoutPlaylistInput = {
    where: ContentItemScalarWhereInput
    data: XOR<ContentItemUpdateManyMutationInput, ContentItemUncheckedUpdateManyWithoutPlaylistInput>
  }

  export type ContentItemScalarWhereInput = {
    AND?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[]
    OR?: ContentItemScalarWhereInput[]
    NOT?: ContentItemScalarWhereInput | ContentItemScalarWhereInput[]
    id?: StringFilter<"ContentItem"> | string
    title?: StringFilter<"ContentItem"> | string
    description?: StringNullableFilter<"ContentItem"> | string | null
    content?: StringFilter<"ContentItem"> | string
    playlistId?: StringFilter<"ContentItem"> | string
    itemTypeId?: StringFilter<"ContentItem"> | string
    order?: IntFilter<"ContentItem"> | number
    isActive?: BoolFilter<"ContentItem"> | boolean
    isDeleted?: BoolFilter<"ContentItem"> | boolean
    deletedAt?: DateTimeNullableFilter<"ContentItem"> | Date | string | null
    createdAt?: DateTimeFilter<"ContentItem"> | Date | string
    updatedAt?: DateTimeFilter<"ContentItem"> | Date | string
  }

  export type GamifiedPlaylistUpsertWithWhereUniqueWithoutPlaylistInput = {
    where: GamifiedPlaylistWhereUniqueInput
    update: XOR<GamifiedPlaylistUpdateWithoutPlaylistInput, GamifiedPlaylistUncheckedUpdateWithoutPlaylistInput>
    create: XOR<GamifiedPlaylistCreateWithoutPlaylistInput, GamifiedPlaylistUncheckedCreateWithoutPlaylistInput>
  }

  export type GamifiedPlaylistUpdateWithWhereUniqueWithoutPlaylistInput = {
    where: GamifiedPlaylistWhereUniqueInput
    data: XOR<GamifiedPlaylistUpdateWithoutPlaylistInput, GamifiedPlaylistUncheckedUpdateWithoutPlaylistInput>
  }

  export type GamifiedPlaylistUpdateManyWithWhereWithoutPlaylistInput = {
    where: GamifiedPlaylistScalarWhereInput
    data: XOR<GamifiedPlaylistUpdateManyMutationInput, GamifiedPlaylistUncheckedUpdateManyWithoutPlaylistInput>
  }

  export type GamifiedPlaylistScalarWhereInput = {
    AND?: GamifiedPlaylistScalarWhereInput | GamifiedPlaylistScalarWhereInput[]
    OR?: GamifiedPlaylistScalarWhereInput[]
    NOT?: GamifiedPlaylistScalarWhereInput | GamifiedPlaylistScalarWhereInput[]
    id?: StringFilter<"GamifiedPlaylist"> | string
    activityId?: StringNullableFilter<"GamifiedPlaylist"> | string | null
    playlistId?: StringNullableFilter<"GamifiedPlaylist"> | string | null
    name?: StringFilter<"GamifiedPlaylist"> | string
    type?: StringFilter<"GamifiedPlaylist"> | string
    sequenceType?: StringFilter<"GamifiedPlaylist"> | string
    status?: StringFilter<"GamifiedPlaylist"> | string
    createdAt?: DateTimeFilter<"GamifiedPlaylist"> | Date | string
    updatedAt?: DateTimeFilter<"GamifiedPlaylist"> | Date | string
  }

  export type MundoUpsertWithoutPlaylistsInput = {
    update: XOR<MundoUpdateWithoutPlaylistsInput, MundoUncheckedUpdateWithoutPlaylistsInput>
    create: XOR<MundoCreateWithoutPlaylistsInput, MundoUncheckedCreateWithoutPlaylistsInput>
    where?: MundoWhereInput
  }

  export type MundoUpdateToOneWithWhereWithoutPlaylistsInput = {
    where?: MundoWhereInput
    data: XOR<MundoUpdateWithoutPlaylistsInput, MundoUncheckedUpdateWithoutPlaylistsInput>
  }

  export type MundoUpdateWithoutPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    worlds?: WorldUpdateManyWithoutMundoNestedInput
  }

  export type MundoUncheckedUpdateWithoutPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    worlds?: WorldUncheckedUpdateManyWithoutMundoNestedInput
  }

  export type VideoItemUpsertWithWhereUniqueWithoutPlaylistInput = {
    where: VideoItemWhereUniqueInput
    update: XOR<VideoItemUpdateWithoutPlaylistInput, VideoItemUncheckedUpdateWithoutPlaylistInput>
    create: XOR<VideoItemCreateWithoutPlaylistInput, VideoItemUncheckedCreateWithoutPlaylistInput>
  }

  export type VideoItemUpdateWithWhereUniqueWithoutPlaylistInput = {
    where: VideoItemWhereUniqueInput
    data: XOR<VideoItemUpdateWithoutPlaylistInput, VideoItemUncheckedUpdateWithoutPlaylistInput>
  }

  export type VideoItemUpdateManyWithWhereWithoutPlaylistInput = {
    where: VideoItemScalarWhereInput
    data: XOR<VideoItemUpdateManyMutationInput, VideoItemUncheckedUpdateManyWithoutPlaylistInput>
  }

  export type VideoItemScalarWhereInput = {
    AND?: VideoItemScalarWhereInput | VideoItemScalarWhereInput[]
    OR?: VideoItemScalarWhereInput[]
    NOT?: VideoItemScalarWhereInput | VideoItemScalarWhereInput[]
    id?: IntFilter<"VideoItem"> | number
    title?: StringFilter<"VideoItem"> | string
    description?: StringNullableFilter<"VideoItem"> | string | null
    content?: StringFilter<"VideoItem"> | string
    url?: StringNullableFilter<"VideoItem"> | string | null
    platform?: StringFilter<"VideoItem"> | string
    externalId?: StringNullableFilter<"VideoItem"> | string | null
    playlistId?: StringFilter<"VideoItem"> | string
    itemTypeId?: StringFilter<"VideoItem"> | string
    order?: IntFilter<"VideoItem"> | number
    isActive?: BoolFilter<"VideoItem"> | boolean
    isDeleted?: BoolFilter<"VideoItem"> | boolean
    deletedAt?: DateTimeNullableFilter<"VideoItem"> | Date | string | null
    createdAt?: DateTimeFilter<"VideoItem"> | Date | string
    updatedAt?: DateTimeFilter<"VideoItem"> | Date | string
    duration?: IntNullableFilter<"VideoItem"> | number | null
    categories?: StringNullableFilter<"VideoItem"> | string | null
    language?: StringNullableFilter<"VideoItem"> | string | null
    quality?: StringNullableFilter<"VideoItem"> | string | null
    tags?: StringNullableFilter<"VideoItem"> | string | null
    thumbnailUrl?: StringNullableFilter<"VideoItem"> | string | null
  }

  export type ActivityCreateWithoutVideoItemInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    multimediaType?: string | null
    contentUrl?: string | null
    duration?: number | null
    order?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedActivitiesInput
    experience: ExperienceCreateNestedOneWithoutActivitiesInput
    questions?: ActivityQuestionCreateNestedManyWithoutActivityInput
    gamifiedPlaylists?: GamifiedPlaylistCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutVideoItemInput = {
    id?: string
    experienceId: string
    title: string
    description?: string | null
    type: string
    multimediaType?: string | null
    contentUrl?: string | null
    duration?: number | null
    order?: number
    status?: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: ActivityQuestionUncheckedCreateNestedManyWithoutActivityInput
    gamifiedPlaylists?: GamifiedPlaylistUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutVideoItemInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutVideoItemInput, ActivityUncheckedCreateWithoutVideoItemInput>
  }

  export type ActivityCreateManyVideoItemInputEnvelope = {
    data: ActivityCreateManyVideoItemInput | ActivityCreateManyVideoItemInput[]
    skipDuplicates?: boolean
  }

  export type QuestionCreateWithoutVideoItemInput = {
    timestamp: number
    type: string
    text: string
    languageCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    endTimestamp?: number | null
    answerOptions?: AnswerOptionCreateNestedManyWithoutQuestionInput
    userAnswers?: UserAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutVideoItemInput = {
    id?: number
    timestamp: number
    type: string
    text: string
    languageCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    endTimestamp?: number | null
    answerOptions?: AnswerOptionUncheckedCreateNestedManyWithoutQuestionInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutVideoItemInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutVideoItemInput, QuestionUncheckedCreateWithoutVideoItemInput>
  }

  export type QuestionCreateManyVideoItemInputEnvelope = {
    data: QuestionCreateManyVideoItemInput | QuestionCreateManyVideoItemInput[]
    skipDuplicates?: boolean
  }

  export type SubtitleCreateWithoutVideoItemInput = {
    languageCode: string
    format?: string
    content?: string | null
    contentUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubtitleUncheckedCreateWithoutVideoItemInput = {
    id?: number
    languageCode: string
    format?: string
    content?: string | null
    contentUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubtitleCreateOrConnectWithoutVideoItemInput = {
    where: SubtitleWhereUniqueInput
    create: XOR<SubtitleCreateWithoutVideoItemInput, SubtitleUncheckedCreateWithoutVideoItemInput>
  }

  export type SubtitleCreateManyVideoItemInputEnvelope = {
    data: SubtitleCreateManyVideoItemInput | SubtitleCreateManyVideoItemInput[]
    skipDuplicates?: boolean
  }

  export type StudyRoomCreateWithoutVideoInput = {
    id?: string
    name: string
    description?: string | null
    maxParticipants?: number
    status?: $Enums.StudyRoomStatus
    currentTime?: number
    isPaused?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    host: UserCreateNestedOneWithoutHostedStudyRoomsInput
    participants?: StudyRoomParticipantCreateNestedManyWithoutStudyRoomInput
    messages?: StudyRoomMessageCreateNestedManyWithoutStudyRoomInput
  }

  export type StudyRoomUncheckedCreateWithoutVideoInput = {
    id?: string
    name: string
    description?: string | null
    hostId: string
    maxParticipants?: number
    status?: $Enums.StudyRoomStatus
    currentTime?: number
    isPaused?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutStudyRoomInput
    messages?: StudyRoomMessageUncheckedCreateNestedManyWithoutStudyRoomInput
  }

  export type StudyRoomCreateOrConnectWithoutVideoInput = {
    where: StudyRoomWhereUniqueInput
    create: XOR<StudyRoomCreateWithoutVideoInput, StudyRoomUncheckedCreateWithoutVideoInput>
  }

  export type StudyRoomCreateManyVideoInputEnvelope = {
    data: StudyRoomCreateManyVideoInput | StudyRoomCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type PlaylistCreateWithoutVideoItemsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    orderInMundo?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
    contentItems?: ContentItemCreateNestedManyWithoutPlaylistInput
    gamifiedPlaylists?: GamifiedPlaylistCreateNestedManyWithoutPlaylistInput
    mundo: MundoCreateNestedOneWithoutPlaylistsInput
  }

  export type PlaylistUncheckedCreateWithoutVideoItemsInput = {
    id?: string
    mundoId: string
    name: string
    description?: string | null
    imageUrl?: string | null
    orderInMundo?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
    contentItems?: ContentItemUncheckedCreateNestedManyWithoutPlaylistInput
    gamifiedPlaylists?: GamifiedPlaylistUncheckedCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistCreateOrConnectWithoutVideoItemsInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutVideoItemsInput, PlaylistUncheckedCreateWithoutVideoItemsInput>
  }

  export type VideoPermissionsCreateWithoutVideoItemInput = {
    id?: string
    showWaveCount?: boolean
    showVideos?: boolean
    showVideoSubtitles?: boolean
    showComments?: boolean
    showPublishDate?: boolean
    showVideoDuration?: boolean
    showLikeButton?: boolean
    allowRewindForward?: boolean
    allowViewComments?: boolean
    allowMakeComments?: boolean
    showLikeComments?: boolean
    sortCommentsByAffinity?: boolean
    showCommenterName?: boolean
    playlistPosition?: string
    isDraft?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutVideoPermissionsInput
  }

  export type VideoPermissionsUncheckedCreateWithoutVideoItemInput = {
    id?: string
    showWaveCount?: boolean
    showVideos?: boolean
    showVideoSubtitles?: boolean
    showComments?: boolean
    showPublishDate?: boolean
    showVideoDuration?: boolean
    showLikeButton?: boolean
    allowRewindForward?: boolean
    allowViewComments?: boolean
    allowMakeComments?: boolean
    showLikeComments?: boolean
    sortCommentsByAffinity?: boolean
    showCommenterName?: boolean
    playlistPosition?: string
    isDraft?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
  }

  export type VideoPermissionsCreateOrConnectWithoutVideoItemInput = {
    where: VideoPermissionsWhereUniqueInput
    create: XOR<VideoPermissionsCreateWithoutVideoItemInput, VideoPermissionsUncheckedCreateWithoutVideoItemInput>
  }

  export type ActivityUpsertWithWhereUniqueWithoutVideoItemInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutVideoItemInput, ActivityUncheckedUpdateWithoutVideoItemInput>
    create: XOR<ActivityCreateWithoutVideoItemInput, ActivityUncheckedCreateWithoutVideoItemInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutVideoItemInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutVideoItemInput, ActivityUncheckedUpdateWithoutVideoItemInput>
  }

  export type ActivityUpdateManyWithWhereWithoutVideoItemInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutVideoItemInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    experienceId?: StringFilter<"Activity"> | string
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    type?: StringFilter<"Activity"> | string
    multimediaType?: StringNullableFilter<"Activity"> | string | null
    contentUrl?: StringNullableFilter<"Activity"> | string | null
    duration?: IntNullableFilter<"Activity"> | number | null
    order?: IntFilter<"Activity"> | number
    status?: StringFilter<"Activity"> | string
    creatorId?: StringFilter<"Activity"> | string
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    videoItemId?: IntNullableFilter<"Activity"> | number | null
  }

  export type QuestionUpsertWithWhereUniqueWithoutVideoItemInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutVideoItemInput, QuestionUncheckedUpdateWithoutVideoItemInput>
    create: XOR<QuestionCreateWithoutVideoItemInput, QuestionUncheckedCreateWithoutVideoItemInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutVideoItemInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutVideoItemInput, QuestionUncheckedUpdateWithoutVideoItemInput>
  }

  export type QuestionUpdateManyWithWhereWithoutVideoItemInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutVideoItemInput>
  }

  export type QuestionScalarWhereInput = {
    AND?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    OR?: QuestionScalarWhereInput[]
    NOT?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    id?: IntFilter<"Question"> | number
    videoItemId?: IntFilter<"Question"> | number
    timestamp?: IntFilter<"Question"> | number
    type?: StringFilter<"Question"> | string
    text?: StringFilter<"Question"> | string
    languageCode?: StringFilter<"Question"> | string
    isActive?: BoolFilter<"Question"> | boolean
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    endTimestamp?: IntNullableFilter<"Question"> | number | null
  }

  export type SubtitleUpsertWithWhereUniqueWithoutVideoItemInput = {
    where: SubtitleWhereUniqueInput
    update: XOR<SubtitleUpdateWithoutVideoItemInput, SubtitleUncheckedUpdateWithoutVideoItemInput>
    create: XOR<SubtitleCreateWithoutVideoItemInput, SubtitleUncheckedCreateWithoutVideoItemInput>
  }

  export type SubtitleUpdateWithWhereUniqueWithoutVideoItemInput = {
    where: SubtitleWhereUniqueInput
    data: XOR<SubtitleUpdateWithoutVideoItemInput, SubtitleUncheckedUpdateWithoutVideoItemInput>
  }

  export type SubtitleUpdateManyWithWhereWithoutVideoItemInput = {
    where: SubtitleScalarWhereInput
    data: XOR<SubtitleUpdateManyMutationInput, SubtitleUncheckedUpdateManyWithoutVideoItemInput>
  }

  export type SubtitleScalarWhereInput = {
    AND?: SubtitleScalarWhereInput | SubtitleScalarWhereInput[]
    OR?: SubtitleScalarWhereInput[]
    NOT?: SubtitleScalarWhereInput | SubtitleScalarWhereInput[]
    id?: IntFilter<"Subtitle"> | number
    videoItemId?: IntFilter<"Subtitle"> | number
    languageCode?: StringFilter<"Subtitle"> | string
    format?: StringFilter<"Subtitle"> | string
    content?: StringNullableFilter<"Subtitle"> | string | null
    contentUrl?: StringNullableFilter<"Subtitle"> | string | null
    isActive?: BoolFilter<"Subtitle"> | boolean
    createdAt?: DateTimeFilter<"Subtitle"> | Date | string
    updatedAt?: DateTimeFilter<"Subtitle"> | Date | string
  }

  export type StudyRoomUpsertWithWhereUniqueWithoutVideoInput = {
    where: StudyRoomWhereUniqueInput
    update: XOR<StudyRoomUpdateWithoutVideoInput, StudyRoomUncheckedUpdateWithoutVideoInput>
    create: XOR<StudyRoomCreateWithoutVideoInput, StudyRoomUncheckedCreateWithoutVideoInput>
  }

  export type StudyRoomUpdateWithWhereUniqueWithoutVideoInput = {
    where: StudyRoomWhereUniqueInput
    data: XOR<StudyRoomUpdateWithoutVideoInput, StudyRoomUncheckedUpdateWithoutVideoInput>
  }

  export type StudyRoomUpdateManyWithWhereWithoutVideoInput = {
    where: StudyRoomScalarWhereInput
    data: XOR<StudyRoomUpdateManyMutationInput, StudyRoomUncheckedUpdateManyWithoutVideoInput>
  }

  export type StudyRoomScalarWhereInput = {
    AND?: StudyRoomScalarWhereInput | StudyRoomScalarWhereInput[]
    OR?: StudyRoomScalarWhereInput[]
    NOT?: StudyRoomScalarWhereInput | StudyRoomScalarWhereInput[]
    id?: StringFilter<"StudyRoom"> | string
    name?: StringFilter<"StudyRoom"> | string
    description?: StringNullableFilter<"StudyRoom"> | string | null
    videoId?: IntFilter<"StudyRoom"> | number
    hostId?: StringFilter<"StudyRoom"> | string
    maxParticipants?: IntFilter<"StudyRoom"> | number
    status?: EnumStudyRoomStatusFilter<"StudyRoom"> | $Enums.StudyRoomStatus
    currentTime?: FloatFilter<"StudyRoom"> | number
    isPaused?: BoolFilter<"StudyRoom"> | boolean
    isActive?: BoolFilter<"StudyRoom"> | boolean
    createdAt?: DateTimeFilter<"StudyRoom"> | Date | string
    updatedAt?: DateTimeFilter<"StudyRoom"> | Date | string
  }

  export type PlaylistUpsertWithoutVideoItemsInput = {
    update: XOR<PlaylistUpdateWithoutVideoItemsInput, PlaylistUncheckedUpdateWithoutVideoItemsInput>
    create: XOR<PlaylistCreateWithoutVideoItemsInput, PlaylistUncheckedCreateWithoutVideoItemsInput>
    where?: PlaylistWhereInput
  }

  export type PlaylistUpdateToOneWithWhereWithoutVideoItemsInput = {
    where?: PlaylistWhereInput
    data: XOR<PlaylistUpdateWithoutVideoItemsInput, PlaylistUncheckedUpdateWithoutVideoItemsInput>
  }

  export type PlaylistUpdateWithoutVideoItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orderInMundo?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    contentItems?: ContentItemUpdateManyWithoutPlaylistNestedInput
    gamifiedPlaylists?: GamifiedPlaylistUpdateManyWithoutPlaylistNestedInput
    mundo?: MundoUpdateOneRequiredWithoutPlaylistsNestedInput
  }

  export type PlaylistUncheckedUpdateWithoutVideoItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mundoId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orderInMundo?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    contentItems?: ContentItemUncheckedUpdateManyWithoutPlaylistNestedInput
    gamifiedPlaylists?: GamifiedPlaylistUncheckedUpdateManyWithoutPlaylistNestedInput
  }

  export type VideoPermissionsUpsertWithoutVideoItemInput = {
    update: XOR<VideoPermissionsUpdateWithoutVideoItemInput, VideoPermissionsUncheckedUpdateWithoutVideoItemInput>
    create: XOR<VideoPermissionsCreateWithoutVideoItemInput, VideoPermissionsUncheckedCreateWithoutVideoItemInput>
    where?: VideoPermissionsWhereInput
  }

  export type VideoPermissionsUpdateToOneWithWhereWithoutVideoItemInput = {
    where?: VideoPermissionsWhereInput
    data: XOR<VideoPermissionsUpdateWithoutVideoItemInput, VideoPermissionsUncheckedUpdateWithoutVideoItemInput>
  }

  export type VideoPermissionsUpdateWithoutVideoItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    showWaveCount?: BoolFieldUpdateOperationsInput | boolean
    showVideos?: BoolFieldUpdateOperationsInput | boolean
    showVideoSubtitles?: BoolFieldUpdateOperationsInput | boolean
    showComments?: BoolFieldUpdateOperationsInput | boolean
    showPublishDate?: BoolFieldUpdateOperationsInput | boolean
    showVideoDuration?: BoolFieldUpdateOperationsInput | boolean
    showLikeButton?: BoolFieldUpdateOperationsInput | boolean
    allowRewindForward?: BoolFieldUpdateOperationsInput | boolean
    allowViewComments?: BoolFieldUpdateOperationsInput | boolean
    allowMakeComments?: BoolFieldUpdateOperationsInput | boolean
    showLikeComments?: BoolFieldUpdateOperationsInput | boolean
    sortCommentsByAffinity?: BoolFieldUpdateOperationsInput | boolean
    showCommenterName?: BoolFieldUpdateOperationsInput | boolean
    playlistPosition?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutVideoPermissionsNestedInput
  }

  export type VideoPermissionsUncheckedUpdateWithoutVideoItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    showWaveCount?: BoolFieldUpdateOperationsInput | boolean
    showVideos?: BoolFieldUpdateOperationsInput | boolean
    showVideoSubtitles?: BoolFieldUpdateOperationsInput | boolean
    showComments?: BoolFieldUpdateOperationsInput | boolean
    showPublishDate?: BoolFieldUpdateOperationsInput | boolean
    showVideoDuration?: BoolFieldUpdateOperationsInput | boolean
    showLikeButton?: BoolFieldUpdateOperationsInput | boolean
    allowRewindForward?: BoolFieldUpdateOperationsInput | boolean
    allowViewComments?: BoolFieldUpdateOperationsInput | boolean
    allowMakeComments?: BoolFieldUpdateOperationsInput | boolean
    showLikeComments?: BoolFieldUpdateOperationsInput | boolean
    sortCommentsByAffinity?: BoolFieldUpdateOperationsInput | boolean
    showCommenterName?: BoolFieldUpdateOperationsInput | boolean
    playlistPosition?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoItemCreateWithoutSubtitlesInput = {
    title: string
    description?: string | null
    content: string
    url?: string | null
    platform?: string
    externalId?: string | null
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    duration?: number | null
    categories?: string | null
    language?: string | null
    quality?: string | null
    tags?: string | null
    thumbnailUrl?: string | null
    activities?: ActivityCreateNestedManyWithoutVideoItemInput
    questions?: QuestionCreateNestedManyWithoutVideoItemInput
    studyRooms?: StudyRoomCreateNestedManyWithoutVideoInput
    playlist: PlaylistCreateNestedOneWithoutVideoItemsInput
    permissions?: VideoPermissionsCreateNestedOneWithoutVideoItemInput
  }

  export type VideoItemUncheckedCreateWithoutSubtitlesInput = {
    id?: number
    title: string
    description?: string | null
    content: string
    url?: string | null
    platform?: string
    externalId?: string | null
    playlistId: string
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    duration?: number | null
    categories?: string | null
    language?: string | null
    quality?: string | null
    tags?: string | null
    thumbnailUrl?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutVideoItemInput
    questions?: QuestionUncheckedCreateNestedManyWithoutVideoItemInput
    studyRooms?: StudyRoomUncheckedCreateNestedManyWithoutVideoInput
    permissions?: VideoPermissionsUncheckedCreateNestedOneWithoutVideoItemInput
  }

  export type VideoItemCreateOrConnectWithoutSubtitlesInput = {
    where: VideoItemWhereUniqueInput
    create: XOR<VideoItemCreateWithoutSubtitlesInput, VideoItemUncheckedCreateWithoutSubtitlesInput>
  }

  export type VideoItemUpsertWithoutSubtitlesInput = {
    update: XOR<VideoItemUpdateWithoutSubtitlesInput, VideoItemUncheckedUpdateWithoutSubtitlesInput>
    create: XOR<VideoItemCreateWithoutSubtitlesInput, VideoItemUncheckedCreateWithoutSubtitlesInput>
    where?: VideoItemWhereInput
  }

  export type VideoItemUpdateToOneWithWhereWithoutSubtitlesInput = {
    where?: VideoItemWhereInput
    data: XOR<VideoItemUpdateWithoutSubtitlesInput, VideoItemUncheckedUpdateWithoutSubtitlesInput>
  }

  export type VideoItemUpdateWithoutSubtitlesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutVideoItemNestedInput
    questions?: QuestionUpdateManyWithoutVideoItemNestedInput
    studyRooms?: StudyRoomUpdateManyWithoutVideoNestedInput
    playlist?: PlaylistUpdateOneRequiredWithoutVideoItemsNestedInput
    permissions?: VideoPermissionsUpdateOneWithoutVideoItemNestedInput
  }

  export type VideoItemUncheckedUpdateWithoutSubtitlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    playlistId?: StringFieldUpdateOperationsInput | string
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutVideoItemNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutVideoItemNestedInput
    studyRooms?: StudyRoomUncheckedUpdateManyWithoutVideoNestedInput
    permissions?: VideoPermissionsUncheckedUpdateOneWithoutVideoItemNestedInput
  }

  export type AnswerOptionCreateWithoutQuestionInput = {
    text: string
    isCorrect?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnswerOptionUncheckedCreateWithoutQuestionInput = {
    id?: number
    text: string
    isCorrect?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnswerOptionCreateOrConnectWithoutQuestionInput = {
    where: AnswerOptionWhereUniqueInput
    create: XOR<AnswerOptionCreateWithoutQuestionInput, AnswerOptionUncheckedCreateWithoutQuestionInput>
  }

  export type AnswerOptionCreateManyQuestionInputEnvelope = {
    data: AnswerOptionCreateManyQuestionInput | AnswerOptionCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type VideoItemCreateWithoutQuestionsInput = {
    title: string
    description?: string | null
    content: string
    url?: string | null
    platform?: string
    externalId?: string | null
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    duration?: number | null
    categories?: string | null
    language?: string | null
    quality?: string | null
    tags?: string | null
    thumbnailUrl?: string | null
    activities?: ActivityCreateNestedManyWithoutVideoItemInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoItemInput
    studyRooms?: StudyRoomCreateNestedManyWithoutVideoInput
    playlist: PlaylistCreateNestedOneWithoutVideoItemsInput
    permissions?: VideoPermissionsCreateNestedOneWithoutVideoItemInput
  }

  export type VideoItemUncheckedCreateWithoutQuestionsInput = {
    id?: number
    title: string
    description?: string | null
    content: string
    url?: string | null
    platform?: string
    externalId?: string | null
    playlistId: string
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    duration?: number | null
    categories?: string | null
    language?: string | null
    quality?: string | null
    tags?: string | null
    thumbnailUrl?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutVideoItemInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoItemInput
    studyRooms?: StudyRoomUncheckedCreateNestedManyWithoutVideoInput
    permissions?: VideoPermissionsUncheckedCreateNestedOneWithoutVideoItemInput
  }

  export type VideoItemCreateOrConnectWithoutQuestionsInput = {
    where: VideoItemWhereUniqueInput
    create: XOR<VideoItemCreateWithoutQuestionsInput, VideoItemUncheckedCreateWithoutQuestionsInput>
  }

  export type UserAnswerCreateWithoutQuestionInput = {
    id?: string
    answerGiven: string
    isCorrect?: boolean | null
    ondasEarned?: number
    createdAt?: Date | string
    activityQuestion?: ActivityQuestionCreateNestedOneWithoutUserAnswersInput
    user: UserCreateNestedOneWithoutUserAnswersInput
  }

  export type UserAnswerUncheckedCreateWithoutQuestionInput = {
    id?: string
    userId: string
    activityQuestionId?: string | null
    answerGiven: string
    isCorrect?: boolean | null
    ondasEarned?: number
    createdAt?: Date | string
  }

  export type UserAnswerCreateOrConnectWithoutQuestionInput = {
    where: UserAnswerWhereUniqueInput
    create: XOR<UserAnswerCreateWithoutQuestionInput, UserAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type UserAnswerCreateManyQuestionInputEnvelope = {
    data: UserAnswerCreateManyQuestionInput | UserAnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type AnswerOptionUpsertWithWhereUniqueWithoutQuestionInput = {
    where: AnswerOptionWhereUniqueInput
    update: XOR<AnswerOptionUpdateWithoutQuestionInput, AnswerOptionUncheckedUpdateWithoutQuestionInput>
    create: XOR<AnswerOptionCreateWithoutQuestionInput, AnswerOptionUncheckedCreateWithoutQuestionInput>
  }

  export type AnswerOptionUpdateWithWhereUniqueWithoutQuestionInput = {
    where: AnswerOptionWhereUniqueInput
    data: XOR<AnswerOptionUpdateWithoutQuestionInput, AnswerOptionUncheckedUpdateWithoutQuestionInput>
  }

  export type AnswerOptionUpdateManyWithWhereWithoutQuestionInput = {
    where: AnswerOptionScalarWhereInput
    data: XOR<AnswerOptionUpdateManyMutationInput, AnswerOptionUncheckedUpdateManyWithoutQuestionInput>
  }

  export type AnswerOptionScalarWhereInput = {
    AND?: AnswerOptionScalarWhereInput | AnswerOptionScalarWhereInput[]
    OR?: AnswerOptionScalarWhereInput[]
    NOT?: AnswerOptionScalarWhereInput | AnswerOptionScalarWhereInput[]
    id?: IntFilter<"AnswerOption"> | number
    questionId?: IntFilter<"AnswerOption"> | number
    text?: StringFilter<"AnswerOption"> | string
    isCorrect?: BoolFilter<"AnswerOption"> | boolean
    order?: IntFilter<"AnswerOption"> | number
    createdAt?: DateTimeFilter<"AnswerOption"> | Date | string
    updatedAt?: DateTimeFilter<"AnswerOption"> | Date | string
  }

  export type VideoItemUpsertWithoutQuestionsInput = {
    update: XOR<VideoItemUpdateWithoutQuestionsInput, VideoItemUncheckedUpdateWithoutQuestionsInput>
    create: XOR<VideoItemCreateWithoutQuestionsInput, VideoItemUncheckedCreateWithoutQuestionsInput>
    where?: VideoItemWhereInput
  }

  export type VideoItemUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: VideoItemWhereInput
    data: XOR<VideoItemUpdateWithoutQuestionsInput, VideoItemUncheckedUpdateWithoutQuestionsInput>
  }

  export type VideoItemUpdateWithoutQuestionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutVideoItemNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoItemNestedInput
    studyRooms?: StudyRoomUpdateManyWithoutVideoNestedInput
    playlist?: PlaylistUpdateOneRequiredWithoutVideoItemsNestedInput
    permissions?: VideoPermissionsUpdateOneWithoutVideoItemNestedInput
  }

  export type VideoItemUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    playlistId?: StringFieldUpdateOperationsInput | string
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutVideoItemNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoItemNestedInput
    studyRooms?: StudyRoomUncheckedUpdateManyWithoutVideoNestedInput
    permissions?: VideoPermissionsUncheckedUpdateOneWithoutVideoItemNestedInput
  }

  export type UserAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: UserAnswerWhereUniqueInput
    update: XOR<UserAnswerUpdateWithoutQuestionInput, UserAnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<UserAnswerCreateWithoutQuestionInput, UserAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type UserAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: UserAnswerWhereUniqueInput
    data: XOR<UserAnswerUpdateWithoutQuestionInput, UserAnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type UserAnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: UserAnswerScalarWhereInput
    data: XOR<UserAnswerUpdateManyMutationInput, UserAnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type UserAnswerScalarWhereInput = {
    AND?: UserAnswerScalarWhereInput | UserAnswerScalarWhereInput[]
    OR?: UserAnswerScalarWhereInput[]
    NOT?: UserAnswerScalarWhereInput | UserAnswerScalarWhereInput[]
    id?: StringFilter<"UserAnswer"> | string
    userId?: StringFilter<"UserAnswer"> | string
    questionId?: IntNullableFilter<"UserAnswer"> | number | null
    activityQuestionId?: StringNullableFilter<"UserAnswer"> | string | null
    answerGiven?: StringFilter<"UserAnswer"> | string
    isCorrect?: BoolNullableFilter<"UserAnswer"> | boolean | null
    ondasEarned?: IntFilter<"UserAnswer"> | number
    createdAt?: DateTimeFilter<"UserAnswer"> | Date | string
  }

  export type QuestionCreateWithoutAnswerOptionsInput = {
    timestamp: number
    type: string
    text: string
    languageCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    endTimestamp?: number | null
    videoItem: VideoItemCreateNestedOneWithoutQuestionsInput
    userAnswers?: UserAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutAnswerOptionsInput = {
    id?: number
    videoItemId: number
    timestamp: number
    type: string
    text: string
    languageCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    endTimestamp?: number | null
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutAnswerOptionsInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutAnswerOptionsInput, QuestionUncheckedCreateWithoutAnswerOptionsInput>
  }

  export type QuestionUpsertWithoutAnswerOptionsInput = {
    update: XOR<QuestionUpdateWithoutAnswerOptionsInput, QuestionUncheckedUpdateWithoutAnswerOptionsInput>
    create: XOR<QuestionCreateWithoutAnswerOptionsInput, QuestionUncheckedCreateWithoutAnswerOptionsInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutAnswerOptionsInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutAnswerOptionsInput, QuestionUncheckedUpdateWithoutAnswerOptionsInput>
  }

  export type QuestionUpdateWithoutAnswerOptionsInput = {
    timestamp?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    videoItem?: VideoItemUpdateOneRequiredWithoutQuestionsNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutAnswerOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoItemId?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type ActivityCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    multimediaType?: string | null
    contentUrl?: string | null
    duration?: number | null
    order?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoItem?: VideoItemCreateNestedOneWithoutActivitiesInput
    experience: ExperienceCreateNestedOneWithoutActivitiesInput
    questions?: ActivityQuestionCreateNestedManyWithoutActivityInput
    gamifiedPlaylists?: GamifiedPlaylistCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutCreatorInput = {
    id?: string
    experienceId: string
    title: string
    description?: string | null
    type: string
    multimediaType?: string | null
    contentUrl?: string | null
    duration?: number | null
    order?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoItemId?: number | null
    questions?: ActivityQuestionUncheckedCreateNestedManyWithoutActivityInput
    gamifiedPlaylists?: GamifiedPlaylistUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutCreatorInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutCreatorInput, ActivityUncheckedCreateWithoutCreatorInput>
  }

  export type ActivityCreateManyCreatorInputEnvelope = {
    data: ActivityCreateManyCreatorInput | ActivityCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    activityId?: string | null
    text: string
    createdAt?: Date | string
    publication?: PublicationCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    publicationId?: string | null
    activityId?: string | null
    text: string
    createdAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    publication: PublicationCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutUserInput = {
    id?: string
    publicationId: string
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutUserInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput>
  }

  export type LikeCreateManyUserInputEnvelope = {
    data: LikeCreateManyUserInput | LikeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExperienceCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    gamificationFramework?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutExperienceInput
    stage: StageCreateNestedOneWithoutExperiencesInput
  }

  export type ExperienceUncheckedCreateWithoutCreatorInput = {
    id?: string
    stageId: string
    title: string
    description?: string | null
    type: string
    gamificationFramework?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutExperienceInput
  }

  export type ExperienceCreateOrConnectWithoutCreatorInput = {
    where: ExperienceWhereUniqueInput
    create: XOR<ExperienceCreateWithoutCreatorInput, ExperienceUncheckedCreateWithoutCreatorInput>
  }

  export type ExperienceCreateManyCreatorInputEnvelope = {
    data: ExperienceCreateManyCreatorInput | ExperienceCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type GiftCardCreateWithoutInviterInput = {
    id?: string
    invitedName: string
    invitedEmail: string
    token: string
    unitsAmount: number
    suggestions?: string | null
    status?: string
    createdAt?: Date | string
    userInvitations?: UserInvitationCreateNestedManyWithoutGiftCardInput
  }

  export type GiftCardUncheckedCreateWithoutInviterInput = {
    id?: string
    invitedName: string
    invitedEmail: string
    token: string
    unitsAmount: number
    suggestions?: string | null
    status?: string
    createdAt?: Date | string
    userInvitations?: UserInvitationUncheckedCreateNestedManyWithoutGiftCardInput
  }

  export type GiftCardCreateOrConnectWithoutInviterInput = {
    where: GiftCardWhereUniqueInput
    create: XOR<GiftCardCreateWithoutInviterInput, GiftCardUncheckedCreateWithoutInviterInput>
  }

  export type GiftCardCreateManyInviterInputEnvelope = {
    data: GiftCardCreateManyInviterInput | GiftCardCreateManyInviterInput[]
    skipDuplicates?: boolean
  }

  export type GroupCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userGroups?: UserGroupCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutOwnerInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput>
  }

  export type GroupCreateManyOwnerInputEnvelope = {
    data: GroupCreateManyOwnerInput | GroupCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type InvitationTemplateCreateWithoutCreatorInput = {
    id?: string
    name: string
    content: string
    createdAt?: Date | string
  }

  export type InvitationTemplateUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    content: string
    createdAt?: Date | string
  }

  export type InvitationTemplateCreateOrConnectWithoutCreatorInput = {
    where: InvitationTemplateWhereUniqueInput
    create: XOR<InvitationTemplateCreateWithoutCreatorInput, InvitationTemplateUncheckedCreateWithoutCreatorInput>
  }

  export type InvitationTemplateCreateManyCreatorInputEnvelope = {
    data: InvitationTemplateCreateManyCreatorInput | InvitationTemplateCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type MeritCreateWithoutUserInput = {
    id?: string
    amount: number
    type: string
    source: string
    relatedEntityId?: string | null
    createdAt?: Date | string
  }

  export type MeritUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    type: string
    source: string
    relatedEntityId?: string | null
    createdAt?: Date | string
  }

  export type MeritCreateOrConnectWithoutUserInput = {
    where: MeritWhereUniqueInput
    create: XOR<MeritCreateWithoutUserInput, MeritUncheckedCreateWithoutUserInput>
  }

  export type MeritCreateManyUserInputEnvelope = {
    data: MeritCreateManyUserInput | MeritCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PublicationCreateWithoutUserInput = {
    id?: string
    content: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPublicationInput
    likes?: LikeCreateNestedManyWithoutPublicationInput
  }

  export type PublicationUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPublicationInput
    likes?: LikeUncheckedCreateNestedManyWithoutPublicationInput
  }

  export type PublicationCreateOrConnectWithoutUserInput = {
    where: PublicationWhereUniqueInput
    create: XOR<PublicationCreateWithoutUserInput, PublicationUncheckedCreateWithoutUserInput>
  }

  export type PublicationCreateManyUserInputEnvelope = {
    data: PublicationCreateManyUserInput | PublicationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutCreatorInput = {
    id?: string
    name: string
    type: string
    parameters?: string | null
    generatedAt?: Date | string
    data: string
  }

  export type ReportUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    type: string
    parameters?: string | null
    generatedAt?: Date | string
    data: string
  }

  export type ReportCreateOrConnectWithoutCreatorInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutCreatorInput, ReportUncheckedCreateWithoutCreatorInput>
  }

  export type ReportCreateManyCreatorInputEnvelope = {
    data: ReportCreateManyCreatorInput | ReportCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionCreateWithoutAssignedByInput = {
    assignedAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
    role: RoleCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutAssignedByInput = {
    roleId: string
    permissionId: string
    assignedAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutAssignedByInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutAssignedByInput, RolePermissionUncheckedCreateWithoutAssignedByInput>
  }

  export type RolePermissionCreateManyAssignedByInputEnvelope = {
    data: RolePermissionCreateManyAssignedByInput | RolePermissionCreateManyAssignedByInput[]
    skipDuplicates?: boolean
  }

  export type TokenCreateWithoutUserInput = {
    id?: string
    amount: number
    type: string
    status?: string
    caducityDate?: Date | string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    type: string
    status?: string
    caducityDate?: Date | string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenCreateOrConnectWithoutUserInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenCreateManyUserInputEnvelope = {
    data: TokenCreateManyUserInput | TokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutToUserInput = {
    id?: string
    amount: number
    tokenType: string
    type: string
    status?: string
    description?: string | null
    createdAt?: Date | string
    toWallet: WalletCreateNestedOneWithoutTransactionsToInput
    fromWallet?: WalletCreateNestedOneWithoutTransactionsFromInput
    fromUser?: UserCreateNestedOneWithoutTransactionsFromInput
  }

  export type TransactionUncheckedCreateWithoutToUserInput = {
    id?: string
    fromUserId?: string | null
    amount: number
    tokenType: string
    type: string
    status?: string
    description?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutToUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutToUserInput, TransactionUncheckedCreateWithoutToUserInput>
  }

  export type TransactionCreateManyToUserInputEnvelope = {
    data: TransactionCreateManyToUserInput | TransactionCreateManyToUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutFromUserInput = {
    id?: string
    amount: number
    tokenType: string
    type: string
    status?: string
    description?: string | null
    createdAt?: Date | string
    toWallet: WalletCreateNestedOneWithoutTransactionsToInput
    fromWallet?: WalletCreateNestedOneWithoutTransactionsFromInput
    toUser: UserCreateNestedOneWithoutTransactionsToInput
  }

  export type TransactionUncheckedCreateWithoutFromUserInput = {
    id?: string
    toUserId: string
    amount: number
    tokenType: string
    type: string
    status?: string
    description?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutFromUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutFromUserInput, TransactionUncheckedCreateWithoutFromUserInput>
  }

  export type TransactionCreateManyFromUserInputEnvelope = {
    data: TransactionCreateManyFromUserInput | TransactionCreateManyFromUserInput[]
    skipDuplicates?: boolean
  }

  export type UIComponentTemplateCreateWithoutCreatorInput = {
    id?: string
    name: string
    type: string
    templateJson: string
    createdAt?: Date | string
  }

  export type UIComponentTemplateUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    type: string
    templateJson: string
    createdAt?: Date | string
  }

  export type UIComponentTemplateCreateOrConnectWithoutCreatorInput = {
    where: UIComponentTemplateWhereUniqueInput
    create: XOR<UIComponentTemplateCreateWithoutCreatorInput, UIComponentTemplateUncheckedCreateWithoutCreatorInput>
  }

  export type UIComponentTemplateCreateManyCreatorInputEnvelope = {
    data: UIComponentTemplateCreateManyCreatorInput | UIComponentTemplateCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type UserAnswerCreateWithoutUserInput = {
    id?: string
    answerGiven: string
    isCorrect?: boolean | null
    ondasEarned?: number
    createdAt?: Date | string
    activityQuestion?: ActivityQuestionCreateNestedOneWithoutUserAnswersInput
    question?: QuestionCreateNestedOneWithoutUserAnswersInput
  }

  export type UserAnswerUncheckedCreateWithoutUserInput = {
    id?: string
    questionId?: number | null
    activityQuestionId?: string | null
    answerGiven: string
    isCorrect?: boolean | null
    ondasEarned?: number
    createdAt?: Date | string
  }

  export type UserAnswerCreateOrConnectWithoutUserInput = {
    where: UserAnswerWhereUniqueInput
    create: XOR<UserAnswerCreateWithoutUserInput, UserAnswerUncheckedCreateWithoutUserInput>
  }

  export type UserAnswerCreateManyUserInputEnvelope = {
    data: UserAnswerCreateManyUserInput | UserAnswerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserChallengeCreateWithoutUserInput = {
    id?: string
    status?: string
    progress?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: string | null
    challenge: ChallengeCreateNestedOneWithoutUserChallengesInput
  }

  export type UserChallengeUncheckedCreateWithoutUserInput = {
    id?: string
    challengeId: string
    status?: string
    progress?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: string | null
  }

  export type UserChallengeCreateOrConnectWithoutUserInput = {
    where: UserChallengeWhereUniqueInput
    create: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput>
  }

  export type UserChallengeCreateManyUserInputEnvelope = {
    data: UserChallengeCreateManyUserInput | UserChallengeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserGroupCreateWithoutUserInput = {
    roleInGroup?: string
    joinedAt?: Date | string
    group: GroupCreateNestedOneWithoutUserGroupsInput
  }

  export type UserGroupUncheckedCreateWithoutUserInput = {
    groupId: string
    roleInGroup?: string
    joinedAt?: Date | string
  }

  export type UserGroupCreateOrConnectWithoutUserInput = {
    where: UserGroupWhereUniqueInput
    create: XOR<UserGroupCreateWithoutUserInput, UserGroupUncheckedCreateWithoutUserInput>
  }

  export type UserGroupCreateManyUserInputEnvelope = {
    data: UserGroupCreateManyUserInput | UserGroupCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserInvitationCreateWithoutInvitedUserInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    giftCard: GiftCardCreateNestedOneWithoutUserInvitationsInput
  }

  export type UserInvitationUncheckedCreateWithoutInvitedUserInput = {
    id?: string
    giftCardId: string
    status?: string
    createdAt?: Date | string
  }

  export type UserInvitationCreateOrConnectWithoutInvitedUserInput = {
    where: UserInvitationWhereUniqueInput
    create: XOR<UserInvitationCreateWithoutInvitedUserInput, UserInvitationUncheckedCreateWithoutInvitedUserInput>
  }

  export type UserInvitationCreateManyInvitedUserInputEnvelope = {
    data: UserInvitationCreateManyInvitedUserInput | UserInvitationCreateManyInvitedUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutAssignedByInput = {
    assignedAt?: Date | string
    role: RoleCreateNestedOneWithoutUserRolesInput
    user: UserCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutAssignedByInput = {
    userId: string
    roleId: string
    assignedAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutAssignedByInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutAssignedByInput, UserRoleUncheckedCreateWithoutAssignedByInput>
  }

  export type UserRoleCreateManyAssignedByInputEnvelope = {
    data: UserRoleCreateManyAssignedByInput | UserRoleCreateManyAssignedByInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutUserInput = {
    assignedAt?: Date | string
    assignedBy?: UserCreateNestedOneWithoutAssignedRolesInput
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    roleId: string
    assignedAt?: Date | string
    assignedById?: string | null
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StudyRoomCreateWithoutHostInput = {
    id?: string
    name: string
    description?: string | null
    maxParticipants?: number
    status?: $Enums.StudyRoomStatus
    currentTime?: number
    isPaused?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    video: VideoItemCreateNestedOneWithoutStudyRoomsInput
    participants?: StudyRoomParticipantCreateNestedManyWithoutStudyRoomInput
    messages?: StudyRoomMessageCreateNestedManyWithoutStudyRoomInput
  }

  export type StudyRoomUncheckedCreateWithoutHostInput = {
    id?: string
    name: string
    description?: string | null
    videoId: number
    maxParticipants?: number
    status?: $Enums.StudyRoomStatus
    currentTime?: number
    isPaused?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutStudyRoomInput
    messages?: StudyRoomMessageUncheckedCreateNestedManyWithoutStudyRoomInput
  }

  export type StudyRoomCreateOrConnectWithoutHostInput = {
    where: StudyRoomWhereUniqueInput
    create: XOR<StudyRoomCreateWithoutHostInput, StudyRoomUncheckedCreateWithoutHostInput>
  }

  export type StudyRoomCreateManyHostInputEnvelope = {
    data: StudyRoomCreateManyHostInput | StudyRoomCreateManyHostInput[]
    skipDuplicates?: boolean
  }

  export type StudyRoomParticipantCreateWithoutUserInput = {
    id?: string
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isActive?: boolean
    studyRoom: StudyRoomCreateNestedOneWithoutParticipantsInput
  }

  export type StudyRoomParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    studyRoomId: string
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isActive?: boolean
  }

  export type StudyRoomParticipantCreateOrConnectWithoutUserInput = {
    where: StudyRoomParticipantWhereUniqueInput
    create: XOR<StudyRoomParticipantCreateWithoutUserInput, StudyRoomParticipantUncheckedCreateWithoutUserInput>
  }

  export type StudyRoomParticipantCreateManyUserInputEnvelope = {
    data: StudyRoomParticipantCreateManyUserInput | StudyRoomParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StudyRoomMessageCreateWithoutUserInput = {
    id?: string
    message: string
    messageType?: string
    metadata?: string | null
    createdAt?: Date | string
    studyRoom: StudyRoomCreateNestedOneWithoutMessagesInput
  }

  export type StudyRoomMessageUncheckedCreateWithoutUserInput = {
    id?: string
    studyRoomId: string
    message: string
    messageType?: string
    metadata?: string | null
    createdAt?: Date | string
  }

  export type StudyRoomMessageCreateOrConnectWithoutUserInput = {
    where: StudyRoomMessageWhereUniqueInput
    create: XOR<StudyRoomMessageCreateWithoutUserInput, StudyRoomMessageUncheckedCreateWithoutUserInput>
  }

  export type StudyRoomMessageCreateManyUserInputEnvelope = {
    data: StudyRoomMessageCreateManyUserInput | StudyRoomMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PersonalityCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    traits: string
    createdAt?: Date | string
  }

  export type PersonalityUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    traits: string
    createdAt?: Date | string
  }

  export type PersonalityCreateOrConnectWithoutUsersInput = {
    where: PersonalityWhereUniqueInput
    create: XOR<PersonalityCreateWithoutUsersInput, PersonalityUncheckedCreateWithoutUsersInput>
  }

  export type VideoPermissionsCreateWithoutCreatedByInput = {
    id?: string
    showWaveCount?: boolean
    showVideos?: boolean
    showVideoSubtitles?: boolean
    showComments?: boolean
    showPublishDate?: boolean
    showVideoDuration?: boolean
    showLikeButton?: boolean
    allowRewindForward?: boolean
    allowViewComments?: boolean
    allowMakeComments?: boolean
    showLikeComments?: boolean
    sortCommentsByAffinity?: boolean
    showCommenterName?: boolean
    playlistPosition?: string
    isDraft?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    videoItem: VideoItemCreateNestedOneWithoutPermissionsInput
  }

  export type VideoPermissionsUncheckedCreateWithoutCreatedByInput = {
    id?: string
    videoItemId: number
    showWaveCount?: boolean
    showVideos?: boolean
    showVideoSubtitles?: boolean
    showComments?: boolean
    showPublishDate?: boolean
    showVideoDuration?: boolean
    showLikeButton?: boolean
    allowRewindForward?: boolean
    allowViewComments?: boolean
    allowMakeComments?: boolean
    showLikeComments?: boolean
    sortCommentsByAffinity?: boolean
    showCommenterName?: boolean
    playlistPosition?: string
    isDraft?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoPermissionsCreateOrConnectWithoutCreatedByInput = {
    where: VideoPermissionsWhereUniqueInput
    create: XOR<VideoPermissionsCreateWithoutCreatedByInput, VideoPermissionsUncheckedCreateWithoutCreatedByInput>
  }

  export type VideoPermissionsCreateManyCreatedByInputEnvelope = {
    data: VideoPermissionsCreateManyCreatedByInput | VideoPermissionsCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type WalletCreateWithoutUserInput = {
    id?: string
    blockchainAddress?: string | null
    balanceUnits?: number
    balanceToins?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionsTo?: TransactionCreateNestedManyWithoutToWalletInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromWalletInput
  }

  export type WalletUncheckedCreateWithoutUserInput = {
    id?: string
    blockchainAddress?: string | null
    balanceUnits?: number
    balanceToins?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToWalletInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromWalletInput
  }

  export type WalletCreateOrConnectWithoutUserInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type WorldCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stages?: StageCreateNestedManyWithoutWorldInput
    mundo?: MundoCreateNestedOneWithoutWorldsInput
  }

  export type WorldUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mundoId?: string | null
    stages?: StageUncheckedCreateNestedManyWithoutWorldInput
  }

  export type WorldCreateOrConnectWithoutCreatorInput = {
    where: WorldWhereUniqueInput
    create: XOR<WorldCreateWithoutCreatorInput, WorldUncheckedCreateWithoutCreatorInput>
  }

  export type WorldCreateManyCreatorInputEnvelope = {
    data: WorldCreateManyCreatorInput | WorldCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type MarketplaceItemCreateWithoutSellerInput = {
    id?: string
    name: string
    description?: string | null
    fullDescription?: string | null
    itemType?: $Enums.MarketplaceItemType
    price?: number
    priceToins?: number
    currency?: $Enums.Currency
    category?: string | null
    tags?: MarketplaceItemCreatetagsInput | string[]
    images?: MarketplaceItemCreateimagesInput | string[]
    stock?: number
    rating?: number
    reviewCount?: number
    location?: string | null
    status?: $Enums.MarketplaceItemStatus
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    viewCount?: number
    favoriteCount?: number
    metadata?: string | null
    reviews?: ReviewCreateNestedManyWithoutMarketplaceItemInput
    matches?: MarketplaceMatchCreateNestedManyWithoutItemInput
  }

  export type MarketplaceItemUncheckedCreateWithoutSellerInput = {
    id?: string
    name: string
    description?: string | null
    fullDescription?: string | null
    itemType?: $Enums.MarketplaceItemType
    price?: number
    priceToins?: number
    currency?: $Enums.Currency
    category?: string | null
    tags?: MarketplaceItemCreatetagsInput | string[]
    images?: MarketplaceItemCreateimagesInput | string[]
    stock?: number
    rating?: number
    reviewCount?: number
    location?: string | null
    status?: $Enums.MarketplaceItemStatus
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    viewCount?: number
    favoriteCount?: number
    metadata?: string | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutMarketplaceItemInput
    matches?: MarketplaceMatchUncheckedCreateNestedManyWithoutItemInput
  }

  export type MarketplaceItemCreateOrConnectWithoutSellerInput = {
    where: MarketplaceItemWhereUniqueInput
    create: XOR<MarketplaceItemCreateWithoutSellerInput, MarketplaceItemUncheckedCreateWithoutSellerInput>
  }

  export type MarketplaceItemCreateManySellerInputEnvelope = {
    data: MarketplaceItemCreateManySellerInput | MarketplaceItemCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type MarketplaceMatchCreateWithoutBuyerInput = {
    id?: string
    buyerConfirmed?: boolean
    sellerConfirmed?: boolean
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    item: MarketplaceItemCreateNestedOneWithoutMatchesInput
    seller: UserCreateNestedOneWithoutSellerMatchesInput
    messages?: MatchMessageCreateNestedManyWithoutMatchInput
  }

  export type MarketplaceMatchUncheckedCreateWithoutBuyerInput = {
    id?: string
    itemId: string
    sellerId: string
    buyerConfirmed?: boolean
    sellerConfirmed?: boolean
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MatchMessageUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MarketplaceMatchCreateOrConnectWithoutBuyerInput = {
    where: MarketplaceMatchWhereUniqueInput
    create: XOR<MarketplaceMatchCreateWithoutBuyerInput, MarketplaceMatchUncheckedCreateWithoutBuyerInput>
  }

  export type MarketplaceMatchCreateManyBuyerInputEnvelope = {
    data: MarketplaceMatchCreateManyBuyerInput | MarketplaceMatchCreateManyBuyerInput[]
    skipDuplicates?: boolean
  }

  export type MarketplaceMatchCreateWithoutSellerInput = {
    id?: string
    buyerConfirmed?: boolean
    sellerConfirmed?: boolean
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    item: MarketplaceItemCreateNestedOneWithoutMatchesInput
    buyer: UserCreateNestedOneWithoutBuyerMatchesInput
    messages?: MatchMessageCreateNestedManyWithoutMatchInput
  }

  export type MarketplaceMatchUncheckedCreateWithoutSellerInput = {
    id?: string
    itemId: string
    buyerId: string
    buyerConfirmed?: boolean
    sellerConfirmed?: boolean
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MatchMessageUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MarketplaceMatchCreateOrConnectWithoutSellerInput = {
    where: MarketplaceMatchWhereUniqueInput
    create: XOR<MarketplaceMatchCreateWithoutSellerInput, MarketplaceMatchUncheckedCreateWithoutSellerInput>
  }

  export type MarketplaceMatchCreateManySellerInputEnvelope = {
    data: MarketplaceMatchCreateManySellerInput | MarketplaceMatchCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type MatchMessageCreateWithoutSenderInput = {
    id?: string
    content: string
    createdAt?: Date | string
    match: MarketplaceMatchCreateNestedOneWithoutMessagesInput
  }

  export type MatchMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    matchId: string
    content: string
    createdAt?: Date | string
  }

  export type MatchMessageCreateOrConnectWithoutSenderInput = {
    where: MatchMessageWhereUniqueInput
    create: XOR<MatchMessageCreateWithoutSenderInput, MatchMessageUncheckedCreateWithoutSenderInput>
  }

  export type MatchMessageCreateManySenderInputEnvelope = {
    data: MatchMessageCreateManySenderInput | MatchMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackReportCreateWithoutUserInput = {
    id?: string
    type: $Enums.FeedbackType
    title: string
    description: string
    priority?: $Enums.FeedbackPriority
    category: string
    status?: $Enums.FeedbackStatus
    elementContext: JsonNullValueInput | InputJsonValue
    technicalContext: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: string | null
    resolvedAt?: Date | string | null
    upvotes?: number
    downvotes?: number
    duplicateOf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adminUser?: UserCreateNestedOneWithoutAdminFeedbackResponsesInput
  }

  export type FeedbackReportUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.FeedbackType
    title: string
    description: string
    priority?: $Enums.FeedbackPriority
    category: string
    status?: $Enums.FeedbackStatus
    elementContext: JsonNullValueInput | InputJsonValue
    technicalContext: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: string | null
    adminUserId?: string | null
    resolvedAt?: Date | string | null
    upvotes?: number
    downvotes?: number
    duplicateOf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackReportCreateOrConnectWithoutUserInput = {
    where: FeedbackReportWhereUniqueInput
    create: XOR<FeedbackReportCreateWithoutUserInput, FeedbackReportUncheckedCreateWithoutUserInput>
  }

  export type FeedbackReportCreateManyUserInputEnvelope = {
    data: FeedbackReportCreateManyUserInput | FeedbackReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackReportCreateWithoutAdminUserInput = {
    id?: string
    type: $Enums.FeedbackType
    title: string
    description: string
    priority?: $Enums.FeedbackPriority
    category: string
    status?: $Enums.FeedbackStatus
    elementContext: JsonNullValueInput | InputJsonValue
    technicalContext: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: string | null
    resolvedAt?: Date | string | null
    upvotes?: number
    downvotes?: number
    duplicateOf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFeedbackReportsInput
  }

  export type FeedbackReportUncheckedCreateWithoutAdminUserInput = {
    id?: string
    userId: string
    type: $Enums.FeedbackType
    title: string
    description: string
    priority?: $Enums.FeedbackPriority
    category: string
    status?: $Enums.FeedbackStatus
    elementContext: JsonNullValueInput | InputJsonValue
    technicalContext: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: string | null
    resolvedAt?: Date | string | null
    upvotes?: number
    downvotes?: number
    duplicateOf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackReportCreateOrConnectWithoutAdminUserInput = {
    where: FeedbackReportWhereUniqueInput
    create: XOR<FeedbackReportCreateWithoutAdminUserInput, FeedbackReportUncheckedCreateWithoutAdminUserInput>
  }

  export type FeedbackReportCreateManyAdminUserInputEnvelope = {
    data: FeedbackReportCreateManyAdminUserInput | FeedbackReportCreateManyAdminUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    skills?: ProfileCreateskillsInput | string[]
    interests?: ProfileCreateinterestsInput | string[]
    isEmprendedorConfiable?: boolean
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    avatar?: string | null
    bio?: string | null
    location?: string | null
    website?: string | null
    skills?: ProfileCreateskillsInput | string[]
    interests?: ProfileCreateinterestsInput | string[]
    isEmprendedorConfiable?: boolean
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    rating: number
    comment?: string | null
    communication?: number | null
    quality?: number | null
    delivery?: number | null
    value?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    marketplaceItem: MarketplaceItemCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    marketplaceItemId: string
    rating: number
    comment?: string | null
    communication?: number | null
    quality?: number | null
    delivery?: number | null
    value?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutCreatorInput, ActivityUncheckedUpdateWithoutCreatorInput>
    create: XOR<ActivityCreateWithoutCreatorInput, ActivityUncheckedCreateWithoutCreatorInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutCreatorInput, ActivityUncheckedUpdateWithoutCreatorInput>
  }

  export type ActivityUpdateManyWithWhereWithoutCreatorInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    publicationId?: StringNullableFilter<"Comment"> | string | null
    activityId?: StringNullableFilter<"Comment"> | string | null
    text?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type LikeUpsertWithWhereUniqueWithoutUserInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutUserInput, LikeUncheckedUpdateWithoutUserInput>
    create: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutUserInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutUserInput, LikeUncheckedUpdateWithoutUserInput>
  }

  export type LikeUpdateManyWithWhereWithoutUserInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutUserInput>
  }

  export type LikeScalarWhereInput = {
    AND?: LikeScalarWhereInput | LikeScalarWhereInput[]
    OR?: LikeScalarWhereInput[]
    NOT?: LikeScalarWhereInput | LikeScalarWhereInput[]
    id?: StringFilter<"Like"> | string
    userId?: StringFilter<"Like"> | string
    publicationId?: StringFilter<"Like"> | string
    createdAt?: DateTimeFilter<"Like"> | Date | string
  }

  export type ExperienceUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ExperienceWhereUniqueInput
    update: XOR<ExperienceUpdateWithoutCreatorInput, ExperienceUncheckedUpdateWithoutCreatorInput>
    create: XOR<ExperienceCreateWithoutCreatorInput, ExperienceUncheckedCreateWithoutCreatorInput>
  }

  export type ExperienceUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ExperienceWhereUniqueInput
    data: XOR<ExperienceUpdateWithoutCreatorInput, ExperienceUncheckedUpdateWithoutCreatorInput>
  }

  export type ExperienceUpdateManyWithWhereWithoutCreatorInput = {
    where: ExperienceScalarWhereInput
    data: XOR<ExperienceUpdateManyMutationInput, ExperienceUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ExperienceScalarWhereInput = {
    AND?: ExperienceScalarWhereInput | ExperienceScalarWhereInput[]
    OR?: ExperienceScalarWhereInput[]
    NOT?: ExperienceScalarWhereInput | ExperienceScalarWhereInput[]
    id?: StringFilter<"Experience"> | string
    stageId?: StringFilter<"Experience"> | string
    title?: StringFilter<"Experience"> | string
    description?: StringNullableFilter<"Experience"> | string | null
    type?: StringFilter<"Experience"> | string
    gamificationFramework?: StringNullableFilter<"Experience"> | string | null
    creatorId?: StringFilter<"Experience"> | string
    createdAt?: DateTimeFilter<"Experience"> | Date | string
    updatedAt?: DateTimeFilter<"Experience"> | Date | string
  }

  export type GiftCardUpsertWithWhereUniqueWithoutInviterInput = {
    where: GiftCardWhereUniqueInput
    update: XOR<GiftCardUpdateWithoutInviterInput, GiftCardUncheckedUpdateWithoutInviterInput>
    create: XOR<GiftCardCreateWithoutInviterInput, GiftCardUncheckedCreateWithoutInviterInput>
  }

  export type GiftCardUpdateWithWhereUniqueWithoutInviterInput = {
    where: GiftCardWhereUniqueInput
    data: XOR<GiftCardUpdateWithoutInviterInput, GiftCardUncheckedUpdateWithoutInviterInput>
  }

  export type GiftCardUpdateManyWithWhereWithoutInviterInput = {
    where: GiftCardScalarWhereInput
    data: XOR<GiftCardUpdateManyMutationInput, GiftCardUncheckedUpdateManyWithoutInviterInput>
  }

  export type GiftCardScalarWhereInput = {
    AND?: GiftCardScalarWhereInput | GiftCardScalarWhereInput[]
    OR?: GiftCardScalarWhereInput[]
    NOT?: GiftCardScalarWhereInput | GiftCardScalarWhereInput[]
    id?: StringFilter<"GiftCard"> | string
    inviterId?: StringFilter<"GiftCard"> | string
    invitedName?: StringFilter<"GiftCard"> | string
    invitedEmail?: StringFilter<"GiftCard"> | string
    token?: StringFilter<"GiftCard"> | string
    unitsAmount?: FloatFilter<"GiftCard"> | number
    suggestions?: StringNullableFilter<"GiftCard"> | string | null
    status?: StringFilter<"GiftCard"> | string
    createdAt?: DateTimeFilter<"GiftCard"> | Date | string
  }

  export type GroupUpsertWithWhereUniqueWithoutOwnerInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutOwnerInput, GroupUncheckedUpdateWithoutOwnerInput>
    create: XOR<GroupCreateWithoutOwnerInput, GroupUncheckedCreateWithoutOwnerInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutOwnerInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutOwnerInput, GroupUncheckedUpdateWithoutOwnerInput>
  }

  export type GroupUpdateManyWithWhereWithoutOwnerInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutOwnerInput>
  }

  export type GroupScalarWhereInput = {
    AND?: GroupScalarWhereInput | GroupScalarWhereInput[]
    OR?: GroupScalarWhereInput[]
    NOT?: GroupScalarWhereInput | GroupScalarWhereInput[]
    id?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    ownerId?: StringFilter<"Group"> | string
    type?: StringFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
  }

  export type InvitationTemplateUpsertWithWhereUniqueWithoutCreatorInput = {
    where: InvitationTemplateWhereUniqueInput
    update: XOR<InvitationTemplateUpdateWithoutCreatorInput, InvitationTemplateUncheckedUpdateWithoutCreatorInput>
    create: XOR<InvitationTemplateCreateWithoutCreatorInput, InvitationTemplateUncheckedCreateWithoutCreatorInput>
  }

  export type InvitationTemplateUpdateWithWhereUniqueWithoutCreatorInput = {
    where: InvitationTemplateWhereUniqueInput
    data: XOR<InvitationTemplateUpdateWithoutCreatorInput, InvitationTemplateUncheckedUpdateWithoutCreatorInput>
  }

  export type InvitationTemplateUpdateManyWithWhereWithoutCreatorInput = {
    where: InvitationTemplateScalarWhereInput
    data: XOR<InvitationTemplateUpdateManyMutationInput, InvitationTemplateUncheckedUpdateManyWithoutCreatorInput>
  }

  export type InvitationTemplateScalarWhereInput = {
    AND?: InvitationTemplateScalarWhereInput | InvitationTemplateScalarWhereInput[]
    OR?: InvitationTemplateScalarWhereInput[]
    NOT?: InvitationTemplateScalarWhereInput | InvitationTemplateScalarWhereInput[]
    id?: StringFilter<"InvitationTemplate"> | string
    name?: StringFilter<"InvitationTemplate"> | string
    content?: StringFilter<"InvitationTemplate"> | string
    creatorId?: StringFilter<"InvitationTemplate"> | string
    createdAt?: DateTimeFilter<"InvitationTemplate"> | Date | string
  }

  export type MeritUpsertWithWhereUniqueWithoutUserInput = {
    where: MeritWhereUniqueInput
    update: XOR<MeritUpdateWithoutUserInput, MeritUncheckedUpdateWithoutUserInput>
    create: XOR<MeritCreateWithoutUserInput, MeritUncheckedCreateWithoutUserInput>
  }

  export type MeritUpdateWithWhereUniqueWithoutUserInput = {
    where: MeritWhereUniqueInput
    data: XOR<MeritUpdateWithoutUserInput, MeritUncheckedUpdateWithoutUserInput>
  }

  export type MeritUpdateManyWithWhereWithoutUserInput = {
    where: MeritScalarWhereInput
    data: XOR<MeritUpdateManyMutationInput, MeritUncheckedUpdateManyWithoutUserInput>
  }

  export type MeritScalarWhereInput = {
    AND?: MeritScalarWhereInput | MeritScalarWhereInput[]
    OR?: MeritScalarWhereInput[]
    NOT?: MeritScalarWhereInput | MeritScalarWhereInput[]
    id?: StringFilter<"Merit"> | string
    userId?: StringFilter<"Merit"> | string
    amount?: FloatFilter<"Merit"> | number
    type?: StringFilter<"Merit"> | string
    source?: StringFilter<"Merit"> | string
    relatedEntityId?: StringNullableFilter<"Merit"> | string | null
    createdAt?: DateTimeFilter<"Merit"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type PublicationUpsertWithWhereUniqueWithoutUserInput = {
    where: PublicationWhereUniqueInput
    update: XOR<PublicationUpdateWithoutUserInput, PublicationUncheckedUpdateWithoutUserInput>
    create: XOR<PublicationCreateWithoutUserInput, PublicationUncheckedCreateWithoutUserInput>
  }

  export type PublicationUpdateWithWhereUniqueWithoutUserInput = {
    where: PublicationWhereUniqueInput
    data: XOR<PublicationUpdateWithoutUserInput, PublicationUncheckedUpdateWithoutUserInput>
  }

  export type PublicationUpdateManyWithWhereWithoutUserInput = {
    where: PublicationScalarWhereInput
    data: XOR<PublicationUpdateManyMutationInput, PublicationUncheckedUpdateManyWithoutUserInput>
  }

  export type PublicationScalarWhereInput = {
    AND?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
    OR?: PublicationScalarWhereInput[]
    NOT?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
    id?: StringFilter<"Publication"> | string
    userId?: StringFilter<"Publication"> | string
    content?: StringFilter<"Publication"> | string
    type?: StringFilter<"Publication"> | string
    createdAt?: DateTimeFilter<"Publication"> | Date | string
    updatedAt?: DateTimeFilter<"Publication"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutCreatorInput, ReportUncheckedUpdateWithoutCreatorInput>
    create: XOR<ReportCreateWithoutCreatorInput, ReportUncheckedCreateWithoutCreatorInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutCreatorInput, ReportUncheckedUpdateWithoutCreatorInput>
  }

  export type ReportUpdateManyWithWhereWithoutCreatorInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    name?: StringFilter<"Report"> | string
    type?: StringFilter<"Report"> | string
    parameters?: StringNullableFilter<"Report"> | string | null
    generatedAt?: DateTimeFilter<"Report"> | Date | string
    data?: StringFilter<"Report"> | string
    creatorId?: StringFilter<"Report"> | string
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutAssignedByInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutAssignedByInput, RolePermissionUncheckedUpdateWithoutAssignedByInput>
    create: XOR<RolePermissionCreateWithoutAssignedByInput, RolePermissionUncheckedCreateWithoutAssignedByInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutAssignedByInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutAssignedByInput, RolePermissionUncheckedUpdateWithoutAssignedByInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutAssignedByInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutAssignedByInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    assignedAt?: DateTimeFilter<"RolePermission"> | Date | string
    assignedById?: StringNullableFilter<"RolePermission"> | string | null
  }

  export type TokenUpsertWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    update: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenUpdateWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    data: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
  }

  export type TokenUpdateManyWithWhereWithoutUserInput = {
    where: TokenScalarWhereInput
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutUserInput>
  }

  export type TokenScalarWhereInput = {
    AND?: TokenScalarWhereInput | TokenScalarWhereInput[]
    OR?: TokenScalarWhereInput[]
    NOT?: TokenScalarWhereInput | TokenScalarWhereInput[]
    id?: StringFilter<"Token"> | string
    userId?: StringFilter<"Token"> | string
    amount?: FloatFilter<"Token"> | number
    type?: StringFilter<"Token"> | string
    status?: StringFilter<"Token"> | string
    caducityDate?: DateTimeNullableFilter<"Token"> | Date | string | null
    source?: StringFilter<"Token"> | string
    createdAt?: DateTimeFilter<"Token"> | Date | string
    updatedAt?: DateTimeFilter<"Token"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutToUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutToUserInput, TransactionUncheckedUpdateWithoutToUserInput>
    create: XOR<TransactionCreateWithoutToUserInput, TransactionUncheckedCreateWithoutToUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutToUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutToUserInput, TransactionUncheckedUpdateWithoutToUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutToUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutToUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    fromUserId?: StringNullableFilter<"Transaction"> | string | null
    toUserId?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    tokenType?: StringFilter<"Transaction"> | string
    type?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    description?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutFromUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutFromUserInput, TransactionUncheckedUpdateWithoutFromUserInput>
    create: XOR<TransactionCreateWithoutFromUserInput, TransactionUncheckedCreateWithoutFromUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutFromUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutFromUserInput, TransactionUncheckedUpdateWithoutFromUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutFromUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutFromUserInput>
  }

  export type UIComponentTemplateUpsertWithWhereUniqueWithoutCreatorInput = {
    where: UIComponentTemplateWhereUniqueInput
    update: XOR<UIComponentTemplateUpdateWithoutCreatorInput, UIComponentTemplateUncheckedUpdateWithoutCreatorInput>
    create: XOR<UIComponentTemplateCreateWithoutCreatorInput, UIComponentTemplateUncheckedCreateWithoutCreatorInput>
  }

  export type UIComponentTemplateUpdateWithWhereUniqueWithoutCreatorInput = {
    where: UIComponentTemplateWhereUniqueInput
    data: XOR<UIComponentTemplateUpdateWithoutCreatorInput, UIComponentTemplateUncheckedUpdateWithoutCreatorInput>
  }

  export type UIComponentTemplateUpdateManyWithWhereWithoutCreatorInput = {
    where: UIComponentTemplateScalarWhereInput
    data: XOR<UIComponentTemplateUpdateManyMutationInput, UIComponentTemplateUncheckedUpdateManyWithoutCreatorInput>
  }

  export type UIComponentTemplateScalarWhereInput = {
    AND?: UIComponentTemplateScalarWhereInput | UIComponentTemplateScalarWhereInput[]
    OR?: UIComponentTemplateScalarWhereInput[]
    NOT?: UIComponentTemplateScalarWhereInput | UIComponentTemplateScalarWhereInput[]
    id?: StringFilter<"UIComponentTemplate"> | string
    name?: StringFilter<"UIComponentTemplate"> | string
    type?: StringFilter<"UIComponentTemplate"> | string
    templateJson?: StringFilter<"UIComponentTemplate"> | string
    creatorId?: StringFilter<"UIComponentTemplate"> | string
    createdAt?: DateTimeFilter<"UIComponentTemplate"> | Date | string
  }

  export type UserAnswerUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAnswerWhereUniqueInput
    update: XOR<UserAnswerUpdateWithoutUserInput, UserAnswerUncheckedUpdateWithoutUserInput>
    create: XOR<UserAnswerCreateWithoutUserInput, UserAnswerUncheckedCreateWithoutUserInput>
  }

  export type UserAnswerUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAnswerWhereUniqueInput
    data: XOR<UserAnswerUpdateWithoutUserInput, UserAnswerUncheckedUpdateWithoutUserInput>
  }

  export type UserAnswerUpdateManyWithWhereWithoutUserInput = {
    where: UserAnswerScalarWhereInput
    data: XOR<UserAnswerUpdateManyMutationInput, UserAnswerUncheckedUpdateManyWithoutUserInput>
  }

  export type UserChallengeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserChallengeWhereUniqueInput
    update: XOR<UserChallengeUpdateWithoutUserInput, UserChallengeUncheckedUpdateWithoutUserInput>
    create: XOR<UserChallengeCreateWithoutUserInput, UserChallengeUncheckedCreateWithoutUserInput>
  }

  export type UserChallengeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserChallengeWhereUniqueInput
    data: XOR<UserChallengeUpdateWithoutUserInput, UserChallengeUncheckedUpdateWithoutUserInput>
  }

  export type UserChallengeUpdateManyWithWhereWithoutUserInput = {
    where: UserChallengeScalarWhereInput
    data: XOR<UserChallengeUpdateManyMutationInput, UserChallengeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserChallengeScalarWhereInput = {
    AND?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
    OR?: UserChallengeScalarWhereInput[]
    NOT?: UserChallengeScalarWhereInput | UserChallengeScalarWhereInput[]
    id?: StringFilter<"UserChallenge"> | string
    userId?: StringFilter<"UserChallenge"> | string
    challengeId?: StringFilter<"UserChallenge"> | string
    status?: StringFilter<"UserChallenge"> | string
    progress?: FloatFilter<"UserChallenge"> | number
    startedAt?: DateTimeFilter<"UserChallenge"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserChallenge"> | Date | string | null
    metadata?: StringNullableFilter<"UserChallenge"> | string | null
  }

  export type UserGroupUpsertWithWhereUniqueWithoutUserInput = {
    where: UserGroupWhereUniqueInput
    update: XOR<UserGroupUpdateWithoutUserInput, UserGroupUncheckedUpdateWithoutUserInput>
    create: XOR<UserGroupCreateWithoutUserInput, UserGroupUncheckedCreateWithoutUserInput>
  }

  export type UserGroupUpdateWithWhereUniqueWithoutUserInput = {
    where: UserGroupWhereUniqueInput
    data: XOR<UserGroupUpdateWithoutUserInput, UserGroupUncheckedUpdateWithoutUserInput>
  }

  export type UserGroupUpdateManyWithWhereWithoutUserInput = {
    where: UserGroupScalarWhereInput
    data: XOR<UserGroupUpdateManyMutationInput, UserGroupUncheckedUpdateManyWithoutUserInput>
  }

  export type UserGroupScalarWhereInput = {
    AND?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
    OR?: UserGroupScalarWhereInput[]
    NOT?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
    userId?: StringFilter<"UserGroup"> | string
    groupId?: StringFilter<"UserGroup"> | string
    roleInGroup?: StringFilter<"UserGroup"> | string
    joinedAt?: DateTimeFilter<"UserGroup"> | Date | string
  }

  export type UserInvitationUpsertWithWhereUniqueWithoutInvitedUserInput = {
    where: UserInvitationWhereUniqueInput
    update: XOR<UserInvitationUpdateWithoutInvitedUserInput, UserInvitationUncheckedUpdateWithoutInvitedUserInput>
    create: XOR<UserInvitationCreateWithoutInvitedUserInput, UserInvitationUncheckedCreateWithoutInvitedUserInput>
  }

  export type UserInvitationUpdateWithWhereUniqueWithoutInvitedUserInput = {
    where: UserInvitationWhereUniqueInput
    data: XOR<UserInvitationUpdateWithoutInvitedUserInput, UserInvitationUncheckedUpdateWithoutInvitedUserInput>
  }

  export type UserInvitationUpdateManyWithWhereWithoutInvitedUserInput = {
    where: UserInvitationScalarWhereInput
    data: XOR<UserInvitationUpdateManyMutationInput, UserInvitationUncheckedUpdateManyWithoutInvitedUserInput>
  }

  export type UserInvitationScalarWhereInput = {
    AND?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
    OR?: UserInvitationScalarWhereInput[]
    NOT?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
    id?: StringFilter<"UserInvitation"> | string
    giftCardId?: StringFilter<"UserInvitation"> | string
    invitedUserId?: StringNullableFilter<"UserInvitation"> | string | null
    status?: StringFilter<"UserInvitation"> | string
    createdAt?: DateTimeFilter<"UserInvitation"> | Date | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutAssignedByInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutAssignedByInput, UserRoleUncheckedUpdateWithoutAssignedByInput>
    create: XOR<UserRoleCreateWithoutAssignedByInput, UserRoleUncheckedCreateWithoutAssignedByInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutAssignedByInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutAssignedByInput, UserRoleUncheckedUpdateWithoutAssignedByInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutAssignedByInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutAssignedByInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    assignedById?: StringNullableFilter<"UserRole"> | string | null
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type StudyRoomUpsertWithWhereUniqueWithoutHostInput = {
    where: StudyRoomWhereUniqueInput
    update: XOR<StudyRoomUpdateWithoutHostInput, StudyRoomUncheckedUpdateWithoutHostInput>
    create: XOR<StudyRoomCreateWithoutHostInput, StudyRoomUncheckedCreateWithoutHostInput>
  }

  export type StudyRoomUpdateWithWhereUniqueWithoutHostInput = {
    where: StudyRoomWhereUniqueInput
    data: XOR<StudyRoomUpdateWithoutHostInput, StudyRoomUncheckedUpdateWithoutHostInput>
  }

  export type StudyRoomUpdateManyWithWhereWithoutHostInput = {
    where: StudyRoomScalarWhereInput
    data: XOR<StudyRoomUpdateManyMutationInput, StudyRoomUncheckedUpdateManyWithoutHostInput>
  }

  export type StudyRoomParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: StudyRoomParticipantWhereUniqueInput
    update: XOR<StudyRoomParticipantUpdateWithoutUserInput, StudyRoomParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<StudyRoomParticipantCreateWithoutUserInput, StudyRoomParticipantUncheckedCreateWithoutUserInput>
  }

  export type StudyRoomParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: StudyRoomParticipantWhereUniqueInput
    data: XOR<StudyRoomParticipantUpdateWithoutUserInput, StudyRoomParticipantUncheckedUpdateWithoutUserInput>
  }

  export type StudyRoomParticipantUpdateManyWithWhereWithoutUserInput = {
    where: StudyRoomParticipantScalarWhereInput
    data: XOR<StudyRoomParticipantUpdateManyMutationInput, StudyRoomParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type StudyRoomParticipantScalarWhereInput = {
    AND?: StudyRoomParticipantScalarWhereInput | StudyRoomParticipantScalarWhereInput[]
    OR?: StudyRoomParticipantScalarWhereInput[]
    NOT?: StudyRoomParticipantScalarWhereInput | StudyRoomParticipantScalarWhereInput[]
    id?: StringFilter<"StudyRoomParticipant"> | string
    studyRoomId?: StringFilter<"StudyRoomParticipant"> | string
    userId?: StringFilter<"StudyRoomParticipant"> | string
    isHost?: BoolFilter<"StudyRoomParticipant"> | boolean
    joinedAt?: DateTimeFilter<"StudyRoomParticipant"> | Date | string
    leftAt?: DateTimeNullableFilter<"StudyRoomParticipant"> | Date | string | null
    isActive?: BoolFilter<"StudyRoomParticipant"> | boolean
  }

  export type StudyRoomMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: StudyRoomMessageWhereUniqueInput
    update: XOR<StudyRoomMessageUpdateWithoutUserInput, StudyRoomMessageUncheckedUpdateWithoutUserInput>
    create: XOR<StudyRoomMessageCreateWithoutUserInput, StudyRoomMessageUncheckedCreateWithoutUserInput>
  }

  export type StudyRoomMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: StudyRoomMessageWhereUniqueInput
    data: XOR<StudyRoomMessageUpdateWithoutUserInput, StudyRoomMessageUncheckedUpdateWithoutUserInput>
  }

  export type StudyRoomMessageUpdateManyWithWhereWithoutUserInput = {
    where: StudyRoomMessageScalarWhereInput
    data: XOR<StudyRoomMessageUpdateManyMutationInput, StudyRoomMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type StudyRoomMessageScalarWhereInput = {
    AND?: StudyRoomMessageScalarWhereInput | StudyRoomMessageScalarWhereInput[]
    OR?: StudyRoomMessageScalarWhereInput[]
    NOT?: StudyRoomMessageScalarWhereInput | StudyRoomMessageScalarWhereInput[]
    id?: StringFilter<"StudyRoomMessage"> | string
    studyRoomId?: StringFilter<"StudyRoomMessage"> | string
    userId?: StringFilter<"StudyRoomMessage"> | string
    message?: StringFilter<"StudyRoomMessage"> | string
    messageType?: StringFilter<"StudyRoomMessage"> | string
    metadata?: StringNullableFilter<"StudyRoomMessage"> | string | null
    createdAt?: DateTimeFilter<"StudyRoomMessage"> | Date | string
  }

  export type PersonalityUpsertWithoutUsersInput = {
    update: XOR<PersonalityUpdateWithoutUsersInput, PersonalityUncheckedUpdateWithoutUsersInput>
    create: XOR<PersonalityCreateWithoutUsersInput, PersonalityUncheckedCreateWithoutUsersInput>
    where?: PersonalityWhereInput
  }

  export type PersonalityUpdateToOneWithWhereWithoutUsersInput = {
    where?: PersonalityWhereInput
    data: XOR<PersonalityUpdateWithoutUsersInput, PersonalityUncheckedUpdateWithoutUsersInput>
  }

  export type PersonalityUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalityUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoPermissionsUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: VideoPermissionsWhereUniqueInput
    update: XOR<VideoPermissionsUpdateWithoutCreatedByInput, VideoPermissionsUncheckedUpdateWithoutCreatedByInput>
    create: XOR<VideoPermissionsCreateWithoutCreatedByInput, VideoPermissionsUncheckedCreateWithoutCreatedByInput>
  }

  export type VideoPermissionsUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: VideoPermissionsWhereUniqueInput
    data: XOR<VideoPermissionsUpdateWithoutCreatedByInput, VideoPermissionsUncheckedUpdateWithoutCreatedByInput>
  }

  export type VideoPermissionsUpdateManyWithWhereWithoutCreatedByInput = {
    where: VideoPermissionsScalarWhereInput
    data: XOR<VideoPermissionsUpdateManyMutationInput, VideoPermissionsUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type VideoPermissionsScalarWhereInput = {
    AND?: VideoPermissionsScalarWhereInput | VideoPermissionsScalarWhereInput[]
    OR?: VideoPermissionsScalarWhereInput[]
    NOT?: VideoPermissionsScalarWhereInput | VideoPermissionsScalarWhereInput[]
    id?: StringFilter<"VideoPermissions"> | string
    videoItemId?: IntFilter<"VideoPermissions"> | number
    showWaveCount?: BoolFilter<"VideoPermissions"> | boolean
    showVideos?: BoolFilter<"VideoPermissions"> | boolean
    showVideoSubtitles?: BoolFilter<"VideoPermissions"> | boolean
    showComments?: BoolFilter<"VideoPermissions"> | boolean
    showPublishDate?: BoolFilter<"VideoPermissions"> | boolean
    showVideoDuration?: BoolFilter<"VideoPermissions"> | boolean
    showLikeButton?: BoolFilter<"VideoPermissions"> | boolean
    allowRewindForward?: BoolFilter<"VideoPermissions"> | boolean
    allowViewComments?: BoolFilter<"VideoPermissions"> | boolean
    allowMakeComments?: BoolFilter<"VideoPermissions"> | boolean
    showLikeComments?: BoolFilter<"VideoPermissions"> | boolean
    sortCommentsByAffinity?: BoolFilter<"VideoPermissions"> | boolean
    showCommenterName?: BoolFilter<"VideoPermissions"> | boolean
    playlistPosition?: StringFilter<"VideoPermissions"> | string
    isDraft?: BoolFilter<"VideoPermissions"> | boolean
    createdAt?: DateTimeFilter<"VideoPermissions"> | Date | string
    updatedAt?: DateTimeFilter<"VideoPermissions"> | Date | string
    createdById?: StringNullableFilter<"VideoPermissions"> | string | null
  }

  export type WalletUpsertWithoutUserInput = {
    update: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutUserInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
  }

  export type WalletUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockchainAddress?: NullableStringFieldUpdateOperationsInput | string | null
    balanceUnits?: FloatFieldUpdateOperationsInput | number
    balanceToins?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionsTo?: TransactionUpdateManyWithoutToWalletNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockchainAddress?: NullableStringFieldUpdateOperationsInput | string | null
    balanceUnits?: FloatFieldUpdateOperationsInput | number
    balanceToins?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToWalletNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromWalletNestedInput
  }

  export type WorldUpsertWithWhereUniqueWithoutCreatorInput = {
    where: WorldWhereUniqueInput
    update: XOR<WorldUpdateWithoutCreatorInput, WorldUncheckedUpdateWithoutCreatorInput>
    create: XOR<WorldCreateWithoutCreatorInput, WorldUncheckedCreateWithoutCreatorInput>
  }

  export type WorldUpdateWithWhereUniqueWithoutCreatorInput = {
    where: WorldWhereUniqueInput
    data: XOR<WorldUpdateWithoutCreatorInput, WorldUncheckedUpdateWithoutCreatorInput>
  }

  export type WorldUpdateManyWithWhereWithoutCreatorInput = {
    where: WorldScalarWhereInput
    data: XOR<WorldUpdateManyMutationInput, WorldUncheckedUpdateManyWithoutCreatorInput>
  }

  export type MarketplaceItemUpsertWithWhereUniqueWithoutSellerInput = {
    where: MarketplaceItemWhereUniqueInput
    update: XOR<MarketplaceItemUpdateWithoutSellerInput, MarketplaceItemUncheckedUpdateWithoutSellerInput>
    create: XOR<MarketplaceItemCreateWithoutSellerInput, MarketplaceItemUncheckedCreateWithoutSellerInput>
  }

  export type MarketplaceItemUpdateWithWhereUniqueWithoutSellerInput = {
    where: MarketplaceItemWhereUniqueInput
    data: XOR<MarketplaceItemUpdateWithoutSellerInput, MarketplaceItemUncheckedUpdateWithoutSellerInput>
  }

  export type MarketplaceItemUpdateManyWithWhereWithoutSellerInput = {
    where: MarketplaceItemScalarWhereInput
    data: XOR<MarketplaceItemUpdateManyMutationInput, MarketplaceItemUncheckedUpdateManyWithoutSellerInput>
  }

  export type MarketplaceItemScalarWhereInput = {
    AND?: MarketplaceItemScalarWhereInput | MarketplaceItemScalarWhereInput[]
    OR?: MarketplaceItemScalarWhereInput[]
    NOT?: MarketplaceItemScalarWhereInput | MarketplaceItemScalarWhereInput[]
    id?: StringFilter<"MarketplaceItem"> | string
    name?: StringFilter<"MarketplaceItem"> | string
    description?: StringNullableFilter<"MarketplaceItem"> | string | null
    fullDescription?: StringNullableFilter<"MarketplaceItem"> | string | null
    itemType?: EnumMarketplaceItemTypeFilter<"MarketplaceItem"> | $Enums.MarketplaceItemType
    price?: FloatFilter<"MarketplaceItem"> | number
    priceToins?: FloatFilter<"MarketplaceItem"> | number
    currency?: EnumCurrencyFilter<"MarketplaceItem"> | $Enums.Currency
    category?: StringNullableFilter<"MarketplaceItem"> | string | null
    tags?: StringNullableListFilter<"MarketplaceItem">
    images?: StringNullableListFilter<"MarketplaceItem">
    stock?: IntFilter<"MarketplaceItem"> | number
    rating?: FloatFilter<"MarketplaceItem"> | number
    reviewCount?: IntFilter<"MarketplaceItem"> | number
    location?: StringNullableFilter<"MarketplaceItem"> | string | null
    status?: EnumMarketplaceItemStatusFilter<"MarketplaceItem"> | $Enums.MarketplaceItemStatus
    isActive?: BoolFilter<"MarketplaceItem"> | boolean
    isDeleted?: BoolFilter<"MarketplaceItem"> | boolean
    deletedAt?: DateTimeNullableFilter<"MarketplaceItem"> | Date | string | null
    createdAt?: DateTimeFilter<"MarketplaceItem"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceItem"> | Date | string
    viewCount?: IntFilter<"MarketplaceItem"> | number
    favoriteCount?: IntFilter<"MarketplaceItem"> | number
    sellerId?: StringFilter<"MarketplaceItem"> | string
    metadata?: StringNullableFilter<"MarketplaceItem"> | string | null
  }

  export type MarketplaceMatchUpsertWithWhereUniqueWithoutBuyerInput = {
    where: MarketplaceMatchWhereUniqueInput
    update: XOR<MarketplaceMatchUpdateWithoutBuyerInput, MarketplaceMatchUncheckedUpdateWithoutBuyerInput>
    create: XOR<MarketplaceMatchCreateWithoutBuyerInput, MarketplaceMatchUncheckedCreateWithoutBuyerInput>
  }

  export type MarketplaceMatchUpdateWithWhereUniqueWithoutBuyerInput = {
    where: MarketplaceMatchWhereUniqueInput
    data: XOR<MarketplaceMatchUpdateWithoutBuyerInput, MarketplaceMatchUncheckedUpdateWithoutBuyerInput>
  }

  export type MarketplaceMatchUpdateManyWithWhereWithoutBuyerInput = {
    where: MarketplaceMatchScalarWhereInput
    data: XOR<MarketplaceMatchUpdateManyMutationInput, MarketplaceMatchUncheckedUpdateManyWithoutBuyerInput>
  }

  export type MarketplaceMatchScalarWhereInput = {
    AND?: MarketplaceMatchScalarWhereInput | MarketplaceMatchScalarWhereInput[]
    OR?: MarketplaceMatchScalarWhereInput[]
    NOT?: MarketplaceMatchScalarWhereInput | MarketplaceMatchScalarWhereInput[]
    id?: StringFilter<"MarketplaceMatch"> | string
    itemId?: StringFilter<"MarketplaceMatch"> | string
    buyerId?: StringFilter<"MarketplaceMatch"> | string
    sellerId?: StringFilter<"MarketplaceMatch"> | string
    buyerConfirmed?: BoolFilter<"MarketplaceMatch"> | boolean
    sellerConfirmed?: BoolFilter<"MarketplaceMatch"> | boolean
    status?: EnumMatchStatusFilter<"MarketplaceMatch"> | $Enums.MatchStatus
    createdAt?: DateTimeFilter<"MarketplaceMatch"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceMatch"> | Date | string
  }

  export type MarketplaceMatchUpsertWithWhereUniqueWithoutSellerInput = {
    where: MarketplaceMatchWhereUniqueInput
    update: XOR<MarketplaceMatchUpdateWithoutSellerInput, MarketplaceMatchUncheckedUpdateWithoutSellerInput>
    create: XOR<MarketplaceMatchCreateWithoutSellerInput, MarketplaceMatchUncheckedCreateWithoutSellerInput>
  }

  export type MarketplaceMatchUpdateWithWhereUniqueWithoutSellerInput = {
    where: MarketplaceMatchWhereUniqueInput
    data: XOR<MarketplaceMatchUpdateWithoutSellerInput, MarketplaceMatchUncheckedUpdateWithoutSellerInput>
  }

  export type MarketplaceMatchUpdateManyWithWhereWithoutSellerInput = {
    where: MarketplaceMatchScalarWhereInput
    data: XOR<MarketplaceMatchUpdateManyMutationInput, MarketplaceMatchUncheckedUpdateManyWithoutSellerInput>
  }

  export type MatchMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MatchMessageWhereUniqueInput
    update: XOR<MatchMessageUpdateWithoutSenderInput, MatchMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MatchMessageCreateWithoutSenderInput, MatchMessageUncheckedCreateWithoutSenderInput>
  }

  export type MatchMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MatchMessageWhereUniqueInput
    data: XOR<MatchMessageUpdateWithoutSenderInput, MatchMessageUncheckedUpdateWithoutSenderInput>
  }

  export type MatchMessageUpdateManyWithWhereWithoutSenderInput = {
    where: MatchMessageScalarWhereInput
    data: XOR<MatchMessageUpdateManyMutationInput, MatchMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MatchMessageScalarWhereInput = {
    AND?: MatchMessageScalarWhereInput | MatchMessageScalarWhereInput[]
    OR?: MatchMessageScalarWhereInput[]
    NOT?: MatchMessageScalarWhereInput | MatchMessageScalarWhereInput[]
    id?: StringFilter<"MatchMessage"> | string
    matchId?: StringFilter<"MatchMessage"> | string
    senderId?: StringFilter<"MatchMessage"> | string
    content?: StringFilter<"MatchMessage"> | string
    createdAt?: DateTimeFilter<"MatchMessage"> | Date | string
  }

  export type FeedbackReportUpsertWithWhereUniqueWithoutUserInput = {
    where: FeedbackReportWhereUniqueInput
    update: XOR<FeedbackReportUpdateWithoutUserInput, FeedbackReportUncheckedUpdateWithoutUserInput>
    create: XOR<FeedbackReportCreateWithoutUserInput, FeedbackReportUncheckedCreateWithoutUserInput>
  }

  export type FeedbackReportUpdateWithWhereUniqueWithoutUserInput = {
    where: FeedbackReportWhereUniqueInput
    data: XOR<FeedbackReportUpdateWithoutUserInput, FeedbackReportUncheckedUpdateWithoutUserInput>
  }

  export type FeedbackReportUpdateManyWithWhereWithoutUserInput = {
    where: FeedbackReportScalarWhereInput
    data: XOR<FeedbackReportUpdateManyMutationInput, FeedbackReportUncheckedUpdateManyWithoutUserInput>
  }

  export type FeedbackReportScalarWhereInput = {
    AND?: FeedbackReportScalarWhereInput | FeedbackReportScalarWhereInput[]
    OR?: FeedbackReportScalarWhereInput[]
    NOT?: FeedbackReportScalarWhereInput | FeedbackReportScalarWhereInput[]
    id?: StringFilter<"FeedbackReport"> | string
    userId?: StringFilter<"FeedbackReport"> | string
    type?: EnumFeedbackTypeFilter<"FeedbackReport"> | $Enums.FeedbackType
    title?: StringFilter<"FeedbackReport"> | string
    description?: StringFilter<"FeedbackReport"> | string
    priority?: EnumFeedbackPriorityFilter<"FeedbackReport"> | $Enums.FeedbackPriority
    category?: StringFilter<"FeedbackReport"> | string
    status?: EnumFeedbackStatusFilter<"FeedbackReport"> | $Enums.FeedbackStatus
    elementContext?: JsonFilter<"FeedbackReport">
    technicalContext?: JsonFilter<"FeedbackReport">
    codeAnalysis?: JsonNullableFilter<"FeedbackReport">
    aiSuggestions?: JsonNullableFilter<"FeedbackReport">
    adminResponse?: StringNullableFilter<"FeedbackReport"> | string | null
    adminUserId?: StringNullableFilter<"FeedbackReport"> | string | null
    resolvedAt?: DateTimeNullableFilter<"FeedbackReport"> | Date | string | null
    upvotes?: IntFilter<"FeedbackReport"> | number
    downvotes?: IntFilter<"FeedbackReport"> | number
    duplicateOf?: StringNullableFilter<"FeedbackReport"> | string | null
    createdAt?: DateTimeFilter<"FeedbackReport"> | Date | string
    updatedAt?: DateTimeFilter<"FeedbackReport"> | Date | string
  }

  export type FeedbackReportUpsertWithWhereUniqueWithoutAdminUserInput = {
    where: FeedbackReportWhereUniqueInput
    update: XOR<FeedbackReportUpdateWithoutAdminUserInput, FeedbackReportUncheckedUpdateWithoutAdminUserInput>
    create: XOR<FeedbackReportCreateWithoutAdminUserInput, FeedbackReportUncheckedCreateWithoutAdminUserInput>
  }

  export type FeedbackReportUpdateWithWhereUniqueWithoutAdminUserInput = {
    where: FeedbackReportWhereUniqueInput
    data: XOR<FeedbackReportUpdateWithoutAdminUserInput, FeedbackReportUncheckedUpdateWithoutAdminUserInput>
  }

  export type FeedbackReportUpdateManyWithWhereWithoutAdminUserInput = {
    where: FeedbackReportScalarWhereInput
    data: XOR<FeedbackReportUpdateManyMutationInput, FeedbackReportUncheckedUpdateManyWithoutAdminUserInput>
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: ProfileUpdateskillsInput | string[]
    interests?: ProfileUpdateinterestsInput | string[]
    isEmprendedorConfiable?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: ProfileUpdateskillsInput | string[]
    interests?: ProfileUpdateinterestsInput | string[]
    isEmprendedorConfiable?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    marketplaceItemId?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    communication?: IntNullableFilter<"Review"> | number | null
    quality?: IntNullableFilter<"Review"> | number | null
    delivery?: IntNullableFilter<"Review"> | number | null
    value?: IntNullableFilter<"Review"> | number | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type RolePermissionCreateWithoutRoleInput = {
    assignedAt?: Date | string
    assignedBy?: UserCreateNestedOneWithoutAssignedPermissionsInput
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    permissionId: string
    assignedAt?: Date | string
    assignedById?: string | null
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutRoleInput = {
    assignedAt?: Date | string
    assignedBy?: UserCreateNestedOneWithoutAssignedRolesInput
    user: UserCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    userId: string
    assignedAt?: Date | string
    assignedById?: string | null
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserCreateWithoutAssignedRolesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedRolesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedRolesInput, UserUncheckedCreateWithoutAssignedRolesInput>
  }

  export type RoleCreateWithoutUserRolesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUserRolesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUserRolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
  }

  export type UserCreateWithoutUserRolesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserRolesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
  }

  export type UserUpsertWithoutAssignedRolesInput = {
    update: XOR<UserUpdateWithoutAssignedRolesInput, UserUncheckedUpdateWithoutAssignedRolesInput>
    create: XOR<UserCreateWithoutAssignedRolesInput, UserUncheckedCreateWithoutAssignedRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedRolesInput, UserUncheckedUpdateWithoutAssignedRolesInput>
  }

  export type UserUpdateWithoutAssignedRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoleUpsertWithoutUserRolesInput = {
    update: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserUpsertWithoutUserRolesInput = {
    update: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    assignedAt?: Date | string
    assignedBy?: UserCreateNestedOneWithoutAssignedPermissionsInput
    role: RoleCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    roleId: string
    assignedAt?: Date | string
    assignedById?: string | null
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type UserCreateWithoutVideoPermissionsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVideoPermissionsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVideoPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVideoPermissionsInput, UserUncheckedCreateWithoutVideoPermissionsInput>
  }

  export type VideoItemCreateWithoutPermissionsInput = {
    title: string
    description?: string | null
    content: string
    url?: string | null
    platform?: string
    externalId?: string | null
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    duration?: number | null
    categories?: string | null
    language?: string | null
    quality?: string | null
    tags?: string | null
    thumbnailUrl?: string | null
    activities?: ActivityCreateNestedManyWithoutVideoItemInput
    questions?: QuestionCreateNestedManyWithoutVideoItemInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoItemInput
    studyRooms?: StudyRoomCreateNestedManyWithoutVideoInput
    playlist: PlaylistCreateNestedOneWithoutVideoItemsInput
  }

  export type VideoItemUncheckedCreateWithoutPermissionsInput = {
    id?: number
    title: string
    description?: string | null
    content: string
    url?: string | null
    platform?: string
    externalId?: string | null
    playlistId: string
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    duration?: number | null
    categories?: string | null
    language?: string | null
    quality?: string | null
    tags?: string | null
    thumbnailUrl?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutVideoItemInput
    questions?: QuestionUncheckedCreateNestedManyWithoutVideoItemInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoItemInput
    studyRooms?: StudyRoomUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoItemCreateOrConnectWithoutPermissionsInput = {
    where: VideoItemWhereUniqueInput
    create: XOR<VideoItemCreateWithoutPermissionsInput, VideoItemUncheckedCreateWithoutPermissionsInput>
  }

  export type UserUpsertWithoutVideoPermissionsInput = {
    update: XOR<UserUpdateWithoutVideoPermissionsInput, UserUncheckedUpdateWithoutVideoPermissionsInput>
    create: XOR<UserCreateWithoutVideoPermissionsInput, UserUncheckedCreateWithoutVideoPermissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVideoPermissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVideoPermissionsInput, UserUncheckedUpdateWithoutVideoPermissionsInput>
  }

  export type UserUpdateWithoutVideoPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVideoPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VideoItemUpsertWithoutPermissionsInput = {
    update: XOR<VideoItemUpdateWithoutPermissionsInput, VideoItemUncheckedUpdateWithoutPermissionsInput>
    create: XOR<VideoItemCreateWithoutPermissionsInput, VideoItemUncheckedCreateWithoutPermissionsInput>
    where?: VideoItemWhereInput
  }

  export type VideoItemUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: VideoItemWhereInput
    data: XOR<VideoItemUpdateWithoutPermissionsInput, VideoItemUncheckedUpdateWithoutPermissionsInput>
  }

  export type VideoItemUpdateWithoutPermissionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutVideoItemNestedInput
    questions?: QuestionUpdateManyWithoutVideoItemNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoItemNestedInput
    studyRooms?: StudyRoomUpdateManyWithoutVideoNestedInput
    playlist?: PlaylistUpdateOneRequiredWithoutVideoItemsNestedInput
  }

  export type VideoItemUncheckedUpdateWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    playlistId?: StringFieldUpdateOperationsInput | string
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutVideoItemNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutVideoItemNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoItemNestedInput
    studyRooms?: StudyRoomUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type UserCreateWithoutAssignedPermissionsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedPermissionsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedPermissionsInput, UserUncheckedCreateWithoutAssignedPermissionsInput>
  }

  export type PermissionCreateWithoutRolePermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolePermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolePermissionsInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
  }

  export type RoleCreateWithoutRolePermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutRolePermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutRolePermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
  }

  export type UserUpsertWithoutAssignedPermissionsInput = {
    update: XOR<UserUpdateWithoutAssignedPermissionsInput, UserUncheckedUpdateWithoutAssignedPermissionsInput>
    create: XOR<UserCreateWithoutAssignedPermissionsInput, UserUncheckedCreateWithoutAssignedPermissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedPermissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedPermissionsInput, UserUncheckedUpdateWithoutAssignedPermissionsInput>
  }

  export type UserUpdateWithoutAssignedPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PermissionUpsertWithoutRolePermissionsInput = {
    update: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUpsertWithoutRolePermissionsInput = {
    update: XOR<RoleUpdateWithoutRolePermissionsInput, RoleUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutRolePermissionsInput, RoleUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type RoleUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type StageCreateWithoutWorldInput = {
    id?: string
    name: string
    order: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    experiences?: ExperienceCreateNestedManyWithoutStageInput
  }

  export type StageUncheckedCreateWithoutWorldInput = {
    id?: string
    name: string
    order: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    experiences?: ExperienceUncheckedCreateNestedManyWithoutStageInput
  }

  export type StageCreateOrConnectWithoutWorldInput = {
    where: StageWhereUniqueInput
    create: XOR<StageCreateWithoutWorldInput, StageUncheckedCreateWithoutWorldInput>
  }

  export type StageCreateManyWorldInputEnvelope = {
    data: StageCreateManyWorldInput | StageCreateManyWorldInput[]
    skipDuplicates?: boolean
  }

  export type MundoCreateWithoutWorldsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
    playlists?: PlaylistCreateNestedManyWithoutMundoInput
  }

  export type MundoUncheckedCreateWithoutWorldsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
    playlists?: PlaylistUncheckedCreateNestedManyWithoutMundoInput
  }

  export type MundoCreateOrConnectWithoutWorldsInput = {
    where: MundoWhereUniqueInput
    create: XOR<MundoCreateWithoutWorldsInput, MundoUncheckedCreateWithoutWorldsInput>
  }

  export type UserCreateWithoutCreatedWorldsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedWorldsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedWorldsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedWorldsInput, UserUncheckedCreateWithoutCreatedWorldsInput>
  }

  export type StageUpsertWithWhereUniqueWithoutWorldInput = {
    where: StageWhereUniqueInput
    update: XOR<StageUpdateWithoutWorldInput, StageUncheckedUpdateWithoutWorldInput>
    create: XOR<StageCreateWithoutWorldInput, StageUncheckedCreateWithoutWorldInput>
  }

  export type StageUpdateWithWhereUniqueWithoutWorldInput = {
    where: StageWhereUniqueInput
    data: XOR<StageUpdateWithoutWorldInput, StageUncheckedUpdateWithoutWorldInput>
  }

  export type StageUpdateManyWithWhereWithoutWorldInput = {
    where: StageScalarWhereInput
    data: XOR<StageUpdateManyMutationInput, StageUncheckedUpdateManyWithoutWorldInput>
  }

  export type StageScalarWhereInput = {
    AND?: StageScalarWhereInput | StageScalarWhereInput[]
    OR?: StageScalarWhereInput[]
    NOT?: StageScalarWhereInput | StageScalarWhereInput[]
    id?: StringFilter<"Stage"> | string
    worldId?: StringFilter<"Stage"> | string
    name?: StringFilter<"Stage"> | string
    order?: IntFilter<"Stage"> | number
    description?: StringNullableFilter<"Stage"> | string | null
    createdAt?: DateTimeFilter<"Stage"> | Date | string
    updatedAt?: DateTimeFilter<"Stage"> | Date | string
  }

  export type MundoUpsertWithoutWorldsInput = {
    update: XOR<MundoUpdateWithoutWorldsInput, MundoUncheckedUpdateWithoutWorldsInput>
    create: XOR<MundoCreateWithoutWorldsInput, MundoUncheckedCreateWithoutWorldsInput>
    where?: MundoWhereInput
  }

  export type MundoUpdateToOneWithWhereWithoutWorldsInput = {
    where?: MundoWhereInput
    data: XOR<MundoUpdateWithoutWorldsInput, MundoUncheckedUpdateWithoutWorldsInput>
  }

  export type MundoUpdateWithoutWorldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    playlists?: PlaylistUpdateManyWithoutMundoNestedInput
  }

  export type MundoUncheckedUpdateWithoutWorldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    playlists?: PlaylistUncheckedUpdateManyWithoutMundoNestedInput
  }

  export type UserUpsertWithoutCreatedWorldsInput = {
    update: XOR<UserUpdateWithoutCreatedWorldsInput, UserUncheckedUpdateWithoutCreatedWorldsInput>
    create: XOR<UserCreateWithoutCreatedWorldsInput, UserUncheckedCreateWithoutCreatedWorldsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedWorldsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedWorldsInput, UserUncheckedUpdateWithoutCreatedWorldsInput>
  }

  export type UserUpdateWithoutCreatedWorldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedWorldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExperienceCreateWithoutStageInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    gamificationFramework?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityCreateNestedManyWithoutExperienceInput
    creator: UserCreateNestedOneWithoutCreatedExperiencesInput
  }

  export type ExperienceUncheckedCreateWithoutStageInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    gamificationFramework?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutExperienceInput
  }

  export type ExperienceCreateOrConnectWithoutStageInput = {
    where: ExperienceWhereUniqueInput
    create: XOR<ExperienceCreateWithoutStageInput, ExperienceUncheckedCreateWithoutStageInput>
  }

  export type ExperienceCreateManyStageInputEnvelope = {
    data: ExperienceCreateManyStageInput | ExperienceCreateManyStageInput[]
    skipDuplicates?: boolean
  }

  export type WorldCreateWithoutStagesInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mundo?: MundoCreateNestedOneWithoutWorldsInput
    creator: UserCreateNestedOneWithoutCreatedWorldsInput
  }

  export type WorldUncheckedCreateWithoutStagesInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    creatorId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mundoId?: string | null
  }

  export type WorldCreateOrConnectWithoutStagesInput = {
    where: WorldWhereUniqueInput
    create: XOR<WorldCreateWithoutStagesInput, WorldUncheckedCreateWithoutStagesInput>
  }

  export type ExperienceUpsertWithWhereUniqueWithoutStageInput = {
    where: ExperienceWhereUniqueInput
    update: XOR<ExperienceUpdateWithoutStageInput, ExperienceUncheckedUpdateWithoutStageInput>
    create: XOR<ExperienceCreateWithoutStageInput, ExperienceUncheckedCreateWithoutStageInput>
  }

  export type ExperienceUpdateWithWhereUniqueWithoutStageInput = {
    where: ExperienceWhereUniqueInput
    data: XOR<ExperienceUpdateWithoutStageInput, ExperienceUncheckedUpdateWithoutStageInput>
  }

  export type ExperienceUpdateManyWithWhereWithoutStageInput = {
    where: ExperienceScalarWhereInput
    data: XOR<ExperienceUpdateManyMutationInput, ExperienceUncheckedUpdateManyWithoutStageInput>
  }

  export type WorldUpsertWithoutStagesInput = {
    update: XOR<WorldUpdateWithoutStagesInput, WorldUncheckedUpdateWithoutStagesInput>
    create: XOR<WorldCreateWithoutStagesInput, WorldUncheckedCreateWithoutStagesInput>
    where?: WorldWhereInput
  }

  export type WorldUpdateToOneWithWhereWithoutStagesInput = {
    where?: WorldWhereInput
    data: XOR<WorldUpdateWithoutStagesInput, WorldUncheckedUpdateWithoutStagesInput>
  }

  export type WorldUpdateWithoutStagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mundo?: MundoUpdateOneWithoutWorldsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorldsNestedInput
  }

  export type WorldUncheckedUpdateWithoutStagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mundoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityCreateWithoutExperienceInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    multimediaType?: string | null
    contentUrl?: string | null
    duration?: number | null
    order?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoItem?: VideoItemCreateNestedOneWithoutActivitiesInput
    creator: UserCreateNestedOneWithoutCreatedActivitiesInput
    questions?: ActivityQuestionCreateNestedManyWithoutActivityInput
    gamifiedPlaylists?: GamifiedPlaylistCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutExperienceInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    multimediaType?: string | null
    contentUrl?: string | null
    duration?: number | null
    order?: number
    status?: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoItemId?: number | null
    questions?: ActivityQuestionUncheckedCreateNestedManyWithoutActivityInput
    gamifiedPlaylists?: GamifiedPlaylistUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutExperienceInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutExperienceInput, ActivityUncheckedCreateWithoutExperienceInput>
  }

  export type ActivityCreateManyExperienceInputEnvelope = {
    data: ActivityCreateManyExperienceInput | ActivityCreateManyExperienceInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedExperiencesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedExperiencesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedExperiencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedExperiencesInput, UserUncheckedCreateWithoutCreatedExperiencesInput>
  }

  export type StageCreateWithoutExperiencesInput = {
    id?: string
    name: string
    order: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    world: WorldCreateNestedOneWithoutStagesInput
  }

  export type StageUncheckedCreateWithoutExperiencesInput = {
    id?: string
    worldId: string
    name: string
    order: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageCreateOrConnectWithoutExperiencesInput = {
    where: StageWhereUniqueInput
    create: XOR<StageCreateWithoutExperiencesInput, StageUncheckedCreateWithoutExperiencesInput>
  }

  export type ActivityUpsertWithWhereUniqueWithoutExperienceInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutExperienceInput, ActivityUncheckedUpdateWithoutExperienceInput>
    create: XOR<ActivityCreateWithoutExperienceInput, ActivityUncheckedCreateWithoutExperienceInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutExperienceInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutExperienceInput, ActivityUncheckedUpdateWithoutExperienceInput>
  }

  export type ActivityUpdateManyWithWhereWithoutExperienceInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutExperienceInput>
  }

  export type UserUpsertWithoutCreatedExperiencesInput = {
    update: XOR<UserUpdateWithoutCreatedExperiencesInput, UserUncheckedUpdateWithoutCreatedExperiencesInput>
    create: XOR<UserCreateWithoutCreatedExperiencesInput, UserUncheckedCreateWithoutCreatedExperiencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedExperiencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedExperiencesInput, UserUncheckedUpdateWithoutCreatedExperiencesInput>
  }

  export type UserUpdateWithoutCreatedExperiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedExperiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StageUpsertWithoutExperiencesInput = {
    update: XOR<StageUpdateWithoutExperiencesInput, StageUncheckedUpdateWithoutExperiencesInput>
    create: XOR<StageCreateWithoutExperiencesInput, StageUncheckedCreateWithoutExperiencesInput>
    where?: StageWhereInput
  }

  export type StageUpdateToOneWithWhereWithoutExperiencesInput = {
    where?: StageWhereInput
    data: XOR<StageUpdateWithoutExperiencesInput, StageUncheckedUpdateWithoutExperiencesInput>
  }

  export type StageUpdateWithoutExperiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    world?: WorldUpdateOneRequiredWithoutStagesNestedInput
  }

  export type StageUncheckedUpdateWithoutExperiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    worldId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoItemCreateWithoutActivitiesInput = {
    title: string
    description?: string | null
    content: string
    url?: string | null
    platform?: string
    externalId?: string | null
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    duration?: number | null
    categories?: string | null
    language?: string | null
    quality?: string | null
    tags?: string | null
    thumbnailUrl?: string | null
    questions?: QuestionCreateNestedManyWithoutVideoItemInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoItemInput
    studyRooms?: StudyRoomCreateNestedManyWithoutVideoInput
    playlist: PlaylistCreateNestedOneWithoutVideoItemsInput
    permissions?: VideoPermissionsCreateNestedOneWithoutVideoItemInput
  }

  export type VideoItemUncheckedCreateWithoutActivitiesInput = {
    id?: number
    title: string
    description?: string | null
    content: string
    url?: string | null
    platform?: string
    externalId?: string | null
    playlistId: string
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    duration?: number | null
    categories?: string | null
    language?: string | null
    quality?: string | null
    tags?: string | null
    thumbnailUrl?: string | null
    questions?: QuestionUncheckedCreateNestedManyWithoutVideoItemInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoItemInput
    studyRooms?: StudyRoomUncheckedCreateNestedManyWithoutVideoInput
    permissions?: VideoPermissionsUncheckedCreateNestedOneWithoutVideoItemInput
  }

  export type VideoItemCreateOrConnectWithoutActivitiesInput = {
    where: VideoItemWhereUniqueInput
    create: XOR<VideoItemCreateWithoutActivitiesInput, VideoItemUncheckedCreateWithoutActivitiesInput>
  }

  export type UserCreateWithoutCreatedActivitiesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedActivitiesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedActivitiesInput, UserUncheckedCreateWithoutCreatedActivitiesInput>
  }

  export type ExperienceCreateWithoutActivitiesInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    gamificationFramework?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedExperiencesInput
    stage: StageCreateNestedOneWithoutExperiencesInput
  }

  export type ExperienceUncheckedCreateWithoutActivitiesInput = {
    id?: string
    stageId: string
    title: string
    description?: string | null
    type: string
    gamificationFramework?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExperienceCreateOrConnectWithoutActivitiesInput = {
    where: ExperienceWhereUniqueInput
    create: XOR<ExperienceCreateWithoutActivitiesInput, ExperienceUncheckedCreateWithoutActivitiesInput>
  }

  export type ActivityQuestionCreateWithoutActivityInput = {
    id?: string
    type: string
    questionType: string
    questionText: string
    options?: string | null
    correctAnswer?: string | null
    ondasList?: string | null
    displayTimeSeconds?: number | null
    optionalDisplaySeconds?: number | null
    createdAt?: Date | string
    userAnswers?: UserAnswerCreateNestedManyWithoutActivityQuestionInput
  }

  export type ActivityQuestionUncheckedCreateWithoutActivityInput = {
    id?: string
    type: string
    questionType: string
    questionText: string
    options?: string | null
    correctAnswer?: string | null
    ondasList?: string | null
    displayTimeSeconds?: number | null
    optionalDisplaySeconds?: number | null
    createdAt?: Date | string
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutActivityQuestionInput
  }

  export type ActivityQuestionCreateOrConnectWithoutActivityInput = {
    where: ActivityQuestionWhereUniqueInput
    create: XOR<ActivityQuestionCreateWithoutActivityInput, ActivityQuestionUncheckedCreateWithoutActivityInput>
  }

  export type ActivityQuestionCreateManyActivityInputEnvelope = {
    data: ActivityQuestionCreateManyActivityInput | ActivityQuestionCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type GamifiedPlaylistCreateWithoutActivityInput = {
    id?: string
    name: string
    type: string
    sequenceType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    playlist?: PlaylistCreateNestedOneWithoutGamifiedPlaylistsInput
  }

  export type GamifiedPlaylistUncheckedCreateWithoutActivityInput = {
    id?: string
    playlistId?: string | null
    name: string
    type: string
    sequenceType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GamifiedPlaylistCreateOrConnectWithoutActivityInput = {
    where: GamifiedPlaylistWhereUniqueInput
    create: XOR<GamifiedPlaylistCreateWithoutActivityInput, GamifiedPlaylistUncheckedCreateWithoutActivityInput>
  }

  export type GamifiedPlaylistCreateManyActivityInputEnvelope = {
    data: GamifiedPlaylistCreateManyActivityInput | GamifiedPlaylistCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type VideoItemUpsertWithoutActivitiesInput = {
    update: XOR<VideoItemUpdateWithoutActivitiesInput, VideoItemUncheckedUpdateWithoutActivitiesInput>
    create: XOR<VideoItemCreateWithoutActivitiesInput, VideoItemUncheckedCreateWithoutActivitiesInput>
    where?: VideoItemWhereInput
  }

  export type VideoItemUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: VideoItemWhereInput
    data: XOR<VideoItemUpdateWithoutActivitiesInput, VideoItemUncheckedUpdateWithoutActivitiesInput>
  }

  export type VideoItemUpdateWithoutActivitiesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: QuestionUpdateManyWithoutVideoItemNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoItemNestedInput
    studyRooms?: StudyRoomUpdateManyWithoutVideoNestedInput
    playlist?: PlaylistUpdateOneRequiredWithoutVideoItemsNestedInput
    permissions?: VideoPermissionsUpdateOneWithoutVideoItemNestedInput
  }

  export type VideoItemUncheckedUpdateWithoutActivitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    playlistId?: StringFieldUpdateOperationsInput | string
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: QuestionUncheckedUpdateManyWithoutVideoItemNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoItemNestedInput
    studyRooms?: StudyRoomUncheckedUpdateManyWithoutVideoNestedInput
    permissions?: VideoPermissionsUncheckedUpdateOneWithoutVideoItemNestedInput
  }

  export type UserUpsertWithoutCreatedActivitiesInput = {
    update: XOR<UserUpdateWithoutCreatedActivitiesInput, UserUncheckedUpdateWithoutCreatedActivitiesInput>
    create: XOR<UserCreateWithoutCreatedActivitiesInput, UserUncheckedCreateWithoutCreatedActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedActivitiesInput, UserUncheckedUpdateWithoutCreatedActivitiesInput>
  }

  export type UserUpdateWithoutCreatedActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExperienceUpsertWithoutActivitiesInput = {
    update: XOR<ExperienceUpdateWithoutActivitiesInput, ExperienceUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ExperienceCreateWithoutActivitiesInput, ExperienceUncheckedCreateWithoutActivitiesInput>
    where?: ExperienceWhereInput
  }

  export type ExperienceUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ExperienceWhereInput
    data: XOR<ExperienceUpdateWithoutActivitiesInput, ExperienceUncheckedUpdateWithoutActivitiesInput>
  }

  export type ExperienceUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    gamificationFramework?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedExperiencesNestedInput
    stage?: StageUpdateOneRequiredWithoutExperiencesNestedInput
  }

  export type ExperienceUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    gamificationFramework?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityQuestionUpsertWithWhereUniqueWithoutActivityInput = {
    where: ActivityQuestionWhereUniqueInput
    update: XOR<ActivityQuestionUpdateWithoutActivityInput, ActivityQuestionUncheckedUpdateWithoutActivityInput>
    create: XOR<ActivityQuestionCreateWithoutActivityInput, ActivityQuestionUncheckedCreateWithoutActivityInput>
  }

  export type ActivityQuestionUpdateWithWhereUniqueWithoutActivityInput = {
    where: ActivityQuestionWhereUniqueInput
    data: XOR<ActivityQuestionUpdateWithoutActivityInput, ActivityQuestionUncheckedUpdateWithoutActivityInput>
  }

  export type ActivityQuestionUpdateManyWithWhereWithoutActivityInput = {
    where: ActivityQuestionScalarWhereInput
    data: XOR<ActivityQuestionUpdateManyMutationInput, ActivityQuestionUncheckedUpdateManyWithoutActivityInput>
  }

  export type ActivityQuestionScalarWhereInput = {
    AND?: ActivityQuestionScalarWhereInput | ActivityQuestionScalarWhereInput[]
    OR?: ActivityQuestionScalarWhereInput[]
    NOT?: ActivityQuestionScalarWhereInput | ActivityQuestionScalarWhereInput[]
    id?: StringFilter<"ActivityQuestion"> | string
    activityId?: StringFilter<"ActivityQuestion"> | string
    type?: StringFilter<"ActivityQuestion"> | string
    questionType?: StringFilter<"ActivityQuestion"> | string
    questionText?: StringFilter<"ActivityQuestion"> | string
    options?: StringNullableFilter<"ActivityQuestion"> | string | null
    correctAnswer?: StringNullableFilter<"ActivityQuestion"> | string | null
    ondasList?: StringNullableFilter<"ActivityQuestion"> | string | null
    displayTimeSeconds?: IntNullableFilter<"ActivityQuestion"> | number | null
    optionalDisplaySeconds?: IntNullableFilter<"ActivityQuestion"> | number | null
    createdAt?: DateTimeFilter<"ActivityQuestion"> | Date | string
  }

  export type GamifiedPlaylistUpsertWithWhereUniqueWithoutActivityInput = {
    where: GamifiedPlaylistWhereUniqueInput
    update: XOR<GamifiedPlaylistUpdateWithoutActivityInput, GamifiedPlaylistUncheckedUpdateWithoutActivityInput>
    create: XOR<GamifiedPlaylistCreateWithoutActivityInput, GamifiedPlaylistUncheckedCreateWithoutActivityInput>
  }

  export type GamifiedPlaylistUpdateWithWhereUniqueWithoutActivityInput = {
    where: GamifiedPlaylistWhereUniqueInput
    data: XOR<GamifiedPlaylistUpdateWithoutActivityInput, GamifiedPlaylistUncheckedUpdateWithoutActivityInput>
  }

  export type GamifiedPlaylistUpdateManyWithWhereWithoutActivityInput = {
    where: GamifiedPlaylistScalarWhereInput
    data: XOR<GamifiedPlaylistUpdateManyMutationInput, GamifiedPlaylistUncheckedUpdateManyWithoutActivityInput>
  }

  export type PlaylistCreateWithoutGamifiedPlaylistsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    orderInMundo?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
    contentItems?: ContentItemCreateNestedManyWithoutPlaylistInput
    mundo: MundoCreateNestedOneWithoutPlaylistsInput
    videoItems?: VideoItemCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistUncheckedCreateWithoutGamifiedPlaylistsInput = {
    id?: string
    mundoId: string
    name: string
    description?: string | null
    imageUrl?: string | null
    orderInMundo?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
    contentItems?: ContentItemUncheckedCreateNestedManyWithoutPlaylistInput
    videoItems?: VideoItemUncheckedCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistCreateOrConnectWithoutGamifiedPlaylistsInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutGamifiedPlaylistsInput, PlaylistUncheckedCreateWithoutGamifiedPlaylistsInput>
  }

  export type ActivityCreateWithoutGamifiedPlaylistsInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    multimediaType?: string | null
    contentUrl?: string | null
    duration?: number | null
    order?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoItem?: VideoItemCreateNestedOneWithoutActivitiesInput
    creator: UserCreateNestedOneWithoutCreatedActivitiesInput
    experience: ExperienceCreateNestedOneWithoutActivitiesInput
    questions?: ActivityQuestionCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutGamifiedPlaylistsInput = {
    id?: string
    experienceId: string
    title: string
    description?: string | null
    type: string
    multimediaType?: string | null
    contentUrl?: string | null
    duration?: number | null
    order?: number
    status?: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoItemId?: number | null
    questions?: ActivityQuestionUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutGamifiedPlaylistsInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutGamifiedPlaylistsInput, ActivityUncheckedCreateWithoutGamifiedPlaylistsInput>
  }

  export type PlaylistUpsertWithoutGamifiedPlaylistsInput = {
    update: XOR<PlaylistUpdateWithoutGamifiedPlaylistsInput, PlaylistUncheckedUpdateWithoutGamifiedPlaylistsInput>
    create: XOR<PlaylistCreateWithoutGamifiedPlaylistsInput, PlaylistUncheckedCreateWithoutGamifiedPlaylistsInput>
    where?: PlaylistWhereInput
  }

  export type PlaylistUpdateToOneWithWhereWithoutGamifiedPlaylistsInput = {
    where?: PlaylistWhereInput
    data: XOR<PlaylistUpdateWithoutGamifiedPlaylistsInput, PlaylistUncheckedUpdateWithoutGamifiedPlaylistsInput>
  }

  export type PlaylistUpdateWithoutGamifiedPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orderInMundo?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    contentItems?: ContentItemUpdateManyWithoutPlaylistNestedInput
    mundo?: MundoUpdateOneRequiredWithoutPlaylistsNestedInput
    videoItems?: VideoItemUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistUncheckedUpdateWithoutGamifiedPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mundoId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orderInMundo?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    contentItems?: ContentItemUncheckedUpdateManyWithoutPlaylistNestedInput
    videoItems?: VideoItemUncheckedUpdateManyWithoutPlaylistNestedInput
  }

  export type ActivityUpsertWithoutGamifiedPlaylistsInput = {
    update: XOR<ActivityUpdateWithoutGamifiedPlaylistsInput, ActivityUncheckedUpdateWithoutGamifiedPlaylistsInput>
    create: XOR<ActivityCreateWithoutGamifiedPlaylistsInput, ActivityUncheckedCreateWithoutGamifiedPlaylistsInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutGamifiedPlaylistsInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutGamifiedPlaylistsInput, ActivityUncheckedUpdateWithoutGamifiedPlaylistsInput>
  }

  export type ActivityUpdateWithoutGamifiedPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    multimediaType?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoItem?: VideoItemUpdateOneWithoutActivitiesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedActivitiesNestedInput
    experience?: ExperienceUpdateOneRequiredWithoutActivitiesNestedInput
    questions?: ActivityQuestionUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutGamifiedPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    multimediaType?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoItemId?: NullableIntFieldUpdateOperationsInput | number | null
    questions?: ActivityQuestionUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityCreateWithoutQuestionsInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    multimediaType?: string | null
    contentUrl?: string | null
    duration?: number | null
    order?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoItem?: VideoItemCreateNestedOneWithoutActivitiesInput
    creator: UserCreateNestedOneWithoutCreatedActivitiesInput
    experience: ExperienceCreateNestedOneWithoutActivitiesInput
    gamifiedPlaylists?: GamifiedPlaylistCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutQuestionsInput = {
    id?: string
    experienceId: string
    title: string
    description?: string | null
    type: string
    multimediaType?: string | null
    contentUrl?: string | null
    duration?: number | null
    order?: number
    status?: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoItemId?: number | null
    gamifiedPlaylists?: GamifiedPlaylistUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutQuestionsInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutQuestionsInput, ActivityUncheckedCreateWithoutQuestionsInput>
  }

  export type UserAnswerCreateWithoutActivityQuestionInput = {
    id?: string
    answerGiven: string
    isCorrect?: boolean | null
    ondasEarned?: number
    createdAt?: Date | string
    question?: QuestionCreateNestedOneWithoutUserAnswersInput
    user: UserCreateNestedOneWithoutUserAnswersInput
  }

  export type UserAnswerUncheckedCreateWithoutActivityQuestionInput = {
    id?: string
    userId: string
    questionId?: number | null
    answerGiven: string
    isCorrect?: boolean | null
    ondasEarned?: number
    createdAt?: Date | string
  }

  export type UserAnswerCreateOrConnectWithoutActivityQuestionInput = {
    where: UserAnswerWhereUniqueInput
    create: XOR<UserAnswerCreateWithoutActivityQuestionInput, UserAnswerUncheckedCreateWithoutActivityQuestionInput>
  }

  export type UserAnswerCreateManyActivityQuestionInputEnvelope = {
    data: UserAnswerCreateManyActivityQuestionInput | UserAnswerCreateManyActivityQuestionInput[]
    skipDuplicates?: boolean
  }

  export type ActivityUpsertWithoutQuestionsInput = {
    update: XOR<ActivityUpdateWithoutQuestionsInput, ActivityUncheckedUpdateWithoutQuestionsInput>
    create: XOR<ActivityCreateWithoutQuestionsInput, ActivityUncheckedCreateWithoutQuestionsInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutQuestionsInput, ActivityUncheckedUpdateWithoutQuestionsInput>
  }

  export type ActivityUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    multimediaType?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoItem?: VideoItemUpdateOneWithoutActivitiesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedActivitiesNestedInput
    experience?: ExperienceUpdateOneRequiredWithoutActivitiesNestedInput
    gamifiedPlaylists?: GamifiedPlaylistUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    multimediaType?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoItemId?: NullableIntFieldUpdateOperationsInput | number | null
    gamifiedPlaylists?: GamifiedPlaylistUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type UserAnswerUpsertWithWhereUniqueWithoutActivityQuestionInput = {
    where: UserAnswerWhereUniqueInput
    update: XOR<UserAnswerUpdateWithoutActivityQuestionInput, UserAnswerUncheckedUpdateWithoutActivityQuestionInput>
    create: XOR<UserAnswerCreateWithoutActivityQuestionInput, UserAnswerUncheckedCreateWithoutActivityQuestionInput>
  }

  export type UserAnswerUpdateWithWhereUniqueWithoutActivityQuestionInput = {
    where: UserAnswerWhereUniqueInput
    data: XOR<UserAnswerUpdateWithoutActivityQuestionInput, UserAnswerUncheckedUpdateWithoutActivityQuestionInput>
  }

  export type UserAnswerUpdateManyWithWhereWithoutActivityQuestionInput = {
    where: UserAnswerScalarWhereInput
    data: XOR<UserAnswerUpdateManyMutationInput, UserAnswerUncheckedUpdateManyWithoutActivityQuestionInput>
  }

  export type ActivityQuestionCreateWithoutUserAnswersInput = {
    id?: string
    type: string
    questionType: string
    questionText: string
    options?: string | null
    correctAnswer?: string | null
    ondasList?: string | null
    displayTimeSeconds?: number | null
    optionalDisplaySeconds?: number | null
    createdAt?: Date | string
    activity: ActivityCreateNestedOneWithoutQuestionsInput
  }

  export type ActivityQuestionUncheckedCreateWithoutUserAnswersInput = {
    id?: string
    activityId: string
    type: string
    questionType: string
    questionText: string
    options?: string | null
    correctAnswer?: string | null
    ondasList?: string | null
    displayTimeSeconds?: number | null
    optionalDisplaySeconds?: number | null
    createdAt?: Date | string
  }

  export type ActivityQuestionCreateOrConnectWithoutUserAnswersInput = {
    where: ActivityQuestionWhereUniqueInput
    create: XOR<ActivityQuestionCreateWithoutUserAnswersInput, ActivityQuestionUncheckedCreateWithoutUserAnswersInput>
  }

  export type QuestionCreateWithoutUserAnswersInput = {
    timestamp: number
    type: string
    text: string
    languageCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    endTimestamp?: number | null
    answerOptions?: AnswerOptionCreateNestedManyWithoutQuestionInput
    videoItem: VideoItemCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionUncheckedCreateWithoutUserAnswersInput = {
    id?: number
    videoItemId: number
    timestamp: number
    type: string
    text: string
    languageCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    endTimestamp?: number | null
    answerOptions?: AnswerOptionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutUserAnswersInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutUserAnswersInput, QuestionUncheckedCreateWithoutUserAnswersInput>
  }

  export type UserCreateWithoutUserAnswersInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserAnswersInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserAnswersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserAnswersInput, UserUncheckedCreateWithoutUserAnswersInput>
  }

  export type ActivityQuestionUpsertWithoutUserAnswersInput = {
    update: XOR<ActivityQuestionUpdateWithoutUserAnswersInput, ActivityQuestionUncheckedUpdateWithoutUserAnswersInput>
    create: XOR<ActivityQuestionCreateWithoutUserAnswersInput, ActivityQuestionUncheckedCreateWithoutUserAnswersInput>
    where?: ActivityQuestionWhereInput
  }

  export type ActivityQuestionUpdateToOneWithWhereWithoutUserAnswersInput = {
    where?: ActivityQuestionWhereInput
    data: XOR<ActivityQuestionUpdateWithoutUserAnswersInput, ActivityQuestionUncheckedUpdateWithoutUserAnswersInput>
  }

  export type ActivityQuestionUpdateWithoutUserAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    ondasList?: NullableStringFieldUpdateOperationsInput | string | null
    displayTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    optionalDisplaySeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type ActivityQuestionUncheckedUpdateWithoutUserAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    ondasList?: NullableStringFieldUpdateOperationsInput | string | null
    displayTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    optionalDisplaySeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUpsertWithoutUserAnswersInput = {
    update: XOR<QuestionUpdateWithoutUserAnswersInput, QuestionUncheckedUpdateWithoutUserAnswersInput>
    create: XOR<QuestionCreateWithoutUserAnswersInput, QuestionUncheckedCreateWithoutUserAnswersInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutUserAnswersInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutUserAnswersInput, QuestionUncheckedUpdateWithoutUserAnswersInput>
  }

  export type QuestionUpdateWithoutUserAnswersInput = {
    timestamp?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    answerOptions?: AnswerOptionUpdateManyWithoutQuestionNestedInput
    videoItem?: VideoItemUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuestionUncheckedUpdateWithoutUserAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    videoItemId?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    answerOptions?: AnswerOptionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type UserUpsertWithoutUserAnswersInput = {
    update: XOR<UserUpdateWithoutUserAnswersInput, UserUncheckedUpdateWithoutUserAnswersInput>
    create: XOR<UserCreateWithoutUserAnswersInput, UserUncheckedCreateWithoutUserAnswersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserAnswersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserAnswersInput, UserUncheckedUpdateWithoutUserAnswersInput>
  }

  export type UserUpdateWithoutUserAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTokensInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTokensInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
  }

  export type UserUpsertWithoutTokensInput = {
    update: XOR<UserUpdateWithoutTokensInput, UserUncheckedUpdateWithoutTokensInput>
    create: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTokensInput, UserUncheckedUpdateWithoutTokensInput>
  }

  export type UserUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMeritsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMeritsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMeritsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMeritsInput, UserUncheckedCreateWithoutMeritsInput>
  }

  export type UserUpsertWithoutMeritsInput = {
    update: XOR<UserUpdateWithoutMeritsInput, UserUncheckedUpdateWithoutMeritsInput>
    create: XOR<UserCreateWithoutMeritsInput, UserUncheckedCreateWithoutMeritsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMeritsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMeritsInput, UserUncheckedUpdateWithoutMeritsInput>
  }

  export type UserUpdateWithoutMeritsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMeritsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionCreateWithoutToWalletInput = {
    id?: string
    amount: number
    tokenType: string
    type: string
    status?: string
    description?: string | null
    createdAt?: Date | string
    fromWallet?: WalletCreateNestedOneWithoutTransactionsFromInput
    toUser: UserCreateNestedOneWithoutTransactionsToInput
    fromUser?: UserCreateNestedOneWithoutTransactionsFromInput
  }

  export type TransactionUncheckedCreateWithoutToWalletInput = {
    id?: string
    fromUserId?: string | null
    amount: number
    tokenType: string
    type: string
    status?: string
    description?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutToWalletInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutToWalletInput, TransactionUncheckedCreateWithoutToWalletInput>
  }

  export type TransactionCreateManyToWalletInputEnvelope = {
    data: TransactionCreateManyToWalletInput | TransactionCreateManyToWalletInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutFromWalletInput = {
    id?: string
    amount: number
    tokenType: string
    type: string
    status?: string
    description?: string | null
    createdAt?: Date | string
    toWallet: WalletCreateNestedOneWithoutTransactionsToInput
    toUser: UserCreateNestedOneWithoutTransactionsToInput
    fromUser?: UserCreateNestedOneWithoutTransactionsFromInput
  }

  export type TransactionUncheckedCreateWithoutFromWalletInput = {
    id?: string
    toUserId: string
    amount: number
    tokenType: string
    type: string
    status?: string
    description?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutFromWalletInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutFromWalletInput, TransactionUncheckedCreateWithoutFromWalletInput>
  }

  export type TransactionCreateManyFromWalletInputEnvelope = {
    data: TransactionCreateManyFromWalletInput | TransactionCreateManyFromWalletInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutWalletInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWalletInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWalletInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutToWalletInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutToWalletInput, TransactionUncheckedUpdateWithoutToWalletInput>
    create: XOR<TransactionCreateWithoutToWalletInput, TransactionUncheckedCreateWithoutToWalletInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutToWalletInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutToWalletInput, TransactionUncheckedUpdateWithoutToWalletInput>
  }

  export type TransactionUpdateManyWithWhereWithoutToWalletInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutToWalletInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutFromWalletInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutFromWalletInput, TransactionUncheckedUpdateWithoutFromWalletInput>
    create: XOR<TransactionCreateWithoutFromWalletInput, TransactionUncheckedCreateWithoutFromWalletInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutFromWalletInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutFromWalletInput, TransactionUncheckedUpdateWithoutFromWalletInput>
  }

  export type TransactionUpdateManyWithWhereWithoutFromWalletInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutFromWalletInput>
  }

  export type UserUpsertWithoutWalletInput = {
    update: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWalletInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
  }

  export type UserUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WalletCreateWithoutTransactionsToInput = {
    id?: string
    blockchainAddress?: string | null
    balanceUnits?: number
    balanceToins?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionsFrom?: TransactionCreateNestedManyWithoutFromWalletInput
    user: UserCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutTransactionsToInput = {
    id?: string
    userId: string
    blockchainAddress?: string | null
    balanceUnits?: number
    balanceToins?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromWalletInput
  }

  export type WalletCreateOrConnectWithoutTransactionsToInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutTransactionsToInput, WalletUncheckedCreateWithoutTransactionsToInput>
  }

  export type WalletCreateWithoutTransactionsFromInput = {
    id?: string
    blockchainAddress?: string | null
    balanceUnits?: number
    balanceToins?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionsTo?: TransactionCreateNestedManyWithoutToWalletInput
    user: UserCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutTransactionsFromInput = {
    id?: string
    userId: string
    blockchainAddress?: string | null
    balanceUnits?: number
    balanceToins?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToWalletInput
  }

  export type WalletCreateOrConnectWithoutTransactionsFromInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutTransactionsFromInput, WalletUncheckedCreateWithoutTransactionsFromInput>
  }

  export type UserCreateWithoutTransactionsToInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsToInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsToInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsToInput, UserUncheckedCreateWithoutTransactionsToInput>
  }

  export type UserCreateWithoutTransactionsFromInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsFromInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsFromInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsFromInput, UserUncheckedCreateWithoutTransactionsFromInput>
  }

  export type WalletUpsertWithoutTransactionsToInput = {
    update: XOR<WalletUpdateWithoutTransactionsToInput, WalletUncheckedUpdateWithoutTransactionsToInput>
    create: XOR<WalletCreateWithoutTransactionsToInput, WalletUncheckedCreateWithoutTransactionsToInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutTransactionsToInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutTransactionsToInput, WalletUncheckedUpdateWithoutTransactionsToInput>
  }

  export type WalletUpdateWithoutTransactionsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockchainAddress?: NullableStringFieldUpdateOperationsInput | string | null
    balanceUnits?: FloatFieldUpdateOperationsInput | number
    balanceToins?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionsFrom?: TransactionUpdateManyWithoutFromWalletNestedInput
    user?: UserUpdateOneRequiredWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutTransactionsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    blockchainAddress?: NullableStringFieldUpdateOperationsInput | string | null
    balanceUnits?: FloatFieldUpdateOperationsInput | number
    balanceToins?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromWalletNestedInput
  }

  export type WalletUpsertWithoutTransactionsFromInput = {
    update: XOR<WalletUpdateWithoutTransactionsFromInput, WalletUncheckedUpdateWithoutTransactionsFromInput>
    create: XOR<WalletCreateWithoutTransactionsFromInput, WalletUncheckedCreateWithoutTransactionsFromInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutTransactionsFromInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutTransactionsFromInput, WalletUncheckedUpdateWithoutTransactionsFromInput>
  }

  export type WalletUpdateWithoutTransactionsFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockchainAddress?: NullableStringFieldUpdateOperationsInput | string | null
    balanceUnits?: FloatFieldUpdateOperationsInput | number
    balanceToins?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionsTo?: TransactionUpdateManyWithoutToWalletNestedInput
    user?: UserUpdateOneRequiredWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutTransactionsFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    blockchainAddress?: NullableStringFieldUpdateOperationsInput | string | null
    balanceUnits?: FloatFieldUpdateOperationsInput | number
    balanceToins?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToWalletNestedInput
  }

  export type UserUpsertWithoutTransactionsToInput = {
    update: XOR<UserUpdateWithoutTransactionsToInput, UserUncheckedUpdateWithoutTransactionsToInput>
    create: XOR<UserCreateWithoutTransactionsToInput, UserUncheckedCreateWithoutTransactionsToInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsToInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsToInput, UserUncheckedUpdateWithoutTransactionsToInput>
  }

  export type UserUpdateWithoutTransactionsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutTransactionsFromInput = {
    update: XOR<UserUpdateWithoutTransactionsFromInput, UserUncheckedUpdateWithoutTransactionsFromInput>
    create: XOR<UserCreateWithoutTransactionsFromInput, UserUncheckedCreateWithoutTransactionsFromInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsFromInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsFromInput, UserUncheckedUpdateWithoutTransactionsFromInput>
  }

  export type UserUpdateWithoutTransactionsFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutOwnedGroupsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedGroupsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedGroupsInput, UserUncheckedCreateWithoutOwnedGroupsInput>
  }

  export type UserGroupCreateWithoutGroupInput = {
    roleInGroup?: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutUserGroupsInput
  }

  export type UserGroupUncheckedCreateWithoutGroupInput = {
    userId: string
    roleInGroup?: string
    joinedAt?: Date | string
  }

  export type UserGroupCreateOrConnectWithoutGroupInput = {
    where: UserGroupWhereUniqueInput
    create: XOR<UserGroupCreateWithoutGroupInput, UserGroupUncheckedCreateWithoutGroupInput>
  }

  export type UserGroupCreateManyGroupInputEnvelope = {
    data: UserGroupCreateManyGroupInput | UserGroupCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnedGroupsInput = {
    update: XOR<UserUpdateWithoutOwnedGroupsInput, UserUncheckedUpdateWithoutOwnedGroupsInput>
    create: XOR<UserCreateWithoutOwnedGroupsInput, UserUncheckedCreateWithoutOwnedGroupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedGroupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedGroupsInput, UserUncheckedUpdateWithoutOwnedGroupsInput>
  }

  export type UserUpdateWithoutOwnedGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserGroupUpsertWithWhereUniqueWithoutGroupInput = {
    where: UserGroupWhereUniqueInput
    update: XOR<UserGroupUpdateWithoutGroupInput, UserGroupUncheckedUpdateWithoutGroupInput>
    create: XOR<UserGroupCreateWithoutGroupInput, UserGroupUncheckedCreateWithoutGroupInput>
  }

  export type UserGroupUpdateWithWhereUniqueWithoutGroupInput = {
    where: UserGroupWhereUniqueInput
    data: XOR<UserGroupUpdateWithoutGroupInput, UserGroupUncheckedUpdateWithoutGroupInput>
  }

  export type UserGroupUpdateManyWithWhereWithoutGroupInput = {
    where: UserGroupScalarWhereInput
    data: XOR<UserGroupUpdateManyMutationInput, UserGroupUncheckedUpdateManyWithoutGroupInput>
  }

  export type GroupCreateWithoutUserGroupsInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedGroupsInput
  }

  export type GroupUncheckedCreateWithoutUserGroupsInput = {
    id?: string
    name: string
    description?: string | null
    ownerId: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupCreateOrConnectWithoutUserGroupsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutUserGroupsInput, GroupUncheckedCreateWithoutUserGroupsInput>
  }

  export type UserCreateWithoutUserGroupsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserGroupsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserGroupsInput, UserUncheckedCreateWithoutUserGroupsInput>
  }

  export type GroupUpsertWithoutUserGroupsInput = {
    update: XOR<GroupUpdateWithoutUserGroupsInput, GroupUncheckedUpdateWithoutUserGroupsInput>
    create: XOR<GroupCreateWithoutUserGroupsInput, GroupUncheckedCreateWithoutUserGroupsInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutUserGroupsInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutUserGroupsInput, GroupUncheckedUpdateWithoutUserGroupsInput>
  }

  export type GroupUpdateWithoutUserGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedGroupsNestedInput
  }

  export type GroupUncheckedUpdateWithoutUserGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutUserGroupsInput = {
    update: XOR<UserUpdateWithoutUserGroupsInput, UserUncheckedUpdateWithoutUserGroupsInput>
    create: XOR<UserCreateWithoutUserGroupsInput, UserUncheckedCreateWithoutUserGroupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserGroupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserGroupsInput, UserUncheckedUpdateWithoutUserGroupsInput>
  }

  export type UserUpdateWithoutUserGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentCreateWithoutPublicationInput = {
    id?: string
    activityId?: string | null
    text: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutPublicationInput = {
    id?: string
    userId: string
    activityId?: string | null
    text: string
    createdAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutPublicationInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPublicationInput, CommentUncheckedCreateWithoutPublicationInput>
  }

  export type CommentCreateManyPublicationInputEnvelope = {
    data: CommentCreateManyPublicationInput | CommentCreateManyPublicationInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutPublicationInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutPublicationInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutPublicationInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutPublicationInput, LikeUncheckedCreateWithoutPublicationInput>
  }

  export type LikeCreateManyPublicationInputEnvelope = {
    data: LikeCreateManyPublicationInput | LikeCreateManyPublicationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPublicationsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPublicationsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPublicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPublicationsInput, UserUncheckedCreateWithoutPublicationsInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutPublicationInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPublicationInput, CommentUncheckedUpdateWithoutPublicationInput>
    create: XOR<CommentCreateWithoutPublicationInput, CommentUncheckedCreateWithoutPublicationInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPublicationInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPublicationInput, CommentUncheckedUpdateWithoutPublicationInput>
  }

  export type CommentUpdateManyWithWhereWithoutPublicationInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPublicationInput>
  }

  export type LikeUpsertWithWhereUniqueWithoutPublicationInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutPublicationInput, LikeUncheckedUpdateWithoutPublicationInput>
    create: XOR<LikeCreateWithoutPublicationInput, LikeUncheckedCreateWithoutPublicationInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutPublicationInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutPublicationInput, LikeUncheckedUpdateWithoutPublicationInput>
  }

  export type LikeUpdateManyWithWhereWithoutPublicationInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutPublicationInput>
  }

  export type UserUpsertWithoutPublicationsInput = {
    update: XOR<UserUpdateWithoutPublicationsInput, UserUncheckedUpdateWithoutPublicationsInput>
    create: XOR<UserCreateWithoutPublicationsInput, UserUncheckedCreateWithoutPublicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPublicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPublicationsInput, UserUncheckedUpdateWithoutPublicationsInput>
  }

  export type UserUpdateWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PublicationCreateWithoutCommentsInput = {
    id?: string
    content: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: LikeCreateNestedManyWithoutPublicationInput
    user: UserCreateNestedOneWithoutPublicationsInput
  }

  export type PublicationUncheckedCreateWithoutCommentsInput = {
    id?: string
    userId: string
    content: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: LikeUncheckedCreateNestedManyWithoutPublicationInput
  }

  export type PublicationCreateOrConnectWithoutCommentsInput = {
    where: PublicationWhereUniqueInput
    create: XOR<PublicationCreateWithoutCommentsInput, PublicationUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type PublicationUpsertWithoutCommentsInput = {
    update: XOR<PublicationUpdateWithoutCommentsInput, PublicationUncheckedUpdateWithoutCommentsInput>
    create: XOR<PublicationCreateWithoutCommentsInput, PublicationUncheckedCreateWithoutCommentsInput>
    where?: PublicationWhereInput
  }

  export type PublicationUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PublicationWhereInput
    data: XOR<PublicationUpdateWithoutCommentsInput, PublicationUncheckedUpdateWithoutCommentsInput>
  }

  export type PublicationUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUpdateManyWithoutPublicationNestedInput
    user?: UserUpdateOneRequiredWithoutPublicationsNestedInput
  }

  export type PublicationUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUncheckedUpdateManyWithoutPublicationNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PublicationCreateWithoutLikesInput = {
    id?: string
    content: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPublicationInput
    user: UserCreateNestedOneWithoutPublicationsInput
  }

  export type PublicationUncheckedCreateWithoutLikesInput = {
    id?: string
    userId: string
    content: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPublicationInput
  }

  export type PublicationCreateOrConnectWithoutLikesInput = {
    where: PublicationWhereUniqueInput
    create: XOR<PublicationCreateWithoutLikesInput, PublicationUncheckedCreateWithoutLikesInput>
  }

  export type UserCreateWithoutLikesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLikesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
  }

  export type PublicationUpsertWithoutLikesInput = {
    update: XOR<PublicationUpdateWithoutLikesInput, PublicationUncheckedUpdateWithoutLikesInput>
    create: XOR<PublicationCreateWithoutLikesInput, PublicationUncheckedCreateWithoutLikesInput>
    where?: PublicationWhereInput
  }

  export type PublicationUpdateToOneWithWhereWithoutLikesInput = {
    where?: PublicationWhereInput
    data: XOR<PublicationUpdateWithoutLikesInput, PublicationUncheckedUpdateWithoutLikesInput>
  }

  export type PublicationUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPublicationNestedInput
    user?: UserUpdateOneRequiredWithoutPublicationsNestedInput
  }

  export type PublicationUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPublicationNestedInput
  }

  export type UserUpsertWithoutLikesInput = {
    update: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
    create: XOR<UserCreateWithoutLikesInput, UserUncheckedCreateWithoutLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLikesInput, UserUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCreatedInvitationTemplatesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedInvitationTemplatesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedInvitationTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedInvitationTemplatesInput, UserUncheckedCreateWithoutCreatedInvitationTemplatesInput>
  }

  export type UserUpsertWithoutCreatedInvitationTemplatesInput = {
    update: XOR<UserUpdateWithoutCreatedInvitationTemplatesInput, UserUncheckedUpdateWithoutCreatedInvitationTemplatesInput>
    create: XOR<UserCreateWithoutCreatedInvitationTemplatesInput, UserUncheckedCreateWithoutCreatedInvitationTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedInvitationTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedInvitationTemplatesInput, UserUncheckedUpdateWithoutCreatedInvitationTemplatesInput>
  }

  export type UserUpdateWithoutCreatedInvitationTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedInvitationTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInvitationsSentInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvitationsSentInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvitationsSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
  }

  export type UserInvitationCreateWithoutGiftCardInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    invitedUser?: UserCreateNestedOneWithoutInvitationsReceivedInput
  }

  export type UserInvitationUncheckedCreateWithoutGiftCardInput = {
    id?: string
    invitedUserId?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type UserInvitationCreateOrConnectWithoutGiftCardInput = {
    where: UserInvitationWhereUniqueInput
    create: XOR<UserInvitationCreateWithoutGiftCardInput, UserInvitationUncheckedCreateWithoutGiftCardInput>
  }

  export type UserInvitationCreateManyGiftCardInputEnvelope = {
    data: UserInvitationCreateManyGiftCardInput | UserInvitationCreateManyGiftCardInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInvitationsSentInput = {
    update: XOR<UserUpdateWithoutInvitationsSentInput, UserUncheckedUpdateWithoutInvitationsSentInput>
    create: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationsSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationsSentInput, UserUncheckedUpdateWithoutInvitationsSentInput>
  }

  export type UserUpdateWithoutInvitationsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserInvitationUpsertWithWhereUniqueWithoutGiftCardInput = {
    where: UserInvitationWhereUniqueInput
    update: XOR<UserInvitationUpdateWithoutGiftCardInput, UserInvitationUncheckedUpdateWithoutGiftCardInput>
    create: XOR<UserInvitationCreateWithoutGiftCardInput, UserInvitationUncheckedCreateWithoutGiftCardInput>
  }

  export type UserInvitationUpdateWithWhereUniqueWithoutGiftCardInput = {
    where: UserInvitationWhereUniqueInput
    data: XOR<UserInvitationUpdateWithoutGiftCardInput, UserInvitationUncheckedUpdateWithoutGiftCardInput>
  }

  export type UserInvitationUpdateManyWithWhereWithoutGiftCardInput = {
    where: UserInvitationScalarWhereInput
    data: XOR<UserInvitationUpdateManyMutationInput, UserInvitationUncheckedUpdateManyWithoutGiftCardInput>
  }

  export type UserCreateWithoutInvitationsReceivedInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvitationsReceivedInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvitationsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationsReceivedInput, UserUncheckedCreateWithoutInvitationsReceivedInput>
  }

  export type GiftCardCreateWithoutUserInvitationsInput = {
    id?: string
    invitedName: string
    invitedEmail: string
    token: string
    unitsAmount: number
    suggestions?: string | null
    status?: string
    createdAt?: Date | string
    inviter: UserCreateNestedOneWithoutInvitationsSentInput
  }

  export type GiftCardUncheckedCreateWithoutUserInvitationsInput = {
    id?: string
    inviterId: string
    invitedName: string
    invitedEmail: string
    token: string
    unitsAmount: number
    suggestions?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type GiftCardCreateOrConnectWithoutUserInvitationsInput = {
    where: GiftCardWhereUniqueInput
    create: XOR<GiftCardCreateWithoutUserInvitationsInput, GiftCardUncheckedCreateWithoutUserInvitationsInput>
  }

  export type UserUpsertWithoutInvitationsReceivedInput = {
    update: XOR<UserUpdateWithoutInvitationsReceivedInput, UserUncheckedUpdateWithoutInvitationsReceivedInput>
    create: XOR<UserCreateWithoutInvitationsReceivedInput, UserUncheckedCreateWithoutInvitationsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationsReceivedInput, UserUncheckedUpdateWithoutInvitationsReceivedInput>
  }

  export type UserUpdateWithoutInvitationsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GiftCardUpsertWithoutUserInvitationsInput = {
    update: XOR<GiftCardUpdateWithoutUserInvitationsInput, GiftCardUncheckedUpdateWithoutUserInvitationsInput>
    create: XOR<GiftCardCreateWithoutUserInvitationsInput, GiftCardUncheckedCreateWithoutUserInvitationsInput>
    where?: GiftCardWhereInput
  }

  export type GiftCardUpdateToOneWithWhereWithoutUserInvitationsInput = {
    where?: GiftCardWhereInput
    data: XOR<GiftCardUpdateWithoutUserInvitationsInput, GiftCardUncheckedUpdateWithoutUserInvitationsInput>
  }

  export type GiftCardUpdateWithoutUserInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitedName?: StringFieldUpdateOperationsInput | string
    invitedEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    unitsAmount?: FloatFieldUpdateOperationsInput | number
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UserUpdateOneRequiredWithoutInvitationsSentNestedInput
  }

  export type GiftCardUncheckedUpdateWithoutUserInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
    invitedName?: StringFieldUpdateOperationsInput | string
    invitedEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    unitsAmount?: FloatFieldUpdateOperationsInput | number
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutCreatedReportsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedReportsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedReportsInput, UserUncheckedCreateWithoutCreatedReportsInput>
  }

  export type UserUpsertWithoutCreatedReportsInput = {
    update: XOR<UserUpdateWithoutCreatedReportsInput, UserUncheckedUpdateWithoutCreatedReportsInput>
    create: XOR<UserCreateWithoutCreatedReportsInput, UserUncheckedCreateWithoutCreatedReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedReportsInput, UserUncheckedUpdateWithoutCreatedReportsInput>
  }

  export type UserUpdateWithoutCreatedReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPersonalityInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPersonalityInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPersonalityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPersonalityInput, UserUncheckedCreateWithoutPersonalityInput>
  }

  export type UserCreateManyPersonalityInputEnvelope = {
    data: UserCreateManyPersonalityInput | UserCreateManyPersonalityInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutPersonalityInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutPersonalityInput, UserUncheckedUpdateWithoutPersonalityInput>
    create: XOR<UserCreateWithoutPersonalityInput, UserUncheckedCreateWithoutPersonalityInput>
  }

  export type UserUpdateWithWhereUniqueWithoutPersonalityInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutPersonalityInput, UserUncheckedUpdateWithoutPersonalityInput>
  }

  export type UserUpdateManyWithWhereWithoutPersonalityInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutPersonalityInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    username?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    documentType?: StringNullableFilter<"User"> | string | null
    documentNumber?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
    topUserCount?: IntFilter<"User"> | number
    personalityId?: StringNullableFilter<"User"> | string | null
  }

  export type UserCreateWithoutCreatedTemplatesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedTemplatesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedTemplatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTemplatesInput, UserUncheckedCreateWithoutCreatedTemplatesInput>
  }

  export type UserUpsertWithoutCreatedTemplatesInput = {
    update: XOR<UserUpdateWithoutCreatedTemplatesInput, UserUncheckedUpdateWithoutCreatedTemplatesInput>
    create: XOR<UserCreateWithoutCreatedTemplatesInput, UserUncheckedCreateWithoutCreatedTemplatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTemplatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTemplatesInput, UserUncheckedUpdateWithoutCreatedTemplatesInput>
  }

  export type UserUpdateWithoutCreatedTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContentItemCreateWithoutItemTypeInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playlist: PlaylistCreateNestedOneWithoutContentItemsInput
  }

  export type ContentItemUncheckedCreateWithoutItemTypeInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    playlistId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentItemCreateOrConnectWithoutItemTypeInput = {
    where: ContentItemWhereUniqueInput
    create: XOR<ContentItemCreateWithoutItemTypeInput, ContentItemUncheckedCreateWithoutItemTypeInput>
  }

  export type ContentItemCreateManyItemTypeInputEnvelope = {
    data: ContentItemCreateManyItemTypeInput | ContentItemCreateManyItemTypeInput[]
    skipDuplicates?: boolean
  }

  export type ContentItemUpsertWithWhereUniqueWithoutItemTypeInput = {
    where: ContentItemWhereUniqueInput
    update: XOR<ContentItemUpdateWithoutItemTypeInput, ContentItemUncheckedUpdateWithoutItemTypeInput>
    create: XOR<ContentItemCreateWithoutItemTypeInput, ContentItemUncheckedCreateWithoutItemTypeInput>
  }

  export type ContentItemUpdateWithWhereUniqueWithoutItemTypeInput = {
    where: ContentItemWhereUniqueInput
    data: XOR<ContentItemUpdateWithoutItemTypeInput, ContentItemUncheckedUpdateWithoutItemTypeInput>
  }

  export type ContentItemUpdateManyWithWhereWithoutItemTypeInput = {
    where: ContentItemScalarWhereInput
    data: XOR<ContentItemUpdateManyMutationInput, ContentItemUncheckedUpdateManyWithoutItemTypeInput>
  }

  export type ItemTypeCreateWithoutContentItemsInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemTypeUncheckedCreateWithoutContentItemsInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemTypeCreateOrConnectWithoutContentItemsInput = {
    where: ItemTypeWhereUniqueInput
    create: XOR<ItemTypeCreateWithoutContentItemsInput, ItemTypeUncheckedCreateWithoutContentItemsInput>
  }

  export type PlaylistCreateWithoutContentItemsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    orderInMundo?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
    gamifiedPlaylists?: GamifiedPlaylistCreateNestedManyWithoutPlaylistInput
    mundo: MundoCreateNestedOneWithoutPlaylistsInput
    videoItems?: VideoItemCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistUncheckedCreateWithoutContentItemsInput = {
    id?: string
    mundoId: string
    name: string
    description?: string | null
    imageUrl?: string | null
    orderInMundo?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
    gamifiedPlaylists?: GamifiedPlaylistUncheckedCreateNestedManyWithoutPlaylistInput
    videoItems?: VideoItemUncheckedCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistCreateOrConnectWithoutContentItemsInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutContentItemsInput, PlaylistUncheckedCreateWithoutContentItemsInput>
  }

  export type ItemTypeUpsertWithoutContentItemsInput = {
    update: XOR<ItemTypeUpdateWithoutContentItemsInput, ItemTypeUncheckedUpdateWithoutContentItemsInput>
    create: XOR<ItemTypeCreateWithoutContentItemsInput, ItemTypeUncheckedCreateWithoutContentItemsInput>
    where?: ItemTypeWhereInput
  }

  export type ItemTypeUpdateToOneWithWhereWithoutContentItemsInput = {
    where?: ItemTypeWhereInput
    data: XOR<ItemTypeUpdateWithoutContentItemsInput, ItemTypeUncheckedUpdateWithoutContentItemsInput>
  }

  export type ItemTypeUpdateWithoutContentItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemTypeUncheckedUpdateWithoutContentItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaylistUpsertWithoutContentItemsInput = {
    update: XOR<PlaylistUpdateWithoutContentItemsInput, PlaylistUncheckedUpdateWithoutContentItemsInput>
    create: XOR<PlaylistCreateWithoutContentItemsInput, PlaylistUncheckedCreateWithoutContentItemsInput>
    where?: PlaylistWhereInput
  }

  export type PlaylistUpdateToOneWithWhereWithoutContentItemsInput = {
    where?: PlaylistWhereInput
    data: XOR<PlaylistUpdateWithoutContentItemsInput, PlaylistUncheckedUpdateWithoutContentItemsInput>
  }

  export type PlaylistUpdateWithoutContentItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orderInMundo?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    gamifiedPlaylists?: GamifiedPlaylistUpdateManyWithoutPlaylistNestedInput
    mundo?: MundoUpdateOneRequiredWithoutPlaylistsNestedInput
    videoItems?: VideoItemUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistUncheckedUpdateWithoutContentItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mundoId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orderInMundo?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    gamifiedPlaylists?: GamifiedPlaylistUncheckedUpdateManyWithoutPlaylistNestedInput
    videoItems?: VideoItemUncheckedUpdateManyWithoutPlaylistNestedInput
  }

  export type ChallengeRewardCreateWithoutChallengeInput = {
    id?: string
    type: string
    amount?: number | null
    description?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type ChallengeRewardUncheckedCreateWithoutChallengeInput = {
    id?: string
    type: string
    amount?: number | null
    description?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type ChallengeRewardCreateOrConnectWithoutChallengeInput = {
    where: ChallengeRewardWhereUniqueInput
    create: XOR<ChallengeRewardCreateWithoutChallengeInput, ChallengeRewardUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeRewardCreateManyChallengeInputEnvelope = {
    data: ChallengeRewardCreateManyChallengeInput | ChallengeRewardCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type UserChallengeCreateWithoutChallengeInput = {
    id?: string
    status?: string
    progress?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: string | null
    user: UserCreateNestedOneWithoutUserChallengesInput
  }

  export type UserChallengeUncheckedCreateWithoutChallengeInput = {
    id?: string
    userId: string
    status?: string
    progress?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: string | null
  }

  export type UserChallengeCreateOrConnectWithoutChallengeInput = {
    where: UserChallengeWhereUniqueInput
    create: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput>
  }

  export type UserChallengeCreateManyChallengeInputEnvelope = {
    data: UserChallengeCreateManyChallengeInput | UserChallengeCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeRewardUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeRewardWhereUniqueInput
    update: XOR<ChallengeRewardUpdateWithoutChallengeInput, ChallengeRewardUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeRewardCreateWithoutChallengeInput, ChallengeRewardUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeRewardUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeRewardWhereUniqueInput
    data: XOR<ChallengeRewardUpdateWithoutChallengeInput, ChallengeRewardUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeRewardUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeRewardScalarWhereInput
    data: XOR<ChallengeRewardUpdateManyMutationInput, ChallengeRewardUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeRewardScalarWhereInput = {
    AND?: ChallengeRewardScalarWhereInput | ChallengeRewardScalarWhereInput[]
    OR?: ChallengeRewardScalarWhereInput[]
    NOT?: ChallengeRewardScalarWhereInput | ChallengeRewardScalarWhereInput[]
    id?: StringFilter<"ChallengeReward"> | string
    challengeId?: StringFilter<"ChallengeReward"> | string
    type?: StringFilter<"ChallengeReward"> | string
    amount?: FloatNullableFilter<"ChallengeReward"> | number | null
    description?: StringNullableFilter<"ChallengeReward"> | string | null
    metadata?: StringNullableFilter<"ChallengeReward"> | string | null
    createdAt?: DateTimeFilter<"ChallengeReward"> | Date | string
  }

  export type UserChallengeUpsertWithWhereUniqueWithoutChallengeInput = {
    where: UserChallengeWhereUniqueInput
    update: XOR<UserChallengeUpdateWithoutChallengeInput, UserChallengeUncheckedUpdateWithoutChallengeInput>
    create: XOR<UserChallengeCreateWithoutChallengeInput, UserChallengeUncheckedCreateWithoutChallengeInput>
  }

  export type UserChallengeUpdateWithWhereUniqueWithoutChallengeInput = {
    where: UserChallengeWhereUniqueInput
    data: XOR<UserChallengeUpdateWithoutChallengeInput, UserChallengeUncheckedUpdateWithoutChallengeInput>
  }

  export type UserChallengeUpdateManyWithWhereWithoutChallengeInput = {
    where: UserChallengeScalarWhereInput
    data: XOR<UserChallengeUpdateManyMutationInput, UserChallengeUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeCreateWithoutRewardsInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    config?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userChallenges?: UserChallengeCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutRewardsInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    config?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutRewardsInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutRewardsInput, ChallengeUncheckedCreateWithoutRewardsInput>
  }

  export type ChallengeUpsertWithoutRewardsInput = {
    update: XOR<ChallengeUpdateWithoutRewardsInput, ChallengeUncheckedUpdateWithoutRewardsInput>
    create: XOR<ChallengeCreateWithoutRewardsInput, ChallengeUncheckedCreateWithoutRewardsInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutRewardsInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutRewardsInput, ChallengeUncheckedUpdateWithoutRewardsInput>
  }

  export type ChallengeUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    config?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userChallenges?: UserChallengeUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    config?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateWithoutUserChallengesInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    config?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rewards?: ChallengeRewardCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutUserChallengesInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    config?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rewards?: ChallengeRewardUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutUserChallengesInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutUserChallengesInput, ChallengeUncheckedCreateWithoutUserChallengesInput>
  }

  export type UserCreateWithoutUserChallengesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserChallengesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserChallengesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserChallengesInput, UserUncheckedCreateWithoutUserChallengesInput>
  }

  export type ChallengeUpsertWithoutUserChallengesInput = {
    update: XOR<ChallengeUpdateWithoutUserChallengesInput, ChallengeUncheckedUpdateWithoutUserChallengesInput>
    create: XOR<ChallengeCreateWithoutUserChallengesInput, ChallengeUncheckedCreateWithoutUserChallengesInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutUserChallengesInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutUserChallengesInput, ChallengeUncheckedUpdateWithoutUserChallengesInput>
  }

  export type ChallengeUpdateWithoutUserChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    config?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewards?: ChallengeRewardUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutUserChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    config?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewards?: ChallengeRewardUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type UserUpsertWithoutUserChallengesInput = {
    update: XOR<UserUpdateWithoutUserChallengesInput, UserUncheckedUpdateWithoutUserChallengesInput>
    create: XOR<UserCreateWithoutUserChallengesInput, UserUncheckedCreateWithoutUserChallengesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserChallengesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserChallengesInput, UserUncheckedUpdateWithoutUserChallengesInput>
  }

  export type UserUpdateWithoutUserChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMarketplaceItemsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMarketplaceItemsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMarketplaceItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMarketplaceItemsInput, UserUncheckedCreateWithoutMarketplaceItemsInput>
  }

  export type ReviewCreateWithoutMarketplaceItemInput = {
    id?: string
    rating: number
    comment?: string | null
    communication?: number | null
    quality?: number | null
    delivery?: number | null
    value?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutMarketplaceItemInput = {
    id?: string
    userId: string
    rating: number
    comment?: string | null
    communication?: number | null
    quality?: number | null
    delivery?: number | null
    value?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutMarketplaceItemInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutMarketplaceItemInput, ReviewUncheckedCreateWithoutMarketplaceItemInput>
  }

  export type ReviewCreateManyMarketplaceItemInputEnvelope = {
    data: ReviewCreateManyMarketplaceItemInput | ReviewCreateManyMarketplaceItemInput[]
    skipDuplicates?: boolean
  }

  export type MarketplaceMatchCreateWithoutItemInput = {
    id?: string
    buyerConfirmed?: boolean
    sellerConfirmed?: boolean
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    buyer: UserCreateNestedOneWithoutBuyerMatchesInput
    seller: UserCreateNestedOneWithoutSellerMatchesInput
    messages?: MatchMessageCreateNestedManyWithoutMatchInput
  }

  export type MarketplaceMatchUncheckedCreateWithoutItemInput = {
    id?: string
    buyerId: string
    sellerId: string
    buyerConfirmed?: boolean
    sellerConfirmed?: boolean
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MatchMessageUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MarketplaceMatchCreateOrConnectWithoutItemInput = {
    where: MarketplaceMatchWhereUniqueInput
    create: XOR<MarketplaceMatchCreateWithoutItemInput, MarketplaceMatchUncheckedCreateWithoutItemInput>
  }

  export type MarketplaceMatchCreateManyItemInputEnvelope = {
    data: MarketplaceMatchCreateManyItemInput | MarketplaceMatchCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMarketplaceItemsInput = {
    update: XOR<UserUpdateWithoutMarketplaceItemsInput, UserUncheckedUpdateWithoutMarketplaceItemsInput>
    create: XOR<UserCreateWithoutMarketplaceItemsInput, UserUncheckedCreateWithoutMarketplaceItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMarketplaceItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMarketplaceItemsInput, UserUncheckedUpdateWithoutMarketplaceItemsInput>
  }

  export type UserUpdateWithoutMarketplaceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMarketplaceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReviewUpsertWithWhereUniqueWithoutMarketplaceItemInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutMarketplaceItemInput, ReviewUncheckedUpdateWithoutMarketplaceItemInput>
    create: XOR<ReviewCreateWithoutMarketplaceItemInput, ReviewUncheckedCreateWithoutMarketplaceItemInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutMarketplaceItemInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutMarketplaceItemInput, ReviewUncheckedUpdateWithoutMarketplaceItemInput>
  }

  export type ReviewUpdateManyWithWhereWithoutMarketplaceItemInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutMarketplaceItemInput>
  }

  export type MarketplaceMatchUpsertWithWhereUniqueWithoutItemInput = {
    where: MarketplaceMatchWhereUniqueInput
    update: XOR<MarketplaceMatchUpdateWithoutItemInput, MarketplaceMatchUncheckedUpdateWithoutItemInput>
    create: XOR<MarketplaceMatchCreateWithoutItemInput, MarketplaceMatchUncheckedCreateWithoutItemInput>
  }

  export type MarketplaceMatchUpdateWithWhereUniqueWithoutItemInput = {
    where: MarketplaceMatchWhereUniqueInput
    data: XOR<MarketplaceMatchUpdateWithoutItemInput, MarketplaceMatchUncheckedUpdateWithoutItemInput>
  }

  export type MarketplaceMatchUpdateManyWithWhereWithoutItemInput = {
    where: MarketplaceMatchScalarWhereInput
    data: XOR<MarketplaceMatchUpdateManyMutationInput, MarketplaceMatchUncheckedUpdateManyWithoutItemInput>
  }

  export type VideoItemCreateWithoutStudyRoomsInput = {
    title: string
    description?: string | null
    content: string
    url?: string | null
    platform?: string
    externalId?: string | null
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    duration?: number | null
    categories?: string | null
    language?: string | null
    quality?: string | null
    tags?: string | null
    thumbnailUrl?: string | null
    activities?: ActivityCreateNestedManyWithoutVideoItemInput
    questions?: QuestionCreateNestedManyWithoutVideoItemInput
    subtitles?: SubtitleCreateNestedManyWithoutVideoItemInput
    playlist: PlaylistCreateNestedOneWithoutVideoItemsInput
    permissions?: VideoPermissionsCreateNestedOneWithoutVideoItemInput
  }

  export type VideoItemUncheckedCreateWithoutStudyRoomsInput = {
    id?: number
    title: string
    description?: string | null
    content: string
    url?: string | null
    platform?: string
    externalId?: string | null
    playlistId: string
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    duration?: number | null
    categories?: string | null
    language?: string | null
    quality?: string | null
    tags?: string | null
    thumbnailUrl?: string | null
    activities?: ActivityUncheckedCreateNestedManyWithoutVideoItemInput
    questions?: QuestionUncheckedCreateNestedManyWithoutVideoItemInput
    subtitles?: SubtitleUncheckedCreateNestedManyWithoutVideoItemInput
    permissions?: VideoPermissionsUncheckedCreateNestedOneWithoutVideoItemInput
  }

  export type VideoItemCreateOrConnectWithoutStudyRoomsInput = {
    where: VideoItemWhereUniqueInput
    create: XOR<VideoItemCreateWithoutStudyRoomsInput, VideoItemUncheckedCreateWithoutStudyRoomsInput>
  }

  export type UserCreateWithoutHostedStudyRoomsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHostedStudyRoomsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHostedStudyRoomsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHostedStudyRoomsInput, UserUncheckedCreateWithoutHostedStudyRoomsInput>
  }

  export type StudyRoomParticipantCreateWithoutStudyRoomInput = {
    id?: string
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isActive?: boolean
    user: UserCreateNestedOneWithoutStudyRoomParticipantsInput
  }

  export type StudyRoomParticipantUncheckedCreateWithoutStudyRoomInput = {
    id?: string
    userId: string
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isActive?: boolean
  }

  export type StudyRoomParticipantCreateOrConnectWithoutStudyRoomInput = {
    where: StudyRoomParticipantWhereUniqueInput
    create: XOR<StudyRoomParticipantCreateWithoutStudyRoomInput, StudyRoomParticipantUncheckedCreateWithoutStudyRoomInput>
  }

  export type StudyRoomParticipantCreateManyStudyRoomInputEnvelope = {
    data: StudyRoomParticipantCreateManyStudyRoomInput | StudyRoomParticipantCreateManyStudyRoomInput[]
    skipDuplicates?: boolean
  }

  export type StudyRoomMessageCreateWithoutStudyRoomInput = {
    id?: string
    message: string
    messageType?: string
    metadata?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSentChatMessagesInput
  }

  export type StudyRoomMessageUncheckedCreateWithoutStudyRoomInput = {
    id?: string
    userId: string
    message: string
    messageType?: string
    metadata?: string | null
    createdAt?: Date | string
  }

  export type StudyRoomMessageCreateOrConnectWithoutStudyRoomInput = {
    where: StudyRoomMessageWhereUniqueInput
    create: XOR<StudyRoomMessageCreateWithoutStudyRoomInput, StudyRoomMessageUncheckedCreateWithoutStudyRoomInput>
  }

  export type StudyRoomMessageCreateManyStudyRoomInputEnvelope = {
    data: StudyRoomMessageCreateManyStudyRoomInput | StudyRoomMessageCreateManyStudyRoomInput[]
    skipDuplicates?: boolean
  }

  export type VideoItemUpsertWithoutStudyRoomsInput = {
    update: XOR<VideoItemUpdateWithoutStudyRoomsInput, VideoItemUncheckedUpdateWithoutStudyRoomsInput>
    create: XOR<VideoItemCreateWithoutStudyRoomsInput, VideoItemUncheckedCreateWithoutStudyRoomsInput>
    where?: VideoItemWhereInput
  }

  export type VideoItemUpdateToOneWithWhereWithoutStudyRoomsInput = {
    where?: VideoItemWhereInput
    data: XOR<VideoItemUpdateWithoutStudyRoomsInput, VideoItemUncheckedUpdateWithoutStudyRoomsInput>
  }

  export type VideoItemUpdateWithoutStudyRoomsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutVideoItemNestedInput
    questions?: QuestionUpdateManyWithoutVideoItemNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoItemNestedInput
    playlist?: PlaylistUpdateOneRequiredWithoutVideoItemsNestedInput
    permissions?: VideoPermissionsUpdateOneWithoutVideoItemNestedInput
  }

  export type VideoItemUncheckedUpdateWithoutStudyRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    playlistId?: StringFieldUpdateOperationsInput | string
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutVideoItemNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutVideoItemNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoItemNestedInput
    permissions?: VideoPermissionsUncheckedUpdateOneWithoutVideoItemNestedInput
  }

  export type UserUpsertWithoutHostedStudyRoomsInput = {
    update: XOR<UserUpdateWithoutHostedStudyRoomsInput, UserUncheckedUpdateWithoutHostedStudyRoomsInput>
    create: XOR<UserCreateWithoutHostedStudyRoomsInput, UserUncheckedCreateWithoutHostedStudyRoomsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHostedStudyRoomsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHostedStudyRoomsInput, UserUncheckedUpdateWithoutHostedStudyRoomsInput>
  }

  export type UserUpdateWithoutHostedStudyRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHostedStudyRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudyRoomParticipantUpsertWithWhereUniqueWithoutStudyRoomInput = {
    where: StudyRoomParticipantWhereUniqueInput
    update: XOR<StudyRoomParticipantUpdateWithoutStudyRoomInput, StudyRoomParticipantUncheckedUpdateWithoutStudyRoomInput>
    create: XOR<StudyRoomParticipantCreateWithoutStudyRoomInput, StudyRoomParticipantUncheckedCreateWithoutStudyRoomInput>
  }

  export type StudyRoomParticipantUpdateWithWhereUniqueWithoutStudyRoomInput = {
    where: StudyRoomParticipantWhereUniqueInput
    data: XOR<StudyRoomParticipantUpdateWithoutStudyRoomInput, StudyRoomParticipantUncheckedUpdateWithoutStudyRoomInput>
  }

  export type StudyRoomParticipantUpdateManyWithWhereWithoutStudyRoomInput = {
    where: StudyRoomParticipantScalarWhereInput
    data: XOR<StudyRoomParticipantUpdateManyMutationInput, StudyRoomParticipantUncheckedUpdateManyWithoutStudyRoomInput>
  }

  export type StudyRoomMessageUpsertWithWhereUniqueWithoutStudyRoomInput = {
    where: StudyRoomMessageWhereUniqueInput
    update: XOR<StudyRoomMessageUpdateWithoutStudyRoomInput, StudyRoomMessageUncheckedUpdateWithoutStudyRoomInput>
    create: XOR<StudyRoomMessageCreateWithoutStudyRoomInput, StudyRoomMessageUncheckedCreateWithoutStudyRoomInput>
  }

  export type StudyRoomMessageUpdateWithWhereUniqueWithoutStudyRoomInput = {
    where: StudyRoomMessageWhereUniqueInput
    data: XOR<StudyRoomMessageUpdateWithoutStudyRoomInput, StudyRoomMessageUncheckedUpdateWithoutStudyRoomInput>
  }

  export type StudyRoomMessageUpdateManyWithWhereWithoutStudyRoomInput = {
    where: StudyRoomMessageScalarWhereInput
    data: XOR<StudyRoomMessageUpdateManyMutationInput, StudyRoomMessageUncheckedUpdateManyWithoutStudyRoomInput>
  }

  export type StudyRoomCreateWithoutParticipantsInput = {
    id?: string
    name: string
    description?: string | null
    maxParticipants?: number
    status?: $Enums.StudyRoomStatus
    currentTime?: number
    isPaused?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    video: VideoItemCreateNestedOneWithoutStudyRoomsInput
    host: UserCreateNestedOneWithoutHostedStudyRoomsInput
    messages?: StudyRoomMessageCreateNestedManyWithoutStudyRoomInput
  }

  export type StudyRoomUncheckedCreateWithoutParticipantsInput = {
    id?: string
    name: string
    description?: string | null
    videoId: number
    hostId: string
    maxParticipants?: number
    status?: $Enums.StudyRoomStatus
    currentTime?: number
    isPaused?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: StudyRoomMessageUncheckedCreateNestedManyWithoutStudyRoomInput
  }

  export type StudyRoomCreateOrConnectWithoutParticipantsInput = {
    where: StudyRoomWhereUniqueInput
    create: XOR<StudyRoomCreateWithoutParticipantsInput, StudyRoomUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutStudyRoomParticipantsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudyRoomParticipantsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudyRoomParticipantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudyRoomParticipantsInput, UserUncheckedCreateWithoutStudyRoomParticipantsInput>
  }

  export type StudyRoomUpsertWithoutParticipantsInput = {
    update: XOR<StudyRoomUpdateWithoutParticipantsInput, StudyRoomUncheckedUpdateWithoutParticipantsInput>
    create: XOR<StudyRoomCreateWithoutParticipantsInput, StudyRoomUncheckedCreateWithoutParticipantsInput>
    where?: StudyRoomWhereInput
  }

  export type StudyRoomUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: StudyRoomWhereInput
    data: XOR<StudyRoomUpdateWithoutParticipantsInput, StudyRoomUncheckedUpdateWithoutParticipantsInput>
  }

  export type StudyRoomUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    status?: EnumStudyRoomStatusFieldUpdateOperationsInput | $Enums.StudyRoomStatus
    currentTime?: FloatFieldUpdateOperationsInput | number
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoItemUpdateOneRequiredWithoutStudyRoomsNestedInput
    host?: UserUpdateOneRequiredWithoutHostedStudyRoomsNestedInput
    messages?: StudyRoomMessageUpdateManyWithoutStudyRoomNestedInput
  }

  export type StudyRoomUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoId?: IntFieldUpdateOperationsInput | number
    hostId?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    status?: EnumStudyRoomStatusFieldUpdateOperationsInput | $Enums.StudyRoomStatus
    currentTime?: FloatFieldUpdateOperationsInput | number
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: StudyRoomMessageUncheckedUpdateManyWithoutStudyRoomNestedInput
  }

  export type UserUpsertWithoutStudyRoomParticipantsInput = {
    update: XOR<UserUpdateWithoutStudyRoomParticipantsInput, UserUncheckedUpdateWithoutStudyRoomParticipantsInput>
    create: XOR<UserCreateWithoutStudyRoomParticipantsInput, UserUncheckedCreateWithoutStudyRoomParticipantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudyRoomParticipantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudyRoomParticipantsInput, UserUncheckedUpdateWithoutStudyRoomParticipantsInput>
  }

  export type UserUpdateWithoutStudyRoomParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudyRoomParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudyRoomCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    maxParticipants?: number
    status?: $Enums.StudyRoomStatus
    currentTime?: number
    isPaused?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    video: VideoItemCreateNestedOneWithoutStudyRoomsInput
    host: UserCreateNestedOneWithoutHostedStudyRoomsInput
    participants?: StudyRoomParticipantCreateNestedManyWithoutStudyRoomInput
  }

  export type StudyRoomUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    description?: string | null
    videoId: number
    hostId: string
    maxParticipants?: number
    status?: $Enums.StudyRoomStatus
    currentTime?: number
    isPaused?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutStudyRoomInput
  }

  export type StudyRoomCreateOrConnectWithoutMessagesInput = {
    where: StudyRoomWhereUniqueInput
    create: XOR<StudyRoomCreateWithoutMessagesInput, StudyRoomUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentChatMessagesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentChatMessagesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentChatMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentChatMessagesInput, UserUncheckedCreateWithoutSentChatMessagesInput>
  }

  export type StudyRoomUpsertWithoutMessagesInput = {
    update: XOR<StudyRoomUpdateWithoutMessagesInput, StudyRoomUncheckedUpdateWithoutMessagesInput>
    create: XOR<StudyRoomCreateWithoutMessagesInput, StudyRoomUncheckedCreateWithoutMessagesInput>
    where?: StudyRoomWhereInput
  }

  export type StudyRoomUpdateToOneWithWhereWithoutMessagesInput = {
    where?: StudyRoomWhereInput
    data: XOR<StudyRoomUpdateWithoutMessagesInput, StudyRoomUncheckedUpdateWithoutMessagesInput>
  }

  export type StudyRoomUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    status?: EnumStudyRoomStatusFieldUpdateOperationsInput | $Enums.StudyRoomStatus
    currentTime?: FloatFieldUpdateOperationsInput | number
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoItemUpdateOneRequiredWithoutStudyRoomsNestedInput
    host?: UserUpdateOneRequiredWithoutHostedStudyRoomsNestedInput
    participants?: StudyRoomParticipantUpdateManyWithoutStudyRoomNestedInput
  }

  export type StudyRoomUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoId?: IntFieldUpdateOperationsInput | number
    hostId?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    status?: EnumStudyRoomStatusFieldUpdateOperationsInput | $Enums.StudyRoomStatus
    currentTime?: FloatFieldUpdateOperationsInput | number
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: StudyRoomParticipantUncheckedUpdateManyWithoutStudyRoomNestedInput
  }

  export type UserUpsertWithoutSentChatMessagesInput = {
    update: XOR<UserUpdateWithoutSentChatMessagesInput, UserUncheckedUpdateWithoutSentChatMessagesInput>
    create: XOR<UserCreateWithoutSentChatMessagesInput, UserUncheckedCreateWithoutSentChatMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentChatMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentChatMessagesInput, UserUncheckedUpdateWithoutSentChatMessagesInput>
  }

  export type UserUpdateWithoutSentChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFeedbackReportsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedbackReportsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedbackReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbackReportsInput, UserUncheckedCreateWithoutFeedbackReportsInput>
  }

  export type UserCreateWithoutAdminFeedbackResponsesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminFeedbackResponsesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminFeedbackResponsesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminFeedbackResponsesInput, UserUncheckedCreateWithoutAdminFeedbackResponsesInput>
  }

  export type UserUpsertWithoutFeedbackReportsInput = {
    update: XOR<UserUpdateWithoutFeedbackReportsInput, UserUncheckedUpdateWithoutFeedbackReportsInput>
    create: XOR<UserCreateWithoutFeedbackReportsInput, UserUncheckedCreateWithoutFeedbackReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbackReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbackReportsInput, UserUncheckedUpdateWithoutFeedbackReportsInput>
  }

  export type UserUpdateWithoutFeedbackReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbackReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutAdminFeedbackResponsesInput = {
    update: XOR<UserUpdateWithoutAdminFeedbackResponsesInput, UserUncheckedUpdateWithoutAdminFeedbackResponsesInput>
    create: XOR<UserCreateWithoutAdminFeedbackResponsesInput, UserUncheckedCreateWithoutAdminFeedbackResponsesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminFeedbackResponsesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminFeedbackResponsesInput, UserUncheckedUpdateWithoutAdminFeedbackResponsesInput>
  }

  export type UserUpdateWithoutAdminFeedbackResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminFeedbackResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MarketplaceItemCreateWithoutReviewsInput = {
    id?: string
    name: string
    description?: string | null
    fullDescription?: string | null
    itemType?: $Enums.MarketplaceItemType
    price?: number
    priceToins?: number
    currency?: $Enums.Currency
    category?: string | null
    tags?: MarketplaceItemCreatetagsInput | string[]
    images?: MarketplaceItemCreateimagesInput | string[]
    stock?: number
    rating?: number
    reviewCount?: number
    location?: string | null
    status?: $Enums.MarketplaceItemStatus
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    viewCount?: number
    favoriteCount?: number
    metadata?: string | null
    seller: UserCreateNestedOneWithoutMarketplaceItemsInput
    matches?: MarketplaceMatchCreateNestedManyWithoutItemInput
  }

  export type MarketplaceItemUncheckedCreateWithoutReviewsInput = {
    id?: string
    name: string
    description?: string | null
    fullDescription?: string | null
    itemType?: $Enums.MarketplaceItemType
    price?: number
    priceToins?: number
    currency?: $Enums.Currency
    category?: string | null
    tags?: MarketplaceItemCreatetagsInput | string[]
    images?: MarketplaceItemCreateimagesInput | string[]
    stock?: number
    rating?: number
    reviewCount?: number
    location?: string | null
    status?: $Enums.MarketplaceItemStatus
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    viewCount?: number
    favoriteCount?: number
    sellerId: string
    metadata?: string | null
    matches?: MarketplaceMatchUncheckedCreateNestedManyWithoutItemInput
  }

  export type MarketplaceItemCreateOrConnectWithoutReviewsInput = {
    where: MarketplaceItemWhereUniqueInput
    create: XOR<MarketplaceItemCreateWithoutReviewsInput, MarketplaceItemUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type MarketplaceItemUpsertWithoutReviewsInput = {
    update: XOR<MarketplaceItemUpdateWithoutReviewsInput, MarketplaceItemUncheckedUpdateWithoutReviewsInput>
    create: XOR<MarketplaceItemCreateWithoutReviewsInput, MarketplaceItemUncheckedCreateWithoutReviewsInput>
    where?: MarketplaceItemWhereInput
  }

  export type MarketplaceItemUpdateToOneWithWhereWithoutReviewsInput = {
    where?: MarketplaceItemWhereInput
    data: XOR<MarketplaceItemUpdateWithoutReviewsInput, MarketplaceItemUncheckedUpdateWithoutReviewsInput>
  }

  export type MarketplaceItemUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumMarketplaceItemTypeFieldUpdateOperationsInput | $Enums.MarketplaceItemType
    price?: FloatFieldUpdateOperationsInput | number
    priceToins?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MarketplaceItemUpdatetagsInput | string[]
    images?: MarketplaceItemUpdateimagesInput | string[]
    stock?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMarketplaceItemStatusFieldUpdateOperationsInput | $Enums.MarketplaceItemStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    seller?: UserUpdateOneRequiredWithoutMarketplaceItemsNestedInput
    matches?: MarketplaceMatchUpdateManyWithoutItemNestedInput
  }

  export type MarketplaceItemUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumMarketplaceItemTypeFieldUpdateOperationsInput | $Enums.MarketplaceItemType
    price?: FloatFieldUpdateOperationsInput | number
    priceToins?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MarketplaceItemUpdatetagsInput | string[]
    images?: MarketplaceItemUpdateimagesInput | string[]
    stock?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMarketplaceItemStatusFieldUpdateOperationsInput | $Enums.MarketplaceItemStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    matches?: MarketplaceMatchUncheckedUpdateManyWithoutItemNestedInput
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type MarketplaceItemCreateWithoutMatchesInput = {
    id?: string
    name: string
    description?: string | null
    fullDescription?: string | null
    itemType?: $Enums.MarketplaceItemType
    price?: number
    priceToins?: number
    currency?: $Enums.Currency
    category?: string | null
    tags?: MarketplaceItemCreatetagsInput | string[]
    images?: MarketplaceItemCreateimagesInput | string[]
    stock?: number
    rating?: number
    reviewCount?: number
    location?: string | null
    status?: $Enums.MarketplaceItemStatus
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    viewCount?: number
    favoriteCount?: number
    metadata?: string | null
    seller: UserCreateNestedOneWithoutMarketplaceItemsInput
    reviews?: ReviewCreateNestedManyWithoutMarketplaceItemInput
  }

  export type MarketplaceItemUncheckedCreateWithoutMatchesInput = {
    id?: string
    name: string
    description?: string | null
    fullDescription?: string | null
    itemType?: $Enums.MarketplaceItemType
    price?: number
    priceToins?: number
    currency?: $Enums.Currency
    category?: string | null
    tags?: MarketplaceItemCreatetagsInput | string[]
    images?: MarketplaceItemCreateimagesInput | string[]
    stock?: number
    rating?: number
    reviewCount?: number
    location?: string | null
    status?: $Enums.MarketplaceItemStatus
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    viewCount?: number
    favoriteCount?: number
    sellerId: string
    metadata?: string | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutMarketplaceItemInput
  }

  export type MarketplaceItemCreateOrConnectWithoutMatchesInput = {
    where: MarketplaceItemWhereUniqueInput
    create: XOR<MarketplaceItemCreateWithoutMatchesInput, MarketplaceItemUncheckedCreateWithoutMatchesInput>
  }

  export type UserCreateWithoutBuyerMatchesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBuyerMatchesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBuyerMatchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBuyerMatchesInput, UserUncheckedCreateWithoutBuyerMatchesInput>
  }

  export type UserCreateWithoutSellerMatchesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    matchMessages?: MatchMessageCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSellerMatchesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    matchMessages?: MatchMessageUncheckedCreateNestedManyWithoutSenderInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSellerMatchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSellerMatchesInput, UserUncheckedCreateWithoutSellerMatchesInput>
  }

  export type MatchMessageCreateWithoutMatchInput = {
    id?: string
    content: string
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutMatchMessagesInput
  }

  export type MatchMessageUncheckedCreateWithoutMatchInput = {
    id?: string
    senderId: string
    content: string
    createdAt?: Date | string
  }

  export type MatchMessageCreateOrConnectWithoutMatchInput = {
    where: MatchMessageWhereUniqueInput
    create: XOR<MatchMessageCreateWithoutMatchInput, MatchMessageUncheckedCreateWithoutMatchInput>
  }

  export type MatchMessageCreateManyMatchInputEnvelope = {
    data: MatchMessageCreateManyMatchInput | MatchMessageCreateManyMatchInput[]
    skipDuplicates?: boolean
  }

  export type MarketplaceItemUpsertWithoutMatchesInput = {
    update: XOR<MarketplaceItemUpdateWithoutMatchesInput, MarketplaceItemUncheckedUpdateWithoutMatchesInput>
    create: XOR<MarketplaceItemCreateWithoutMatchesInput, MarketplaceItemUncheckedCreateWithoutMatchesInput>
    where?: MarketplaceItemWhereInput
  }

  export type MarketplaceItemUpdateToOneWithWhereWithoutMatchesInput = {
    where?: MarketplaceItemWhereInput
    data: XOR<MarketplaceItemUpdateWithoutMatchesInput, MarketplaceItemUncheckedUpdateWithoutMatchesInput>
  }

  export type MarketplaceItemUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumMarketplaceItemTypeFieldUpdateOperationsInput | $Enums.MarketplaceItemType
    price?: FloatFieldUpdateOperationsInput | number
    priceToins?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MarketplaceItemUpdatetagsInput | string[]
    images?: MarketplaceItemUpdateimagesInput | string[]
    stock?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMarketplaceItemStatusFieldUpdateOperationsInput | $Enums.MarketplaceItemStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    seller?: UserUpdateOneRequiredWithoutMarketplaceItemsNestedInput
    reviews?: ReviewUpdateManyWithoutMarketplaceItemNestedInput
  }

  export type MarketplaceItemUncheckedUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumMarketplaceItemTypeFieldUpdateOperationsInput | $Enums.MarketplaceItemType
    price?: FloatFieldUpdateOperationsInput | number
    priceToins?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MarketplaceItemUpdatetagsInput | string[]
    images?: MarketplaceItemUpdateimagesInput | string[]
    stock?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMarketplaceItemStatusFieldUpdateOperationsInput | $Enums.MarketplaceItemStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    sellerId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: ReviewUncheckedUpdateManyWithoutMarketplaceItemNestedInput
  }

  export type UserUpsertWithoutBuyerMatchesInput = {
    update: XOR<UserUpdateWithoutBuyerMatchesInput, UserUncheckedUpdateWithoutBuyerMatchesInput>
    create: XOR<UserCreateWithoutBuyerMatchesInput, UserUncheckedCreateWithoutBuyerMatchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBuyerMatchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBuyerMatchesInput, UserUncheckedUpdateWithoutBuyerMatchesInput>
  }

  export type UserUpdateWithoutBuyerMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBuyerMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutSellerMatchesInput = {
    update: XOR<UserUpdateWithoutSellerMatchesInput, UserUncheckedUpdateWithoutSellerMatchesInput>
    create: XOR<UserCreateWithoutSellerMatchesInput, UserUncheckedCreateWithoutSellerMatchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSellerMatchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSellerMatchesInput, UserUncheckedUpdateWithoutSellerMatchesInput>
  }

  export type UserUpdateWithoutSellerMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSellerMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MatchMessageUpsertWithWhereUniqueWithoutMatchInput = {
    where: MatchMessageWhereUniqueInput
    update: XOR<MatchMessageUpdateWithoutMatchInput, MatchMessageUncheckedUpdateWithoutMatchInput>
    create: XOR<MatchMessageCreateWithoutMatchInput, MatchMessageUncheckedCreateWithoutMatchInput>
  }

  export type MatchMessageUpdateWithWhereUniqueWithoutMatchInput = {
    where: MatchMessageWhereUniqueInput
    data: XOR<MatchMessageUpdateWithoutMatchInput, MatchMessageUncheckedUpdateWithoutMatchInput>
  }

  export type MatchMessageUpdateManyWithWhereWithoutMatchInput = {
    where: MatchMessageScalarWhereInput
    data: XOR<MatchMessageUpdateManyMutationInput, MatchMessageUncheckedUpdateManyWithoutMatchInput>
  }

  export type MarketplaceMatchCreateWithoutMessagesInput = {
    id?: string
    buyerConfirmed?: boolean
    sellerConfirmed?: boolean
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    item: MarketplaceItemCreateNestedOneWithoutMatchesInput
    buyer: UserCreateNestedOneWithoutBuyerMatchesInput
    seller: UserCreateNestedOneWithoutSellerMatchesInput
  }

  export type MarketplaceMatchUncheckedCreateWithoutMessagesInput = {
    id?: string
    itemId: string
    buyerId: string
    sellerId: string
    buyerConfirmed?: boolean
    sellerConfirmed?: boolean
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceMatchCreateOrConnectWithoutMessagesInput = {
    where: MarketplaceMatchWhereUniqueInput
    create: XOR<MarketplaceMatchCreateWithoutMessagesInput, MarketplaceMatchUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMatchMessagesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    createdActivities?: ActivityCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    likes?: LikeCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateCreateNestedManyWithoutCreatorInput
    merits?: MeritCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
    createdReports?: ReportCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionCreateNestedManyWithoutAssignedByInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeCreateNestedManyWithoutUserInput
    userGroups?: UserGroupCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageCreateNestedManyWithoutUserInput
    personality?: PersonalityCreateNestedOneWithoutUsersInput
    videoPermissions?: VideoPermissionsCreateNestedManyWithoutCreatedByInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    createdWorlds?: WorldCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchCreateNestedManyWithoutSellerInput
    feedbackReports?: FeedbackReportCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportCreateNestedManyWithoutAdminUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMatchMessagesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
    personalityId?: string | null
    createdActivities?: ActivityUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    likes?: LikeUncheckedCreateNestedManyWithoutUserInput
    createdExperiences?: ExperienceUncheckedCreateNestedManyWithoutCreatorInput
    invitationsSent?: GiftCardUncheckedCreateNestedManyWithoutInviterInput
    ownedGroups?: GroupUncheckedCreateNestedManyWithoutOwnerInput
    createdInvitationTemplates?: InvitationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    merits?: MeritUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
    createdReports?: ReportUncheckedCreateNestedManyWithoutCreatorInput
    assignedPermissions?: RolePermissionUncheckedCreateNestedManyWithoutAssignedByInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    transactionsTo?: TransactionUncheckedCreateNestedManyWithoutToUserInput
    transactionsFrom?: TransactionUncheckedCreateNestedManyWithoutFromUserInput
    createdTemplates?: UIComponentTemplateUncheckedCreateNestedManyWithoutCreatorInput
    userAnswers?: UserAnswerUncheckedCreateNestedManyWithoutUserInput
    userChallenges?: UserChallengeUncheckedCreateNestedManyWithoutUserInput
    userGroups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    invitationsReceived?: UserInvitationUncheckedCreateNestedManyWithoutInvitedUserInput
    assignedRoles?: UserRoleUncheckedCreateNestedManyWithoutAssignedByInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedStudyRooms?: StudyRoomUncheckedCreateNestedManyWithoutHostInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedCreateNestedManyWithoutUserInput
    sentChatMessages?: StudyRoomMessageUncheckedCreateNestedManyWithoutUserInput
    videoPermissions?: VideoPermissionsUncheckedCreateNestedManyWithoutCreatedByInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    createdWorlds?: WorldUncheckedCreateNestedManyWithoutCreatorInput
    marketplaceItems?: MarketplaceItemUncheckedCreateNestedManyWithoutSellerInput
    buyerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutBuyerInput
    sellerMatches?: MarketplaceMatchUncheckedCreateNestedManyWithoutSellerInput
    feedbackReports?: FeedbackReportUncheckedCreateNestedManyWithoutUserInput
    adminFeedbackResponses?: FeedbackReportUncheckedCreateNestedManyWithoutAdminUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMatchMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMatchMessagesInput, UserUncheckedCreateWithoutMatchMessagesInput>
  }

  export type MarketplaceMatchUpsertWithoutMessagesInput = {
    update: XOR<MarketplaceMatchUpdateWithoutMessagesInput, MarketplaceMatchUncheckedUpdateWithoutMessagesInput>
    create: XOR<MarketplaceMatchCreateWithoutMessagesInput, MarketplaceMatchUncheckedCreateWithoutMessagesInput>
    where?: MarketplaceMatchWhereInput
  }

  export type MarketplaceMatchUpdateToOneWithWhereWithoutMessagesInput = {
    where?: MarketplaceMatchWhereInput
    data: XOR<MarketplaceMatchUpdateWithoutMessagesInput, MarketplaceMatchUncheckedUpdateWithoutMessagesInput>
  }

  export type MarketplaceMatchUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    sellerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: MarketplaceItemUpdateOneRequiredWithoutMatchesNestedInput
    buyer?: UserUpdateOneRequiredWithoutBuyerMatchesNestedInput
    seller?: UserUpdateOneRequiredWithoutSellerMatchesNestedInput
  }

  export type MarketplaceMatchUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    sellerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMatchMessagesInput = {
    update: XOR<UserUpdateWithoutMatchMessagesInput, UserUncheckedUpdateWithoutMatchMessagesInput>
    create: XOR<UserCreateWithoutMatchMessagesInput, UserUncheckedCreateWithoutMatchMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMatchMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMatchMessagesInput, UserUncheckedUpdateWithoutMatchMessagesInput>
  }

  export type UserUpdateWithoutMatchMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    personality?: PersonalityUpdateOneWithoutUsersNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMatchMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    personalityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlaylistCreateManyMundoInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    orderInMundo?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: string | null
    version?: number
  }

  export type WorldCreateManyMundoInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    creatorId: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlaylistUpdateWithoutMundoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orderInMundo?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    contentItems?: ContentItemUpdateManyWithoutPlaylistNestedInput
    gamifiedPlaylists?: GamifiedPlaylistUpdateManyWithoutPlaylistNestedInput
    videoItems?: VideoItemUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistUncheckedUpdateWithoutMundoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orderInMundo?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    contentItems?: ContentItemUncheckedUpdateManyWithoutPlaylistNestedInput
    gamifiedPlaylists?: GamifiedPlaylistUncheckedUpdateManyWithoutPlaylistNestedInput
    videoItems?: VideoItemUncheckedUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistUncheckedUpdateManyWithoutMundoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    orderInMundo?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
  }

  export type WorldUpdateWithoutMundoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: StageUpdateManyWithoutWorldNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorldsNestedInput
  }

  export type WorldUncheckedUpdateWithoutMundoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: StageUncheckedUpdateManyWithoutWorldNestedInput
  }

  export type WorldUncheckedUpdateManyWithoutMundoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentItemCreateManyPlaylistInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GamifiedPlaylistCreateManyPlaylistInput = {
    id?: string
    activityId?: string | null
    name: string
    type: string
    sequenceType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoItemCreateManyPlaylistInput = {
    id?: number
    title: string
    description?: string | null
    content: string
    url?: string | null
    platform?: string
    externalId?: string | null
    itemTypeId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    duration?: number | null
    categories?: string | null
    language?: string | null
    quality?: string | null
    tags?: string | null
    thumbnailUrl?: string | null
  }

  export type ContentItemUpdateWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemType?: ItemTypeUpdateOneRequiredWithoutContentItemsNestedInput
  }

  export type ContentItemUncheckedUpdateWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentItemUncheckedUpdateManyWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GamifiedPlaylistUpdateWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sequenceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneWithoutGamifiedPlaylistsNestedInput
  }

  export type GamifiedPlaylistUncheckedUpdateWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sequenceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GamifiedPlaylistUncheckedUpdateManyWithoutPlaylistInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sequenceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoItemUpdateWithoutPlaylistInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUpdateManyWithoutVideoItemNestedInput
    questions?: QuestionUpdateManyWithoutVideoItemNestedInput
    subtitles?: SubtitleUpdateManyWithoutVideoItemNestedInput
    studyRooms?: StudyRoomUpdateManyWithoutVideoNestedInput
    permissions?: VideoPermissionsUpdateOneWithoutVideoItemNestedInput
  }

  export type VideoItemUncheckedUpdateWithoutPlaylistInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activities?: ActivityUncheckedUpdateManyWithoutVideoItemNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutVideoItemNestedInput
    subtitles?: SubtitleUncheckedUpdateManyWithoutVideoItemNestedInput
    studyRooms?: StudyRoomUncheckedUpdateManyWithoutVideoNestedInput
    permissions?: VideoPermissionsUncheckedUpdateOneWithoutVideoItemNestedInput
  }

  export type VideoItemUncheckedUpdateManyWithoutPlaylistInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    itemTypeId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    quality?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityCreateManyVideoItemInput = {
    id?: string
    experienceId: string
    title: string
    description?: string | null
    type: string
    multimediaType?: string | null
    contentUrl?: string | null
    duration?: number | null
    order?: number
    status?: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionCreateManyVideoItemInput = {
    id?: number
    timestamp: number
    type: string
    text: string
    languageCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    endTimestamp?: number | null
  }

  export type SubtitleCreateManyVideoItemInput = {
    id?: number
    languageCode: string
    format?: string
    content?: string | null
    contentUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudyRoomCreateManyVideoInput = {
    id?: string
    name: string
    description?: string | null
    hostId: string
    maxParticipants?: number
    status?: $Enums.StudyRoomStatus
    currentTime?: number
    isPaused?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateWithoutVideoItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    multimediaType?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedActivitiesNestedInput
    experience?: ExperienceUpdateOneRequiredWithoutActivitiesNestedInput
    questions?: ActivityQuestionUpdateManyWithoutActivityNestedInput
    gamifiedPlaylists?: GamifiedPlaylistUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutVideoItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    multimediaType?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ActivityQuestionUncheckedUpdateManyWithoutActivityNestedInput
    gamifiedPlaylists?: GamifiedPlaylistUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutVideoItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    multimediaType?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUpdateWithoutVideoItemInput = {
    timestamp?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    answerOptions?: AnswerOptionUpdateManyWithoutQuestionNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutVideoItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
    answerOptions?: AnswerOptionUncheckedUpdateManyWithoutQuestionNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateManyWithoutVideoItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endTimestamp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubtitleUpdateWithoutVideoItemInput = {
    languageCode?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtitleUncheckedUpdateWithoutVideoItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    languageCode?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtitleUncheckedUpdateManyWithoutVideoItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    languageCode?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyRoomUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    status?: EnumStudyRoomStatusFieldUpdateOperationsInput | $Enums.StudyRoomStatus
    currentTime?: FloatFieldUpdateOperationsInput | number
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    host?: UserUpdateOneRequiredWithoutHostedStudyRoomsNestedInput
    participants?: StudyRoomParticipantUpdateManyWithoutStudyRoomNestedInput
    messages?: StudyRoomMessageUpdateManyWithoutStudyRoomNestedInput
  }

  export type StudyRoomUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hostId?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    status?: EnumStudyRoomStatusFieldUpdateOperationsInput | $Enums.StudyRoomStatus
    currentTime?: FloatFieldUpdateOperationsInput | number
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: StudyRoomParticipantUncheckedUpdateManyWithoutStudyRoomNestedInput
    messages?: StudyRoomMessageUncheckedUpdateManyWithoutStudyRoomNestedInput
  }

  export type StudyRoomUncheckedUpdateManyWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    hostId?: StringFieldUpdateOperationsInput | string
    maxParticipants?: IntFieldUpdateOperationsInput | number
    status?: EnumStudyRoomStatusFieldUpdateOperationsInput | $Enums.StudyRoomStatus
    currentTime?: FloatFieldUpdateOperationsInput | number
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerOptionCreateManyQuestionInput = {
    id?: number
    text: string
    isCorrect?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAnswerCreateManyQuestionInput = {
    id?: string
    userId: string
    activityQuestionId?: string | null
    answerGiven: string
    isCorrect?: boolean | null
    ondasEarned?: number
    createdAt?: Date | string
  }

  export type AnswerOptionUpdateWithoutQuestionInput = {
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerOptionUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerOptionUncheckedUpdateManyWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnswerUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerGiven?: StringFieldUpdateOperationsInput | string
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ondasEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityQuestion?: ActivityQuestionUpdateOneWithoutUserAnswersNestedInput
    user?: UserUpdateOneRequiredWithoutUserAnswersNestedInput
  }

  export type UserAnswerUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    activityQuestionId?: NullableStringFieldUpdateOperationsInput | string | null
    answerGiven?: StringFieldUpdateOperationsInput | string
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ondasEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    activityQuestionId?: NullableStringFieldUpdateOperationsInput | string | null
    answerGiven?: StringFieldUpdateOperationsInput | string
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ondasEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyCreatorInput = {
    id?: string
    experienceId: string
    title: string
    description?: string | null
    type: string
    multimediaType?: string | null
    contentUrl?: string | null
    duration?: number | null
    order?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoItemId?: number | null
  }

  export type CommentCreateManyUserInput = {
    id?: string
    publicationId?: string | null
    activityId?: string | null
    text: string
    createdAt?: Date | string
  }

  export type LikeCreateManyUserInput = {
    id?: string
    publicationId: string
    createdAt?: Date | string
  }

  export type ExperienceCreateManyCreatorInput = {
    id?: string
    stageId: string
    title: string
    description?: string | null
    type: string
    gamificationFramework?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GiftCardCreateManyInviterInput = {
    id?: string
    invitedName: string
    invitedEmail: string
    token: string
    unitsAmount: number
    suggestions?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type GroupCreateManyOwnerInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationTemplateCreateManyCreatorInput = {
    id?: string
    name: string
    content: string
    createdAt?: Date | string
  }

  export type MeritCreateManyUserInput = {
    id?: string
    amount: number
    type: string
    source: string
    relatedEntityId?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type PublicationCreateManyUserInput = {
    id?: string
    content: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateManyCreatorInput = {
    id?: string
    name: string
    type: string
    parameters?: string | null
    generatedAt?: Date | string
    data: string
  }

  export type RolePermissionCreateManyAssignedByInput = {
    roleId: string
    permissionId: string
    assignedAt?: Date | string
  }

  export type TokenCreateManyUserInput = {
    id?: string
    amount: number
    type: string
    status?: string
    caducityDate?: Date | string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyToUserInput = {
    id?: string
    fromUserId?: string | null
    amount: number
    tokenType: string
    type: string
    status?: string
    description?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateManyFromUserInput = {
    id?: string
    toUserId: string
    amount: number
    tokenType: string
    type: string
    status?: string
    description?: string | null
    createdAt?: Date | string
  }

  export type UIComponentTemplateCreateManyCreatorInput = {
    id?: string
    name: string
    type: string
    templateJson: string
    createdAt?: Date | string
  }

  export type UserAnswerCreateManyUserInput = {
    id?: string
    questionId?: number | null
    activityQuestionId?: string | null
    answerGiven: string
    isCorrect?: boolean | null
    ondasEarned?: number
    createdAt?: Date | string
  }

  export type UserChallengeCreateManyUserInput = {
    id?: string
    challengeId: string
    status?: string
    progress?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: string | null
  }

  export type UserGroupCreateManyUserInput = {
    groupId: string
    roleInGroup?: string
    joinedAt?: Date | string
  }

  export type UserInvitationCreateManyInvitedUserInput = {
    id?: string
    giftCardId: string
    status?: string
    createdAt?: Date | string
  }

  export type UserRoleCreateManyAssignedByInput = {
    userId: string
    roleId: string
    assignedAt?: Date | string
  }

  export type UserRoleCreateManyUserInput = {
    roleId: string
    assignedAt?: Date | string
    assignedById?: string | null
  }

  export type StudyRoomCreateManyHostInput = {
    id?: string
    name: string
    description?: string | null
    videoId: number
    maxParticipants?: number
    status?: $Enums.StudyRoomStatus
    currentTime?: number
    isPaused?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudyRoomParticipantCreateManyUserInput = {
    id?: string
    studyRoomId: string
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isActive?: boolean
  }

  export type StudyRoomMessageCreateManyUserInput = {
    id?: string
    studyRoomId: string
    message: string
    messageType?: string
    metadata?: string | null
    createdAt?: Date | string
  }

  export type VideoPermissionsCreateManyCreatedByInput = {
    id?: string
    videoItemId: number
    showWaveCount?: boolean
    showVideos?: boolean
    showVideoSubtitles?: boolean
    showComments?: boolean
    showPublishDate?: boolean
    showVideoDuration?: boolean
    showLikeButton?: boolean
    allowRewindForward?: boolean
    allowViewComments?: boolean
    allowMakeComments?: boolean
    showLikeComments?: boolean
    sortCommentsByAffinity?: boolean
    showCommenterName?: boolean
    playlistPosition?: string
    isDraft?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorldCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mundoId?: string | null
  }

  export type MarketplaceItemCreateManySellerInput = {
    id?: string
    name: string
    description?: string | null
    fullDescription?: string | null
    itemType?: $Enums.MarketplaceItemType
    price?: number
    priceToins?: number
    currency?: $Enums.Currency
    category?: string | null
    tags?: MarketplaceItemCreatetagsInput | string[]
    images?: MarketplaceItemCreateimagesInput | string[]
    stock?: number
    rating?: number
    reviewCount?: number
    location?: string | null
    status?: $Enums.MarketplaceItemStatus
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    viewCount?: number
    favoriteCount?: number
    metadata?: string | null
  }

  export type MarketplaceMatchCreateManyBuyerInput = {
    id?: string
    itemId: string
    sellerId: string
    buyerConfirmed?: boolean
    sellerConfirmed?: boolean
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceMatchCreateManySellerInput = {
    id?: string
    itemId: string
    buyerId: string
    buyerConfirmed?: boolean
    sellerConfirmed?: boolean
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchMessageCreateManySenderInput = {
    id?: string
    matchId: string
    content: string
    createdAt?: Date | string
  }

  export type FeedbackReportCreateManyUserInput = {
    id?: string
    type: $Enums.FeedbackType
    title: string
    description: string
    priority?: $Enums.FeedbackPriority
    category: string
    status?: $Enums.FeedbackStatus
    elementContext: JsonNullValueInput | InputJsonValue
    technicalContext: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: string | null
    adminUserId?: string | null
    resolvedAt?: Date | string | null
    upvotes?: number
    downvotes?: number
    duplicateOf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedbackReportCreateManyAdminUserInput = {
    id?: string
    userId: string
    type: $Enums.FeedbackType
    title: string
    description: string
    priority?: $Enums.FeedbackPriority
    category: string
    status?: $Enums.FeedbackStatus
    elementContext: JsonNullValueInput | InputJsonValue
    technicalContext: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: string | null
    resolvedAt?: Date | string | null
    upvotes?: number
    downvotes?: number
    duplicateOf?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    marketplaceItemId: string
    rating: number
    comment?: string | null
    communication?: number | null
    quality?: number | null
    delivery?: number | null
    value?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    multimediaType?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoItem?: VideoItemUpdateOneWithoutActivitiesNestedInput
    experience?: ExperienceUpdateOneRequiredWithoutActivitiesNestedInput
    questions?: ActivityQuestionUpdateManyWithoutActivityNestedInput
    gamifiedPlaylists?: GamifiedPlaylistUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    multimediaType?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoItemId?: NullableIntFieldUpdateOperationsInput | number | null
    questions?: ActivityQuestionUncheckedUpdateManyWithoutActivityNestedInput
    gamifiedPlaylists?: GamifiedPlaylistUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    experienceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    multimediaType?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoItemId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publication?: PublicationUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationId?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationId?: NullableStringFieldUpdateOperationsInput | string | null
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publication?: PublicationUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    publicationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    gamificationFramework?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutExperienceNestedInput
    stage?: StageUpdateOneRequiredWithoutExperiencesNestedInput
  }

  export type ExperienceUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    gamificationFramework?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutExperienceNestedInput
  }

  export type ExperienceUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    gamificationFramework?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GiftCardUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitedName?: StringFieldUpdateOperationsInput | string
    invitedEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    unitsAmount?: FloatFieldUpdateOperationsInput | number
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userInvitations?: UserInvitationUpdateManyWithoutGiftCardNestedInput
  }

  export type GiftCardUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitedName?: StringFieldUpdateOperationsInput | string
    invitedEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    unitsAmount?: FloatFieldUpdateOperationsInput | number
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userInvitations?: UserInvitationUncheckedUpdateManyWithoutGiftCardNestedInput
  }

  export type GiftCardUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitedName?: StringFieldUpdateOperationsInput | string
    invitedEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    unitsAmount?: FloatFieldUpdateOperationsInput | number
    suggestions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userGroups?: UserGroupUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userGroups?: UserGroupUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationTemplateUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationTemplateUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationTemplateUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeritUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeritUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeritUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    relatedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPublicationNestedInput
    likes?: LikeUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPublicationNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
  }

  export type ReportUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
  }

  export type ReportUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionUpdateWithoutAssignedByInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
    role?: RoleUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutAssignedByInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutAssignedByInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    caducityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    caducityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    caducityDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tokenType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toWallet?: WalletUpdateOneRequiredWithoutTransactionsToNestedInput
    fromWallet?: WalletUpdateOneWithoutTransactionsFromNestedInput
    fromUser?: UserUpdateOneWithoutTransactionsFromNestedInput
  }

  export type TransactionUncheckedUpdateWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tokenType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tokenType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tokenType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toWallet?: WalletUpdateOneRequiredWithoutTransactionsToNestedInput
    fromWallet?: WalletUpdateOneWithoutTransactionsFromNestedInput
    toUser?: UserUpdateOneRequiredWithoutTransactionsToNestedInput
  }

  export type TransactionUncheckedUpdateWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tokenType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutFromUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tokenType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UIComponentTemplateUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    templateJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UIComponentTemplateUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    templateJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UIComponentTemplateUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    templateJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnswerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerGiven?: StringFieldUpdateOperationsInput | string
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ondasEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityQuestion?: ActivityQuestionUpdateOneWithoutUserAnswersNestedInput
    question?: QuestionUpdateOneWithoutUserAnswersNestedInput
  }

  export type UserAnswerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    activityQuestionId?: NullableStringFieldUpdateOperationsInput | string | null
    answerGiven?: StringFieldUpdateOperationsInput | string
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ondasEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnswerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    activityQuestionId?: NullableStringFieldUpdateOperationsInput | string | null
    answerGiven?: StringFieldUpdateOperationsInput | string
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ondasEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserChallengeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    challenge?: ChallengeUpdateOneRequiredWithoutUserChallengesNestedInput
  }

  export type UserChallengeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserChallengeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserGroupUpdateWithoutUserInput = {
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneRequiredWithoutUserGroupsNestedInput
  }

  export type UserGroupUncheckedUpdateWithoutUserInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupUncheckedUpdateManyWithoutUserInput = {
    groupId?: StringFieldUpdateOperationsInput | string
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationUpdateWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    giftCard?: GiftCardUpdateOneRequiredWithoutUserInvitationsNestedInput
  }

  export type UserInvitationUncheckedUpdateWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    giftCardId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationUncheckedUpdateManyWithoutInvitedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    giftCardId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutAssignedByInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutAssignedByInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutAssignedByInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutUserInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: UserUpdateOneWithoutAssignedRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudyRoomUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    status?: EnumStudyRoomStatusFieldUpdateOperationsInput | $Enums.StudyRoomStatus
    currentTime?: FloatFieldUpdateOperationsInput | number
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    video?: VideoItemUpdateOneRequiredWithoutStudyRoomsNestedInput
    participants?: StudyRoomParticipantUpdateManyWithoutStudyRoomNestedInput
    messages?: StudyRoomMessageUpdateManyWithoutStudyRoomNestedInput
  }

  export type StudyRoomUncheckedUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoId?: IntFieldUpdateOperationsInput | number
    maxParticipants?: IntFieldUpdateOperationsInput | number
    status?: EnumStudyRoomStatusFieldUpdateOperationsInput | $Enums.StudyRoomStatus
    currentTime?: FloatFieldUpdateOperationsInput | number
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: StudyRoomParticipantUncheckedUpdateManyWithoutStudyRoomNestedInput
    messages?: StudyRoomMessageUncheckedUpdateManyWithoutStudyRoomNestedInput
  }

  export type StudyRoomUncheckedUpdateManyWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    videoId?: IntFieldUpdateOperationsInput | number
    maxParticipants?: IntFieldUpdateOperationsInput | number
    status?: EnumStudyRoomStatusFieldUpdateOperationsInput | $Enums.StudyRoomStatus
    currentTime?: FloatFieldUpdateOperationsInput | number
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyRoomParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    studyRoom?: StudyRoomUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type StudyRoomParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyRoomId?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudyRoomParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyRoomId?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudyRoomMessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyRoom?: StudyRoomUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type StudyRoomMessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyRoomId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyRoomMessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyRoomId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoPermissionsUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    showWaveCount?: BoolFieldUpdateOperationsInput | boolean
    showVideos?: BoolFieldUpdateOperationsInput | boolean
    showVideoSubtitles?: BoolFieldUpdateOperationsInput | boolean
    showComments?: BoolFieldUpdateOperationsInput | boolean
    showPublishDate?: BoolFieldUpdateOperationsInput | boolean
    showVideoDuration?: BoolFieldUpdateOperationsInput | boolean
    showLikeButton?: BoolFieldUpdateOperationsInput | boolean
    allowRewindForward?: BoolFieldUpdateOperationsInput | boolean
    allowViewComments?: BoolFieldUpdateOperationsInput | boolean
    allowMakeComments?: BoolFieldUpdateOperationsInput | boolean
    showLikeComments?: BoolFieldUpdateOperationsInput | boolean
    sortCommentsByAffinity?: BoolFieldUpdateOperationsInput | boolean
    showCommenterName?: BoolFieldUpdateOperationsInput | boolean
    playlistPosition?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoItem?: VideoItemUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type VideoPermissionsUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoItemId?: IntFieldUpdateOperationsInput | number
    showWaveCount?: BoolFieldUpdateOperationsInput | boolean
    showVideos?: BoolFieldUpdateOperationsInput | boolean
    showVideoSubtitles?: BoolFieldUpdateOperationsInput | boolean
    showComments?: BoolFieldUpdateOperationsInput | boolean
    showPublishDate?: BoolFieldUpdateOperationsInput | boolean
    showVideoDuration?: BoolFieldUpdateOperationsInput | boolean
    showLikeButton?: BoolFieldUpdateOperationsInput | boolean
    allowRewindForward?: BoolFieldUpdateOperationsInput | boolean
    allowViewComments?: BoolFieldUpdateOperationsInput | boolean
    allowMakeComments?: BoolFieldUpdateOperationsInput | boolean
    showLikeComments?: BoolFieldUpdateOperationsInput | boolean
    sortCommentsByAffinity?: BoolFieldUpdateOperationsInput | boolean
    showCommenterName?: BoolFieldUpdateOperationsInput | boolean
    playlistPosition?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoPermissionsUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoItemId?: IntFieldUpdateOperationsInput | number
    showWaveCount?: BoolFieldUpdateOperationsInput | boolean
    showVideos?: BoolFieldUpdateOperationsInput | boolean
    showVideoSubtitles?: BoolFieldUpdateOperationsInput | boolean
    showComments?: BoolFieldUpdateOperationsInput | boolean
    showPublishDate?: BoolFieldUpdateOperationsInput | boolean
    showVideoDuration?: BoolFieldUpdateOperationsInput | boolean
    showLikeButton?: BoolFieldUpdateOperationsInput | boolean
    allowRewindForward?: BoolFieldUpdateOperationsInput | boolean
    allowViewComments?: BoolFieldUpdateOperationsInput | boolean
    allowMakeComments?: BoolFieldUpdateOperationsInput | boolean
    showLikeComments?: BoolFieldUpdateOperationsInput | boolean
    sortCommentsByAffinity?: BoolFieldUpdateOperationsInput | boolean
    showCommenterName?: BoolFieldUpdateOperationsInput | boolean
    playlistPosition?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorldUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: StageUpdateManyWithoutWorldNestedInput
    mundo?: MundoUpdateOneWithoutWorldsNestedInput
  }

  export type WorldUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mundoId?: NullableStringFieldUpdateOperationsInput | string | null
    stages?: StageUncheckedUpdateManyWithoutWorldNestedInput
  }

  export type WorldUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mundoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarketplaceItemUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumMarketplaceItemTypeFieldUpdateOperationsInput | $Enums.MarketplaceItemType
    price?: FloatFieldUpdateOperationsInput | number
    priceToins?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MarketplaceItemUpdatetagsInput | string[]
    images?: MarketplaceItemUpdateimagesInput | string[]
    stock?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMarketplaceItemStatusFieldUpdateOperationsInput | $Enums.MarketplaceItemStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: ReviewUpdateManyWithoutMarketplaceItemNestedInput
    matches?: MarketplaceMatchUpdateManyWithoutItemNestedInput
  }

  export type MarketplaceItemUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumMarketplaceItemTypeFieldUpdateOperationsInput | $Enums.MarketplaceItemType
    price?: FloatFieldUpdateOperationsInput | number
    priceToins?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MarketplaceItemUpdatetagsInput | string[]
    images?: MarketplaceItemUpdateimagesInput | string[]
    stock?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMarketplaceItemStatusFieldUpdateOperationsInput | $Enums.MarketplaceItemStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: ReviewUncheckedUpdateManyWithoutMarketplaceItemNestedInput
    matches?: MarketplaceMatchUncheckedUpdateManyWithoutItemNestedInput
  }

  export type MarketplaceItemUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fullDescription?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: EnumMarketplaceItemTypeFieldUpdateOperationsInput | $Enums.MarketplaceItemType
    price?: FloatFieldUpdateOperationsInput | number
    priceToins?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyFieldUpdateOperationsInput | $Enums.Currency
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: MarketplaceItemUpdatetagsInput | string[]
    images?: MarketplaceItemUpdateimagesInput | string[]
    stock?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMarketplaceItemStatusFieldUpdateOperationsInput | $Enums.MarketplaceItemStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarketplaceMatchUpdateWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    sellerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: MarketplaceItemUpdateOneRequiredWithoutMatchesNestedInput
    seller?: UserUpdateOneRequiredWithoutSellerMatchesNestedInput
    messages?: MatchMessageUpdateManyWithoutMatchNestedInput
  }

  export type MarketplaceMatchUncheckedUpdateWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    sellerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MatchMessageUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MarketplaceMatchUncheckedUpdateManyWithoutBuyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    sellerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceMatchUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    sellerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: MarketplaceItemUpdateOneRequiredWithoutMatchesNestedInput
    buyer?: UserUpdateOneRequiredWithoutBuyerMatchesNestedInput
    messages?: MatchMessageUpdateManyWithoutMatchNestedInput
  }

  export type MarketplaceMatchUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    buyerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    sellerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MatchMessageUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MarketplaceMatchUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    buyerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    sellerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    match?: MarketplaceMatchUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MatchMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackReportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    elementContext?: JsonNullValueInput | InputJsonValue
    technicalContext?: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    duplicateOf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminUser?: UserUpdateOneWithoutAdminFeedbackResponsesNestedInput
  }

  export type FeedbackReportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    elementContext?: JsonNullValueInput | InputJsonValue
    technicalContext?: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    duplicateOf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackReportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    elementContext?: JsonNullValueInput | InputJsonValue
    technicalContext?: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    duplicateOf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackReportUpdateWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    elementContext?: JsonNullValueInput | InputJsonValue
    technicalContext?: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    duplicateOf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedbackReportsNestedInput
  }

  export type FeedbackReportUncheckedUpdateWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    elementContext?: JsonNullValueInput | InputJsonValue
    technicalContext?: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    duplicateOf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackReportUncheckedUpdateManyWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumFeedbackPriorityFieldUpdateOperationsInput | $Enums.FeedbackPriority
    category?: StringFieldUpdateOperationsInput | string
    status?: EnumFeedbackStatusFieldUpdateOperationsInput | $Enums.FeedbackStatus
    elementContext?: JsonNullValueInput | InputJsonValue
    technicalContext?: JsonNullValueInput | InputJsonValue
    codeAnalysis?: NullableJsonNullValueInput | InputJsonValue
    aiSuggestions?: NullableJsonNullValueInput | InputJsonValue
    adminResponse?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    duplicateOf?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    delivery?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplaceItem?: MarketplaceItemUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketplaceItemId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    delivery?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketplaceItemId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    delivery?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyRoleInput = {
    permissionId: string
    assignedAt?: Date | string
    assignedById?: string | null
  }

  export type UserRoleCreateManyRoleInput = {
    userId: string
    assignedAt?: Date | string
    assignedById?: string | null
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: UserUpdateOneWithoutAssignedPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    permissionId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    permissionId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleUpdateWithoutRoleInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: UserUpdateOneWithoutAssignedRolesNestedInput
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionCreateManyPermissionInput = {
    roleId: string
    assignedAt?: Date | string
    assignedById?: string | null
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: UserUpdateOneWithoutAssignedPermissionsNestedInput
    role?: RoleUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StageCreateManyWorldInput = {
    id?: string
    name: string
    order: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageUpdateWithoutWorldInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUpdateManyWithoutStageNestedInput
  }

  export type StageUncheckedUpdateWithoutWorldInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    experiences?: ExperienceUncheckedUpdateManyWithoutStageNestedInput
  }

  export type StageUncheckedUpdateManyWithoutWorldInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExperienceCreateManyStageInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    gamificationFramework?: string | null
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExperienceUpdateWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    gamificationFramework?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUpdateManyWithoutExperienceNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedExperiencesNestedInput
  }

  export type ExperienceUncheckedUpdateWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    gamificationFramework?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutExperienceNestedInput
  }

  export type ExperienceUncheckedUpdateManyWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    gamificationFramework?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyExperienceInput = {
    id?: string
    title: string
    description?: string | null
    type: string
    multimediaType?: string | null
    contentUrl?: string | null
    duration?: number | null
    order?: number
    status?: string
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoItemId?: number | null
  }

  export type ActivityUpdateWithoutExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    multimediaType?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoItem?: VideoItemUpdateOneWithoutActivitiesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedActivitiesNestedInput
    questions?: ActivityQuestionUpdateManyWithoutActivityNestedInput
    gamifiedPlaylists?: GamifiedPlaylistUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    multimediaType?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoItemId?: NullableIntFieldUpdateOperationsInput | number | null
    questions?: ActivityQuestionUncheckedUpdateManyWithoutActivityNestedInput
    gamifiedPlaylists?: GamifiedPlaylistUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    multimediaType?: NullableStringFieldUpdateOperationsInput | string | null
    contentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoItemId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityQuestionCreateManyActivityInput = {
    id?: string
    type: string
    questionType: string
    questionText: string
    options?: string | null
    correctAnswer?: string | null
    ondasList?: string | null
    displayTimeSeconds?: number | null
    optionalDisplaySeconds?: number | null
    createdAt?: Date | string
  }

  export type GamifiedPlaylistCreateManyActivityInput = {
    id?: string
    playlistId?: string | null
    name: string
    type: string
    sequenceType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityQuestionUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    ondasList?: NullableStringFieldUpdateOperationsInput | string | null
    displayTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    optionalDisplaySeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAnswers?: UserAnswerUpdateManyWithoutActivityQuestionNestedInput
  }

  export type ActivityQuestionUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    ondasList?: NullableStringFieldUpdateOperationsInput | string | null
    displayTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    optionalDisplaySeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutActivityQuestionNestedInput
  }

  export type ActivityQuestionUncheckedUpdateManyWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswer?: NullableStringFieldUpdateOperationsInput | string | null
    ondasList?: NullableStringFieldUpdateOperationsInput | string | null
    displayTimeSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    optionalDisplaySeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GamifiedPlaylistUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sequenceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playlist?: PlaylistUpdateOneWithoutGamifiedPlaylistsNestedInput
  }

  export type GamifiedPlaylistUncheckedUpdateWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    playlistId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sequenceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GamifiedPlaylistUncheckedUpdateManyWithoutActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    playlistId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    sequenceType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnswerCreateManyActivityQuestionInput = {
    id?: string
    userId: string
    questionId?: number | null
    answerGiven: string
    isCorrect?: boolean | null
    ondasEarned?: number
    createdAt?: Date | string
  }

  export type UserAnswerUpdateWithoutActivityQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerGiven?: StringFieldUpdateOperationsInput | string
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ondasEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneWithoutUserAnswersNestedInput
    user?: UserUpdateOneRequiredWithoutUserAnswersNestedInput
  }

  export type UserAnswerUncheckedUpdateWithoutActivityQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    answerGiven?: StringFieldUpdateOperationsInput | string
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ondasEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAnswerUncheckedUpdateManyWithoutActivityQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: NullableIntFieldUpdateOperationsInput | number | null
    answerGiven?: StringFieldUpdateOperationsInput | string
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ondasEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyToWalletInput = {
    id?: string
    fromUserId?: string | null
    amount: number
    tokenType: string
    type: string
    status?: string
    description?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateManyFromWalletInput = {
    id?: string
    toUserId: string
    amount: number
    tokenType: string
    type: string
    status?: string
    description?: string | null
    createdAt?: Date | string
  }

  export type TransactionUpdateWithoutToWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tokenType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromWallet?: WalletUpdateOneWithoutTransactionsFromNestedInput
    toUser?: UserUpdateOneRequiredWithoutTransactionsToNestedInput
    fromUser?: UserUpdateOneWithoutTransactionsFromNestedInput
  }

  export type TransactionUncheckedUpdateWithoutToWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tokenType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutToWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromUserId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tokenType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutFromWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tokenType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toWallet?: WalletUpdateOneRequiredWithoutTransactionsToNestedInput
    toUser?: UserUpdateOneRequiredWithoutTransactionsToNestedInput
    fromUser?: UserUpdateOneWithoutTransactionsFromNestedInput
  }

  export type TransactionUncheckedUpdateWithoutFromWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tokenType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutFromWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tokenType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupCreateManyGroupInput = {
    userId: string
    roleInGroup?: string
    joinedAt?: Date | string
  }

  export type UserGroupUpdateWithoutGroupInput = {
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserGroupsNestedInput
  }

  export type UserGroupUncheckedUpdateWithoutGroupInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupUncheckedUpdateManyWithoutGroupInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleInGroup?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyPublicationInput = {
    id?: string
    userId: string
    activityId?: string | null
    text: string
    createdAt?: Date | string
  }

  export type LikeCreateManyPublicationInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type CommentUpdateWithoutPublicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutPublicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutPublicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutPublicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutPublicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutPublicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationCreateManyGiftCardInput = {
    id?: string
    invitedUserId?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type UserInvitationUpdateWithoutGiftCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedUser?: UserUpdateOneWithoutInvitationsReceivedNestedInput
  }

  export type UserInvitationUncheckedUpdateWithoutGiftCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationUncheckedUpdateManyWithoutGiftCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    invitedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyPersonalityInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    documentType?: string | null
    documentNumber?: string | null
    phone?: string | null
    country?: string | null
    address?: string | null
    status?: string
    topUserCount?: number
  }

  export type UserUpdateWithoutPersonalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    likes?: LikeUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUpdateManyWithoutCreatorNestedInput
    merits?: MeritUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
    createdReports?: ReportUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPersonalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
    createdActivities?: ActivityUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUserNestedInput
    createdExperiences?: ExperienceUncheckedUpdateManyWithoutCreatorNestedInput
    invitationsSent?: GiftCardUncheckedUpdateManyWithoutInviterNestedInput
    ownedGroups?: GroupUncheckedUpdateManyWithoutOwnerNestedInput
    createdInvitationTemplates?: InvitationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    merits?: MeritUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
    createdReports?: ReportUncheckedUpdateManyWithoutCreatorNestedInput
    assignedPermissions?: RolePermissionUncheckedUpdateManyWithoutAssignedByNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    transactionsTo?: TransactionUncheckedUpdateManyWithoutToUserNestedInput
    transactionsFrom?: TransactionUncheckedUpdateManyWithoutFromUserNestedInput
    createdTemplates?: UIComponentTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    userAnswers?: UserAnswerUncheckedUpdateManyWithoutUserNestedInput
    userChallenges?: UserChallengeUncheckedUpdateManyWithoutUserNestedInput
    userGroups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    invitationsReceived?: UserInvitationUncheckedUpdateManyWithoutInvitedUserNestedInput
    assignedRoles?: UserRoleUncheckedUpdateManyWithoutAssignedByNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedStudyRooms?: StudyRoomUncheckedUpdateManyWithoutHostNestedInput
    studyRoomParticipants?: StudyRoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    sentChatMessages?: StudyRoomMessageUncheckedUpdateManyWithoutUserNestedInput
    videoPermissions?: VideoPermissionsUncheckedUpdateManyWithoutCreatedByNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    createdWorlds?: WorldUncheckedUpdateManyWithoutCreatorNestedInput
    marketplaceItems?: MarketplaceItemUncheckedUpdateManyWithoutSellerNestedInput
    buyerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutBuyerNestedInput
    sellerMatches?: MarketplaceMatchUncheckedUpdateManyWithoutSellerNestedInput
    matchMessages?: MatchMessageUncheckedUpdateManyWithoutSenderNestedInput
    feedbackReports?: FeedbackReportUncheckedUpdateManyWithoutUserNestedInput
    adminFeedbackResponses?: FeedbackReportUncheckedUpdateManyWithoutAdminUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutPersonalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: NullableStringFieldUpdateOperationsInput | string | null
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    topUserCount?: IntFieldUpdateOperationsInput | number
  }

  export type ContentItemCreateManyItemTypeInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    playlistId: string
    order?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentItemUpdateWithoutItemTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playlist?: PlaylistUpdateOneRequiredWithoutContentItemsNestedInput
  }

  export type ContentItemUncheckedUpdateWithoutItemTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    playlistId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentItemUncheckedUpdateManyWithoutItemTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    playlistId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeRewardCreateManyChallengeInput = {
    id?: string
    type: string
    amount?: number | null
    description?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type UserChallengeCreateManyChallengeInput = {
    id?: string
    userId: string
    status?: string
    progress?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: string | null
  }

  export type ChallengeRewardUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeRewardUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeRewardUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserChallengeUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserChallengesNestedInput
  }

  export type UserChallengeUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserChallengeUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewCreateManyMarketplaceItemInput = {
    id?: string
    userId: string
    rating: number
    comment?: string | null
    communication?: number | null
    quality?: number | null
    delivery?: number | null
    value?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceMatchCreateManyItemInput = {
    id?: string
    buyerId: string
    sellerId: string
    buyerConfirmed?: boolean
    sellerConfirmed?: boolean
    status?: $Enums.MatchStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateWithoutMarketplaceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    delivery?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutMarketplaceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    delivery?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutMarketplaceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    communication?: NullableIntFieldUpdateOperationsInput | number | null
    quality?: NullableIntFieldUpdateOperationsInput | number | null
    delivery?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceMatchUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    sellerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyer?: UserUpdateOneRequiredWithoutBuyerMatchesNestedInput
    seller?: UserUpdateOneRequiredWithoutSellerMatchesNestedInput
    messages?: MatchMessageUpdateManyWithoutMatchNestedInput
  }

  export type MarketplaceMatchUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    sellerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MatchMessageUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MarketplaceMatchUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerId?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    buyerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    sellerConfirmed?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyRoomParticipantCreateManyStudyRoomInput = {
    id?: string
    userId: string
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    isActive?: boolean
  }

  export type StudyRoomMessageCreateManyStudyRoomInput = {
    id?: string
    userId: string
    message: string
    messageType?: string
    metadata?: string | null
    createdAt?: Date | string
  }

  export type StudyRoomParticipantUpdateWithoutStudyRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutStudyRoomParticipantsNestedInput
  }

  export type StudyRoomParticipantUncheckedUpdateWithoutStudyRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudyRoomParticipantUncheckedUpdateManyWithoutStudyRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudyRoomMessageUpdateWithoutStudyRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSentChatMessagesNestedInput
  }

  export type StudyRoomMessageUncheckedUpdateWithoutStudyRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyRoomMessageUncheckedUpdateManyWithoutStudyRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchMessageCreateManyMatchInput = {
    id?: string
    senderId: string
    content: string
    createdAt?: Date | string
  }

  export type MatchMessageUpdateWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMatchMessagesNestedInput
  }

  export type MatchMessageUncheckedUpdateWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchMessageUncheckedUpdateManyWithoutMatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use MundoCountOutputTypeDefaultArgs instead
     */
    export type MundoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MundoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlaylistCountOutputTypeDefaultArgs instead
     */
    export type PlaylistCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlaylistCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoItemCountOutputTypeDefaultArgs instead
     */
    export type VideoItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionCountOutputTypeDefaultArgs instead
     */
    export type QuestionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionCountOutputTypeDefaultArgs instead
     */
    export type PermissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorldCountOutputTypeDefaultArgs instead
     */
    export type WorldCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorldCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StageCountOutputTypeDefaultArgs instead
     */
    export type StageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExperienceCountOutputTypeDefaultArgs instead
     */
    export type ExperienceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExperienceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityCountOutputTypeDefaultArgs instead
     */
    export type ActivityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityQuestionCountOutputTypeDefaultArgs instead
     */
    export type ActivityQuestionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityQuestionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WalletCountOutputTypeDefaultArgs instead
     */
    export type WalletCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WalletCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupCountOutputTypeDefaultArgs instead
     */
    export type GroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PublicationCountOutputTypeDefaultArgs instead
     */
    export type PublicationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PublicationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GiftCardCountOutputTypeDefaultArgs instead
     */
    export type GiftCardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GiftCardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonalityCountOutputTypeDefaultArgs instead
     */
    export type PersonalityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonalityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemTypeCountOutputTypeDefaultArgs instead
     */
    export type ItemTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChallengeCountOutputTypeDefaultArgs instead
     */
    export type ChallengeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChallengeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketplaceItemCountOutputTypeDefaultArgs instead
     */
    export type MarketplaceItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketplaceItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudyRoomCountOutputTypeDefaultArgs instead
     */
    export type StudyRoomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudyRoomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketplaceMatchCountOutputTypeDefaultArgs instead
     */
    export type MarketplaceMatchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketplaceMatchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MundoDefaultArgs instead
     */
    export type MundoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MundoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlaylistDefaultArgs instead
     */
    export type PlaylistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlaylistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoItemDefaultArgs instead
     */
    export type VideoItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubtitleDefaultArgs instead
     */
    export type SubtitleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubtitleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionDefaultArgs instead
     */
    export type QuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnswerOptionDefaultArgs instead
     */
    export type AnswerOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnswerOptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleDefaultArgs instead
     */
    export type UserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionDefaultArgs instead
     */
    export type PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoPermissionsDefaultArgs instead
     */
    export type VideoPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoPermissionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolePermissionDefaultArgs instead
     */
    export type RolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolePermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorldDefaultArgs instead
     */
    export type WorldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorldDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StageDefaultArgs instead
     */
    export type StageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExperienceDefaultArgs instead
     */
    export type ExperienceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExperienceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityDefaultArgs instead
     */
    export type ActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GamifiedPlaylistDefaultArgs instead
     */
    export type GamifiedPlaylistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GamifiedPlaylistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityQuestionDefaultArgs instead
     */
    export type ActivityQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityQuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAnswerDefaultArgs instead
     */
    export type UserAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAnswerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TokenDefaultArgs instead
     */
    export type TokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MeritDefaultArgs instead
     */
    export type MeritArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MeritDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WalletDefaultArgs instead
     */
    export type WalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WalletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupDefaultArgs instead
     */
    export type GroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserGroupDefaultArgs instead
     */
    export type UserGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserGroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PublicationDefaultArgs instead
     */
    export type PublicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PublicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LikeDefaultArgs instead
     */
    export type LikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LikeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvitationTemplateDefaultArgs instead
     */
    export type InvitationTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvitationTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GiftCardDefaultArgs instead
     */
    export type GiftCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GiftCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserInvitationDefaultArgs instead
     */
    export type UserInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserInvitationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConfigurationDefaultArgs instead
     */
    export type ConfigurationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConfigurationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogDefaultArgs instead
     */
    export type LogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnalyticsDataDefaultArgs instead
     */
    export type AnalyticsDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnalyticsDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RankingDefaultArgs instead
     */
    export type RankingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RankingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonalityDefaultArgs instead
     */
    export type PersonalityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonalityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UIComponentTemplateDefaultArgs instead
     */
    export type UIComponentTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UIComponentTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemTypeDefaultArgs instead
     */
    export type ItemTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContentItemDefaultArgs instead
     */
    export type ContentItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContentItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChallengeDefaultArgs instead
     */
    export type ChallengeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChallengeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChallengeRewardDefaultArgs instead
     */
    export type ChallengeRewardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChallengeRewardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserChallengeDefaultArgs instead
     */
    export type UserChallengeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserChallengeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketplaceItemDefaultArgs instead
     */
    export type MarketplaceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketplaceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudyRoomDefaultArgs instead
     */
    export type StudyRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudyRoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudyRoomParticipantDefaultArgs instead
     */
    export type StudyRoomParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudyRoomParticipantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudyRoomMessageDefaultArgs instead
     */
    export type StudyRoomMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudyRoomMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedbackReportDefaultArgs instead
     */
    export type FeedbackReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedbackReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReviewDefaultArgs instead
     */
    export type ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketplaceMatchDefaultArgs instead
     */
    export type MarketplaceMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketplaceMatchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatchMessageDefaultArgs instead
     */
    export type MatchMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatchMessageDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}