[{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/analytics/analytics.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_dbError' is defined but never used.","line":442,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":442,"endColumn":24}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Inject } from '@nestjs/common';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { CreateUserEngagementDto } from './dto/create-user-engagement.dto';\nimport { Activity } from '../generated/prisma'; // Use Activity from generated Prisma\n\ninterface TimeRangeParams {\n  interval?: string;\n  startDate?: string;\n  endDate?: string;\n}\n\nexport interface TimeSeriesDataPoint {\n  time_period: string;\n  count: number;\n}\n\nexport interface ContentViewMetric {\n  id: string;\n  name: string;\n  view_count: number;\n  thumbnail_url?: string;\n}\n\nexport interface ContentInteractionMetric {\n  id: string;\n  name: string;\n  interaction_count: number;\n  content_type: 'playlist' | 'mundo';\n  thumbnail_url?: string;\n}\n\n@Injectable()\nexport class AnalyticsService {\n  constructor(@Inject(PrismaService) private readonly prisma: PrismaService) {\n    // //     console.log('>>> AnalyticsService CONSTRUCTOR: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n  }\n\n  async recordEngagement(\n    data: CreateUserEngagementDto,\n    userId: string\n  ): Promise<Activity> {\n    return this.prisma.activity.create({\n      data: {\n        title: `User Engagement - ${data.eventType}`,\n        description: data.eventData\n          ? JSON.stringify(data.eventData)\n          : undefined,\n        type: data.eventType,\n        creatorId: userId,\n        experienceId: data.contentItemId || 'default-experience-id', // Use contentItemId from DTO\n        status: 'ACTIVE',\n      },\n    });\n  }\n\n  async getUserEngagement(userId: string): Promise<Activity[]> {\n    return this.prisma.activity.findMany({\n      where: { creatorId: userId },\n      orderBy: { createdAt: 'desc' },\n    });\n  }\n\n  async getContentItemEngagement(contentItemId: string): Promise<Activity[]> {\n    return this.prisma.activity.findMany({\n      where: { experienceId: contentItemId },\n      orderBy: { createdAt: 'desc' },\n    });\n  }\n\n  async getMyEngagement(userId: string): Promise<Activity[]> {\n    // This method is essentially the same as getUserEngagement but provided for controller clarity\n    return this.getUserEngagement(userId);\n  }\n\n  async getTotalUsers(): Promise<{ count: number }> {\n    try {\n      const count = await this.prisma.user.count();\n      return { count };\n    } catch (error) {\n      console.warn('[AnalyticsService] Error getting total users:', error);\n      return { count: 0 };\n    }\n  }\n\n  async getTotalPlaylists(): Promise<{ count: number }> {\n    try {\n      const count = await this.prisma.playlist.count();\n      return { count };\n    } catch (error) {\n      console.warn('[AnalyticsService] Error getting total playlists:', error);\n      return { count: 0 };\n    }\n  }\n\n  async getTotalMundos(): Promise<{ count: number }> {\n    try {\n      const count = await this.prisma.mundo.count();\n      return { count };\n    } catch (error) {\n      console.warn('[AnalyticsService] Error getting total mundos:', error);\n      return { count: 0 };\n    }\n  }\n\n  async getUsersCreatedOverTime(\n    _params: TimeRangeParams\n  ): Promise<TimeSeriesDataPoint[]> {\n    try {\n      // Por ahora devolvemos datos mock, pero aqu√≠ se implementar√≠a la l√≥gica real\n      // usando agregaciones de Prisma con fechas\n      const mockData: TimeSeriesDataPoint[] = [\n        { time_period: '2024-01-01', count: 5 },\n        { time_period: '2024-01-02', count: 8 },\n        { time_period: '2024-01-03', count: 12 },\n      ];\n      return mockData;\n    } catch (error) {\n      console.warn(\n        '[AnalyticsService] Error getting users created over time:',\n        error\n      );\n      return [];\n    }\n  }\n\n  async getPlaylistsCreatedOverTime(\n    _params: TimeRangeParams\n  ): Promise<TimeSeriesDataPoint[]> {\n    try {\n      const mockData: TimeSeriesDataPoint[] = [\n        { time_period: '2024-01-01', count: 2 },\n        { time_period: '2024-01-02', count: 4 },\n        { time_period: '2024-01-03', count: 6 },\n      ];\n      return mockData;\n    } catch (error) {\n      console.warn(\n        '[AnalyticsService] Error getting playlists created over time:',\n        error\n      );\n      return [];\n    }\n  }\n\n  async getMundosCreatedOverTime(\n    _params: TimeRangeParams\n  ): Promise<TimeSeriesDataPoint[]> {\n    try {\n      const mockData: TimeSeriesDataPoint[] = [\n        { time_period: '2024-01-01', count: 1 },\n        { time_period: '2024-01-02', count: 2 },\n        { time_period: '2024-01-03', count: 3 },\n      ];\n      return mockData;\n    } catch (error) {\n      console.warn(\n        '[AnalyticsService] Error getting mundos created over time:',\n        error\n      );\n      return [];\n    }\n  }\n\n  async getTopViewedPlaylists(): Promise<ContentViewMetric[]> {\n    try {\n      // Implementaci√≥n b√°sica usando datos reales de playlists\n      const playlists = await this.prisma.playlist.findMany({\n        take: 10,\n        orderBy: { createdAt: 'desc' },\n        select: {\n          id: true,\n          name: true,\n          description: true,\n        },\n      });\n\n      return playlists.map((playlist, _index) => ({\n        id: playlist.id,\n        name: playlist.name,\n        view_count: Math.floor(Math.random() * 100) + 10, // Mock view count\n        thumbnail_url: undefined,\n      }));\n    } catch (error) {\n      console.warn(\n        '[AnalyticsService] Error getting top viewed playlists:',\n        error\n      );\n      return [];\n    }\n  }\n\n  async getTopViewedMundos(): Promise<ContentViewMetric[]> {\n    try {\n      const mundos = await this.prisma.mundo.findMany({\n        take: 10,\n        orderBy: { createdAt: 'desc' },\n        select: {\n          id: true,\n          name: true,\n          description: true,\n        },\n      });\n\n      return mundos.map((mundo, _index) => ({\n        id: mundo.id,\n        name: mundo.name,\n        view_count: Math.floor(Math.random() * 100) + 10, // Mock view count\n        thumbnail_url: undefined,\n      }));\n    } catch (error) {\n      console.warn(\n        '[AnalyticsService] Error getting top viewed mundos:',\n        error\n      );\n      return [];\n    }\n  }\n\n  async getActiveUsersOverTime(\n    _params: TimeRangeParams\n  ): Promise<TimeSeriesDataPoint[]> {\n    try {\n      const mockData: TimeSeriesDataPoint[] = [\n        { time_period: '2024-01-01', count: 15 },\n        { time_period: '2024-01-02', count: 22 },\n        { time_period: '2024-01-03', count: 18 },\n      ];\n      return mockData;\n    } catch (error) {\n      console.warn(\n        '[AnalyticsService] Error getting active users over time:',\n        error\n      );\n      return [];\n    }\n  }\n\n  async getTopInteractedContent(): Promise<ContentInteractionMetric[]> {\n    try {\n      const mockData: ContentInteractionMetric[] = [\n        {\n          id: '1',\n          name: 'Popular Playlist',\n          interaction_count: 45,\n          content_type: 'playlist',\n        },\n        {\n          id: '2',\n          name: 'Trending Mundo',\n          interaction_count: 38,\n          content_type: 'mundo',\n        },\n      ];\n      return mockData;\n    } catch (error) {\n      console.warn(\n        '[AnalyticsService] Error getting top interacted content:',\n        error\n      );\n      return [];\n    }\n  }\n\n  async getLeastViewedPlaylists(): Promise<ContentViewMetric[]> {\n    try {\n      const playlists = await this.prisma.playlist.findMany({\n        take: 10,\n        orderBy: { createdAt: 'asc' },\n        select: {\n          id: true,\n          name: true,\n          description: true,\n        },\n      });\n\n      return playlists.map((playlist) => ({\n        id: playlist.id,\n        name: playlist.name,\n        view_count: Math.floor(Math.random() * 10) + 1, // Mock low view count\n        thumbnail_url: undefined,\n      }));\n    } catch (error) {\n      console.warn(\n        '[AnalyticsService] Error getting least viewed playlists:',\n        error\n      );\n      return [];\n    }\n  }\n\n  async getLeastViewedMundos(): Promise<ContentViewMetric[]> {\n    try {\n      const mundos = await this.prisma.mundo.findMany({\n        take: 10,\n        orderBy: { createdAt: 'asc' },\n        select: {\n          id: true,\n          name: true,\n          description: true,\n        },\n      });\n\n      return mundos.map((mundo) => ({\n        id: mundo.id,\n        name: mundo.name,\n        view_count: Math.floor(Math.random() * 10) + 1, // Mock low view count\n        thumbnail_url: undefined,\n      }));\n    } catch (error) {\n      console.warn(\n        '[AnalyticsService] Error getting least viewed mundos:',\n        error\n      );\n      return [];\n    }\n  }\n\n  async getLeastInteractedPlaylists(): Promise<ContentInteractionMetric[]> {\n    try {\n      const mockData: ContentInteractionMetric[] = [\n        {\n          id: '3',\n          name: 'Low Interaction Playlist',\n          interaction_count: 2,\n          content_type: 'playlist',\n        },\n      ];\n      return mockData;\n    } catch (error) {\n      console.warn(\n        '[AnalyticsService] Error getting least interacted playlists:',\n        error\n      );\n      return [];\n    }\n  }\n\n  async getLeastInteractedMundos(): Promise<ContentInteractionMetric[]> {\n    try {\n      const mockData: ContentInteractionMetric[] = [\n        {\n          id: '4',\n          name: 'Low Interaction Mundo',\n          interaction_count: 1,\n          content_type: 'mundo',\n        },\n      ];\n      return mockData;\n    } catch (error) {\n      console.warn(\n        '[AnalyticsService] Error getting least interacted mundos:',\n        error\n      );\n      return [];\n    }\n  }\n\n  async getSystemStats() {\n    try {\n      const [totalUsers, totalPlaylists, totalMundos] = await Promise.all([\n        this.prisma.user.count(),\n        this.prisma.playlist.count(),\n        this.prisma.mundo.count(),\n      ]);\n\n      return {\n        totalUsers,\n        totalMundos,\n        totalPlaylists,\n        totalVideos: 0, // Por implementar cuando tengamos videos\n      };\n    } catch (error) {\n      console.warn('[AnalyticsService] Error getting system stats:', error);\n      return {\n        totalUsers: 0,\n        totalMundos: 0,\n        totalPlaylists: 0,\n        totalVideos: 0,\n      };\n    }\n  }\n\n  async getUserStats() {\n    try {\n      const totalUsers = await this.prisma.user.count();\n      const recentUsers = await this.prisma.user.count({\n        where: {\n          createdAt: {\n            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // √öltimos 30 d√≠as\n          },\n        },\n      });\n\n      return {\n        activeUsers: totalUsers,\n        newUsers: recentUsers,\n        topUsers: [], // Por implementar\n      };\n    } catch (error) {\n      console.warn('[AnalyticsService] Error getting user stats:', error);\n      return {\n        activeUsers: 0,\n        newUsers: 0,\n        topUsers: [],\n      };\n    }\n  }\n\n  async getContentStats() {\n    try {\n      const totalPlaylists = await this.prisma.playlist.count();\n      const totalMundos = await this.prisma.mundo.count();\n      const totalContentItems = await this.prisma.contentItem.count();\n\n      return {\n        total_playlists: totalPlaylists,\n        total_mundos: totalMundos,\n        total_content_items: totalContentItems,\n        total_content: totalPlaylists + totalMundos + totalContentItems,\n      };\n    } catch (error) {\n      console.warn('[AnalyticsService] Error getting content stats:', error);\n      return {\n        total_playlists: 0,\n        total_mundos: 0,\n        total_content_items: 0,\n        total_content: 0,\n      };\n    }\n  }\n\n  async getVideoAnalytics() {\n    try {\n      // TODO: Implementar l√≥gica real con agregaciones de Prisma\n      // Por ahora devolvemos datos simulados con la estructura correcta\n\n      // Intentar obtener el conteo real de videos\n      let totalVideos = 42; // Valor por defecto\n      try {\n        const videoCount = await this.prisma.contentItem.count();\n        totalVideos = videoCount > 0 ? videoCount : 42;\n      } catch (_dbError) {\n        console.warn(\n          '[AnalyticsService] Could not fetch video count from DB, using mock data'\n        );\n      }\n\n      return {\n        totalViews: 10500,\n        averageWatchTime: 180, // en segundos\n        mostViewedVideo: 'Introducci√≥n a la Gamificaci√≥n',\n        totalQuestionsAnswered: 5320,\n        totalVideos,\n        topVideos: [\n          {\n            id: '1',\n            title: 'Introducci√≥n a la Gamificaci√≥n',\n            views: 2500,\n            duration: 300,\n          },\n          {\n            id: '2',\n            title: 'Principios de Reciprocidad',\n            views: 1800,\n            duration: 240,\n          },\n          {\n            id: '3',\n            title: 'Econom√≠a Colaborativa',\n            views: 1200,\n            duration: 420,\n          },\n        ],\n        viewsByDay: [\n          { date: '2024-01-01', views: 150 },\n          { date: '2024-01-02', views: 200 },\n          { date: '2024-01-03', views: 180 },\n          { date: '2024-01-04', views: 220 },\n          { date: '2024-01-05', views: 190 },\n        ],\n      };\n    } catch (error) {\n      console.warn('[AnalyticsService] Error getting video analytics:', error);\n      return {\n        totalViews: 0,\n        averageWatchTime: 0,\n        mostViewedVideo: 'N/A',\n        totalQuestionsAnswered: 0,\n        totalVideos: 0,\n        topVideos: [],\n        viewsByDay: [],\n      };\n    }\n  }\n\n  // Nuevos m√©todos requeridos por el reporte de integraci√≥n\n  async getDashboardMetrics() {\n    try {\n      console.log('[AnalyticsService] Getting dashboard metrics...');\n\n      // Obtener m√©tricas b√°sicas del sistema\n      const [\n        totalUsers,\n        totalPlaylists,\n        totalMundos,\n        totalContentItems,\n        recentEngagement,\n      ] = await Promise.all([\n        this.prisma.user.count(),\n        this.prisma.playlist.count(),\n        this.prisma.mundo.count(),\n        this.prisma.contentItem.count(),\n        this.prisma.activity.findMany({\n          take: 10,\n          orderBy: { createdAt: 'desc' },\n          include: { creator: { select: { name: true, email: true } } },\n        }),\n      ]);\n\n      // Calcular usuarios activos (√∫ltimos 7 d√≠as) - usando actividades como proxy\n      const activeUsers = await this.prisma.user.count({\n        where: {\n          createdActivities: {\n            some: {\n              createdAt: {\n                gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),\n              },\n            },\n          },\n        },\n      });\n\n      const totalContent = totalPlaylists + totalMundos + totalContentItems;\n\n      // M√©tricas de Reciprocidad (simuladas por ahora)\n      const reciprocidadMetrics = {\n        totalLukas: Math.floor(Math.random() * 10000) + 5000,\n        totalOndas: Math.floor(Math.random() * 50000) + 25000,\n        reciprocidadBalance: {\n          given: Math.floor(Math.random() * 1000) + 500,\n          received: Math.floor(Math.random() * 1000) + 500,\n        },\n        trustLevel: Math.random() * 5 + 3, // Entre 3-8\n      };\n\n      // Actividad reciente\n      const recentActivity = recentEngagement.map((engagement) => ({\n        id: engagement.id,\n        type: engagement.type,\n        user: engagement.creator?.name || 'Usuario An√≥nimo',\n        timestamp: engagement.createdAt,\n        details: engagement.description,\n      }));\n\n      return {\n        timestamp: new Date().toISOString(),\n        totalUsers,\n        activeUsers,\n        totalContent,\n        breakdown: {\n          playlists: totalPlaylists,\n          mundos: totalMundos,\n          contentItems: totalContentItems,\n        },\n        engagement: {\n          totalEvents: recentEngagement.length,\n          recentEvents: recentEngagement.length,\n        },\n        recentActivity: recentActivity.slice(0, 5), // √öltimas 5 actividades\n        reciprocidadMetrics,\n        summary: {\n          userGrowth: Math.floor(Math.random() * 20) + 5, // % crecimiento simulado\n          engagementRate: Math.random() * 30 + 70, // % entre 70-100\n          contentUtilization: totalContent > 0 ? Math.random() * 40 + 60 : 0, // % entre 60-100\n        },\n      };\n    } catch (error) {\n      console.error(\n        '[AnalyticsService] Error getting dashboard metrics:',\n        error\n      );\n      return {\n        timestamp: new Date().toISOString(),\n        totalUsers: 0,\n        activeUsers: 0,\n        totalContent: 0,\n        breakdown: { playlists: 0, mundos: 0, contentItems: 0 },\n        engagement: { totalEvents: 0, recentEvents: 0 },\n        recentActivity: [],\n        reciprocidadMetrics: {\n          totalLukas: 0,\n          totalOndas: 0,\n          reciprocidadBalance: { given: 0, received: 0 },\n          trustLevel: 0,\n        },\n        summary: {\n          userGrowth: 0,\n          engagementRate: 0,\n          contentUtilization: 0,\n        },\n      };\n    }\n  }\n\n  async getSystemHealth() {\n    try {\n      console.log('[AnalyticsService] Checking system health...');\n\n      const startTime = Date.now();\n      let databaseStatus = 'healthy';\n      let dbResponseTime = 0;\n\n      // Test database connection\n      try {\n        const dbStart = Date.now();\n        await this.prisma.$queryRaw`SELECT 1`;\n        dbResponseTime = Date.now() - dbStart;\n\n        if (dbResponseTime > 1000) {\n          databaseStatus = 'warning';\n        } else if (dbResponseTime > 2000) {\n          databaseStatus = 'critical';\n        }\n      } catch (_dbError) {\n        console.error(\n          '[AnalyticsService] Database health check failed:',\n          _dbError\n        );\n        databaseStatus = 'critical';\n        dbResponseTime = -1;\n      }\n\n      // Memory usage (simulated - in real app would use process.memoryUsage())\n      const memoryUsage = {\n        used: Math.floor(Math.random() * 500) + 200, // MB\n        total: 1024, // MB\n        percentage: Math.floor(Math.random() * 50 + 20), // 20-70%\n      };\n\n      // Determine overall health status\n      let overallStatus = 'healthy';\n      if (databaseStatus === 'critical' || memoryUsage.percentage > 90) {\n        overallStatus = 'critical';\n      } else if (databaseStatus === 'warning' || memoryUsage.percentage > 75) {\n        overallStatus = 'warning';\n      }\n\n      // System uptime (simulated)\n      const uptime = Math.floor(Math.random() * 86400) + 3600; // 1-24 hours in seconds\n\n      return {\n        status: overallStatus,\n        timestamp: new Date().toISOString(),\n        uptime,\n        services: {\n          database: {\n            status: databaseStatus,\n            responseTime: dbResponseTime,\n            connection: databaseStatus !== 'critical',\n          },\n          cache: {\n            status: 'healthy', // Simulated\n            responseTime: Math.floor(Math.random() * 50) + 5,\n          },\n          api: {\n            status: 'healthy',\n            responseTime: Date.now() - startTime,\n          },\n        },\n        resources: {\n          memory: memoryUsage,\n          cpu: {\n            usage: Math.floor(Math.random() * 60) + 10, // 10-70%\n            load: Math.random() * 2 + 0.5, // 0.5-2.5\n          },\n        },\n        metrics: {\n          activeConnections: Math.floor(Math.random() * 100) + 10,\n          requestsPerMinute: Math.floor(Math.random() * 500) + 50,\n          errorRate: Math.random() * 5, // 0-5%\n        },\n        lastHealthCheck: new Date().toISOString(),\n      };\n    } catch (error) {\n      console.error('[AnalyticsService] Error checking system health:', error);\n      return {\n        status: 'critical',\n        timestamp: new Date().toISOString(),\n        uptime: 0,\n        services: {\n          database: { status: 'critical', responseTime: -1, connection: false },\n          cache: { status: 'unknown', responseTime: -1 },\n          api: { status: 'critical', responseTime: -1 },\n        },\n        resources: {\n          memory: { used: 0, total: 0, percentage: 0 },\n          cpu: { usage: 0, load: 0 },\n        },\n        metrics: {\n          activeConnections: 0,\n          requestsPerMinute: 0,\n          errorRate: 100,\n        },\n        lastHealthCheck: new Date().toISOString(),\n        error: error.message,\n      };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/auth/auth.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_error' is defined but never used.","line":69,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":69,"endColumn":20}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  UnauthorizedException,\n  ConflictException,\n  Inject,\n} from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport * as bcrypt from 'bcryptjs';\nimport { RegisterDto } from './dto/register.dto';\nimport { LoginDto } from './dto/login.dto';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { AuditLogsService } from '../admin/audit-logs/audit-logs.service';\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    @Inject(PrismaService) private readonly prisma: PrismaService,\n    @Inject(JwtService) private readonly jwtService: JwtService,\n    @Inject(AuditLogsService)\n    private readonly auditLogsService: AuditLogsService\n  ) {\n    // //     console.log('>>> AuthService CONSTRUCTOR: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n    // //     console.log('>>> AuthService CONSTRUCTOR: this.jwtService IS', this.jwtService ? 'DEFINED' : 'UNDEFINED');\n    // //     console.log('>>> AuthService CONSTRUCTOR: this.auditLogsService IS', this.auditLogsService ? 'DEFINED' : 'UNDEFINED');\n  }\n\n  async validateUser(email: string, password: string) {\n    // //     console.log('>>> AuthService validateUser called for:', email);\n\n    try {\n      // Find user in database by email\n      const user = await this.prisma.user.findUnique({\n        where: { email },\n        include: {\n          userRoles: {\n            include: {\n              role: {\n                include: {\n                  rolePermissions: {\n                    include: {\n                      permission: true,\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      });\n\n      if (!user) {\n        // //         console.log('>>> AuthService validateUser: User not found');\n        return null;\n      }\n\n      // Verify password with bcrypt\n      const isPasswordValid = await bcrypt.compare(password, user.password);\n\n      if (!isPasswordValid) {\n        // //         console.log('>>> AuthService validateUser: Invalid password');\n        return null;\n      }\n\n      // //       console.log('>>> AuthService validateUser: User authenticated successfully');\n\n      // Remove password from returned user object\n      const { password: _, ...userWithoutPassword } = user;\n      return userWithoutPassword;\n    } catch (_error) {\n      //       console.error('>>> AuthService validateUser error:', _error);\n      return null;\n    }\n  }\n\n  async login(dto: LoginDto) {\n    // //     console.log('>>> AuthService login called with:', dto.email);\n\n    const user = await this.validateUser(dto.email, dto.password);\n    if (!user) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    // Extract roles and permissions from user data\n    const roles = user.userRoles?.map((userRole) => userRole.role.name) || [];\n    const permissions =\n      user.userRoles?.flatMap(\n        (userRole) =>\n          userRole.role.rolePermissions?.map(\n            (rolePermission) => rolePermission.permission.name\n          ) || []\n      ) || [];\n\n    // //       console.log('>>> AuthService login: User roles:', roles);\n    // //       console.log('>>> AuthService login: User permissions:', permissions);\n\n    // Create JWT payload\n    const payload = {\n      sub: user.id,\n      email: user.email,\n      name: user.name,\n      roles,\n      permissions,\n      iat: Math.floor(Date.now() / 1000),\n    };\n\n    // //       console.log('>>> AuthService login: Creating JWT with payload:', payload);\n\n    const access_token = this.jwtService.sign(payload);\n\n    // //       console.log('>>> AuthService login: JWT created successfully');\n\n    // Log audit entry - TEMPORARILY DISABLED FOR TESTING\n    // await this.auditLogsService.createLog({\n    //   action: 'LOGIN',\n    //   entityType: 'User',\n    //   entityId: user.id,\n    //   userId: user.id,\n    //   details: { email: user.email },\n    // });\n\n    return {\n      access_token,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n        avatarUrl: user.avatarUrl,\n        roles,\n        permissions,\n      },\n    };\n  }\n\n  async register(dto: RegisterDto) {\n    //     console.log('>>> AuthService register called with:', dto.email);\n\n    // Check if user already exists\n    const existingUser = await this.prisma.user.findUnique({\n      where: { email: dto.email },\n    });\n\n    if (existingUser) {\n      throw new ConflictException('User with this email already exists');\n    }\n\n    // Hash password with bcrypt\n    const hashedPassword = await bcrypt.hash(dto.password, 12);\n\n    // Create user in database\n    const user = await this.prisma.user.create({\n      data: {\n        email: dto.email,\n        name: dto.name || dto.email.split('@')[0],\n        password: hashedPassword,\n        avatarUrl: null,\n      },\n      include: {\n        userRoles: {\n          include: {\n            role: {\n              include: {\n                rolePermissions: {\n                  include: {\n                    permission: true,\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    });\n\n    // Extract roles and permissions from user data\n    const roles = user.userRoles?.map((userRole) => userRole.role.name) || [];\n    const permissions =\n      user.userRoles?.flatMap(\n        (userRole) =>\n          userRole.role.rolePermissions?.map(\n            (rolePermission) => rolePermission.permission.name\n          ) || []\n      ) || [];\n\n    //       console.log('>>> AuthService register: User roles:', roles);\n    //       console.log('>>> AuthService register: User permissions:', permissions);\n\n    // Create JWT payload\n    const payload = {\n      sub: user.id,\n      email: user.email,\n      name: user.name,\n      roles,\n      permissions,\n      iat: Math.floor(Date.now() / 1000),\n    };\n\n    const access_token = this.jwtService.sign(payload);\n\n    // Log audit entry - TEMPORARILY DISABLED FOR TESTING\n    // await this.auditLogsService.createLog({\n    //   action: 'REGISTER',\n    //   entityType: 'User',\n    //   entityId: user.id,\n    //   userId: user.id,\n    //   details: { email: user.email },\n    // });\n\n    return {\n      access_token,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n        avatarUrl: user.avatarUrl,\n        roles,\n        permissions,\n      },\n    };\n  }\n\n  async getCurrentUser() {\n    //     console.log('>>> AuthService getCurrentUser called');\n    // For now, return a mock current user\n    // In a real implementation, this would get the user from the JWT payload\n    return {\n      id: '00000000-0000-0000-0000-000000000001',\n      email: 'admin@gamifier.com',\n      name: 'Administrator',\n      avatarUrl: null,\n      roles: ['admin'],\n      permissions: ['admin:all'],\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/challenges/user-challenges/user-challenges.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'User' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":7}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  ConflictException,\n  NotFoundException,\n  ForbiddenException,\n  BadRequestException,\n} from '@nestjs/common';\nimport { PrismaService } from '../../prisma/prisma.service';\nimport { TransactionsService } from '../../merits-and-wallet/transactions/transactions.service';\nimport {\n  User,\n  Challenge,\n  ChallengeReward,\n  UserChallenge,\n} from '../../generated/prisma';\nimport { UpdateUserChallengeDto } from './dto/update-user-challenge.dto';\nimport { ChallengeConfig } from '../types/challenge-config.interface';\nimport { AuditLogsService } from '../../admin/audit-logs/audit-logs.service';\nimport { AuthenticatedUser } from '../../types/auth.types';\n\n@Injectable()\nexport class UserChallengesService {\n  constructor(\n    private prisma: PrismaService,\n    private transactionsService: TransactionsService, // Inject TransactionsService\n    private readonly auditLogsService: AuditLogsService // Inject AuditLogsService\n  ) {}\n\n  async startChallenge(\n    userId: string,\n    challengeId: string,\n    user: AuthenticatedUser\n  ): Promise<UserChallenge> {\n    const existingUserChallenge = await this.prisma.userChallenge.findUnique({\n      where: {\n        userId_challengeId: {\n          userId,\n          challengeId,\n        },\n      },\n    });\n\n    if (existingUserChallenge) {\n      throw new ConflictException('User has already started this challenge.');\n    }\n\n    // Optional: Check if challenge exists and is active\n    const challenge = await this.prisma.challenge.findUnique({\n      where: { id: challengeId },\n    });\n\n    if (!challenge) {\n      throw new NotFoundException(`Challenge with ID ${challengeId} not found`);\n    }\n\n    // Consider challenge status and dates if not handled by findAllActive in ChallengesService\n\n    const newUserChallenge = await this.prisma.userChallenge.create({\n      data: {\n        userId,\n        challengeId,\n        status: 'STARTED',\n        progress: 0,\n      },\n    });\n\n    // Log user starting a challenge\n    await this.auditLogsService.createLog({\n      userId: user.id, // User performing the action\n      actionType: 'user_challenge:started',\n      entityType: 'UserChallenge',\n      entityId: newUserChallenge.id,\n      newValue: {\n        userId: newUserChallenge.userId,\n        challengeId: newUserChallenge.challengeId,\n        status: newUserChallenge.status,\n      },\n      // TODO: Add ipAddress, userAgent if available from request context\n    });\n\n    return newUserChallenge;\n  }\n\n  async updateProgress(\n    user: AuthenticatedUser,\n    userChallengeId: string,\n    updateData: UpdateUserChallengeDto\n  ): Promise<UserChallenge> {\n    const userChallenge = await this.prisma.userChallenge.findUnique({\n      where: { id: userChallengeId },\n    });\n\n    if (!userChallenge) {\n      throw new NotFoundException(\n        `User Challenge with ID ${userChallengeId} not found`\n      );\n    }\n\n    // Ownership check: User must be the owner OR have the 'admin' role\n    if (userChallenge.userId !== user.id && !user.roles.includes('admin')) {\n      throw new ForbiddenException(\n        'You do not have permission to update this user challenge.'\n      );\n    }\n\n    // Capture old progress before update\n    const oldProgress: number = userChallenge.progress;\n\n    // Ensure the updated progress conforms to the type if possible, or add validation here\n    if (updateData.progress && typeof updateData.progress !== 'number') {\n      throw new BadRequestException('Progress data must be a valid number.');\n    }\n\n    const updatedUserChallenge = await this.prisma.userChallenge.update({\n      where: { id: userChallengeId },\n      data: {\n        ...updateData,\n        progress: updateData.progress ?? userChallenge.progress,\n      },\n    });\n\n    // Capture new progress after update\n    const newProgress: number = updatedUserChallenge.progress;\n\n    // Log user updating challenge progress\n    await this.auditLogsService.createLog({\n      userId: user.id, // User performing the action\n      actionType: 'user_challenge:progress_updated',\n      entityType: 'UserChallenge',\n      entityId: updatedUserChallenge.id,\n      oldValue: oldProgress,\n      newValue: newProgress,\n      // TODO: Add ipAddress, userAgent if available from request context\n    });\n\n    return updatedUserChallenge;\n  }\n\n  async completeChallenge(\n    user: AuthenticatedUser,\n    userChallengeId: string\n  ): Promise<\n    UserChallenge & { challenge: Challenge & { rewards: ChallengeReward[] } }\n  > {\n    const userChallenge = await this.prisma.userChallenge.findUnique({\n      where: { id: userChallengeId },\n      include: {\n        challenge: {\n          include: { rewards: true },\n        },\n      },\n    });\n\n    if (!userChallenge) {\n      throw new NotFoundException(\n        `User Challenge with ID ${userChallengeId} not found`\n      );\n    }\n\n    // Ownership check: User must be the owner OR have the 'admin' role\n    if (userChallenge.userId !== user.id && !user.roles.includes('admin')) {\n      throw new ForbiddenException(\n        'You do not have permission to complete this user challenge.'\n      );\n    }\n\n    // Prevent completing an already completed challenge\n    if (userChallenge.completedAt) {\n      throw new ConflictException('Challenge is already completed.');\n    }\n\n    // --- Refactored Completion Logic ---\n    const challenge = userChallenge.challenge;\n    const progress = userChallenge.progress;\n    // The config is stored as a JSON string in the database, so it must be parsed.\n    const config: ChallengeConfig = JSON.parse(challenge.config as string);\n\n    let isCompleted = false;\n    const requiredCompletions = config.requiredCompletions || 100;\n\n    // Implement completion logic based on challenge type\n    switch (challenge.type) {\n      case 'AUTOMATED':\n        if (progress >= requiredCompletions) {\n          isCompleted = true;\n        }\n        break;\n      case 'CUSTOM':\n        if (user.roles.includes('admin')) {\n          isCompleted = true;\n        }\n        break;\n      default:\n        isCompleted = false;\n    }\n\n    if (!isCompleted && !user.roles.includes('admin')) {\n      // Only allow completion if criteria met OR user is admin\n      throw new ConflictException('Challenge requirements not met.');\n    }\n    // --- End Refactored Completion Logic ---\n\n    // Award rewards\n    if (challenge.rewards && challenge.rewards.length > 0) {\n      for (const reward of challenge.rewards) {\n        // Assuming TransactionsService.createTransaction exists and handles merit awarding\n        await this.transactionsService.createTransaction({\n          toUserId: userChallenge.userId,\n          amount: reward.amount,\n          type: 'RECEIVE',\n          description: `Reward for completing challenge \"${challenge.title}\": ${reward.description || ''}`,\n        });\n      }\n    }\n\n    // Update user challenge status\n    const completedUserChallenge = await this.prisma.userChallenge.update({\n      where: { id: userChallengeId },\n      data: {\n        completedAt: new Date(),\n        progress,\n      },\n      include: {\n        challenge: {\n          include: { rewards: true },\n        },\n      },\n    });\n\n    // Log user completing a challenge\n    await this.auditLogsService.createLog({\n      userId: user.id, // User performing the action\n      actionType: 'user_challenge:completed',\n      entityType: 'UserChallenge',\n      entityId: completedUserChallenge.id,\n      newValue: {\n        id: completedUserChallenge.id,\n        status: completedUserChallenge.status,\n        completedAt: completedUserChallenge.completedAt,\n      },\n      // TODO: Add ipAddress, userAgent if available from request context\n    });\n\n    return completedUserChallenge;\n  }\n\n  async findUserChallenges(\n    userId: string,\n    status?: string\n  ): Promise<UserChallenge[]> {\n    // This method already filters by userId, so it's safe for non-admin users\n    return this.prisma.userChallenge.findMany({\n      where: {\n        userId,\n        status,\n      },\n      include: { challenge: true },\n    });\n  }\n\n  async findOneUserChallenge(\n    user: AuthenticatedUser,\n    userChallengeId: string\n  ): Promise<UserChallenge | null> {\n    const userChallenge = await this.prisma.userChallenge.findUnique({\n      where: { id: userChallengeId },\n      include: { challenge: true },\n    });\n\n    if (!userChallenge) {\n      throw new NotFoundException(\n        `User Challenge with ID ${userChallengeId} not found`\n      );\n    }\n\n    // Ownership check: User must be the owner OR have the 'admin' role\n    if (userChallenge.userId !== user.id && !user.roles.includes('admin')) {\n      throw new ForbiddenException(\n        'You do not have permission to view this user challenge.'\n      );\n    }\n\n    return userChallenge;\n  }\n\n  // Admin method to find any user challenges (no ownership check)\n  async findAllUserChallengesAdmin(status?: string): Promise<UserChallenge[]> {\n    return this.prisma.userChallenge.findMany({\n      where: {\n        status,\n      },\n      include: { challenge: true, user: true },\n    });\n  }\n\n  // Admin method to find a specific user challenge (no ownership check)\n  async findOneUserChallengeAdmin(\n    userChallengeId: string\n  ): Promise<UserChallenge | null> {\n    const userChallenge = await this.prisma.userChallenge.findUnique({\n      where: { id: userChallengeId },\n      include: { challenge: true, user: true },\n    });\n\n    if (!userChallenge) {\n      throw new NotFoundException(\n        `User Challenge with ID ${userChallengeId} not found`\n      );\n    }\n    return userChallenge;\n  }\n\n  // Keep the helper if still needed elsewhere, but main logic is in the methods above\n  async isUserChallengeOwner(\n    userId: string,\n    userChallengeId: string\n  ): Promise<boolean> {\n    const userChallenge = await this.prisma.userChallenge.findUnique({\n      where: { id: userChallengeId },\n      select: { userId: true },\n    });\n    return userChallenge?.userId === userId;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/common/logger/logger.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'color' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":153,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":153,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'key' is defined but never used. Allowed unused elements of array destructuring must match /^_/u.","line":253,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":253,"endColumn":12}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, LoggerService } from '@nestjs/common';\n\nexport enum LogLevel {\n  ERROR = 0,\n  WARN = 1,\n  INFO = 2,\n  DEBUG = 3,\n  VERBOSE = 4,\n}\n\nexport interface LogContext {\n  module?: string;\n  method?: string;\n  userId?: string;\n  requestId?: string;\n  [key: string]: unknown;\n}\n\ntype LoggableData = Record<string, unknown> | string | number | boolean | null;\n\n@Injectable()\nexport class CoomUnityLoggerService implements LoggerService {\n  private readonly logLevel: LogLevel;\n  private readonly enabledModules: Set<string>;\n  private readonly colors = {\n    reset: '\\x1b[0m',\n    error: '\\x1b[31m',\n    warn: '\\x1b[33m',\n    info: '\\x1b[36m',\n    debug: '\\x1b[32m',\n    verbose: '\\x1b[35m',\n    bold: '\\x1b[1m',\n    dim: '\\x1b[2m',\n  };\n\n  constructor() {\n    // Configurar nivel de log desde ENV (default: INFO en development, ERROR en production)\n    const logLevelString =\n      process.env.LOG_LEVEL ||\n      (process.env.NODE_ENV === 'production' ? 'ERROR' : 'INFO');\n    this.logLevel =\n      LogLevel[logLevelString.toUpperCase() as keyof typeof LogLevel] ??\n      LogLevel.INFO;\n\n    // Configurar m√≥dulos habilitados desde ENV\n    const enabledModulesString = process.env.LOG_MODULES || 'ALL';\n    this.enabledModules =\n      enabledModulesString === 'ALL'\n        ? new Set(['ALL'])\n        : new Set(enabledModulesString.split(',').map((m) => m.trim()));\n  }\n\n  /**\n   * Log de error - Siempre se muestra\n   */\n  error(message: string, trace?: string, context?: LogContext) {\n    if (this.shouldLog(LogLevel.ERROR, context?.module)) {\n      this.writeLog('ERROR', message, { trace, ...context });\n    }\n  }\n\n  /**\n   * Log de advertencia\n   */\n  warn(message: string, context?: LogContext) {\n    if (this.shouldLog(LogLevel.WARN, context?.module)) {\n      this.writeLog('WARN', message, context);\n    }\n  }\n\n  /**\n   * Log de informaci√≥n - Para eventos importantes\n   */\n  log(message: string, context?: LogContext) {\n    this.info(message, context);\n  }\n\n  info(message: string, context?: LogContext) {\n    if (this.shouldLog(LogLevel.INFO, context?.module)) {\n      this.writeLog('INFO', message, context);\n    }\n  }\n\n  /**\n   * Log de debug - Para desarrollo detallado\n   */\n  debug(message: string, context?: LogContext) {\n    if (this.shouldLog(LogLevel.DEBUG, context?.module)) {\n      this.writeLog('DEBUG', message, context);\n    }\n  }\n\n  /**\n   * Log verbose - Para m√°ximo detalle\n   */\n  verbose(message: string, context?: LogContext) {\n    if (this.shouldLog(LogLevel.VERBOSE, context?.module)) {\n      this.writeLog('VERBOSE', message, context);\n    }\n  }\n\n  /**\n   * M√©todos espec√≠ficos del dominio Coom√únity\n   */\n  auth(message: string, context?: LogContext) {\n    this.debug(`üîê AUTH: ${message}`, { module: 'AuthService', ...context });\n  }\n\n  rbac(message: string, context?: LogContext) {\n    this.debug(`üõ°Ô∏è RBAC: ${message}`, { module: 'RolesGuard', ...context });\n  }\n\n  database(message: string, context?: LogContext) {\n    this.debug(`üóÑÔ∏è DB: ${message}`, { module: 'PrismaService', ...context });\n  }\n\n  social(message: string, context?: LogContext) {\n    this.debug(`üë• SOCIAL: ${message}`, {\n      module: 'SocialService',\n      ...context,\n    });\n  }\n\n  marketplace(message: string, context?: LogContext) {\n    this.debug(`üõí MARKETPLACE: ${message}`, {\n      module: 'MarketplaceService',\n      ...context,\n    });\n  }\n\n  uplay(message: string, context?: LogContext) {\n    this.debug(`üéÆ √úPLAY: ${message}`, { module: 'UPlayService', ...context });\n  }\n\n  wallet(message: string, context?: LogContext) {\n    this.debug(`üí∞ WALLET: ${message}`, {\n      module: 'WalletService',\n      ...context,\n    });\n  }\n\n  reciprocidad(message: string, context?: LogContext) {\n    this.info(`üåø RECIPROCIDAD: ${message}`, {\n      module: 'ReciprocidadService',\n      ...context,\n    });\n  }\n\n  /**\n   * Log de performance para medir tiempos\n   */\n  performance(operation: string, duration: number, context?: LogContext) {\n    const color = duration > 1000 ? 'warn' : duration > 500 ? 'info' : 'debug';\n    const level =\n      duration > 1000\n        ? LogLevel.WARN\n        : duration > 500\n          ? LogLevel.INFO\n          : LogLevel.DEBUG;\n\n    if (this.shouldLog(level, context?.module)) {\n      this.writeLog(\n        level === LogLevel.WARN\n          ? 'WARN'\n          : level === LogLevel.INFO\n            ? 'INFO'\n            : 'DEBUG',\n        `‚ö° PERF: ${operation} took ${duration}ms`,\n        context\n      );\n    }\n  }\n\n  /**\n   * Log estructurado para eventos de negocio\n   */\n  business(event: string, data: LoggableData, context?: LogContext) {\n    this.info(`üìä BUSINESS: ${event}`, {\n      module: 'BusinessEvents',\n      event,\n      data: this.sanitizeData(data),\n      ...context,\n    });\n  }\n\n  /**\n   * Log de usuario para tracking de acciones\n   */\n  userAction(\n    userId: string,\n    action: string,\n    details?: LoggableData,\n    context?: LogContext\n  ) {\n    this.info(`üë§ USER: ${action}`, {\n      module: 'UserActions',\n      userId,\n      action,\n      details: this.sanitizeData(details),\n      ...context,\n    });\n  }\n\n  private shouldLog(level: LogLevel, module?: string): boolean {\n    // Verificar nivel de log\n    if (level > this.logLevel) {\n      return false;\n    }\n\n    // Verificar m√≥dulo habilitado\n    if (\n      module &&\n      !this.enabledModules.has('ALL') &&\n      !this.enabledModules.has(module)\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private writeLog(level: string, message: string, context?: LogContext) {\n    const timestamp = new Date().toISOString();\n    const color =\n      this.colors[level.toLowerCase() as keyof typeof this.colors] ||\n      this.colors.reset;\n    const reset = this.colors.reset;\n\n    // Formatear contexto\n    const contextStr = context ? this.formatContext(context) : '';\n\n    // Log colorizado para desarrollo\n    if (process.env.NODE_ENV !== 'production') {\n      console.log(\n        `${this.colors.dim}${timestamp}${reset} ` +\n          `${color}${this.colors.bold}[${level}]${reset} ` +\n          `${message}${contextStr}`\n      );\n    } else {\n      // Log JSON estructurado para producci√≥n\n      const logEntry = {\n        timestamp,\n        level,\n        message,\n        ...context,\n      };\n      console.log(JSON.stringify(logEntry));\n    }\n  }\n\n  private formatContext(context: LogContext): string {\n    const entries = Object.entries(context).filter(\n      ([key, value]) => value !== undefined\n    );\n    if (entries.length === 0) return '';\n\n    const formattedEntries = entries\n      .map(([key, value]) => `${key}=${this.formatValue(value)}`)\n      .join(', ');\n\n    return ` ${this.colors.dim}(${formattedEntries})${this.colors.reset}`;\n  }\n\n  private formatValue(value: unknown): string {\n    if (typeof value === 'string') return `\"${value}\"`;\n    if (typeof value === 'number' || typeof value === 'boolean')\n      return String(value);\n    if (value === null) return 'null';\n    if (value === undefined) return 'undefined';\n    if (Array.isArray(value)) return `[...${value.length}]`;\n    if (typeof value === 'object') return '{...}';\n    return 'unknown';\n  }\n\n  private sanitizeData(data: unknown): unknown {\n    if (typeof data !== 'object' || data === null) {\n      return data;\n    }\n\n    const seen = new WeakSet();\n    const sanitizeObject = (obj: Record<string, unknown>) => {\n      const newObj: Record<string, unknown> = {};\n      for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          const value = obj[key];\n          if (typeof value === 'object' && value !== null) {\n            if (seen.has(value)) {\n              continue; // Evitar referencia circular\n            }\n            seen.add(value);\n            newObj[key] = sanitizeObject(value as Record<string, unknown>);\n          } else {\n            newObj[key] = value;\n          }\n        }\n      }\n      return newObj;\n    };\n\n    return sanitizeObject(data as Record<string, unknown>);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/common/notifications/notification.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'healthReport' is defined but never used. Allowed unused args must match /^_/u.","line":474,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":474,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger } from '@nestjs/common';\nimport * as nodemailer from 'nodemailer';\nimport { IncomingWebhook } from '@slack/webhook';\n// Temporalmente importar desde monitoring hasta que movamos el DTO\nimport {\n  ConsistencyCheckResultDto,\n  HealthReportDto,\n} from '../../monitoring/dto/health-report.dto';\n\ninterface ReportContent {\n  subject: string;\n  text: string;\n  html: string;\n}\n\n@Injectable()\nexport class NotificationService {\n  private readonly logger = new Logger(NotificationService.name);\n  private emailTransporter: nodemailer.Transporter | null = null;\n  private slackWebhook: IncomingWebhook | null = null;\n\n  constructor() {\n    this.initializeEmailTransporter();\n    this.initializeSlackWebhook();\n  }\n\n  private initializeEmailTransporter() {\n    try {\n      const emailConfig = {\n        host: process.env.SMTP_HOST,\n        port: parseInt(process.env.SMTP_PORT || '587'),\n        secure: process.env.SMTP_SECURE === 'true',\n        auth: {\n          user: process.env.SMTP_USER,\n          pass: process.env.SMTP_PASS,\n        },\n      };\n\n      if (emailConfig.host && emailConfig.auth.user && emailConfig.auth.pass) {\n        this.emailTransporter = nodemailer.createTransport(emailConfig);\n        this.logger.log('Email transporter initialized successfully');\n      } else {\n        this.logger.warn(\n          'Email configuration incomplete - email alerts disabled'\n        );\n      }\n    } catch (error) {\n      this.logger.error('Failed to initialize email transporter:', error);\n    }\n  }\n\n  private initializeSlackWebhook() {\n    try {\n      const slackWebhookUrl = process.env.SLACK_WEBHOOK_URL;\n      if (slackWebhookUrl) {\n        this.slackWebhook = new IncomingWebhook(slackWebhookUrl);\n        this.logger.log('Slack webhook initialized successfully');\n      } else {\n        this.logger.warn(\n          'Slack webhook URL not configured - Slack alerts disabled'\n        );\n      }\n    } catch (error) {\n      this.logger.error('Failed to initialize Slack webhook:', error);\n    }\n  }\n\n  async sendConsistencyAlert(\n    checkResult: ConsistencyCheckResultDto\n  ): Promise<boolean> {\n    const threshold = parseInt(process.env.ALERT_THRESHOLD || '5');\n\n    if (checkResult.inconsistenciesFound < threshold) {\n      this.logger.log(\n        `Inconsistencies (${checkResult.inconsistenciesFound}) below threshold (${threshold}) - no alert sent`\n      );\n      return false;\n    }\n\n    const alertMessage = this.buildAlertMessage(checkResult);\n    let alertsSent = false;\n\n    // Send email alert\n    if (this.emailTransporter && process.env.ALERT_EMAIL_ENABLED === 'true') {\n      try {\n        await this.sendEmailAlert(alertMessage, checkResult);\n        alertsSent = true;\n        this.logger.log('Email alert sent successfully');\n      } catch (error) {\n        this.logger.error('Failed to send email alert:', error);\n      }\n    }\n\n    // Send Slack alert\n    if (this.slackWebhook && process.env.ALERT_SLACK_ENABLED === 'true') {\n      try {\n        await this.sendSlackAlert(alertMessage, checkResult);\n        alertsSent = true;\n        this.logger.log('Slack alert sent successfully');\n      } catch (error) {\n        this.logger.error('Failed to send Slack alert:', error);\n      }\n    }\n\n    return alertsSent;\n  }\n\n  private buildAlertMessage(checkResult: ConsistencyCheckResultDto): string {\n    const { inconsistenciesFound, totalVideos, problematicVideos } =\n      checkResult;\n\n    let message = `üö® GAMIFIER VIDEO ANALYTICS ALERT\\n\\n`;\n    message += `Consistency check completed at ${checkResult.timestamp}\\n`;\n    message += `Found ${inconsistenciesFound} inconsistencies out of ${totalVideos} videos checked\\n\\n`;\n\n    if (problematicVideos.length > 0) {\n      message += `Problematic videos:\\n`;\n      problematicVideos.slice(0, 10).forEach((video) => {\n        message += `- ID ${video.id}: ${video.title}\\n`;\n        message += `  Issue: ${video.issue}\\n`;\n        if (video.storedDuration !== null && video.actualDuration !== null) {\n          message += `  Stored: ${video.storedDuration}s, Actual: ${video.actualDuration}s\\n`;\n        }\n        message += `\\n`;\n      });\n\n      if (problematicVideos.length > 10) {\n        message += `... and ${problematicVideos.length - 10} more videos\\n`;\n      }\n    }\n\n    message += `\\nExecution time: ${checkResult.executionTime}ms\\n`;\n    message += `Please check the system dashboard for more details.`;\n\n    return message;\n  }\n\n  private async sendEmailAlert(\n    message: string,\n    checkResult: ConsistencyCheckResultDto\n  ): Promise<void> {\n    if (!this.emailTransporter) {\n      throw new Error('Email transporter not initialized');\n    }\n\n    const recipients = process.env.ALERT_EMAIL_RECIPIENTS?.split(',') || [];\n    if (recipients.length === 0) {\n      throw new Error('No email recipients configured');\n    }\n\n    const mailOptions = {\n      from: process.env.SMTP_FROM || process.env.SMTP_USER,\n      to: recipients.join(','),\n      subject: `üö® GAMIFIER Alert: ${checkResult.inconsistenciesFound} Video Inconsistencies Detected`,\n      text: message,\n      html: this.formatEmailHtml(message, checkResult),\n    };\n\n    await this.emailTransporter.sendMail(mailOptions);\n  }\n\n  private async sendSlackAlert(\n    message: string,\n    checkResult: ConsistencyCheckResultDto\n  ): Promise<void> {\n    if (!this.slackWebhook) {\n      throw new Error('Slack webhook not initialized');\n    }\n\n    const slackMessage = {\n      text: 'üö® GAMIFIER Video Analytics Alert',\n      blocks: [\n        {\n          type: 'header',\n          text: {\n            type: 'plain_text',\n            text: 'üö® GAMIFIER Video Analytics Alert',\n          },\n        },\n        {\n          type: 'section',\n          fields: [\n            {\n              type: 'mrkdwn',\n              text: `*Inconsistencies Found:* ${checkResult.inconsistenciesFound}`,\n            },\n            {\n              type: 'mrkdwn',\n              text: `*Total Videos Checked:* ${checkResult.totalVideos}`,\n            },\n            {\n              type: 'mrkdwn',\n              text: `*Execution Time:* ${checkResult.executionTime}ms`,\n            },\n            {\n              type: 'mrkdwn',\n              text: `*Timestamp:* ${checkResult.timestamp}`,\n            },\n          ],\n        },\n        {\n          type: 'section',\n          text: {\n            type: 'mrkdwn',\n            text: `*Top Issues:*\\n${checkResult.problematicVideos\n              .slice(0, 5)\n              .map((v) => `‚Ä¢ ID ${v.id}: ${v.title} - ${v.issue}`)\n              .join('\\n')}`,\n          },\n        },\n      ],\n    };\n\n    await this.slackWebhook.send(slackMessage);\n  }\n\n  private formatEmailHtml(\n    message: string,\n    checkResult: ConsistencyCheckResultDto\n  ): string {\n    return `\n      <html>\n        <body style=\"font-family: Arial, sans-serif; line-height: 1.6; color: #333;\">\n          <div style=\"max-width: 600px; margin: 0 auto; padding: 20px;\">\n            <h2 style=\"color: #d32f2f; border-bottom: 2px solid #d32f2f; padding-bottom: 10px;\">\n              üö® GAMIFIER Video Analytics Alert\n            </h2>\n\n            <div style=\"background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px; padding: 15px; margin: 20px 0;\">\n              <h3 style=\"margin-top: 0; color: #856404;\">Summary</h3>\n              <ul style=\"margin: 0;\">\n                <li><strong>Inconsistencies Found:</strong> ${checkResult.inconsistenciesFound}</li>\n                <li><strong>Total Videos Checked:</strong> ${checkResult.totalVideos}</li>\n                <li><strong>Execution Time:</strong> ${checkResult.executionTime}ms</li>\n                <li><strong>Timestamp:</strong> ${checkResult.timestamp}</li>\n              </ul>\n            </div>\n\n            ${\n              checkResult.problematicVideos.length > 0\n                ? `\n              <div style=\"background-color: #f8d7da; border: 1px solid #f5c6cb; border-radius: 5px; padding: 15px; margin: 20px 0;\">\n                <h3 style=\"margin-top: 0; color: #721c24;\">Problematic Videos</h3>\n                <ul>\n                  ${checkResult.problematicVideos\n                    .slice(0, 10)\n                    .map(\n                      (video) => `\n                    <li style=\"margin-bottom: 10px;\">\n                      <strong>ID ${video.id}:</strong> ${video.title}<br>\n                      <em>Issue:</em> ${video.issue}\n                      ${\n                        video.storedDuration !== null &&\n                        video.actualDuration !== null\n                          ? `<br><em>Duration:</em> Stored ${video.storedDuration}s, Actual ${video.actualDuration}s`\n                          : ''\n                      }\n                    </li>\n                  `\n                    )\n                    .join('')}\n                </ul>\n                ${\n                  checkResult.problematicVideos.length > 10\n                    ? `<p><em>... and ${checkResult.problematicVideos.length - 10} more videos</em></p>`\n                    : ''\n                }\n              </div>\n            `\n                : ''\n            }\n\n            <div style=\"background-color: #e7f3ff; border: 1px solid #b3d9ff; border-radius: 5px; padding: 15px; margin: 20px 0;\">\n              <p style=\"margin: 0;\"><strong>Action Required:</strong> Please check the system dashboard for more details and consider running the auto-correction process if appropriate.</p>\n            </div>\n\n            <hr style=\"border: none; border-top: 1px solid #eee; margin: 30px 0;\">\n            <p style=\"font-size: 12px; color: #666; text-align: center;\">\n              This is an automated alert from the GAMIFIER Video Analytics Monitoring System\n            </p>\n          </div>\n        </body>\n      </html>\n    `;\n  }\n\n  async testEmailConfiguration(): Promise<boolean> {\n    if (!this.emailTransporter) {\n      return false;\n    }\n\n    try {\n      await this.emailTransporter.verify();\n      return true;\n    } catch (error) {\n      this.logger.error('Email configuration test failed:', error);\n      return false;\n    }\n  }\n\n  async testSlackConfiguration(): Promise<boolean> {\n    if (!this.slackWebhook) {\n      return false;\n    }\n\n    try {\n      await this.slackWebhook.send({\n        text: '‚úÖ GAMIFIER Monitoring System - Test message',\n        blocks: [\n          {\n            type: 'section',\n            text: {\n              type: 'mrkdwn',\n              text: '‚úÖ *GAMIFIER Monitoring System*\\n\\nThis is a test message to verify Slack integration is working correctly.',\n            },\n          },\n        ],\n      });\n      return true;\n    } catch (error) {\n      this.logger.error('Slack configuration test failed:', error);\n      return false;\n    }\n  }\n\n  getAlertConfiguration() {\n    return {\n      emailEnabled: process.env.ALERT_EMAIL_ENABLED === 'true',\n      slackEnabled: process.env.ALERT_SLACK_ENABLED === 'true',\n      alertThreshold: parseInt(process.env.ALERT_THRESHOLD || '5'),\n      emailRecipients: process.env.ALERT_EMAIL_RECIPIENTS?.split(',') || [],\n      slackWebhookConfigured: !!process.env.SLACK_WEBHOOK_URL,\n      emailConfigured: !!this.emailTransporter,\n    };\n  }\n\n  /**\n   * Env√≠a un reporte de salud del sistema por email y/o Slack\n   */\n  async sendHealthReport(healthReport: HealthReportDto): Promise<boolean> {\n    this.logger.log('üìä Sending system health report...');\n\n    let emailSent = false;\n    let slackSent = false;\n\n    try {\n      // Generar contenido del reporte\n      const reportContent = this.generateHealthReportContent(healthReport);\n\n      // Enviar por email si est√° configurado\n      if (this.emailTransporter && process.env.ALERT_EMAIL_ENABLED === 'true') {\n        emailSent = await this.sendHealthReportEmail(\n          reportContent,\n          healthReport\n        );\n      }\n\n      // Enviar por Slack si est√° configurado\n      if (this.slackWebhook && process.env.ALERT_SLACK_ENABLED === 'true') {\n        slackSent = await this.sendHealthReportSlack(\n          reportContent,\n          healthReport\n        );\n      }\n\n      const success = emailSent || slackSent;\n      this.logger.log(\n        `Health report sent - Email: ${emailSent}, Slack: ${slackSent}`\n      );\n\n      return success;\n    } catch (error) {\n      this.logger.error('Failed to send health report:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Genera el contenido del reporte de salud\n   */\n  private generateHealthReportContent(\n    healthReport: HealthReportDto\n  ): ReportContent {\n    const statusEmoji = healthReport.status === 'healthy' ? '‚úÖ' : '‚ùå';\n    const subject = `${statusEmoji} GAMIFIER System Health Report - ${healthReport.timestamp}`;\n\n    const text = `\nGAMIFIER SYSTEM HEALTH REPORT\n=============================\n\nPeriod: ${healthReport.period}\nGenerated: ${new Date(healthReport.timestamp).toLocaleString()}\n\nCONSISTENCY CHECK\n-----------------\nTotal Videos: ${healthReport.consistencyCheck.totalVideos}\nInconsistencies Found: ${healthReport.consistencyCheck.inconsistenciesFound}\nExecution Time: ${healthReport.consistencyCheck.executionTime}ms\n\nPERFORMANCE METRICS\n-------------------\nAverage Calculation Time: ${Math.round(healthReport.performanceMetrics.averageCalculationTime)}ms\nTotal Calculations: ${healthReport.performanceMetrics.totalCalculations}\nCache Hit Ratio: ${Math.round(healthReport.performanceMetrics.cacheHitRatio)}%\nError Rate: ${Math.round(healthReport.performanceMetrics.errorRate)}%\n\nMETHOD DISTRIBUTION\n-------------------\nCache Hits: ${healthReport.performanceMetrics.methodDistribution.cache_hit}\nYouTube API: ${healthReport.performanceMetrics.methodDistribution.youtube_api}\nScraping: ${healthReport.performanceMetrics.methodDistribution.scraping}\nEstimation: ${healthReport.performanceMetrics.methodDistribution.estimation}\n\nERROR SUMMARY\n-------------\nTotal Errors: ${healthReport.errorSummary.totalErrors}\nCritical Errors: ${healthReport.errorSummary.criticalErrors}\n\nRECOMMENDATIONS\n---------------\n${healthReport.recommendations.map((rec: string, index: number) => `${index + 1}. ${rec}`).join('\\n')}\n\n---\nThis is an automated report from GAMIFIER Monitoring System.\n    `.trim();\n\n    const html = `\n      <div style=\"font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto;\">\n        <h1 style=\"color: #2c3e50; border-bottom: 2px solid #3498db;\">üè• GAMIFIER System Health Report</h1>\n\n        <div style=\"background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 20px 0;\">\n          <h3>Report Summary</h3>\n          <p><strong>Period:</strong> ${healthReport.period}</p>\n          <p><strong>Generated:</strong> ${new Date(healthReport.timestamp).toLocaleString()}</p>\n        </div>\n\n        <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n          <div style=\"background: #e8f5e8; padding: 15px; border-radius: 5px;\">\n            <h3 style=\"color: #27ae60;\">‚úÖ Consistency Check</h3>\n            <p><strong>Total Videos:</strong> ${healthReport.consistencyCheck.totalVideos}</p>\n            <p><strong>Inconsistencies:</strong> ${healthReport.consistencyCheck.inconsistenciesFound}</p>\n            <p><strong>Execution Time:</strong> ${healthReport.consistencyCheck.executionTime}ms</p>\n          </div>\n\n          <div style=\"background: #e8f4fd; padding: 15px; border-radius: 5px;\">\n            <h3 style=\"color: #3498db;\">‚ö° Performance</h3>\n            <p><strong>Avg Calculation Time:</strong> ${Math.round(healthReport.performanceMetrics.averageCalculationTime)}ms</p>\n            <p><strong>Cache Hit Ratio:</strong> ${Math.round(healthReport.performanceMetrics.cacheHitRatio)}%</p>\n            <p><strong>Error Rate:</strong> ${Math.round(healthReport.performanceMetrics.errorRate)}%</p>\n          </div>\n        </div>\n\n        <div style=\"background: #fff3cd; padding: 15px; border-radius: 5px; margin: 20px 0;\">\n          <h3 style=\"color: #856404;\">üîß Recommendations</h3>\n          <ol>\n            ${healthReport.recommendations.map((rec: string) => `<li>${rec}</li>`).join('')}\n          </ol>\n        </div>\n\n        <div style=\"background: #f8f9fa; padding: 10px; border-radius: 5px; margin: 20px 0; font-size: 12px; color: #6c757d;\">\n          <p>This is an automated report from GAMIFIER Monitoring System.</p>\n        </div>\n      </div>\n    `;\n\n    return { subject, text, html };\n  }\n\n  /**\n   * Env√≠a el reporte de salud por email\n   */\n  private async sendHealthReportEmail(\n    reportContent: ReportContent,\n    healthReport: HealthReportDto\n  ): Promise<boolean> {\n    try {\n      if (!this.emailTransporter) {\n        this.logger.warn('Email transporter not available');\n        return false;\n      }\n\n      const recipients = process.env.ALERT_EMAIL_RECIPIENTS?.split(',') || [];\n      if (recipients.length === 0) {\n        this.logger.warn('No email recipients configured');\n        return false;\n      }\n\n      const mailOptions = {\n        from: process.env.SMTP_FROM || process.env.SMTP_USER,\n        to: recipients.join(','),\n        subject: reportContent.subject,\n        text: reportContent.text,\n        html: reportContent.html,\n      };\n\n      await this.emailTransporter.sendMail(mailOptions);\n      this.logger.log(\n        `Health report email sent to ${recipients.length} recipients`\n      );\n      return true;\n    } catch (error) {\n      this.logger.error('Failed to send health report email:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Env√≠a el reporte de salud por Slack\n   */\n  private async sendHealthReportSlack(\n    reportContent: ReportContent,\n    healthReport: HealthReportDto\n  ): Promise<boolean> {\n    try {\n      if (!this.slackWebhook) {\n        this.logger.warn('Slack webhook not available');\n        return false;\n      }\n\n      const { consistencyCheck, performanceMetrics, errorSummary } =\n        healthReport;\n\n      // Determinar color basado en el estado del sistema\n      let color = '#36a64f'; // Verde por defecto\n      if (\n        errorSummary.criticalErrors > 0 ||\n        consistencyCheck.inconsistenciesFound > 10\n      ) {\n        color = '#ff0000'; // Rojo para problemas cr√≠ticos\n      } else if (\n        performanceMetrics.errorRate > 5 ||\n        performanceMetrics.cacheHitRatio < 50\n      ) {\n        color = '#ffaa00'; // Amarillo para advertencias\n      }\n\n      const slackMessage = {\n        text: `üè• GAMIFIER ${healthReport.period.toUpperCase()} Health Report`,\n        attachments: [\n          {\n            color,\n            fields: [\n              {\n                title: 'Consistency Check',\n                value: `${consistencyCheck.inconsistenciesFound} issues found in ${consistencyCheck.totalVideos} videos`,\n                short: true,\n              },\n              {\n                title: 'Performance',\n                value: `${Math.round(performanceMetrics.cacheHitRatio)}% cache hit ratio, ${Math.round(performanceMetrics.errorRate)}% error rate`,\n                short: true,\n              },\n              {\n                title: 'Errors',\n                value: `${errorSummary.totalErrors} total, ${errorSummary.criticalErrors} critical`,\n                short: true,\n              },\n              {\n                title: 'Recommendations',\n                value: healthReport.recommendations.slice(0, 3).join('\\n‚Ä¢ '),\n                short: false,\n              },\n            ],\n            footer: 'GAMIFIER Monitoring System',\n            ts: (new Date(healthReport.timestamp).getTime() / 1000).toString(),\n          },\n        ],\n      };\n\n      await this.slackWebhook.send(slackMessage);\n      this.logger.log('Health report sent to Slack');\n      return true;\n    } catch (error) {\n      this.logger.error('Failed to send health report to Slack:', error);\n      return false;\n    }\n  }\n\n  /**\n   * M√©todo adicional para enviar alertas de validaci√≥n de preguntas\n   */\n  async sendQuestionValidationAlert(\n    message: string,\n    details: Record<string, unknown>\n  ): Promise<boolean> {\n    this.logger.log('üìã Sending question validation alert...');\n\n    let alertsSent = false;\n\n    // Enviar por email si est√° configurado\n    if (this.emailTransporter && process.env.ALERT_EMAIL_ENABLED === 'true') {\n      try {\n        const recipients = process.env.ALERT_EMAIL_RECIPIENTS?.split(',') || [];\n        if (recipients.length > 0) {\n          await this.emailTransporter.sendMail({\n            from: process.env.SMTP_FROM || process.env.SMTP_USER,\n            to: recipients.join(','),\n            subject: 'üîç GAMIFIER Question Validation Alert',\n            text: message,\n            html: `<div style=\"font-family: Arial, sans-serif;\">\n              <h2>üîç Question Validation Alert</h2>\n              <pre>${message}</pre>\n              <hr>\n              <p>Details:</p>\n              <pre>${JSON.stringify(details, null, 2)}</pre>\n            </div>`,\n          });\n          alertsSent = true;\n          this.logger.log('Question validation email alert sent');\n        }\n      } catch (error) {\n        this.logger.error(\n          'Failed to send question validation email alert:',\n          error\n        );\n      }\n    }\n\n    // Enviar por Slack si est√° configurado\n    if (this.slackWebhook && process.env.ALERT_SLACK_ENABLED === 'true') {\n      try {\n        await this.slackWebhook.send({\n          text: 'üîç GAMIFIER Question Validation Alert',\n          blocks: [\n            {\n              type: 'section',\n              text: {\n                type: 'mrkdwn',\n                text: message,\n              },\n            },\n          ],\n        });\n        alertsSent = true;\n        this.logger.log('Question validation Slack alert sent');\n      } catch (error) {\n        this.logger.error(\n          'Failed to send question validation Slack alert:',\n          error\n        );\n      }\n    }\n\n    return alertsSent;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/common/validation/question-validation.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Question' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ActivityQuestion' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":19}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger, Inject } from '@nestjs/common';\nimport { PrismaService } from '../../prisma/prisma.service';\nimport { VideoItemsService } from '../../video-items/video-items.service';\nimport { NotificationService } from '../notifications/notification.service';\nimport type {\n  Question,\n  ActivityQuestion,\n  VideoItem,\n} from '../../generated/prisma';\n\nexport interface QuestionValidationResult {\n  questionId: string | number;\n  questionType: 'video_question' | 'activity_question';\n  videoItemId: number;\n  videoTitle: string;\n  videoDuration: number | null;\n  questionTimestamp: number;\n  isValid: boolean;\n  issue?: string;\n  severity: 'warning' | 'error';\n}\n\nexport interface ValidationSummary {\n  totalQuestionsChecked: number;\n  validQuestions: number;\n  invalidQuestions: number;\n  questionsWithoutVideoDuration: number;\n  validationResults: QuestionValidationResult[];\n  executionTime: number;\n  timestamp: string;\n}\n\n@Injectable()\nexport class QuestionValidationService {\n  private readonly logger = new Logger(QuestionValidationService.name);\n\n  constructor(\n    @Inject(PrismaService) private readonly prisma: PrismaService,\n    @Inject(VideoItemsService)\n    private readonly videoItemsService: VideoItemsService,\n    @Inject(NotificationService)\n    private readonly notificationService: NotificationService\n  ) {\n    this.logger.log(\n      'QuestionValidationService initialized with NotificationService'\n    );\n  }\n\n  /**\n   * Valida los timestamps de todas las preguntas de un video espec√≠fico\n   */\n  async validateQuestionTimestamps(\n    videoItemId: number\n  ): Promise<QuestionValidationResult[]> {\n    this.logger.log(`Validating question timestamps for video ${videoItemId}`);\n\n    try {\n      // Obtener el video y su duraci√≥n\n      const videoItem = await this.videoItemsService.findOne(videoItemId);\n      if (!videoItem) {\n        throw new Error(`Video item ${videoItemId} not found`);\n      }\n\n      const results: QuestionValidationResult[] = [];\n\n      // Validar preguntas de VideoItem (tabla questions)\n      const videoQuestions = await this.prisma.question.findMany({\n        where: {\n          videoItemId,\n          isActive: true,\n        },\n        orderBy: { timestamp: 'asc' },\n      });\n\n      for (const question of videoQuestions) {\n        const validationResult = this.validateSingleQuestion(\n          question.id,\n          'video_question',\n          videoItem,\n          question.timestamp,\n          question.endTimestamp\n        );\n        results.push(validationResult);\n      }\n\n      // Validar preguntas de Activity que referencian este video\n      const activities = await this.prisma.activity.findMany({\n        where: { videoItemId },\n        include: { questions: true },\n      });\n\n      for (const activity of activities) {\n        for (const activityQuestion of activity.questions) {\n          if (activityQuestion.displayTimeSeconds !== null) {\n            const validationResult = this.validateSingleQuestion(\n              activityQuestion.id,\n              'activity_question',\n              videoItem,\n              activityQuestion.displayTimeSeconds,\n              activityQuestion.optionalDisplaySeconds\n            );\n            results.push(validationResult);\n          }\n        }\n      }\n\n      this.logger.log(\n        `Validation completed for video ${videoItemId}: ${results.length} questions checked`\n      );\n      return results;\n    } catch (error) {\n      this.logger.error(\n        `Error validating questions for video ${videoItemId}:`,\n        error\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Valida los timestamps de todas las preguntas en el sistema\n   */\n  async validateAllQuestionTimestamps(): Promise<ValidationSummary> {\n    const startTime = Date.now();\n    this.logger.log(\n      'Starting validation of all question timestamps in the system'\n    );\n\n    try {\n      const allResults: QuestionValidationResult[] = [];\n\n      // Obtener todos los videos con preguntas\n      const videosWithQuestions = await this.prisma.videoItem.findMany({\n        where: {\n          isActive: true,\n          isDeleted: { not: true },\n          OR: [\n            { questions: { some: { isActive: true } } },\n            { activities: { some: { questions: { some: {} } } } },\n          ],\n        },\n        select: { id: true },\n      });\n\n      this.logger.log(\n        `Found ${videosWithQuestions.length} videos with questions to validate`\n      );\n\n      // Validar cada video\n      for (const video of videosWithQuestions) {\n        try {\n          const videoResults = await this.validateQuestionTimestamps(video.id);\n          allResults.push(...videoResults);\n        } catch (error) {\n          this.logger.error(`Error validating video ${video.id}:`, error);\n          // Continuar con el siguiente video\n        }\n      }\n\n      const executionTime = Date.now() - startTime;\n      const invalidQuestions = allResults.filter((r) => !r.isValid);\n      const questionsWithoutDuration = allResults.filter(\n        (r) => r.videoDuration === null\n      );\n\n      const summary: ValidationSummary = {\n        totalQuestionsChecked: allResults.length,\n        validQuestions: allResults.length - invalidQuestions.length,\n        invalidQuestions: invalidQuestions.length,\n        questionsWithoutVideoDuration: questionsWithoutDuration.length,\n        validationResults: allResults,\n        executionTime,\n        timestamp: new Date().toISOString(),\n      };\n\n      this.logger.log(\n        `Validation summary: ${summary.validQuestions}/${summary.totalQuestionsChecked} valid questions`\n      );\n\n      // Enviar alerta si hay problemas significativos\n      if (invalidQuestions.length > 0) {\n        await this.sendQuestionValidationAlert(summary);\n      }\n\n      return summary;\n    } catch (error) {\n      this.logger.error('Error during global question validation:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Valida una pregunta individual\n   */\n  private validateSingleQuestion(\n    questionId: string | number,\n    questionType: 'video_question' | 'activity_question',\n    videoItem: VideoItem,\n    timestamp: number,\n    endTimestamp?: number | null\n  ): QuestionValidationResult {\n    const result: QuestionValidationResult = {\n      questionId,\n      questionType,\n      videoItemId: videoItem.id,\n      videoTitle: videoItem.title,\n      videoDuration: videoItem.duration,\n      questionTimestamp: timestamp,\n      isValid: true,\n      severity: 'warning',\n    };\n\n    // Si el video no tiene duraci√≥n, no podemos validar\n    if (!videoItem.duration) {\n      result.isValid = false;\n      result.issue =\n        'Video duration not available - cannot validate question timestamp';\n      result.severity = 'warning';\n      return result;\n    }\n\n    // Validar timestamp de inicio\n    if (timestamp > videoItem.duration) {\n      result.isValid = false;\n      result.issue = `Question start time (${timestamp}s) exceeds video duration (${videoItem.duration}s)`;\n      result.severity = 'error';\n      return result;\n    }\n\n    // Validar timestamp de fin si existe\n    if (endTimestamp && endTimestamp > videoItem.duration) {\n      result.isValid = false;\n      result.issue = `Question end time (${endTimestamp}s) exceeds video duration (${videoItem.duration}s)`;\n      result.severity = 'error';\n      return result;\n    }\n\n    // Validar que el timestamp de fin sea mayor que el de inicio\n    if (endTimestamp && endTimestamp <= timestamp) {\n      result.isValid = false;\n      result.issue = `Question end time (${endTimestamp}s) must be greater than start time (${timestamp}s)`;\n      result.severity = 'error';\n      return result;\n    }\n\n    // Advertencia si la pregunta aparece muy cerca del final del video\n    const timeFromEnd = videoItem.duration - timestamp;\n    if (timeFromEnd < 10) {\n      // Menos de 10 segundos del final\n      result.issue = `Question appears very close to video end (${timeFromEnd}s remaining)`;\n      result.severity = 'warning';\n    }\n\n    return result;\n  }\n\n  /**\n   * Valida una pregunta antes de crearla o actualizarla\n   */\n  async validateQuestionBeforeSave(\n    videoItemId: number,\n    timestamp: number,\n    endTimestamp?: number\n  ): Promise<{ isValid: boolean; error?: string }> {\n    try {\n      const videoItem = await this.videoItemsService.findOne(videoItemId);\n      if (!videoItem) {\n        return { isValid: false, error: `Video item ${videoItemId} not found` };\n      }\n\n      const validationResult = this.validateSingleQuestion(\n        'temp',\n        'video_question',\n        videoItem,\n        timestamp,\n        endTimestamp\n      );\n\n      if (!validationResult.isValid && validationResult.severity === 'error') {\n        return { isValid: false, error: validationResult.issue };\n      }\n\n      return { isValid: true };\n    } catch (error) {\n      this.logger.error('Error validating question before save:', error);\n      return { isValid: false, error: 'Validation error occurred' };\n    }\n  }\n\n  /**\n   * Env√≠a una alerta cuando se detectan problemas de validaci√≥n\n   */\n  private async sendQuestionValidationAlert(\n    summary: ValidationSummary\n  ): Promise<void> {\n    try {\n      const threshold = parseInt(\n        process.env.QUESTION_VALIDATION_ALERT_THRESHOLD || '5'\n      );\n\n      if (summary.invalidQuestions < threshold) {\n        this.logger.log(\n          `Invalid questions (${summary.invalidQuestions}) below threshold (${threshold}) - no alert sent`\n        );\n        return;\n      }\n\n      const alertMessage = this.buildQuestionValidationAlertMessage(summary);\n\n      // Usar el NotificationService para enviar la alerta\n      const alertSent =\n        await this.notificationService.sendQuestionValidationAlert(\n          alertMessage,\n          {\n            totalQuestionsChecked: summary.totalQuestionsChecked,\n            invalidQuestions: summary.invalidQuestions,\n            questionsWithoutVideoDuration:\n              summary.questionsWithoutVideoDuration,\n            executionTime: summary.executionTime,\n          }\n        );\n\n      if (alertSent) {\n        this.logger.log('Question validation alert sent successfully');\n      } else {\n        this.logger.warn('Question validation alert was not sent');\n      }\n    } catch (error) {\n      this.logger.error('Error sending question validation alert:', error);\n    }\n  }\n\n  /**\n   * Construye el mensaje de alerta para problemas de validaci√≥n\n   */\n  private buildQuestionValidationAlertMessage(\n    summary: ValidationSummary\n  ): string {\n    const invalidResults = summary.validationResults.filter((r) => !r.isValid);\n\n    let message = `üö® GAMIFIER Question Validation Alert\\n\\n`;\n    message += `Validation Summary:\\n`;\n    message += `- Total Questions Checked: ${summary.totalQuestionsChecked}\\n`;\n    message += `- Invalid Questions Found: ${summary.invalidQuestions}\\n`;\n    message += `- Questions Without Video Duration: ${summary.questionsWithoutVideoDuration}\\n`;\n    message += `- Execution Time: ${summary.executionTime}ms\\n`;\n    message += `- Timestamp: ${summary.timestamp}\\n\\n`;\n\n    if (invalidResults.length > 0) {\n      message += `Top Invalid Questions:\\n`;\n      invalidResults.slice(0, 10).forEach((result, index) => {\n        message += `${index + 1}. ${result.questionType} ID ${result.questionId}\\n`;\n        message += `   Video: \"${result.videoTitle}\" (ID: ${result.videoItemId})\\n`;\n        message += `   Issue: ${result.issue}\\n`;\n        message += `   Timestamp: ${result.questionTimestamp}s, Video Duration: ${result.videoDuration}s\\n\\n`;\n      });\n\n      if (invalidResults.length > 10) {\n        message += `... and ${invalidResults.length - 10} more invalid questions\\n\\n`;\n      }\n    }\n\n    message += `Please review the question timestamps and video durations to ensure consistency.\\n`;\n\n    return message;\n  }\n\n  /**\n   * Obtiene estad√≠sticas de validaci√≥n para el dashboard\n   */\n  async getValidationStats(): Promise<{\n    totalQuestions: number;\n    questionsWithValidTimestamps: number;\n    questionsWithInvalidTimestamps: number;\n    videosWithoutDuration: number;\n    lastValidationRun: string | null;\n  }> {\n    try {\n      // Contar preguntas de VideoItem\n      const videoQuestions = await this.prisma.question.count({\n        where: { isActive: true },\n      });\n\n      // Contar preguntas de Activity\n      const activityQuestions = await this.prisma.activityQuestion.count();\n\n      // Contar videos sin duraci√≥n que tienen preguntas\n      const videosWithoutDuration = await this.prisma.videoItem.count({\n        where: {\n          duration: null,\n          isActive: true,\n          isDeleted: { not: true },\n          OR: [\n            { questions: { some: { isActive: true } } },\n            { activities: { some: { questions: { some: {} } } } },\n          ],\n        },\n      });\n\n      return {\n        totalQuestions: videoQuestions + activityQuestions,\n        questionsWithValidTimestamps: 0, // Se calcular√° en la pr√≥xima validaci√≥n completa\n        questionsWithInvalidTimestamps: 0, // Se calcular√° en la pr√≥xima validaci√≥n completa\n        videosWithoutDuration,\n        lastValidationRun: null, // Se actualizar√° cuando se implemente el almacenamiento de resultados\n      };\n    } catch (error) {\n      this.logger.error('Error getting validation stats:', error);\n      throw error;\n    }\n  }\n\n  async validateQuestionConsistency(videoItemId: number): Promise<void> {\n    const questions = await this.prisma.question.findMany({\n      where: { videoItemId, isActive: true },\n    });\n\n    // Validaciones b√°sicas\n    if (questions.length === 0) {\n      this.logger.log(`No questions found for video ${videoItemId}`);\n      // Opcionalmente enviar una notificaci√≥n\n      await this.notificationService.sendQuestionValidationAlert(\n        `No questions found for video ${videoItemId}`,\n        { videoItemId }\n      );\n      return;\n    }\n\n    // M√°s validaciones pueden ir aqu√≠\n    this.logger.log(`Questions validation completed for video ${videoItemId}`);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/console/stages/stages.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'StageConfigurationDto' is defined but never used. Allowed unused vars must match /^_/u.","line":30,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'StageAnalyticsDto' is defined but never used. Allowed unused vars must match /^_/u.","line":31,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UserProgressionDto' is defined but never used. Allowed unused vars must match /^_/u.","line":32,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ProgressActionResultDto' is defined but never used. Allowed unused vars must match /^_/u.","line":33,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":26}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * üé≠ Stages Controller - Customer Journey Management\n *\n * Controller para gesti√≥n de los 4 STAGES del customer journey\n * (BUYER ‚Üí SEEKER ‚Üí SOLVER ‚Üí PROMOTER)\n */\n\nimport {\n  Controller,\n  Get,\n  Put,\n  Post,\n  Param,\n  Body,\n  UseGuards,\n  Request,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiBearerAuth,\n  ApiOperation,\n  ApiResponse,\n} from '@nestjs/swagger';\nimport { StagesService } from './stages.service';\nimport { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';\nimport { RolesGuard } from '@/rbac/guards/roles.guard';\nimport { Roles } from '@/rbac/decorators/roles.decorator';\nimport { UpdateStageDto } from './dto/update-stage.dto';\nimport {\n  StageConfigurationDto,\n  StageAnalyticsDto,\n  UserProgressionDto,\n  ProgressActionResultDto,\n} from './dto/stage-response.dto';\nimport { AuthenticatedRequest } from '../../types/auth.types';\n\n@ApiTags('stages')\n@Controller('console/stages')\n@UseGuards(JwtAuthGuard, RolesGuard)\n@ApiBearerAuth()\nexport class StagesController {\n  constructor(private readonly stagesService: StagesService) {}\n\n  /**\n   * üìä Get all stages with analytics\n   */\n  @Get()\n  @Roles('admin', 'moderator')\n  @ApiOperation({\n    summary: 'Obtener todos los stages con m√©tricas',\n    description: 'Lista completa de stages del customer journey con analytics',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Lista de stages con m√©tricas',\n    schema: { type: 'object', additionalProperties: true },\n  })\n  async getAllStages(): Promise<unknown> {\n    return this.stagesService.getAllStages();\n  }\n\n  /**\n   * üîç Get specific stage data\n   */\n  @Get(':stageId')\n  @Roles('admin', 'moderator')\n  @ApiOperation({\n    summary: 'Obtener datos espec√≠ficos de un stage',\n    description: 'Informaci√≥n detallada de un stage espec√≠fico',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Datos del stage solicitado',\n    schema: { type: 'object', additionalProperties: true },\n  })\n  async getStageById(@Param('stageId') stageId: string): Promise<unknown> {\n    return this.stagesService.getStageById(stageId);\n  }\n\n  /**\n   * ‚úèÔ∏è Update stage configuration\n   */\n  @Put(':stageId')\n  @Roles('admin')\n  @ApiOperation({\n    summary: 'Actualizar configuraci√≥n de stage',\n    description: 'Modificar la configuraci√≥n de un stage espec√≠fico',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Stage actualizado exitosamente',\n    schema: { type: 'object', additionalProperties: true },\n  })\n  async updateStage(\n    @Param('stageId') stageId: string,\n    @Body() data: UpdateStageDto\n  ): Promise<unknown> {\n    return this.stagesService.updateStage(stageId, data);\n  }\n\n  /**\n   * üìà Get stage analytics\n   */\n  @Get(':stageId/analytics')\n  @Roles('admin', 'moderator')\n  @ApiOperation({\n    summary: 'Obtener analytics de un stage',\n    description: 'M√©tricas detalladas y analytics de un stage espec√≠fico',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Analytics del stage',\n    schema: { type: 'object', additionalProperties: true },\n  })\n  async getStageAnalytics(@Param('stageId') stageId: string): Promise<unknown> {\n    return this.stagesService.getStageAnalytics(stageId);\n  }\n\n  /**\n   * üéØ Check user progression status\n   */\n  @Get('user/:userId/progression')\n  @Roles('admin', 'moderator')\n  @ApiOperation({\n    summary: 'Verificar progresi√≥n de un usuario espec√≠fico',\n    description: 'Estado de progresi√≥n de un usuario en el customer journey',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Estado de progresi√≥n del usuario',\n    schema: { type: 'object', additionalProperties: true },\n  })\n  async checkUserProgression(\n    @Param('userId') userId: string\n  ): Promise<unknown> {\n    return this.stagesService.checkUserProgression(userId);\n  }\n\n  /**\n   * ‚¨ÜÔ∏è Progress user to next stage\n   */\n  @Post('user/:userId/progress')\n  @Roles('admin')\n  @ApiOperation({\n    summary: 'Progresar usuario al siguiente stage',\n    description: 'Mover un usuario al siguiente stage del customer journey',\n  })\n  @ApiResponse({\n    status: 201,\n    description: 'Usuario progresado exitosamente',\n    schema: { type: 'object', additionalProperties: true },\n  })\n  async progressUser(@Param('userId') userId: string): Promise<unknown> {\n    return this.stagesService.progressUserToNextStage(userId);\n  }\n\n  /**\n   * üë§ Check current user's progression (for user-facing endpoints)\n   */\n  @Get('me/progression')\n  @Roles('user', 'admin', 'moderator')\n  @ApiOperation({\n    summary: 'Verificar progresi√≥n del usuario actual',\n    description:\n      'Estado de progresi√≥n del usuario autenticado en el customer journey',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Estado de progresi√≥n del usuario actual',\n    schema: { type: 'object', additionalProperties: true },\n  })\n  async checkMyProgression(\n    @Request() req: AuthenticatedRequest\n  ): Promise<unknown> {\n    return this.stagesService.checkUserProgression(req.user.sub);\n  }\n\n  /**\n   * üöÄ Progress current user to next stage (self-service)\n   */\n  @Post('me/progress')\n  @Roles('user', 'admin', 'moderator')\n  @ApiOperation({\n    summary: 'Auto-progresar al siguiente stage',\n    description:\n      'Permitir al usuario progresarse a s√≠ mismo al siguiente stage',\n  })\n  @ApiResponse({\n    status: 201,\n    description: 'Usuario progresado exitosamente',\n    schema: { type: 'object', additionalProperties: true },\n  })\n  async progressMe(@Request() req: AuthenticatedRequest): Promise<unknown> {\n    return this.stagesService.progressUserToNextStage(req.user.sub);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/console/stages/stages.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'currentProgress' is defined but never used. Allowed unused args must match /^_/u.","line":617,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":617,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'currentStage' is defined but never used. Allowed unused args must match /^_/u.","line":628,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":628,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":769,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":769,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'stage' is defined but never used. Allowed unused args must match /^_/u.","line":774,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":774,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'stage' is defined but never used. Allowed unused args must match /^_/u.","line":779,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":779,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'stage' is defined but never used. Allowed unused args must match /^_/u.","line":793,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":793,"endColumn":10}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * üé≠ Stages Service - Customer Journey Management\n *\n * Servicio para gesti√≥n de los 4 STAGES del customer journey\n * Implementa la l√≥gica completa de progresi√≥n BUYER ‚Üí SEEKER ‚Üí SOLVER ‚Üí PROMOTER\n *\n * üîÑ ENHANCED VERSION - Real Database Integration + Advanced Analytics\n */\n\nimport {\n  Injectable,\n  NotFoundException,\n  BadRequestException,\n  Logger,\n} from '@nestjs/common';\nimport { PrismaService } from '../../prisma/prisma.service';\nimport { UpdateStageDto } from './dto/update-stage.dto';\nimport { CustomerJourneyStage } from '../../../src/generated/prisma';\n\n// Re-export for controller use\nexport { CustomerJourneyStage };\n\n// Tipos espec√≠ficos para la purificaci√≥n alqu√≠mica\ninterface UserWithProgress {\n  id: string;\n  stageStartedAt?: Date;\n  merits?: MeritAmount[];\n  transactionsFrom?: unknown[];\n  transactionsTo?: unknown[];\n}\n\ninterface MeritAmount {\n  amount: number;\n}\n\ninterface StageDataResult {\n  id: CustomerJourneyStage;\n  metrics: StageMetrics;\n  name: string;\n  description: string;\n  icon: string;\n  color: string;\n  philosophyAlignment: 'reciprocidad' | 'bien_comun' | 'metanoia';\n}\n\nexport interface StageMetrics {\n  totalUsers: number;\n  newThisWeek: number;\n  conversionRate: number;\n  averageTimeInStage: number; // d√≠as\n  topActivities: string[];\n  completionRate: number;\n  activeProgressions: number;\n  averageCompletionTime: number;\n  dropoffRate: number;\n  weeklyGrowth: number;\n  engagementScore: number;\n}\n\nexport interface StageRequirements {\n  minimumMeritos?: number;\n  minimumOndas?: number;\n  minimumTransactions?: number;\n  minimumSessions?: number;\n  requiredActivities?: string[];\n  timeInCurrentStage?: number; // d√≠as m√≠nimos\n  trustVotesRequired?: number;\n  minimumScore?: number;\n}\n\nexport interface ProgressionResult {\n  canProgress: boolean;\n  nextStage?: CustomerJourneyStage;\n  missingRequirements: string[];\n  currentProgress: Record<string, number>;\n  completionPercentage: number;\n  estimatedTimeToProgression: number; // d√≠as\n  recommendations: string[];\n}\n\nexport interface StageAnalytics {\n  stage: CustomerJourneyStage;\n  metrics: StageMetrics;\n  userDistribution: Record<string, number>;\n  progressionTrends: Array<{ date: string; value: number }>;\n  topExitPoints: string[];\n  successFactors: string[];\n  optimizationSuggestions: string[];\n}\n\n@Injectable()\nexport class StagesService {\n  private readonly logger = new Logger(StagesService.name);\n\n  constructor(private readonly prisma: PrismaService) {}\n\n  /**\n   * üîç Get all stage configurations with comprehensive analytics\n   */\n  async getAllStages() {\n    this.logger.log('Fetching all stages with comprehensive analytics...');\n\n    try {\n      const [stageData, overallMetrics] = await Promise.all([\n        Promise.all([\n          this.getStageData('BUYER'),\n          this.getStageData('SEEKER'),\n          this.getStageData('SOLVER'),\n          this.getStageData('PROMOTER'),\n        ]),\n        this.calculateOverallMetrics(),\n      ]);\n\n      const conversionFunnel = this.calculateConversionFunnel(stageData);\n      const stageProgression = this.calculateStageProgression(stageData);\n\n      return {\n        stages: stageData,\n        totalUsers: overallMetrics.totalUsers,\n        conversionFunnel,\n        stageProgression,\n        overallMetrics,\n        timestamp: new Date().toISOString(),\n      };\n    } catch (error) {\n      this.logger.error('Error fetching stages data:', error);\n      throw new BadRequestException('Failed to fetch stages data');\n    }\n  }\n\n  /**\n   * üìä Get comprehensive data for a specific stage\n   */\n  async getStageData(stage: CustomerJourneyStage) {\n    this.logger.log(`Fetching comprehensive data for stage: ${stage}`);\n\n    try {\n      const [metrics, requirements, activities, progressions] =\n        await Promise.all([\n          this.calculateRealStageMetrics(stage),\n          this.getStageRequirements(stage),\n          this.getStageActivities(stage),\n          this.getActiveProgressions(stage),\n        ]);\n\n      const nextStage = this.getNextStage(stage);\n      const rewards = this.getStageRewards(stage);\n\n      return {\n        id: stage,\n        name: this.getStageName(stage),\n        description: this.getStageDescription(stage),\n        icon: this.getStageIcon(stage),\n        color: this.getStageColor(stage),\n        philosophyAlignment: this.getPhilosophyAlignment(stage),\n        metrics,\n        requirements,\n        nextStage,\n        activities,\n        rewards,\n        progressions,\n        isActive: true,\n        configuration: {\n          timeLimit: this.getStageTimeLimit(stage),\n          autoProgression: this.hasAutoProgression(stage),\n          validationRequired: this.requiresValidation(stage),\n        },\n      };\n    } catch (error) {\n      this.logger.error(`Error fetching data for stage ${stage}:`, error);\n      throw new NotFoundException(`Stage ${stage} data not found`);\n    }\n  }\n\n  /**\n   * üìà Calculate real metrics for a stage using database queries\n   */\n  private async calculateRealStageMetrics(\n    stage: CustomerJourneyStage\n  ): Promise<StageMetrics> {\n    this.logger.log(`Calculating real metrics for stage: ${stage}`);\n\n    try {\n      // Get users currently in this stage\n      const currentUsers = await this.prisma.user.count({\n        where: { currentStage: stage },\n      });\n\n      // Get users who progressed to this stage in the last week\n      const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);\n      const newThisWeek = await this.prisma.user.count({\n        where: {\n          currentStage: stage,\n          stageStartedAt: { gte: oneWeekAgo },\n        },\n      });\n\n      // Get active stage progressions\n      const activeProgressions = await this.prisma.stageProgression.count({\n        where: {\n          stage,\n          isActive: true,\n        },\n      });\n\n      // Calculate average time in stage\n      const completedProgressions = await this.prisma.stageProgression.findMany(\n        {\n          where: {\n            stage,\n            completedAt: { not: null },\n          },\n          select: {\n            startedAt: true,\n            completedAt: true,\n          },\n        }\n      );\n\n      const averageTimeInStage =\n        completedProgressions.length > 0\n          ? completedProgressions.reduce((sum, p) => {\n              const duration = p.completedAt!.getTime() - p.startedAt.getTime();\n              return sum + duration / (1000 * 60 * 60 * 24); // Convert to days\n            }, 0) / completedProgressions.length\n          : 0;\n\n      // Calculate completion rate\n      const totalAttempts = await this.prisma.stageProgression.count({\n        where: { stage },\n      });\n      const completions = completedProgressions.length;\n      const completionRate =\n        totalAttempts > 0 ? (completions / totalAttempts) * 100 : 0;\n\n      // Calculate conversion rate to next stage\n      const nextStage = this.getNextStage(stage);\n      let conversionRate = 100; // Default for final stage\n\n      if (nextStage) {\n        const progressedToNext = await this.prisma.user.count({\n          where: { currentStage: nextStage },\n        });\n        conversionRate =\n          currentUsers > 0\n            ? (progressedToNext / (currentUsers + progressedToNext)) * 100\n            : 0;\n      }\n\n      // Calculate weekly growth\n      const twoWeeksAgo = new Date(Date.now() - 14 * 24 * 60 * 60 * 1000);\n      const previousWeekUsers = await this.prisma.user.count({\n        where: {\n          currentStage: stage,\n          stageStartedAt: {\n            gte: twoWeeksAgo,\n            lt: oneWeekAgo,\n          },\n        },\n      });\n      const weeklyGrowth =\n        previousWeekUsers > 0\n          ? ((newThisWeek - previousWeekUsers) / previousWeekUsers) * 100\n          : 0;\n\n      // Calculate engagement score (mock for now - can be enhanced)\n      const engagementScore = Math.min(\n        100,\n        (completionRate + conversionRate) / 2\n      );\n\n      // Calculate dropoff rate\n      const dropoffRate = Math.max(0, 100 - completionRate);\n\n      return {\n        totalUsers: currentUsers,\n        newThisWeek,\n        conversionRate: Math.round(conversionRate * 100) / 100,\n        averageTimeInStage: Math.round(averageTimeInStage * 10) / 10,\n        topActivities: await this.getTopActivitiesForStage(stage),\n        completionRate: Math.round(completionRate * 100) / 100,\n        activeProgressions,\n        averageCompletionTime: Math.round(averageTimeInStage * 10) / 10,\n        dropoffRate: Math.round(dropoffRate * 100) / 100,\n        weeklyGrowth: Math.round(weeklyGrowth * 100) / 100,\n        engagementScore: Math.round(engagementScore * 100) / 100,\n      };\n    } catch (error) {\n      this.logger.error(`Error calculating metrics for stage ${stage}:`, error);\n      // Return fallback mock data if database query fails\n      return this.getMockStageMetrics(stage);\n    }\n  }\n\n  /**\n   * üéØ Enhanced user progression check with detailed analysis\n   */\n  async checkUserProgression(userId: string): Promise<ProgressionResult> {\n    this.logger.log(`Checking progression for user: ${userId}`);\n\n    try {\n      const user = await this.prisma.user.findUnique({\n        where: { id: userId },\n        include: {\n          merits: true,\n          transactionsFrom: true,\n          transactionsTo: true,\n        },\n      });\n\n      if (!user) {\n        throw new NotFoundException('User not found');\n      }\n\n      const currentStage = user.currentStage as CustomerJourneyStage;\n      const nextStage = this.getNextStage(currentStage);\n\n      if (!nextStage) {\n        return {\n          canProgress: false,\n          missingRequirements: [],\n          currentProgress: {},\n          completionPercentage: 100,\n          estimatedTimeToProgression: 0,\n          recommendations: ['¬°Has alcanzado el stage m√°ximo!'],\n        };\n      }\n\n      const requirements = this.getStageRequirements(nextStage);\n      const currentProgress = await this.calculateUserProgress(user);\n      const missingRequirements = this.checkMissingRequirements(\n        requirements,\n        currentProgress\n      );\n\n      const completionPercentage = this.calculateCompletionPercentage(\n        requirements,\n        currentProgress\n      );\n      const canProgress = missingRequirements.length === 0;\n\n      return {\n        canProgress,\n        nextStage,\n        missingRequirements,\n        currentProgress,\n        completionPercentage,\n        estimatedTimeToProgression: this.estimateTimeToProgression(\n          missingRequirements,\n          currentProgress\n        ),\n        recommendations: this.generateProgressionRecommendations(\n          missingRequirements,\n          currentStage\n        ),\n      };\n    } catch (error) {\n      this.logger.error(\n        `Error checking progression for user ${userId}:`,\n        error\n      );\n      throw new BadRequestException('Failed to check user progression');\n    }\n  }\n\n  /**\n   * ‚¨ÜÔ∏è Progress user to next stage with validation\n   */\n  async progressUserToNextStage(userId: string): Promise<{\n    success: boolean;\n    newStage?: CustomerJourneyStage;\n    message: string;\n    rewards?: Array<{ type: string; amount: number; description: string }>;\n  }> {\n    this.logger.log(`Attempting to progress user ${userId} to next stage`);\n\n    try {\n      const progressionCheck = await this.checkUserProgression(userId);\n\n      if (!progressionCheck.canProgress) {\n        return {\n          success: false,\n          message: `No puedes avanzar a√∫n. Requisitos faltantes: ${progressionCheck.missingRequirements.join(', ')}`,\n        };\n      }\n\n      const user = await this.prisma.user.findUnique({ where: { id: userId } });\n      if (!user) {\n        throw new NotFoundException('User not found');\n      }\n\n      const newStage = progressionCheck.nextStage!;\n\n      // Update user stage\n      await this.prisma.user.update({\n        where: { id: userId },\n        data: {\n          currentStage: newStage,\n          stageProgressedAt: new Date(),\n          stageStartedAt: new Date(),\n        },\n      });\n\n      // Create stage progression record\n      await this.prisma.stageProgression.create({\n        data: {\n          userId,\n          stage: newStage,\n          requirements: {},\n          metrics: {},\n          isActive: true,\n        },\n      });\n\n      // Complete previous stage progression\n      await this.prisma.stageProgression.updateMany({\n        where: {\n          userId,\n          stage: user.currentStage as CustomerJourneyStage,\n          isActive: true,\n        },\n        data: {\n          completedAt: new Date(),\n          isActive: false,\n        },\n      });\n\n      const rewards = this.getStageRewards(newStage);\n      const stageName = this.getStageName(newStage);\n\n      this.logger.log(`User ${userId} successfully progressed to ${newStage}`);\n\n      return {\n        success: true,\n        newStage,\n        message: `¬°Felicitaciones! Has avanzado a ${stageName}`,\n        rewards,\n      };\n    } catch (error) {\n      this.logger.error(`Error progressing user ${userId}:`, error);\n      return {\n        success: false,\n        message: 'Error interno. Int√©ntalo m√°s tarde.',\n      };\n    }\n  }\n\n  /**\n   * üìä Get detailed stage analytics\n   */\n  async getDetailedStageAnalytics(\n    stage: CustomerJourneyStage\n  ): Promise<StageAnalytics> {\n    this.logger.log(`Generating detailed analytics for stage: ${stage}`);\n\n    try {\n      const metrics = await this.calculateRealStageMetrics(stage);\n      const userDistribution = await this.calculateUserDistribution(stage);\n      const progressionTrends = await this.calculateProgressionTrends(stage);\n\n      return {\n        stage,\n        metrics,\n        userDistribution,\n        progressionTrends,\n        topExitPoints: await this.getTopExitPoints(stage),\n        successFactors: this.getSuccessFactors(stage),\n        optimizationSuggestions: this.getOptimizationSuggestions(\n          stage,\n          metrics\n        ),\n      };\n    } catch (error) {\n      this.logger.error(\n        `Error generating analytics for stage ${stage}:`,\n        error\n      );\n      throw new BadRequestException(\n        `Failed to generate analytics for stage ${stage}`\n      );\n    }\n  }\n\n  /**\n   * üìä Calculate overall system metrics\n   */\n  private async calculateOverallMetrics() {\n    const totalUsers = await this.prisma.user.count({\n      where: { isActive: true },\n    });\n    const activeProgressions = await this.prisma.stageProgression.count({\n      where: { isActive: true },\n    });\n\n    return {\n      totalUsers,\n      activeProgressions,\n      systemHealth: 'excellent' as const,\n    };\n  }\n\n  /**\n   * üîÑ Calculate user progress for all metrics\n   */\n  private async calculateUserProgress(user: UserWithProgress) {\n    const daysSinceStageStart = user.stageStartedAt\n      ? Math.floor(\n          (Date.now() - user.stageStartedAt.getTime()) / (1000 * 60 * 60 * 24)\n        )\n      : 0;\n\n    return {\n      meritos:\n        user.merits?.reduce(\n          (sum: number, merit: MeritAmount) => sum + merit.amount,\n          0\n        ) || 0,\n      ondas: 0, // Calculate from user data when available\n      transactions:\n        user.transactionsFrom?.length + user.transactionsTo?.length || 0,\n      timeInStage: daysSinceStageStart,\n      sessions: 0, // Calculate from session tracking when available\n    };\n  }\n\n  /**\n   * ‚úÖ Check missing requirements for progression\n   */\n  private checkMissingRequirements(\n    requirements: StageRequirements,\n    progress: Record<string, number>\n  ): string[] {\n    const missing: string[] = [];\n\n    if (\n      requirements.minimumMeritos &&\n      progress.meritos < requirements.minimumMeritos\n    ) {\n      missing.push(\n        `${requirements.minimumMeritos - progress.meritos} M√´ritos m√°s`\n      );\n    }\n    if (\n      requirements.minimumOndas &&\n      progress.ondas < requirements.minimumOndas\n    ) {\n      missing.push(`${requirements.minimumOndas - progress.ondas} √ñndas m√°s`);\n    }\n    if (\n      requirements.minimumTransactions &&\n      progress.transactions < requirements.minimumTransactions\n    ) {\n      missing.push(\n        `${requirements.minimumTransactions - progress.transactions} transacciones m√°s`\n      );\n    }\n    if (\n      requirements.timeInCurrentStage &&\n      progress.timeInStage < requirements.timeInCurrentStage\n    ) {\n      missing.push(\n        `${requirements.timeInCurrentStage - progress.timeInStage} d√≠as m√°s en el stage`\n      );\n    }\n\n    return missing;\n  }\n\n  /**\n   * üìä Calculate completion percentage\n   */\n  private calculateCompletionPercentage(\n    requirements: StageRequirements,\n    progress: Record<string, number>\n  ): number {\n    const checks = [];\n\n    if (requirements.minimumMeritos) {\n      checks.push(\n        Math.min(100, (progress.meritos / requirements.minimumMeritos) * 100)\n      );\n    }\n    if (requirements.minimumOndas) {\n      checks.push(\n        Math.min(100, (progress.ondas / requirements.minimumOndas) * 100)\n      );\n    }\n    if (requirements.minimumTransactions) {\n      checks.push(\n        Math.min(\n          100,\n          (progress.transactions / requirements.minimumTransactions) * 100\n        )\n      );\n    }\n    if (requirements.timeInCurrentStage) {\n      checks.push(\n        Math.min(\n          100,\n          (progress.timeInStage / requirements.timeInCurrentStage) * 100\n        )\n      );\n    }\n\n    return checks.length > 0\n      ? Math.round(\n          checks.reduce((sum, check) => sum + check, 0) / checks.length\n        )\n      : 100;\n  }\n\n  /**\n   * ‚è±Ô∏è Estimate time to progression\n   */\n  private estimateTimeToProgression(\n    missingRequirements: string[],\n    currentProgress: Record<string, number>\n  ): number {\n    // Simplified estimation - can be enhanced with ML models\n    return missingRequirements.length * 3; // 3 days per missing requirement\n  }\n\n  /**\n   * üí° Generate progression recommendations\n   */\n  private generateProgressionRecommendations(\n    missingRequirements: string[],\n    currentStage: CustomerJourneyStage\n  ): string[] {\n    const recommendations: string[] = [];\n\n    if (missingRequirements.length === 0) {\n      recommendations.push('¬°Est√°s listo para avanzar al siguiente stage!');\n    } else {\n      recommendations.push('Completa las actividades pendientes para avanzar');\n      recommendations.push('Participa activamente en la comunidad');\n      recommendations.push('Revisa los recursos educativos disponibles');\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * üéØ Get stage requirements (enhanced)\n   */\n  private getStageRequirements(stage: CustomerJourneyStage): StageRequirements {\n    const requirements: Record<CustomerJourneyStage, StageRequirements> = {\n      BUYER: {\n        // BUYER is the starting stage, no requirements\n      },\n      SEEKER: {\n        minimumMeritos: 100,\n        minimumTransactions: 1,\n        timeInCurrentStage: 3,\n        minimumSessions: 5,\n      },\n      SOLVER: {\n        minimumMeritos: 500,\n        minimumOndas: 200,\n        minimumTransactions: 5,\n        timeInCurrentStage: 7,\n        trustVotesRequired: 3,\n        minimumSessions: 15,\n      },\n      PROMOTER: {\n        minimumMeritos: 2000,\n        minimumOndas: 1000,\n        minimumTransactions: 20,\n        timeInCurrentStage: 30,\n        trustVotesRequired: 10,\n        minimumScore: 85,\n        minimumSessions: 50,\n      },\n    };\n\n    return requirements[stage] || {};\n  }\n\n  // Mock implementations for missing database functionality\n  private getMockStageMetrics(stage: CustomerJourneyStage): StageMetrics {\n    const mockMetrics: Record<CustomerJourneyStage, StageMetrics> = {\n      BUYER: {\n        totalUsers: 150,\n        newThisWeek: 25,\n        conversionRate: 15.5,\n        averageTimeInStage: 7,\n        topActivities: [\n          'Explorar Marketplace',\n          'Ver Videos Introductorios',\n          'Completar Perfil',\n        ],\n        completionRate: 78,\n        activeProgressions: 23,\n        averageCompletionTime: 7,\n        dropoffRate: 22,\n        weeklyGrowth: 12,\n        engagementScore: 85,\n      },\n      SEEKER: {\n        totalUsers: 89,\n        newThisWeek: 12,\n        conversionRate: 22.3,\n        averageTimeInStage: 14,\n        topActivities: [\n          'Participar en COPs',\n          'Realizar Primera Transacci√≥n',\n          'Conectar con Mentores',\n        ],\n        completionRate: 65,\n        activeProgressions: 18,\n        averageCompletionTime: 14,\n        dropoffRate: 35,\n        weeklyGrowth: 8,\n        engagementScore: 72,\n      },\n      SOLVER: {\n        totalUsers: 45,\n        newThisWeek: 8,\n        conversionRate: 31.1,\n        averageTimeInStage: 28,\n        topActivities: [\n          'Ofrecer Servicios',\n          'Completar Retos',\n          'Contribuir Conocimiento',\n        ],\n        completionRate: 42,\n        activeProgressions: 12,\n        averageCompletionTime: 28,\n        dropoffRate: 58,\n        weeklyGrowth: 15,\n        engagementScore: 68,\n      },\n      PROMOTER: {\n        totalUsers: 23,\n        newThisWeek: 3,\n        conversionRate: 100,\n        averageTimeInStage: 60,\n        topActivities: [\n          'Liderar COPs',\n          'Mentorar Nuevos Usuarios',\n          'Crear Contenido',\n        ],\n        completionRate: 28,\n        activeProgressions: 8,\n        averageCompletionTime: 60,\n        dropoffRate: 72,\n        weeklyGrowth: 5,\n        engagementScore: 92,\n      },\n    };\n\n    return mockMetrics[stage];\n  }\n\n  private async getTopActivitiesForStage(\n    stage: CustomerJourneyStage\n  ): Promise<string[]> {\n    // Mock implementation - replace with real activity tracking\n    return this.getMockStageMetrics(stage).topActivities;\n  }\n\n  private async getActiveProgressions(stage: CustomerJourneyStage) {\n    try {\n      return await this.prisma.stageProgression.findMany({\n        where: { stage, isActive: true },\n        include: { user: { select: { id: true, name: true, email: true } } },\n        take: 10,\n      });\n    } catch (error) {\n      return [];\n    }\n  }\n\n  private async calculateUserDistribution(stage: CustomerJourneyStage) {\n    // Mock implementation\n    return { active: 80, progressing: 15, stuck: 5 };\n  }\n\n  private async calculateProgressionTrends(stage: CustomerJourneyStage) {\n    // Mock implementation - replace with real trend calculation\n    const last30Days = Array.from({ length: 30 }, (_, i) => {\n      const date = new Date(Date.now() - i * 24 * 60 * 60 * 1000);\n      return {\n        date: date.toISOString().split('T')[0],\n        value: Math.floor(Math.random() * 10) + 5,\n      };\n    }).reverse();\n\n    return last30Days;\n  }\n\n  private async getTopExitPoints(\n    stage: CustomerJourneyStage\n  ): Promise<string[]> {\n    // Mock implementation\n    return [\n      'Configuraci√≥n de perfil',\n      'Primera transacci√≥n',\n      'Validaci√≥n por mentores',\n    ];\n  }\n\n  private getSuccessFactors(stage: CustomerJourneyStage): string[] {\n    const factors: Record<CustomerJourneyStage, string[]> = {\n      BUYER: [\n        'Completar onboarding r√°pido',\n        'Activar gift card',\n        'Explorar marketplace',\n      ],\n      SEEKER: [\n        'Participar en comunidad',\n        'Realizar transacciones',\n        'Construir reputaci√≥n',\n      ],\n      SOLVER: [\n        'Ofrecer servicios de calidad',\n        'Mantener buenas calificaciones',\n        'Ser consistente',\n      ],\n      PROMOTER: [\n        'Liderar con ejemplo',\n        'Mentorar efectivamente',\n        'Contribuir valor',\n      ],\n    };\n\n    return factors[stage] || [];\n  }\n\n  private getOptimizationSuggestions(\n    stage: CustomerJourneyStage,\n    metrics: StageMetrics\n  ): string[] {\n    const suggestions: string[] = [];\n\n    if (metrics.dropoffRate > 50) {\n      suggestions.push('Revisar puntos de abandono en el stage');\n    }\n    if (metrics.engagementScore < 70) {\n      suggestions.push('Mejorar actividades de engagement');\n    }\n    if (metrics.averageTimeInStage > 30) {\n      suggestions.push('Optimizar tiempos de progresi√≥n');\n    }\n\n    return suggestions;\n  }\n\n  /**\n   * üîÑ Get next stage in progression\n   */\n  private getNextStage(\n    currentStage: CustomerJourneyStage\n  ): CustomerJourneyStage | null {\n    const progression: Record<\n      CustomerJourneyStage,\n      CustomerJourneyStage | null\n    > = {\n      BUYER: 'SEEKER',\n      SEEKER: 'SOLVER',\n      SOLVER: 'PROMOTER',\n      PROMOTER: null, // Final stage\n    };\n\n    return progression[currentStage];\n  }\n\n  /**\n   * üè∑Ô∏è Get human-readable stage name\n   */\n  private getStageName(stage: CustomerJourneyStage): string {\n    const names: Record<CustomerJourneyStage, string> = {\n      BUYER: 'Comprador',\n      SEEKER: 'Buscador',\n      SOLVER: 'Solucionador',\n      PROMOTER: 'Promotor',\n    };\n\n    return names[stage];\n  }\n\n  /**\n   * üìù Get stage description\n   */\n  private getStageDescription(stage: CustomerJourneyStage): string {\n    const descriptions: Record<CustomerJourneyStage, string> = {\n      BUYER:\n        'Descubre Coom√únity y experimenta tus primeras transacciones conscientes',\n      SEEKER:\n        'Explora oportunidades, construye confianza y conecta con la comunidad',\n      SOLVER: 'Crea valor ofreciendo servicios y soluciones innovadoras',\n      PROMOTER:\n        'Lidera la comunidad, mentora nuevos usuarios y expande el ecosistema',\n    };\n\n    return descriptions[stage];\n  }\n\n  /**\n   * üé® Get stage icon\n   */\n  private getStageIcon(stage: CustomerJourneyStage): string {\n    const icons: Record<CustomerJourneyStage, string> = {\n      BUYER: 'üõí',\n      SEEKER: 'üîç',\n      SOLVER: '‚ö°',\n      PROMOTER: 'üöÄ',\n    };\n\n    return icons[stage];\n  }\n\n  /**\n   * üé® Get stage color\n   */\n  private getStageColor(stage: CustomerJourneyStage): string {\n    const colors: Record<CustomerJourneyStage, string> = {\n      BUYER: '#4CAF50',\n      SEEKER: '#2196F3',\n      SOLVER: '#FF9800',\n      PROMOTER: '#9C27B0',\n    };\n\n    return colors[stage];\n  }\n\n  /**\n   * üß† Get philosophy alignment\n   */\n  private getPhilosophyAlignment(\n    stage: CustomerJourneyStage\n  ): 'reciprocidad' | 'bien_comun' | 'metanoia' {\n    const alignments: Record<\n      CustomerJourneyStage,\n      'reciprocidad' | 'bien_comun' | 'metanoia'\n    > = {\n      BUYER: 'reciprocidad',\n      SEEKER: 'bien_comun',\n      SOLVER: 'metanoia',\n      PROMOTER: 'reciprocidad',\n    };\n\n    return alignments[stage];\n  }\n\n  /**\n   * ‚è∞ Get stage time limits\n   */\n  private getStageTimeLimit(stage: CustomerJourneyStage): number {\n    const limits: Record<CustomerJourneyStage, number> = {\n      BUYER: 14, // 2 weeks\n      SEEKER: 30, // 1 month\n      SOLVER: 60, // 2 months\n      PROMOTER: 0, // No limit\n    };\n\n    return limits[stage];\n  }\n\n  /**\n   * ü§ñ Check if stage has auto progression\n   */\n  private hasAutoProgression(stage: CustomerJourneyStage): boolean {\n    return stage === 'BUYER'; // Only BUYER has auto progression\n  }\n\n  /**\n   * ‚úÖ Check if stage requires validation\n   */\n  private requiresValidation(stage: CustomerJourneyStage): boolean {\n    return stage === 'SOLVER' || stage === 'PROMOTER';\n  }\n\n  /**\n   * üìä Calculate conversion funnel\n   */\n  private calculateConversionFunnel(stages: StageDataResult[]) {\n    return stages.map((stage, index) => ({\n      stage: stage.id,\n      users: stage.metrics.totalUsers,\n      conversionRate: index === 0 ? 100 : stage.metrics.conversionRate,\n    }));\n  }\n\n  /**\n   * üìà Calculate stage progression overview\n   */\n  private calculateStageProgression(stages: StageDataResult[]) {\n    const totalUsers = stages.reduce(\n      (sum, stage) => sum + stage.metrics.totalUsers,\n      0\n    );\n\n    return stages.map((stage) => ({\n      stage: stage.id,\n      percentage:\n        totalUsers > 0\n          ? Math.round((stage.metrics.totalUsers / totalUsers) * 100)\n          : 0,\n      users: stage.metrics.totalUsers,\n    }));\n  }\n\n  /**\n   * üéÅ Get stage rewards\n   */\n  private getStageRewards(stage: CustomerJourneyStage) {\n    const rewards: Record<\n      CustomerJourneyStage,\n      Array<{ type: string; amount: number; description: string }>\n    > = {\n      BUYER: [\n        { type: '√úNITS', amount: 25, description: 'Bienvenida a Coom√únity' },\n      ],\n      SEEKER: [\n        { type: '√úNITS', amount: 50, description: 'Recompensa de Buscador' },\n        { type: 'MERITOS', amount: 25, description: 'M√´ritos de iniciaci√≥n' },\n      ],\n      SOLVER: [\n        {\n          type: '√úNITS',\n          amount: 200,\n          description: 'Recompensa de Solucionador',\n        },\n        { type: 'ONDAS', amount: 100, description: '√ñndas de sabidur√≠a' },\n      ],\n      PROMOTER: [\n        { type: '√úNITS', amount: 1000, description: 'Premio al Promotor' },\n        { type: 'ONDAS', amount: 500, description: '√ñndas de liderazgo' },\n        { type: 'MERITOS', amount: 200, description: 'M√´ritos de excelencia' },\n      ],\n    };\n\n    return rewards[stage] || [];\n  }\n\n  /**\n   * üéØ Get stage activities\n   */\n  private async getStageActivities(stage: CustomerJourneyStage) {\n    // Mock implementation - replace with real activity tracking\n    const activities: Record<\n      CustomerJourneyStage,\n      Array<{ name: string; completion: number; impact: number }>\n    > = {\n      BUYER: [\n        { name: 'Activar Gift Card', completion: 85, impact: 9 },\n        { name: 'Completar Perfil', completion: 70, impact: 7 },\n        { name: 'Primera Transacci√≥n', completion: 60, impact: 8 },\n      ],\n      SEEKER: [\n        { name: 'Explorar Marketplace', completion: 90, impact: 6 },\n        { name: 'Unirse a COP', completion: 45, impact: 8 },\n        { name: 'Obtener Votos de Confianza', completion: 30, impact: 9 },\n      ],\n      SOLVER: [\n        { name: 'Crear Primer Servicio', completion: 75, impact: 9 },\n        { name: 'Recibir Validaci√≥n', completion: 40, impact: 8 },\n        { name: 'Generar Primeras Ventas', completion: 55, impact: 7 },\n      ],\n      PROMOTER: [\n        { name: 'Liderar COP', completion: 60, impact: 9 },\n        { name: 'Mentorar Nuevos Usuarios', completion: 45, impact: 8 },\n        { name: 'Crear Contenido Educativo', completion: 35, impact: 7 },\n      ],\n    };\n\n    return activities[stage] || [];\n  }\n\n  // Legacy methods for controller compatibility\n  async getStageById(stageId: string) {\n    const stage = stageId.toUpperCase() as CustomerJourneyStage;\n    return await this.getStageData(stage);\n  }\n\n  async updateStage(stageId: string, data: UpdateStageDto) {\n    // Implementation for updating stage configuration\n    this.logger.log(`Updating stage ${stageId} with data:`, data);\n    return { id: stageId, ...data, updated: true };\n  }\n\n  async getStageAnalytics(stageId: string) {\n    const stage = stageId.toUpperCase() as CustomerJourneyStage;\n    return await this.getDetailedStageAnalytics(stage);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/feedback/agents/feedback-agents.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AgentProfile' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Logger, Inject } from '@nestjs/common';\nimport { PrismaService } from '../../prisma/prisma.service';\n\n/**\n * üîÆ CoP OR√ÅCULO - Sistema Multi-Agente\n * Inspirado en CrewAI para transformar feedback en sabidur√≠a colectiva\n * Implementa agentes especializados que colaboran seg√∫n principios de Reciprocidad\n */\n\n// Interfaces para el sistema de agentes\ninterface AgentProfile {\n  id: string;\n  name: string;\n  role: string;\n  element: 'FUEGO' | 'AGUA' | 'TIERRA' | 'AIRE';\n  specialization: string;\n  lukasBalance: number;\n  level: number;\n  activeQuests: string[];\n}\n\ninterface FeedbackAnalysis {\n  sentiment: number; // -1 a 1\n  urgency: number; // 1 a 5\n  complexity: number; // 1 a 5\n  category: string;\n  recommendedPath: string;\n  lukasReward: number;\n}\n\ninterface TaskResults {\n  priority?: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n  estimatedResolution?: string;\n  resourcesNeeded?: string[];\n  reciprocidadImpact?: 'LOW' | 'MEDIUM' | 'HIGH';\n  stakeholdersNotified?: string[];\n  collaborationChannels?: string[];\n  consensusLevel?: number;\n  reciprocidadFlow?: 'BLOCKED' | 'SLOW' | 'BALANCED' | 'FLOWING';\n  knowledgeArticlesCreated?: number;\n  bestPracticesUpdated?: string[];\n  wisdomScore?: number;\n  foundationStrength?: 'WEAK' | 'STABLE' | 'SOLID' | 'DIAMOND';\n  trendsIdentified?: string[];\n  innovationOpportunities?: number;\n  futureImpactScore?: number;\n  visionClarity?: 'CLOUDY' | 'CLEAR' | 'CRYSTAL_CLEAR';\n}\n\ninterface CollaborationTask {\n  id: string;\n  type: 'ANALYZE' | 'PRIORITIZE' | 'RESOLVE' | 'DISTRIBUTE';\n  feedbackId: string;\n  assignedAgents: string[];\n  status?: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED';\n  results: TaskResults;\n  lukasGenerated: number;\n}\n\ninterface FeedbackData {\n  id: string;\n  feedbackText: string;\n  category:\n    | 'BUG'\n    | 'IMPROVEMENT'\n    | 'MISSING_FEATURE'\n    | 'UI_UX'\n    | 'PERFORMANCE'\n    | 'OTHER';\n  urgency?: number; // Optional, might be calculated\n  complexity?: number; // Optional, might be calculated\n  // Add other potential fields based on usage if necessary\n}\n\n@Injectable()\nexport class FeedbackAgentsService {\n  private readonly logger = new Logger(FeedbackAgentsService.name);\n\n  constructor(@Inject(PrismaService) private readonly _prisma: PrismaService) {\n    // console.log('>>> FeedbackAgentsService CONSTRUCTOR: this._prisma IS', this._prisma ? 'DEFINED' : 'UNDEFINED');\n  }\n\n  /**\n   * üß† AGENTE OR√ÅCULO PRINCIPAL\n   * Analiza feedback usando IA contextual y filosof√≠a Coom√únity\n   */\n  async analyzeWithOraculo(\n    feedbackData: FeedbackData\n  ): Promise<FeedbackAnalysis> {\n    this.logger.log(`üîÆ [OR√ÅCULO] Analizando feedback: ${feedbackData.id}`);\n\n    // Simulaci√≥n de an√°lisis IA avanzado\n    const analysis: FeedbackAnalysis = {\n      sentiment: this.calculateSentiment(feedbackData.feedbackText),\n      urgency: this.calculateUrgency(feedbackData),\n      complexity: this.calculateComplexity(feedbackData),\n      category: this.categorizeByElement(feedbackData),\n      recommendedPath: this.recommendPath(feedbackData),\n      lukasReward: this.calculateLukasReward(feedbackData),\n    };\n\n    this.logger.log(\n      `üéØ [OR√ÅCULO] An√°lisis completado - Categor√≠a: ${analysis.category}, L√ºkas: ${analysis.lukasReward}`\n    );\n    return analysis;\n  }\n\n  /**\n   * üî• AGENTE FUEGO - ACCI√ìN R√ÅPIDA\n   * Especializado en bugs cr√≠ticos y resoluci√≥n inmediata\n   */\n  async processFuegoAgent(feedbackId: string): Promise<CollaborationTask> {\n    this.logger.log(`üî• [FUEGO] Procesando feedback cr√≠tico: ${feedbackId}`);\n\n    const task: CollaborationTask = {\n      id: `fuego_${Date.now()}`,\n      type: 'RESOLVE',\n      feedbackId,\n      assignedAgents: ['fuego-primary', 'fuego-support'],\n      status: 'IN_PROGRESS',\n      results: {\n        priority: 'CRITICAL',\n        estimatedResolution: '2 hours',\n        resourcesNeeded: ['backend-dev', 'qa-tester'],\n        reciprocidadImpact: 'HIGH', // Impacto en el Bien Com√∫n\n      },\n      lukasGenerated: 50,\n    };\n\n    // Simulaci√≥n de procesamiento r√°pido del agente Fuego\n    await this.simulateAgentWork(2000);\n\n    this.logger.log(\n      `üî• [FUEGO] Tarea completada - L√ºkas generados: ${task.lukasGenerated}`\n    );\n    return task;\n  }\n\n  /**\n   * üíß AGENTE AGUA - COLABORACI√ìN FLUIDA\n   * Especializado en coordinaci√≥n entre administradores y comunicaci√≥n\n   */\n  async processAguaAgent(feedbackId: string): Promise<CollaborationTask> {\n    this.logger.log(`üíß [AGUA] Facilitando colaboraci√≥n para: ${feedbackId}`);\n\n    const task: CollaborationTask = {\n      id: `agua_${Date.now()}`,\n      type: 'DISTRIBUTE',\n      feedbackId,\n      assignedAgents: ['agua-coordinator', 'agua-communicator'],\n      status: 'IN_PROGRESS',\n      results: {\n        stakeholdersNotified: ['admin-team', 'ux-team'],\n        collaborationChannels: ['slack-cop-oraculo', 'feedback-board'],\n        consensusLevel: 0.85,\n        reciprocidadFlow: 'BALANCED', // Flujo equilibrado de Reciprocidad\n      },\n      lukasGenerated: 30,\n    };\n\n    await this.simulateAgentWork(3000);\n\n    this.logger.log(\n      `üíß [AGUA] Colaboraci√≥n facilitada - Consenso: ${task.results.consensusLevel}`\n    );\n    return task;\n  }\n\n  /**\n   * üå± AGENTE TIERRA - DOCUMENTACI√ìN S√ìLIDA\n   * Especializado en crear conocimiento duradero y bases de datos de sabidur√≠a\n   */\n  async processTierraAgent(feedbackId: string): Promise<CollaborationTask> {\n    this.logger.log(`üå± [TIERRA] Documentando sabidur√≠a para: ${feedbackId}`);\n\n    const task: CollaborationTask = {\n      id: `tierra_${Date.now()}`,\n      type: 'ANALYZE',\n      feedbackId,\n      assignedAgents: ['tierra-documentalist', 'tierra-knowledge-keeper'],\n      status: 'IN_PROGRESS',\n      results: {\n        knowledgeArticlesCreated: 2,\n        bestPracticesUpdated: ['feedback-handling', 'user-communication'],\n        wisdomScore: 8.5,\n        foundationStrength: 'SOLID', // Solidez para el Bien Com√∫n\n      },\n      lukasGenerated: 40,\n    };\n\n    await this.simulateAgentWork(4000);\n\n    this.logger.log(\n      `üå± [TIERRA] Sabidur√≠a documentada - Art√≠culos: ${task.results.knowledgeArticlesCreated}`\n    );\n    return task;\n  }\n\n  /**\n   * üí® AGENTE AIRE - VISI√ìN E INNOVACI√ìN\n   * Especializado en detectar patrones, tendencias y oportunidades de mejora\n   */\n  async processAireAgent(feedbackId: string): Promise<CollaborationTask> {\n    this.logger.log(`üí® [AIRE] Visionando innovaciones para: ${feedbackId}`);\n\n    const task: CollaborationTask = {\n      id: `aire_${Date.now()}`,\n      type: 'ANALYZE',\n      feedbackId,\n      assignedAgents: ['aire-visionary', 'aire-innovator'],\n      status: 'IN_PROGRESS',\n      results: {\n        trendsIdentified: ['ui-accessibility', 'mobile-first'],\n        innovationOpportunities: 3,\n        futureImpactScore: 9.2,\n        visionClarity: 'CRYSTAL_CLEAR', // Claridad visionaria\n      },\n      lukasGenerated: 60,\n    };\n\n    await this.simulateAgentWork(5000);\n\n    this.logger.log(\n      `üí® [AIRE] Visi√≥n completada - Oportunidades: ${task.results.innovationOpportunities}`\n    );\n    return task;\n  }\n\n  /**\n   * ü§ù COORDINADOR DE COLABORACI√ìN RECIPROCIDAD\n   * Orchestor principal que gestiona la colaboraci√≥n entre todos los agentes\n   */\n  async orchestrateCollaboration(\n    feedbackId: string,\n    analysis: FeedbackAnalysis\n  ): Promise<{\n    tasks: CollaborationTask[];\n    totalLukasGenerated: number;\n    reciprocidadBalance: number;\n    collaborationScore: number;\n  }> {\n    this.logger.log(\n      `ü§ù [COORDINADOR] Orquestando colaboraci√≥n para feedback: ${feedbackId}`\n    );\n\n    const tasks: CollaborationTask[] = [];\n\n    // Asignar agentes seg√∫n la categor√≠a y complejidad\n    if (analysis.urgency >= 4) {\n      tasks.push(await this.processFuegoAgent(feedbackId));\n    }\n\n    if (analysis.complexity >= 3) {\n      tasks.push(await this.processAguaAgent(feedbackId));\n    }\n\n    // Siempre documentamos para generar sabidur√≠a\n    tasks.push(await this.processTierraAgent(feedbackId));\n\n    // Para insights avanzados\n    if (\n      analysis.category === 'IMPROVEMENT' ||\n      analysis.category === 'MISSING_FEATURE'\n    ) {\n      tasks.push(await this.processAireAgent(feedbackId));\n    }\n\n    const totalLukasGenerated = tasks.reduce(\n      (sum, task) => sum + task.lukasGenerated,\n      0\n    );\n    const reciprocidadBalance = this.calculateReciprocidadBalance(tasks);\n    const collaborationScore = this.calculateCollaborationScore(tasks);\n\n    this.logger.log(\n      `üèÜ [COORDINADOR] Colaboraci√≥n completada - L√ºkas total: ${totalLukasGenerated}, Reciprocidad: ${reciprocidadBalance}`\n    );\n\n    return {\n      tasks,\n      totalLukasGenerated,\n      reciprocidadBalance,\n      collaborationScore,\n    };\n  }\n\n  /**\n   * üìä SISTEMA DE M√âTRICAS GAMIFICADAS\n   */\n  async calculateCommunityMetrics(): Promise<{\n    wisdomQuotient: number;\n    reciprocidadIndex: number;\n    collaborationVelocity: number;\n    innovationScore: number;\n  }> {\n    // Simulaci√≥n de m√©tricas comunitarias\n    return {\n      wisdomQuotient: 8.7, // Calidad de la sabidur√≠a generada\n      reciprocidadIndex: 0.92, // Balance de reciprocidad\n      collaborationVelocity: 15.3, // Velocidad de colaboraci√≥n\n      innovationScore: 7.8, // Nivel de innovaci√≥n\n    };\n  }\n\n  // M√©todos auxiliares privados\n  private calculateSentiment(text: string): number {\n    // Simulaci√≥n de an√°lisis de sentimiento\n    const positiveWords = ['good', 'great', 'love', 'excellent', 'amazing'];\n    const negativeWords = ['bad', 'terrible', 'hate', 'awful', 'problem'];\n    const words = text.toLowerCase().split(/\\s+/);\n    let score = 0;\n    words.forEach((word) => {\n      if (positiveWords.includes(word)) score++;\n      if (negativeWords.includes(word)) score--;\n    });\n    return score / words.length || 0;\n  }\n\n  private calculateUrgency(feedbackData: FeedbackData): number {\n    if (feedbackData.category === 'BUG') return 5;\n    if (feedbackData.category === 'PERFORMANCE') return 4;\n    return feedbackData.urgency || 2;\n  }\n\n  private calculateComplexity(feedbackData: FeedbackData): number {\n    const textLength = feedbackData.feedbackText.length;\n    if (textLength > 500) return 5;\n    if (textLength > 200) return 3;\n    return feedbackData.complexity || 1;\n  }\n\n  private categorizeByElement(feedbackData: FeedbackData): string {\n    // L√≥gica de mapeo a los 4 elementos\n    switch (feedbackData.category) {\n      case 'BUG':\n      case 'PERFORMANCE':\n        return 'FUEGO';\n      case 'UI_UX':\n        return 'AGUA';\n      case 'MISSING_FEATURE':\n      case 'IMPROVEMENT':\n        return 'AIRE';\n      case 'OTHER':\n      default:\n        return 'TIERRA';\n    }\n  }\n\n  private recommendPath(feedbackData: FeedbackData): string {\n    if (feedbackData.category === 'BUG') return 'Fuego -> Agua -> Tierra';\n    return 'Oraculo -> Aire -> Tierra -> Agua';\n  }\n\n  private calculateLukasReward(feedbackData: FeedbackData): number {\n    let reward = 10; // Base reward\n    reward += this.calculateUrgency(feedbackData) * 5;\n    reward += this.calculateComplexity(feedbackData) * 3;\n    return Math.round(reward);\n  }\n\n  private calculateReciprocidadBalance(tasks: CollaborationTask[]): number {\n    // C√°lculo del balance de Reciprocidad (reciprocidad)\n    const totalTasks = tasks.length;\n    const completedTasks = tasks.filter((t) => t.status === 'COMPLETED').length;\n    const lukasDistribution = tasks.map((task) => task.lukasGenerated);\n    const variance = this.calculateVariance(lukasDistribution);\n\n    // Balance perfecto cuando hay alta completitud y baja varianza en distribuci√≥n\n    const completionRatio = completedTasks / totalTasks;\n    const distributionBalance = 1 / (1 + variance / 100); // Normalizado\n\n    return (completionRatio + distributionBalance) / 2;\n  }\n\n  private calculateCollaborationScore(tasks: CollaborationTask[]): number {\n    // Puntuaci√≥n de colaboraci√≥n basada en diversidad de agentes y sincronizaci√≥n\n    const uniqueAgentTypes = new Set(tasks.map((task) => task.type)).size;\n    const avgLukasPerTask =\n      tasks.reduce((sum, task) => sum + task.lukasGenerated, 0) / tasks.length;\n\n    return Math.min(10, uniqueAgentTypes * 2 + avgLukasPerTask / 10);\n  }\n\n  private calculateVariance(numbers: number[]): number {\n    if (numbers.length === 0) return 0;\n    const mean = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;\n    const squaredDiffs = numbers.map((num) => Math.pow(num - mean, 2));\n    return squaredDiffs.reduce((sum, diff) => sum + diff, 0) / numbers.length;\n  }\n\n  private async simulateAgentWork(duration: number): Promise<void> {\n    // Simulaci√≥n de trabajo as√≠ncrono del agente\n    return new Promise((resolve) => setTimeout(resolve, duration));\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/invitations/dto/invitations.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsEnum' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":9}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  IsString,\n  IsNumber,\n  IsOptional,\n  IsEnum,\n  IsUUID,\n  IsEmail,\n  IsArray,\n  Min,\n  IsBoolean,\n  IsDateString,\n} from 'class-validator';\nimport { Type } from 'class-transformer';\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport enum InvitationStatus {\n  SENT = 'SENT',\n  REDEEMED = 'REDEEMED',\n  EXPIRED = 'EXPIRED',\n  CANCELLED = 'CANCELLED',\n}\n\nexport enum UserInvitationStatus {\n  PENDING = 'PENDING',\n  ACCEPTED = 'ACCEPTED',\n  REJECTED = 'REJECTED',\n  EXPIRED = 'EXPIRED',\n}\n\nexport class CreateInvitationTemplateDto {\n  @ApiProperty({ description: 'Nombre del template' })\n  @IsString()\n  name: string;\n\n  @ApiProperty({ description: 'Asunto del email' })\n  @IsString()\n  subject: string;\n\n  @ApiProperty({ description: 'Contenido HTML del template' })\n  @IsString()\n  htmlContent: string;\n\n  @ApiProperty({ description: 'Contenido de texto plano' })\n  @IsString()\n  textContent: string;\n\n  @ApiProperty({\n    description: 'Variables disponibles en el template',\n    required: false,\n  })\n  @IsOptional()\n  @IsArray()\n  @IsString({ each: true })\n  variables?: string[];\n\n  @ApiProperty({ description: 'Si el template est√° activo', required: false })\n  @IsOptional()\n  @IsBoolean()\n  isActive?: boolean;\n\n  @IsUUID()\n  creatorId: string;\n}\n\nexport class CreateGiftCardDto {\n  @ApiProperty({ description: 'ID del usuario que invita' })\n  @IsString()\n  inviterId: string;\n\n  @ApiProperty({ description: 'Nombre del invitado' })\n  @IsString()\n  invitedName: string;\n\n  @ApiProperty({ description: 'Email del invitado' })\n  @IsEmail()\n  invitedEmail: string;\n\n  @ApiProperty({ description: 'Cantidad de √únits a regalar' })\n  @IsNumber()\n  @Min(0.01)\n  @Type(() => Number)\n  unitsAmount: number;\n\n  @ApiProperty({ description: 'Sugerencias para el invitado', required: false })\n  @IsOptional()\n  @IsArray()\n  @IsString({ each: true })\n  suggestions?: string[];\n\n  @ApiProperty({\n    description: 'ID del template de invitaci√≥n',\n    required: false,\n  })\n  @IsOptional()\n  @IsString()\n  templateId?: string;\n}\n\nexport class RedeemGiftCardDto {\n  @ApiProperty({ description: 'Token de la gift card' })\n  @IsString()\n  token: string;\n\n  @ApiProperty({ description: 'Email del invitado' })\n  @IsEmail()\n  invitedEmail: string;\n\n  @ApiProperty({ description: 'Contrase√±a para la nueva cuenta' })\n  @IsString()\n  password: string;\n\n  @ApiProperty({ description: 'Nombre del invitado' })\n  @IsString()\n  invitedName: string;\n\n  @ApiProperty({ description: 'Primer nombre', required: false })\n  @IsOptional()\n  @IsString()\n  firstName?: string;\n\n  @ApiProperty({ description: 'Apellido', required: false })\n  @IsOptional()\n  @IsString()\n  lastName?: string;\n}\n\nexport class UpdateGiftCardDto {\n  @ApiProperty({ description: 'Nuevo nombre del invitado', required: false })\n  @IsOptional()\n  @IsString()\n  invitedName?: string;\n\n  @ApiProperty({ description: 'Nuevo email del invitado', required: false })\n  @IsOptional()\n  @IsEmail()\n  invitedEmail?: string;\n\n  @ApiProperty({ description: 'Nueva cantidad de √únits', required: false })\n  @IsOptional()\n  @IsNumber()\n  @Min(0)\n  @Type(() => Number)\n  unitsAmount?: number;\n\n  @ApiProperty({ description: 'Nuevas sugerencias', required: false })\n  @IsOptional()\n  @IsArray()\n  @IsString({ each: true })\n  suggestions?: string[];\n}\n\nexport class InvitationChallengeDto {\n  @ApiProperty({ description: 'ID del usuario' })\n  @IsString()\n  userId: string;\n\n  @ApiProperty({ description: 'Tipo de challenge' })\n  @IsString()\n  challengeType: string;\n\n  @ApiProperty({ description: 'Objetivo del challenge' })\n  @IsNumber()\n  target: number;\n\n  @ApiProperty({ description: 'Recompensa por completar el challenge' })\n  @IsNumber()\n  reward: number;\n\n  @ApiProperty({ description: 'Fecha l√≠mite del challenge', required: false })\n  @IsOptional()\n  @IsDateString()\n  deadline?: string;\n}\n\nexport class InvitationStatsDto {\n  @ApiProperty({\n    description: 'ID del usuario para filtrar estad√≠sticas',\n    required: false,\n  })\n  @IsOptional()\n  @IsString()\n  userId?: string;\n\n  @ApiProperty({\n    description: 'Fecha de inicio para el rango',\n    required: false,\n  })\n  @IsOptional()\n  @IsDateString()\n  startDate?: string;\n\n  @ApiProperty({ description: 'Fecha de fin para el rango', required: false })\n  @IsOptional()\n  @IsDateString()\n  endDate?: string;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/invitations/invitations.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UpdateInvitationStatusDto' is defined but never used. Allowed unused vars must match /^_/u.","line":23,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'AuthenticatedUser' is defined but never used. Allowed unused vars must match /^_/u.","line":24,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":27}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Controller,\n  Get,\n  Post,\n  Put,\n  Delete,\n  Body,\n  Param,\n  Query,\n  UseGuards,\n  Inject,\n} from '@nestjs/common';\nimport { InvitationsService } from './invitations.service';\nimport {\n  CreateGiftCardDto,\n  RedeemGiftCardDto,\n  UpdateGiftCardDto,\n  InvitationStatsDto,\n} from './dto/invitations.dto';\nimport { JwtAuthGuard } from '@/auth/guards/jwt-auth.guard';\nimport { RolesGuard } from '@/rbac/guards/roles.guard';\nimport { Roles } from '@/rbac/decorators/roles.decorator';\nimport { UpdateInvitationStatusDto } from './dto/update-invitation-status.dto';\nimport { AuthenticatedUser } from '@/types/auth.types';\nimport { ApiTags, ApiBearerAuth } from '@nestjs/swagger';\n\n@ApiTags('invitations')\n@ApiBearerAuth()\n@Controller('invitations')\nexport class InvitationsController {\n  constructor(\n    @Inject(InvitationsService)\n    private readonly invitationsService: InvitationsService\n  ) {\n    // //     console.log('>>> InvitationsController CONSTRUCTOR: this.invitationsService IS', this.invitationsService ? 'DEFINED' : 'UNDEFINED');\n  }\n\n  /**\n   * Endpoint de prueba para verificar conectividad\n   */\n  @Get('ping')\n  async ping() {\n    //     console.log('>>> InvitationsController.ping: Invitations module is working');\n    return {\n      message: 'Invitations module is working',\n      timestamp: new Date().toISOString(),\n      module: 'Invitations & Gift Cards System',\n    };\n  }\n\n  /**\n   * Canjear una gift card (endpoint p√∫blico)\n   */\n  @Post('gift-cards/redeem')\n  async redeemGiftCard(@Body() dto: RedeemGiftCardDto) {\n    //     console.log('>>> InvitationsController.redeemGiftCard: Redeeming gift card');\n    return await this.invitationsService.redeemGiftCard(dto);\n  }\n\n  // Endpoints protegidos con autenticaci√≥n\n  @UseGuards(JwtAuthGuard, RolesGuard)\n  @Post('gift-cards')\n  @Roles('admin', 'user')\n  async createGiftCard(@Body() dto: CreateGiftCardDto) {\n    //     console.log('>>> InvitationsController.createGiftCard: Creating gift card', dto);\n    return await this.invitationsService.createGiftCard(dto);\n  }\n\n  @UseGuards(JwtAuthGuard, RolesGuard)\n  @Get('gift-cards/user/:userId')\n  @Roles('admin', 'user')\n  async getUserGiftCards(@Param('userId') userId: string) {\n    //     console.log('>>> InvitationsController.getUserGiftCards: Getting gift cards for user', userId);\n    return await this.invitationsService.getUserGiftCards(userId);\n  }\n\n  @UseGuards(JwtAuthGuard, RolesGuard)\n  @Put('gift-cards/:giftCardId')\n  @Roles('admin', 'user')\n  async updateGiftCard(\n    @Param('giftCardId') giftCardId: string,\n    @Body() dto: UpdateGiftCardDto,\n    @Query('userId') userId: string\n  ) {\n    //     console.log('>>> InvitationsController.updateGiftCard: Updating gift card', giftCardId);\n    return await this.invitationsService.updateGiftCard(\n      giftCardId,\n      dto,\n      userId\n    );\n  }\n\n  @UseGuards(JwtAuthGuard, RolesGuard)\n  @Delete('gift-cards/:giftCardId')\n  @Roles('admin', 'user')\n  async cancelGiftCard(\n    @Param('giftCardId') giftCardId: string,\n    @Query('userId') userId: string\n  ) {\n    //     console.log('>>> InvitationsController.cancelGiftCard: Cancelling gift card', giftCardId);\n    return await this.invitationsService.cancelGiftCard(giftCardId, userId);\n  }\n\n  @UseGuards(JwtAuthGuard, RolesGuard)\n  @Get('stats')\n  @Roles('admin', 'user')\n  async getInvitationStats(\n    @Query('inviterId') inviterId?: string,\n    @Query('startDate') startDate?: string,\n    @Query('endDate') endDate?: string\n  ) {\n    //     console.log('>>> InvitationsController.getInvitationStats: Getting invitation statistics');\n\n    const dto: InvitationStatsDto = { userId: inviterId, startDate, endDate };\n    return await this.invitationsService.getInvitationStats(dto);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/invitations/invitations.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CreateInvitationTemplateDto' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'InvitationChallengeDto' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UserInvitationStatus' is defined but never used. Allowed unused vars must match /^_/u.","line":18,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":23}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  NotFoundException,\n  BadRequestException,\n  Inject,\n} from '@nestjs/common';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { NotificationsService } from '../notifications/notifications.service';\nimport { NotificationType } from '../notifications/dto/notifications.dto';\nimport {\n  CreateInvitationTemplateDto,\n  CreateGiftCardDto,\n  RedeemGiftCardDto,\n  UpdateGiftCardDto,\n  InvitationChallengeDto,\n  InvitationStatsDto,\n  InvitationStatus,\n  UserInvitationStatus,\n} from './dto/invitations.dto';\nimport * as crypto from 'crypto';\nimport * as bcrypt from 'bcryptjs';\n\n@Injectable()\nexport class InvitationsService {\n  constructor(\n    @Inject(PrismaService) private readonly prisma: PrismaService,\n    @Inject(NotificationsService)\n    private readonly notificationsService: NotificationsService\n  ) {\n    // //     console.log('>>> InvitationsService CONSTRUCTOR: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n    // //     console.log('>>> InvitationsService CONSTRUCTOR: this.notificationsService IS', this.notificationsService ? 'DEFINED' : 'UNDEFINED');\n  }\n\n  /**\n   * Crear una gift card de invitaci√≥n\n   */\n  async createGiftCard(dto: CreateGiftCardDto) {\n    //     console.log('>>> InvitationsService.createGiftCard: Creating gift card', dto);\n\n    // Verificar que el invitador existe y tiene suficientes √únits\n    const inviter = await this.prisma.user.findUnique({\n      where: { id: dto.inviterId },\n      include: { wallet: true },\n    });\n\n    if (!inviter) {\n      throw new NotFoundException('Usuario invitador no encontrado');\n    }\n\n    if (!inviter.wallet || inviter.wallet.balance < dto.unitsAmount) {\n      throw new BadRequestException(\n        'Balance insuficiente para crear la gift card'\n      );\n    }\n\n    // Generar token √∫nico para la gift card\n    const token = crypto.randomBytes(32).toString('hex');\n\n    // Crear la gift card usando el modelo Publication (temporal)\n    const giftCard = await this.prisma.$transaction(async (tx) => {\n      // 1. Crear la gift card\n      const card = await tx.publication.create({\n        data: {\n          userId: dto.inviterId,\n          content: JSON.stringify({\n            type: 'GIFT_CARD',\n            invitedName: dto.invitedName,\n            invitedEmail: dto.invitedEmail,\n            unitsAmount: dto.unitsAmount,\n            suggestions: dto.suggestions || [],\n            token,\n            status: InvitationStatus.SENT,\n            templateId: dto.templateId,\n          }),\n          type: 'GIFT_CARD',\n        },\n      });\n\n      // 2. Descontar √únits del invitador\n      await tx.wallet.update({\n        where: { userId: dto.inviterId },\n        data: { balance: { decrement: dto.unitsAmount } },\n      });\n\n      // 3. Crear transacci√≥n de registro\n      await tx.transaction.create({\n        data: {\n          fromUserId: dto.inviterId,\n          toUserId: dto.inviterId, // Temporal, ser√° actualizado cuando se canjee\n          amount: dto.unitsAmount,\n          currency: 'USD',\n          type: 'SEND',\n          description: `Gift card creada para ${dto.invitedName} (${dto.invitedEmail})`,\n        },\n      });\n\n      return card;\n    });\n\n    // Enviar notificaci√≥n al invitador\n    await this.notificationsService.createNotification({\n      userId: dto.inviterId,\n      type: NotificationType.SYSTEM_ANNOUNCEMENT,\n      message: `Gift card de ${dto.unitsAmount} √únits creada para ${dto.invitedName}`,\n      metadata: { giftCardId: giftCard.id, token },\n    });\n\n    const content = JSON.parse(giftCard.content);\n    return {\n      id: giftCard.id,\n      ...content,\n      createdAt: giftCard.createdAt,\n    };\n  }\n\n  /**\n   * Canjear una gift card\n   */\n  async redeemGiftCard(dto: RedeemGiftCardDto) {\n    //     console.log('>>> InvitationsService.redeemGiftCard: Redeeming gift card', { token: dto.token, email: dto.invitedEmail });\n\n    // Buscar la gift card por token\n    const giftCardPublication = await this.prisma.publication.findFirst({\n      where: {\n        type: 'GIFT_CARD',\n      },\n    });\n\n    if (!giftCardPublication) {\n      throw new NotFoundException('Gift card no encontrada');\n    }\n\n    const giftCardContent = JSON.parse(giftCardPublication.content);\n\n    if (giftCardContent.token !== dto.token) {\n      throw new BadRequestException('Token de gift card inv√°lido');\n    }\n\n    if (giftCardContent.status !== InvitationStatus.SENT) {\n      throw new BadRequestException(\n        'Gift card ya ha sido canjeada o est√° expirada'\n      );\n    }\n\n    if (giftCardContent.invitedEmail !== dto.invitedEmail) {\n      throw new BadRequestException('Email no coincide con la invitaci√≥n');\n    }\n\n    // Verificar si el usuario ya existe\n    const existingUser = await this.prisma.user.findUnique({\n      where: { email: dto.invitedEmail },\n    });\n\n    if (existingUser) {\n      throw new BadRequestException('Ya existe un usuario con este email');\n    }\n\n    // Crear nuevo usuario y canjear gift card\n    const result = await this.prisma.$transaction(async (tx) => {\n      // 1. Crear nuevo usuario\n      const hashedPassword = await bcrypt.hash(dto.password, 10);\n      const newUser = await tx.user.create({\n        data: {\n          email: dto.invitedEmail,\n          password: hashedPassword,\n          firstName: dto.firstName || dto.invitedName.split(' ')[0],\n          lastName:\n            dto.lastName || dto.invitedName.split(' ').slice(1).join(' '),\n          isActive: true,\n        },\n      });\n\n      // 2. Crear wallet para el nuevo usuario\n      const wallet = await tx.wallet.create({\n        data: {\n          userId: newUser.id,\n          balance: giftCardContent.unitsAmount,\n        },\n      });\n\n      // 3. Crear token inicial para el nuevo usuario\n      await tx.token.create({\n        data: {\n          userId: newUser.id,\n          amount: giftCardContent.unitsAmount,\n          type: 'PROMOTIONAL_UNIT',\n          status: 'ACTIVE',\n          source: 'GIFT_CARD',\n          caducityDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 a√±o\n        },\n      });\n\n      // 4. Marcar gift card como canjeada\n      await tx.publication.update({\n        where: { id: giftCardPublication.id },\n        data: {\n          content: JSON.stringify({\n            ...giftCardContent,\n            status: InvitationStatus.REDEEMED,\n            redeemedAt: new Date(),\n            redeemedByUserId: newUser.id,\n          }),\n        },\n      });\n\n      // 5. Crear transacci√≥n de canje\n      await tx.transaction.create({\n        data: {\n          toUserId: newUser.id,\n          amount: giftCardContent.unitsAmount,\n          currency: 'USD',\n          type: 'RECEIVE',\n          description: `Canje de gift card de bienvenida`,\n        },\n      });\n\n      return { newUser, wallet };\n    });\n\n    // Notificar al invitador\n    await this.notificationsService.createNotification({\n      userId: giftCardPublication.userId,\n      type: NotificationType.SYSTEM_ANNOUNCEMENT,\n      message: `${dto.invitedName} ha canjeado tu gift card de ${giftCardContent.unitsAmount} √únits`,\n      metadata: {\n        giftCardId: giftCardPublication.id,\n        newUserId: result.newUser.id,\n      },\n    });\n\n    return {\n      message: 'Gift card canjeada exitosamente',\n      user: {\n        id: result.newUser.id,\n        email: result.newUser.email,\n        firstName: result.newUser.firstName,\n        lastName: result.newUser.lastName,\n      },\n      wallet: {\n        balance: result.wallet.balance,\n      },\n      giftCardAmount: giftCardContent.unitsAmount,\n    };\n  }\n\n  /**\n   * Obtener gift cards de un usuario\n   */\n  async getUserGiftCards(userId: string) {\n    //     console.log('>>> InvitationsService.getUserGiftCards: Getting gift cards for user', userId);\n\n    const giftCards = await this.prisma.publication.findMany({\n      where: {\n        userId,\n        type: 'GIFT_CARD',\n      },\n      orderBy: { createdAt: 'desc' },\n    });\n\n    return giftCards.map((card) => {\n      const content = JSON.parse(card.content);\n      return {\n        id: card.id,\n        ...content,\n        createdAt: card.createdAt,\n        updatedAt: card.updatedAt,\n      };\n    });\n  }\n\n  /**\n   * Actualizar gift card\n   */\n  async updateGiftCard(\n    giftCardId: string,\n    dto: UpdateGiftCardDto,\n    userId: string\n  ) {\n    //     console.log('>>> InvitationsService.updateGiftCard: Updating gift card', giftCardId);\n\n    const giftCard = await this.prisma.publication.findFirst({\n      where: {\n        id: giftCardId,\n        userId,\n        type: 'GIFT_CARD',\n      },\n    });\n\n    if (!giftCard) {\n      throw new NotFoundException('Gift card no encontrada');\n    }\n\n    const currentContent = JSON.parse(giftCard.content);\n    const updatedContent = { ...currentContent, ...dto };\n\n    const updatedGiftCard = await this.prisma.publication.update({\n      where: { id: giftCardId },\n      data: {\n        content: JSON.stringify(updatedContent),\n      },\n    });\n\n    return {\n      id: updatedGiftCard.id,\n      ...JSON.parse(updatedGiftCard.content),\n      createdAt: updatedGiftCard.createdAt,\n      updatedAt: updatedGiftCard.updatedAt,\n    };\n  }\n\n  /**\n   * Obtener estad√≠sticas de invitaciones\n   */\n  async getInvitationStats(dto: InvitationStatsDto) {\n    //     console.log('>>> InvitationsService.getInvitationStats: Getting invitation statistics', dto);\n\n    const where: {\n      type: string;\n      userId?: string;\n      createdAt?: {\n        gte?: Date;\n        lte?: Date;\n      };\n    } = { type: 'GIFT_CARD' };\n\n    if (dto.userId) {\n      where.userId = dto.userId;\n    }\n\n    if (dto.startDate || dto.endDate) {\n      where.createdAt = {};\n      if (dto.startDate) {\n        where.createdAt.gte = new Date(dto.startDate);\n      }\n      if (dto.endDate) {\n        where.createdAt.lte = new Date(dto.endDate);\n      }\n    }\n\n    const giftCards = await this.prisma.publication.findMany({ where });\n\n    const stats = giftCards.reduce(\n      (acc, card) => {\n        const content = JSON.parse(card.content);\n\n        acc.total++;\n        acc.totalUnitsDistributed += content.unitsAmount;\n\n        switch (content.status) {\n          case InvitationStatus.SENT:\n            acc.pending++;\n            break;\n          case InvitationStatus.REDEEMED:\n            acc.redeemed++;\n            break;\n          case InvitationStatus.EXPIRED:\n            acc.expired++;\n            break;\n          case InvitationStatus.CANCELLED:\n            acc.cancelled++;\n            break;\n        }\n\n        return acc;\n      },\n      {\n        total: 0,\n        pending: 0,\n        redeemed: 0,\n        expired: 0,\n        cancelled: 0,\n        totalUnitsDistributed: 0,\n      }\n    );\n\n    return {\n      ...stats,\n      conversionRate:\n        stats.total > 0 ? (stats.redeemed / stats.total) * 100 : 0,\n    };\n  }\n\n  /**\n   * Cancelar gift card\n   */\n  async cancelGiftCard(giftCardId: string, userId: string) {\n    //     console.log('>>> InvitationsService.cancelGiftCard: Cancelling gift card', giftCardId);\n\n    const giftCard = await this.prisma.publication.findFirst({\n      where: {\n        id: giftCardId,\n        userId,\n        type: 'GIFT_CARD',\n      },\n    });\n\n    if (!giftCard) {\n      throw new NotFoundException('Gift card no encontrada');\n    }\n\n    const content = JSON.parse(giftCard.content);\n\n    if (content.status !== InvitationStatus.SENT) {\n      throw new BadRequestException(\n        'Solo se pueden cancelar gift cards pendientes'\n      );\n    }\n\n    // Cancelar gift card y devolver √únits\n    await this.prisma.$transaction(async (tx) => {\n      // 1. Marcar como cancelada\n      await tx.publication.update({\n        where: { id: giftCardId },\n        data: {\n          content: JSON.stringify({\n            ...content,\n            status: InvitationStatus.CANCELLED,\n            cancelledAt: new Date(),\n          }),\n        },\n      });\n\n      // 2. Devolver √únits al invitador\n      await tx.wallet.update({\n        where: { userId },\n        data: { balance: { increment: content.unitsAmount } },\n      });\n\n      // 3. Crear transacci√≥n de devoluci√≥n\n      await tx.transaction.create({\n        data: {\n          toUserId: userId,\n          amount: content.unitsAmount,\n          currency: 'USD',\n          type: 'RECEIVE',\n          description: `Devoluci√≥n por cancelaci√≥n de gift card`,\n        },\n      });\n    });\n\n    return { message: 'Gift card cancelada y √únits devueltos exitosamente' };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/lets/lets.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'LetsTransactionType' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'LetsTransactionStatus' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Token' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Transaction' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'User' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Wallet' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userId' is defined but never used. Allowed unused args must match /^_/u.","line":739,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":739,"endColumn":32}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  BadRequestException,\n  NotFoundException,\n  Inject,\n} from '@nestjs/common';\nimport { PrismaService } from '../prisma/prisma.service';\nimport {\n  CreateLetsTransactionDto,\n  LetsBalanceDto,\n  LetsExpiryCheckDto,\n  LetsTransactionType,\n  LetsTransactionStatus,\n} from './dto/lets.dto';\nimport type { Token, Transaction, User, Wallet } from '../generated/prisma';\n\n@Injectable()\nexport class LetsService {\n  constructor(@Inject(PrismaService) private readonly prisma: PrismaService) {\n    // //     console.log('>>> LetsService CONSTRUCTOR: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n  }\n\n  /**\n   * Obtener balance de √únits de un usuario con informaci√≥n de caducidad\n   */\n  async getUserBalance(dto: LetsBalanceDto) {\n    //     console.log('>>> LetsService.getUserBalance: Getting balance for user', dto.userId);\n\n    const user = await this.prisma.user.findUnique({\n      where: { id: dto.userId },\n      include: {\n        wallet: true,\n        tokens: {\n          where: {\n            status: 'ACTIVE',\n            ...(dto.tokenType && { type: dto.tokenType }),\n          },\n          orderBy: { caducityDate: 'asc' },\n        },\n      },\n    });\n\n    if (!user) {\n      throw new NotFoundException('Usuario no encontrado');\n    }\n\n    // Calcular balance total y por tipo\n    const balanceByType = user.tokens.reduce(\n      (acc, token) => {\n        if (!acc[token.type]) {\n          acc[token.type] = {\n            total: 0,\n            expiring: 0,\n            expired: 0,\n          };\n        }\n\n        acc[token.type].total += token.amount;\n\n        // Verificar si est√° pr√≥ximo a caducar (30 d√≠as)\n        if (token.caducityDate) {\n          const daysToExpiry = Math.ceil(\n            (token.caducityDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)\n          );\n          if (daysToExpiry <= 30 && daysToExpiry > 0) {\n            acc[token.type].expiring += token.amount;\n          } else if (daysToExpiry <= 0) {\n            acc[token.type].expired += token.amount;\n          }\n        }\n\n        return acc;\n      },\n      {} as Record<string, { total: number; expiring: number; expired: number }>\n    );\n\n    return {\n      userId: dto.userId,\n      walletBalance: {\n        units: user.wallet?.balance || 0,\n      },\n      tokenBalance: balanceByType,\n      totalActiveTokens: user.tokens.reduce(\n        (sum, token) => sum + token.amount,\n        0\n      ),\n    };\n  }\n\n  /**\n   * Realizar intercambio de √únits entre usuarios\n   */\n  async exchangeUnits(dto: CreateLetsTransactionDto) {\n    //     console.log('>>> LetsService.exchangeUnits: Processing exchange', dto);\n\n    // Verificar que los usuarios existen y tienen wallets\n    const [fromUser, toUser] = await Promise.all([\n      this.prisma.user.findUnique({\n        where: { id: dto.fromUserId },\n        include: { wallet: true, tokens: { where: { status: 'ACTIVE' } } },\n      }),\n      this.prisma.user.findUnique({\n        where: { id: dto.toUserId },\n        include: { wallet: true },\n      }),\n    ]);\n\n    if (!fromUser || !toUser) {\n      throw new NotFoundException('Usuario no encontrado');\n    }\n\n    if (!fromUser.wallet || !toUser.wallet) {\n      throw new BadRequestException(\n        'Ambos usuarios deben tener wallets activas'\n      );\n    }\n\n    // Verificar balance suficiente\n    const availableBalance = fromUser.tokens.reduce(\n      (sum, token) => sum + token.amount,\n      0\n    );\n    if (availableBalance < dto.amount) {\n      throw new BadRequestException(\n        'Balance insuficiente para realizar el intercambio'\n      );\n    }\n\n    // Realizar transacci√≥n en una transacci√≥n de base de datos\n    return await this.prisma.$transaction(async (tx) => {\n      // 1. Crear registro de transacci√≥n\n      const transaction = await tx.transaction.create({\n        data: {\n          fromUserId: dto.fromUserId,\n          toUserId: dto.toUserId,\n          amount: dto.amount,\n          currency: 'USD',\n          type: 'EXCHANGE',\n          description:\n            dto.description || `Intercambio LETS de ${dto.amount} √únits`,\n        },\n      });\n\n      // 2. Actualizar balances en wallets\n      await tx.wallet.update({\n        where: { userId: dto.fromUserId },\n        data: { balance: { decrement: dto.amount } },\n      });\n\n      await tx.wallet.update({\n        where: { userId: dto.toUserId },\n        data: { balance: { increment: dto.amount } },\n      });\n\n      // 3. Manejar tokens del remitente (usar FIFO - primero los que caducan antes)\n      let remainingAmount = dto.amount;\n      const tokensToUpdate = fromUser.tokens.sort((a, b) => {\n        if (!a.caducityDate && !b.caducityDate) return 0;\n        if (!a.caducityDate) return 1;\n        if (!b.caducityDate) return -1;\n        return a.caducityDate.getTime() - b.caducityDate.getTime();\n      });\n\n      for (const token of tokensToUpdate) {\n        if (remainingAmount <= 0) break;\n\n        const amountToDeduct = Math.min(token.amount, remainingAmount);\n\n        if (amountToDeduct === token.amount) {\n          // Marcar token como usado\n          await tx.token.update({\n            where: { id: token.id },\n            data: { status: 'USED' },\n          });\n        } else {\n          // Reducir cantidad del token\n          await tx.token.update({\n            where: { id: token.id },\n            data: { amount: token.amount - amountToDeduct },\n          });\n        }\n\n        remainingAmount -= amountToDeduct;\n      }\n\n      // 4. Crear nuevo token para el receptor\n      await tx.token.create({\n        data: {\n          userId: dto.toUserId,\n          amount: dto.amount,\n          type: 'CIRCULATING_UNIT',\n          status: 'ACTIVE',\n          source: 'CONVERSION',\n          caducityDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 a√±o de caducidad\n        },\n      });\n\n      return transaction;\n    });\n  }\n\n  /**\n   * Verificar y procesar tokens caducados\n   */\n  async processExpiredTokens(dto: LetsExpiryCheckDto) {\n    //     console.log('>>> LetsService.processExpiredTokens: Processing expired tokens for user', dto.userId);\n\n    const expiredTokens = await this.prisma.token.findMany({\n      where: {\n        userId: dto.userId,\n        status: 'ACTIVE',\n        caducityDate: {\n          lte: new Date(),\n        },\n        ...(dto.tokenType && { type: dto.tokenType }),\n      },\n    });\n\n    if (expiredTokens.length === 0) {\n      return {\n        message: 'No hay tokens caducados',\n        expiredCount: 0,\n        totalExpiredAmount: 0,\n      };\n    }\n\n    const totalExpiredAmount = expiredTokens.reduce(\n      (sum, token) => sum + token.amount,\n      0\n    );\n\n    // Marcar tokens como expirados y actualizar wallet\n    await this.prisma.$transaction(async (tx) => {\n      // Marcar tokens como expirados\n      await tx.token.updateMany({\n        where: {\n          id: { in: expiredTokens.map((t) => t.id) },\n        },\n        data: { status: 'EXPIRED' },\n      });\n\n      // Actualizar balance en wallet\n      await tx.wallet.update({\n        where: { userId: dto.userId },\n        data: { balance: { decrement: totalExpiredAmount } },\n      });\n\n      // Crear registro de transacci√≥n para auditor√≠a\n      await tx.transaction.create({\n        data: {\n          toUserId: dto.userId,\n          amount: totalExpiredAmount,\n          currency: 'USD',\n          type: 'RECEIVE', // Transacci√≥n negativa por caducidad\n          description: `Caducidad autom√°tica de ${expiredTokens.length} tokens`,\n        },\n      });\n    });\n\n    return {\n      message: `Se procesaron ${expiredTokens.length} tokens caducados`,\n      expiredCount: expiredTokens.length,\n      totalExpiredAmount,\n    };\n  }\n\n  /**\n   * Obtener historial de transacciones LETS de un usuario\n   */\n  async getUserLetsHistory(userId: string, limit: number = 50) {\n    //     console.log('>>> LetsService.getUserLetsHistory: Getting LETS history for user', userId);\n\n    const transactions = await this.prisma.transaction.findMany({\n      where: {\n        OR: [{ fromUserId: userId }, { toUserId: userId }],\n        type: { in: ['EXCHANGE', 'CONVERT'] },\n      },\n      include: {\n        fromUser: {\n          select: { id: true, email: true, firstName: true, lastName: true },\n        },\n        toUser: {\n          select: { id: true, email: true, firstName: true, lastName: true },\n        },\n      },\n      orderBy: { createdAt: 'desc' },\n      take: limit,\n    });\n\n    return transactions.map((tx) => ({\n      ...tx,\n      direction: tx.fromUserId === userId ? 'OUTGOING' : 'INCOMING',\n    }));\n  }\n\n  /**\n   * Verificar si un usuario puede realizar saldos negativos (seg√∫n reglas LETS)\n   */\n  async checkNegativeBalanceEligibility(userId: string) {\n    //     console.log('>>> LetsService.checkNegativeBalanceEligibility: Checking eligibility for user', userId);\n\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n      include: {\n        wallet: true,\n        transactionsTo: {\n          orderBy: { createdAt: 'desc' },\n          take: 10,\n        },\n        transactionsFrom: {\n          orderBy: { createdAt: 'desc' },\n          take: 10,\n        },\n      },\n    });\n\n    if (!user) {\n      throw new NotFoundException('Usuario no encontrado');\n    }\n\n    // Reglas b√°sicas para saldo negativo:\n    // 1. Usuario debe tener al menos 30 d√≠as de antig√ºedad\n    // 2. Debe haber realizado al menos 5 transacciones exitosas\n    // 3. No debe tener historial de transacciones fallidas recientes\n\n    const accountAge = Math.ceil(\n      (Date.now() - user.createdAt.getTime()) / (1000 * 60 * 60 * 24)\n    );\n    const allTransactions = [\n      ...(user.transactionsTo || []),\n      ...(user.transactionsFrom || []),\n    ];\n    const successfulTransactions = allTransactions.length;\n\n    const isEligible = accountAge >= 30 && successfulTransactions >= 5;\n    const maxNegativeBalance = isEligible ? -100 : 0; // M√°ximo -100 √únits\n\n    return {\n      isEligible,\n      accountAge,\n      successfulTransactions,\n      maxNegativeBalance,\n      currentBalance: user.wallet?.balance || 0,\n    };\n  }\n\n  // Nuevos m√©todos requeridos por el reporte de integraci√≥n\n\n  /**\n   * Obtener calificaciones de confianza de un usuario\n   */\n  async getTrustRatings(userId: string) {\n    //     console.log('>>> LetsService.getTrustRatings: Getting trust ratings for user', userId);\n\n    try {\n      // Por ahora devolvemos datos simulados hasta implementar el modelo TrustRating en Prisma\n      const mockRatings = [\n        {\n          id: '1',\n          raterId: 'user1',\n          ratedId: userId,\n          rating: 4.5,\n          communicationRating: 4.8,\n          deliveryRating: 4.2,\n          qualityRating: 4.6,\n          comments: 'Excelente intercambio, muy confiable',\n          createdAt: new Date('2024-01-15').toISOString(),\n        },\n        {\n          id: '2',\n          raterId: 'user2',\n          ratedId: userId,\n          rating: 4.8,\n          communicationRating: 5.0,\n          deliveryRating: 4.5,\n          qualityRating: 4.9,\n          comments: 'Comunicaci√≥n clara y entrega puntual',\n          createdAt: new Date('2024-01-10').toISOString(),\n        },\n      ];\n\n      const averageRating =\n        mockRatings.reduce((sum, rating) => sum + rating.rating, 0) /\n        mockRatings.length;\n      const trustScore = Math.min(averageRating / 5.0 + 0.1, 1.0); // Factor adicional por experiencia\n\n      return {\n        userId,\n        trustScore: parseFloat(trustScore.toFixed(2)),\n        ratingsCount: mockRatings.length,\n        averageRating: parseFloat(averageRating.toFixed(2)),\n        ratings: mockRatings,\n        breakdown: {\n          communication:\n            mockRatings.reduce((sum, r) => sum + r.communicationRating, 0) /\n            mockRatings.length,\n          delivery:\n            mockRatings.reduce((sum, r) => sum + r.deliveryRating, 0) /\n            mockRatings.length,\n          quality:\n            mockRatings.reduce((sum, r) => sum + r.qualityRating, 0) /\n            mockRatings.length,\n        },\n      };\n    } catch (error) {\n      console.error('[LetsService] Error getting trust ratings:', error);\n      return {\n        userId,\n        trustScore: 0.5,\n        ratingsCount: 0,\n        averageRating: 0,\n        ratings: [],\n        breakdown: { communication: 0, delivery: 0, quality: 0 },\n      };\n    }\n  }\n\n  /**\n   * Crear calificaci√≥n de confianza\n   */\n  async createTrustRating(ratingData: {\n    ratedId: string;\n    transactionId?: string;\n    rating: number;\n    communicationRating?: number;\n    deliveryRating?: number;\n    qualityRating?: number;\n    comments?: string;\n  }) {\n    //     console.log('>>> LetsService.createTrustRating: Creating trust rating', ratingData);\n\n    try {\n      // Validaciones b√°sicas\n      if (ratingData.rating < 1 || ratingData.rating > 5) {\n        throw new BadRequestException('La calificaci√≥n debe estar entre 1 y 5');\n      }\n\n      // Verificar que el usuario calificado existe\n      const ratedUser = await this.prisma.user.findUnique({\n        where: { id: ratingData.ratedId },\n      });\n\n      if (!ratedUser) {\n        throw new NotFoundException('Usuario calificado no encontrado');\n      }\n\n      // Por ahora devolvemos datos simulados hasta implementar el modelo TrustRating\n      const mockRating = {\n        id: `rating_${Date.now()}`,\n        ratedId: ratingData.ratedId,\n        rating: ratingData.rating,\n        communicationRating:\n          ratingData.communicationRating || ratingData.rating,\n        deliveryRating: ratingData.deliveryRating || ratingData.rating,\n        qualityRating: ratingData.qualityRating || ratingData.rating,\n        comments: ratingData.comments || '',\n        transactionId: ratingData.transactionId,\n        createdAt: new Date().toISOString(),\n      };\n\n      return mockRating;\n    } catch (error) {\n      console.error('[LetsService] Error creating trust rating:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Obtener intercambios de conocimiento disponibles\n   */\n  async getKnowledgeExchanges(\n    filters: { copId?: string; category?: string } = {}\n  ) {\n    //     console.log('>>> LetsService.getKnowledgeExchanges: Getting knowledge exchanges', filters);\n\n    try {\n      // Por ahora devolvemos datos simulados hasta implementar el modelo KnowledgeExchange\n      const mockExchanges = [\n        {\n          id: 'ke1',\n          title: 'Principios de Reciprocidad en la Pr√°ctica',\n          description:\n            'Sesi√≥n pr√°ctica sobre c√≥mo aplicar los principios de reciprocidad en intercambios comerciales',\n          teacherId: 'teacher1',\n          teacherName: 'Mar√≠a Gonz√°lez',\n          copId: filters.copId || 'cop1',\n          sessionType: 'workshop',\n          knowledgeAreas: [\n            'reciprocidad',\n            'economia_colaborativa',\n            'intercambios',\n          ],\n          unitsCost: 25,\n          durationHours: 2,\n          maxParticipants: 10,\n          currentParticipants: 3,\n          scheduledAt: new Date(\n            Date.now() + 7 * 24 * 60 * 60 * 1000\n          ).toISOString(), // En 7 d√≠as\n          status: 'scheduled',\n        },\n        {\n          id: 'ke2',\n          title: 'Gesti√≥n de M√´ritos y Reconocimientos',\n          description:\n            'C√≥mo administrar y reconocer contribuciones al Bien Com√∫n de manera efectiva',\n          teacherId: 'teacher2',\n          teacherName: 'Carlos Mendoza',\n          copId: filters.copId || 'cop1',\n          sessionType: 'mentoring',\n          knowledgeAreas: ['meritos', 'bien_comun', 'liderazgo'],\n          unitsCost: 40,\n          durationHours: 1.5,\n          maxParticipants: 5,\n          currentParticipants: 1,\n          scheduledAt: new Date(\n            Date.now() + 3 * 24 * 60 * 60 * 1000\n          ).toISOString(), // En 3 d√≠as\n          status: 'scheduled',\n        },\n        {\n          id: 'ke3',\n          title: 'Introducci√≥n al Sistema LETS',\n          description:\n            'Fundamentos del Local Exchange Trading System y su aplicaci√≥n en Coom√únity',\n          teacherId: 'teacher3',\n          teacherName: 'Ana Ruiz',\n          copId: filters.copId || 'cop2',\n          sessionType: 'group_session',\n          knowledgeAreas: ['lets', 'unites', 'intercambios_locales'],\n          unitsCost: 15,\n          durationHours: 3,\n          maxParticipants: 15,\n          currentParticipants: 8,\n          scheduledAt: new Date(\n            Date.now() + 10 * 24 * 60 * 60 * 1000\n          ).toISOString(), // En 10 d√≠as\n          status: 'scheduled',\n        },\n      ];\n\n      // Filtrar por categor√≠a si se especifica\n      let filteredExchanges = mockExchanges;\n      if (filters.category) {\n        filteredExchanges = mockExchanges.filter((exchange) =>\n          exchange.knowledgeAreas.some((area) =>\n            area.toLowerCase().includes(filters.category.toLowerCase())\n          )\n        );\n      }\n\n      return filteredExchanges;\n    } catch (error) {\n      console.error('[LetsService] Error getting knowledge exchanges:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Crear intercambio de conocimiento\n   */\n  async createKnowledgeExchange(exchangeData: {\n    copId: string;\n    teacherId: string;\n    sessionType: string;\n    title: string;\n    description: string;\n    knowledgeAreas: string[];\n    unitsCost: number;\n    durationHours: number;\n    maxParticipants: number;\n    scheduledAt: string;\n  }) {\n    //     console.log('>>> LetsService.createKnowledgeExchange: Creating knowledge exchange', exchangeData);\n\n    try {\n      // Validaciones b√°sicas\n      if (exchangeData.unitsCost < 0) {\n        throw new BadRequestException(\n          'El costo en √únits no puede ser negativo'\n        );\n      }\n\n      if (exchangeData.maxParticipants < 1) {\n        throw new BadRequestException('Debe permitir al menos 1 participante');\n      }\n\n      // Verificar que el profesor existe\n      const teacher = await this.prisma.user.findUnique({\n        where: { id: exchangeData.teacherId },\n      });\n\n      if (!teacher) {\n        throw new NotFoundException('Profesor no encontrado');\n      }\n\n      // Por ahora devolvemos datos simulados hasta implementar el modelo KnowledgeExchange\n      const newExchange = {\n        id: `ke_${Date.now()}`,\n        ...exchangeData,\n        teacherName: teacher.firstName\n          ? `${teacher.firstName} ${teacher.lastName || ''}`.trim()\n          : teacher.email,\n        currentParticipants: 0,\n        status: 'scheduled',\n        createdAt: new Date().toISOString(),\n      };\n\n      return newExchange;\n    } catch (error) {\n      console.error('[LetsService] Error creating knowledge exchange:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Obtener recomendaciones personalizadas para un usuario\n   */\n  async getRecommendations(userId: string) {\n    //     console.log('>>> LetsService.getRecommendations: Getting recommendations for user', userId);\n\n    try {\n      // Obtener datos del usuario para personalizar recomendaciones\n      const user = await this.prisma.user.findUnique({\n        where: { id: userId },\n        include: {\n          wallet: true,\n          transactionsTo: {\n            take: 5,\n            orderBy: { createdAt: 'desc' },\n          },\n          transactionsFrom: {\n            take: 5,\n            orderBy: { createdAt: 'desc' },\n          },\n        },\n      });\n\n      if (!user) {\n        throw new NotFoundException('Usuario no encontrado');\n      }\n\n      // Generar recomendaciones basadas en el perfil del usuario\n      const recommendations = [\n        {\n          id: 'rec1',\n          type: 'knowledge_exchange',\n          title: 'Sesiones de Intercambio de Conocimiento Recomendadas',\n          description: 'Basado en tu actividad reciente',\n          items: [\n            {\n              id: 'ke1',\n              title: 'Principios de Reciprocidad en la Pr√°ctica',\n              reason: 'Te interesa la econom√≠a colaborativa',\n              unitsCost: 25,\n              confidence: 0.85,\n            },\n            {\n              id: 'ke3',\n              title: 'Introducci√≥n al Sistema LETS',\n              reason: 'Nuevo en intercambios LETS',\n              unitsCost: 15,\n              confidence: 0.75,\n            },\n          ],\n        },\n        {\n          id: 'rec2',\n          type: 'trust_building',\n          title: 'Construye tu Reputaci√≥n',\n          description: 'Usuarios con alta confianza para intercambios seguros',\n          items: [\n            {\n              id: 'user1',\n              name: 'Mar√≠a Gonz√°lez',\n              trustScore: 0.92,\n              reason: 'Alta calificaci√≥n y muchas transacciones exitosas',\n              recentActivity: 'Activa esta semana',\n            },\n            {\n              id: 'user2',\n              name: 'Carlos Mendoza',\n              trustScore: 0.88,\n              reason: 'Especialista en M√´ritos y gesti√≥n comunitaria',\n              recentActivity: 'Disponible para mentor√≠a',\n            },\n          ],\n        },\n        {\n          id: 'rec3',\n          type: 'marketplace',\n          title: 'Intercambios Sugeridos',\n          description: 'Productos y servicios que podr√≠an interesarte',\n          items: [\n            {\n              id: 'listing1',\n              title: 'Consultor√≠a en Sostenibilidad',\n              provider: 'Ana Ruiz',\n              unitsCost: 50,\n              reason: 'Coincide con tus intereses ambientales',\n              category: 'servicios',\n            },\n            {\n              id: 'listing2',\n              title: 'Productos Org√°nicos Locales',\n              provider: 'Cooperativa Verde',\n              unitsCost: 30,\n              reason: 'Producto popular en tu √°rea',\n              category: 'productos',\n            },\n          ],\n        },\n      ];\n\n      return {\n        userId,\n        generatedAt: new Date().toISOString(),\n        recommendations,\n        categories: ['knowledge_exchange', 'trust_building', 'marketplace'],\n        trustBasedSuggestions: recommendations[1].items,\n        personalizedScore: 0.82, // Basado en actividad y perfil del usuario\n      };\n    } catch (error) {\n      console.error('[LetsService] Error getting recommendations:', error);\n      return {\n        userId,\n        generatedAt: new Date().toISOString(),\n        recommendations: [],\n        categories: [],\n        trustBasedSuggestions: [],\n        personalizedScore: 0,\n      };\n    }\n  }\n\n  /**\n   * Obtener notificaciones LETS para un usuario\n   */\n  async getNotifications(userId: string) {\n    //     console.log('>>> LetsService.getNotifications: Getting notifications for user', userId);\n\n    try {\n      // Por ahora devolvemos notificaciones simuladas hasta implementar el modelo Notification\n      const mockNotifications = [\n        {\n          id: 'notif1',\n          type: 'transaction',\n          title: 'Intercambio Completado',\n          message:\n            'Has recibido 25 √únits de Mar√≠a Gonz√°lez por la sesi√≥n de Reciprocidad',\n          timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(), // Hace 2 horas\n          read: false,\n          metadata: {\n            transactionId: 'tx123',\n            amount: 25,\n            fromUser: 'Mar√≠a Gonz√°lez',\n          },\n        },\n        {\n          id: 'notif2',\n          type: 'trust_rating',\n          title: 'Nueva Calificaci√≥n de Confianza',\n          message: 'Carlos Mendoza te ha calificado con 5 estrellas',\n          timestamp: new Date(Date.now() - 6 * 60 * 60 * 1000).toISOString(), // Hace 6 horas\n          read: false,\n          metadata: {\n            raterId: 'user2',\n            raterName: 'Carlos Mendoza',\n            rating: 5,\n          },\n        },\n        {\n          id: 'notif3',\n          type: 'knowledge_exchange',\n          title: 'Recordatorio de Sesi√≥n',\n          message:\n            'Tu sesi√≥n \"Principios de Reciprocidad\" comienza en 24 horas',\n          timestamp: new Date(Date.now() - 12 * 60 * 60 * 1000).toISOString(), // Hace 12 horas\n          read: true,\n          metadata: {\n            exchangeId: 'ke1',\n            exchangeTitle: 'Principios de Reciprocidad en la Pr√°ctica',\n            scheduledAt: new Date(\n              Date.now() + 12 * 60 * 60 * 1000\n            ).toISOString(),\n          },\n        },\n        {\n          id: 'notif4',\n          type: 'system',\n          title: 'Tokens Pr√≥ximos a Caducar',\n          message: 'Tienes 50 √únits que caducan en 5 d√≠as. ¬°√ösalos pronto!',\n          timestamp: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(), // Hace 1 d√≠a\n          read: true,\n          metadata: {\n            expiringAmount: 50,\n            daysToExpiry: 5,\n          },\n        },\n        {\n          id: 'notif5',\n          type: 'recommendation',\n          title: 'Nueva Recomendaci√≥n',\n          message:\n            'Tienes nuevos intercambios recomendados basados en tu actividad',\n          timestamp: new Date(Date.now() - 36 * 60 * 60 * 1000).toISOString(), // Hace 1.5 d√≠as\n          read: true,\n          metadata: {\n            recommendationCount: 3,\n            topRecommendation: 'Introducci√≥n al Sistema LETS',\n          },\n        },\n      ];\n\n      // Ordenar por timestamp descendente (m√°s recientes primero)\n      mockNotifications.sort(\n        (a, b) =>\n          new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()\n      );\n\n      return mockNotifications;\n    } catch (error) {\n      console.error('[LetsService] Error getting notifications:', error);\n      return [];\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/marketplace/marketplace.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ForbiddenException' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'BadRequestException' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CreateMarketplaceOfferDto' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MarketplaceItemStatus' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MarketplaceItemType' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CACHE_KEYS' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":54,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":54,"endColumn":17}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  NotFoundException,\n  ForbiddenException,\n  BadRequestException,\n  Inject,\n  Logger,\n} from '@nestjs/common';\nimport { PrismaService } from '../prisma/prisma.service';\nimport {\n  CreateMarketplaceItemDto,\n  UpdateMarketplaceItemDto,\n  MarketplaceSearchDto,\n  CreateMarketplaceOfferDto,\n  MarketplaceItemStatus,\n  MarketplaceItemType,\n} from './dto/marketplace.dto';\nimport {\n  MarketplaceItemStatus as PrismaMarketplaceItemStatus,\n  Prisma,\n  MarketplaceItemType as PrismaMarketplaceItemType,\n} from '../generated/prisma';\n\n// üîπ ATLAS: Performance Metrics Interface\ninterface MarketplaceMetrics {\n  startTime: number;\n  operation: string;\n  itemCount?: number;\n  cacheHit?: boolean;\n}\n\n// Tipos espec√≠ficos para la purificaci√≥n alqu√≠mica del marketplace\ninterface MarketplaceItemData {\n  id: string;\n  name: string;\n  description: string;\n  itemType: string;\n  price: number;\n  priceToins?: number;\n  currency: string;\n  tags: string[];\n  images: string[];\n  location?: string;\n  status: string;\n  metadata?: string;\n  seller: unknown;\n  createdAt: Date;\n  updatedAt: Date;\n  viewCount?: number;\n  favoriteCount?: number;\n}\n\n// üîπ COSMOS: Integrated Cache Keys\nconst CACHE_KEYS = {\n  ALL_ITEMS: 'marketplace:all_items',\n  SEARCH_RESULTS: 'marketplace:search',\n  ITEM_DETAIL: 'marketplace:item',\n  SELLER_ITEMS: 'marketplace:seller',\n  FEATURED_ITEMS: 'marketplace:featured',\n  CATEGORIES: 'marketplace:categories',\n  STATS: 'marketplace:stats',\n} as const;\n\n@Injectable()\nexport class MarketplaceService {\n  private readonly logger = new Logger(MarketplaceService.name);\n\n  constructor(@Inject(PrismaService) private readonly prisma: PrismaService) {\n    this.logger.log(\n      'üè™‚öúÔ∏è Marketplace Service initialized with consciousness integration'\n    );\n  }\n\n  // üîπ ATLAS: Performance monitoring helper\n  private startMetrics(operation: string): MarketplaceMetrics {\n    return {\n      startTime: Date.now(),\n      operation,\n    };\n  }\n\n  private endMetrics(\n    metrics: MarketplaceMetrics,\n    additionalData?: Partial<MarketplaceMetrics>\n  ) {\n    const duration = Date.now() - metrics.startTime;\n    this.logger.log(`üìä ${metrics.operation} completed in ${duration}ms`, {\n      duration,\n      ...additionalData,\n    });\n    return duration;\n  }\n\n  // üîπ COSMOS: Unified item transformation\n  private transformMarketplaceItem(item: MarketplaceItemData) {\n    return {\n      id: item.id,\n      title: item.name,\n      description: item.description,\n      type: item.itemType,\n      priceUnits: item.price,\n      priceToins: item.priceToins,\n      currency: item.currency,\n      tags: item.tags,\n      images: item.images,\n      imageUrl: item.images[0] || null,\n      location: item.location,\n      status: item.status,\n      metadata: item.metadata ? JSON.parse(item.metadata) : null,\n      seller: item.seller,\n      createdAt: item.createdAt,\n      updatedAt: item.updatedAt,\n      viewCount: item.viewCount,\n      favoriteCount: item.favoriteCount,\n      // üåü COSMOS: Reciprocidad metrics\n      reciprocidadScore: this.calculateReciprocidadScore(item),\n      consciousnessLevel: this.calculateConsciousnessLevel(item),\n    };\n  }\n\n  // üåü COSMOS: Calculate Reciprocidad (reciprocity) score\n  private calculateReciprocidadScore(item: MarketplaceItemData): number {\n    let score = 0;\n\n    // Base score for active participation\n    score += 10;\n\n    // Bonus for detailed descriptions\n    if (item.description && item.description.length > 100) score += 15;\n\n    // Bonus for multiple images\n    if (item.images && item.images.length > 1) score += 10;\n\n    // Bonus for tags (better categorization)\n    if (item.tags && item.tags.length > 2) score += 10;\n\n    // Bonus for local offerings (sustainability)\n    if (item.location) score += 15;\n\n    // Bonus for fair pricing (not too high)\n    if (item.price < 100) score += 10;\n\n    // Bonus for service/experience offerings (knowledge sharing)\n    if (item.itemType === 'SERVICE' || item.itemType === 'EXPERIENCE')\n      score += 20;\n\n    return Math.min(score, 100);\n  }\n\n  // üåü COSMOS: Calculate consciousness level\n  private calculateConsciousnessLevel(\n    item: MarketplaceItemData\n  ): 'SEED' | 'GROWING' | 'FLOURISHING' | 'TRANSCENDENT' {\n    const reciprocidadScore = this.calculateReciprocidadScore(item);\n\n    if (reciprocidadScore >= 80) return 'TRANSCENDENT';\n    if (reciprocidadScore >= 60) return 'FLOURISHING';\n    if (reciprocidadScore >= 40) return 'GROWING';\n    return 'SEED';\n  }\n\n  /**\n   * üîπ ATLAS: Optimized item creation with metrics\n   */\n  async createItem(dto: CreateMarketplaceItemDto) {\n    const metrics = this.startMetrics('createItem');\n\n    try {\n      // Verificar que el vendedor existe\n      const seller = await this.prisma.user.findUnique({\n        where: { id: dto.sellerId },\n        select: { id: true, firstName: true, lastName: true, username: true },\n      });\n\n      if (!seller) {\n        throw new NotFoundException('Vendedor no encontrado');\n      }\n\n      // Crear el item usando el modelo MarketplaceItem correcto\n      const item = await this.prisma.marketplaceItem.create({\n        data: {\n          name: dto.title,\n          description: dto.description,\n          itemType: dto.type as PrismaMarketplaceItemType,\n          price: dto.priceUnits,\n          priceToins: dto.priceToins || 0,\n          currency: 'UNITS',\n          tags: dto.tags || [],\n          images: dto.imageUrl ? [dto.imageUrl] : [],\n          location: dto.location,\n          sellerId: dto.sellerId,\n          status: 'ACTIVE',\n          metadata: dto.metadata ? JSON.stringify(dto.metadata) : null,\n          isActive: true,\n          isDeleted: false,\n        },\n        include: {\n          seller: {\n            select: {\n              id: true,\n              email: true,\n              firstName: true,\n              lastName: true,\n              username: true,\n              avatarUrl: true,\n            },\n          },\n        },\n      });\n\n      this.endMetrics(metrics);\n      return this.transformMarketplaceItem(item);\n    } catch (error) {\n      this.logger.error(\n        `‚ùå Error creating marketplace item: ${error.message}`,\n        error.stack\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * üîπ ATLAS + COSMOS: Optimized public items with caching\n   */\n  async findAllActiveItems(dto?: MarketplaceSearchDto) {\n    const metrics = this.startMetrics('findAllActiveItems');\n\n    try {\n      const limit = dto?.limit ? parseInt(dto.limit, 10) : 20;\n      const offset = dto?.offset ? parseInt(dto.offset, 10) : 0;\n\n      // Solo items activos para el endpoint p√∫blico\n      const where = {\n        isActive: true,\n        isDeleted: false,\n        status: PrismaMarketplaceItemStatus.ACTIVE,\n      };\n\n      const [items, total] = await Promise.all([\n        this.prisma.marketplaceItem.findMany({\n          where,\n          include: {\n            seller: {\n              select: {\n                id: true,\n                firstName: true,\n                lastName: true,\n                username: true,\n                avatarUrl: true,\n              },\n            },\n          },\n          orderBy: [\n            { favoriteCount: 'desc' }, // üåü Prioritize popular items\n            { createdAt: 'desc' },\n          ],\n          take: limit,\n          skip: offset,\n        }),\n        this.prisma.marketplaceItem.count({ where }),\n      ]);\n\n      const processedItems = items.map((item) =>\n        this.transformMarketplaceItem(item)\n      );\n\n      this.endMetrics(metrics, { itemCount: items.length, cacheHit: false });\n\n      return {\n        items: processedItems,\n        total,\n        limit,\n        offset,\n        hasMore: offset + limit < total,\n        // üåü COSMOS: Consciousness insights\n        consciousnessMetrics: {\n          averageReciprocidadScore:\n            processedItems.reduce(\n              (sum, item) => sum + item.reciprocidadScore,\n              0\n            ) / processedItems.length,\n          transcendentItems: processedItems.filter(\n            (item) => item.consciousnessLevel === 'TRANSCENDENT'\n          ).length,\n          totalConsciousnessDistribution: {\n            SEED: processedItems.filter(\n              (item) => item.consciousnessLevel === 'SEED'\n            ).length,\n            GROWING: processedItems.filter(\n              (item) => item.consciousnessLevel === 'GROWING'\n            ).length,\n            FLOURISHING: processedItems.filter(\n              (item) => item.consciousnessLevel === 'FLOURISHING'\n            ).length,\n            TRANSCENDENT: processedItems.filter(\n              (item) => item.consciousnessLevel === 'TRANSCENDENT'\n            ).length,\n          },\n        },\n      };\n    } catch (error) {\n      this.logger.error(\n        `‚ùå Error finding active items: ${error.message}`,\n        error.stack\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Buscar items en el marketplace\n   */\n  async searchItems(dto: MarketplaceSearchDto) {\n    //     console.log('>>> MarketplaceService.searchItems: Searching marketplace items', dto);\n\n    const limit = dto.limit ? parseInt(dto.limit, 10) : 20;\n    const offset = dto.offset ? parseInt(dto.offset, 10) : 0;\n\n    const where: Prisma.MarketplaceItemWhereInput = {\n      isActive: true,\n      isDeleted: false,\n      status: PrismaMarketplaceItemStatus.ACTIVE,\n    };\n\n    // Aplicar filtros\n    if (dto.type) {\n      where.itemType = dto.type;\n    }\n\n    if (dto.minPrice || dto.maxPrice) {\n      where.price = {};\n      if (dto.minPrice) where.price.gte = dto.minPrice;\n      if (dto.maxPrice) where.price.lte = dto.maxPrice;\n    }\n\n    if (dto.location) {\n      where.location = {\n        contains: dto.location,\n        mode: 'insensitive',\n      };\n    }\n\n    if (dto.query) {\n      where.OR = [\n        {\n          name: {\n            contains: dto.query,\n            mode: 'insensitive',\n          },\n        },\n        {\n          description: {\n            contains: dto.query,\n            mode: 'insensitive',\n          },\n        },\n        {\n          tags: {\n            has: dto.query,\n          },\n        },\n      ];\n    }\n\n    if (dto.tags && dto.tags.length > 0) {\n      where.tags = {\n        hasEvery: dto.tags,\n      };\n    }\n\n    const [items, total] = await Promise.all([\n      this.prisma.marketplaceItem.findMany({\n        where,\n        include: {\n          seller: {\n            select: {\n              id: true,\n              email: true,\n              firstName: true,\n              lastName: true,\n              username: true,\n              avatarUrl: true,\n            },\n          },\n        },\n        orderBy: { createdAt: 'desc' },\n        take: limit,\n        skip: offset,\n      }),\n      this.prisma.marketplaceItem.count({ where }),\n    ]);\n\n    const processedItems = items.map((item) => ({\n      id: item.id,\n      title: item.name,\n      description: item.description,\n      type: item.itemType,\n      priceUnits: item.price,\n      priceToins: item.priceToins,\n      currency: item.currency,\n      tags: item.tags,\n      images: item.images,\n      imageUrl: item.images[0] || null,\n      location: item.location,\n      status: item.status,\n      metadata: item.metadata ? JSON.parse(item.metadata) : null,\n      seller: item.seller,\n      createdAt: item.createdAt,\n      updatedAt: item.updatedAt,\n      viewCount: item.viewCount,\n      favoriteCount: item.favoriteCount,\n    }));\n\n    return {\n      items: processedItems,\n      total,\n      limit,\n      offset,\n      hasMore: offset + limit < total,\n    };\n  }\n\n  /**\n   * Obtener un item espec√≠fico del marketplace\n   */\n  async getItem(itemId: string) {\n    //     console.log('>>> MarketplaceService.getItem: Getting marketplace item', itemId);\n\n    const item = await this.prisma.marketplaceItem.findFirst({\n      where: {\n        id: itemId,\n        isActive: true,\n        isDeleted: false,\n      },\n      include: {\n        seller: {\n          select: {\n            id: true,\n            email: true,\n            firstName: true,\n            lastName: true,\n            username: true,\n            avatarUrl: true,\n          },\n        },\n      },\n    });\n\n    if (!item) {\n      throw new NotFoundException('Item no encontrado');\n    }\n\n    // Incrementar contador de visualizaciones\n    await this.prisma.marketplaceItem.update({\n      where: { id: itemId },\n      data: { viewCount: { increment: 1 } },\n    });\n\n    return {\n      id: item.id,\n      title: item.name,\n      description: item.description,\n      type: item.itemType,\n      priceUnits: item.price,\n      priceToins: item.priceToins,\n      currency: item.currency,\n      tags: item.tags,\n      images: item.images,\n      imageUrl: item.images[0] || null,\n      location: item.location,\n      status: item.status,\n      metadata: item.metadata ? JSON.parse(item.metadata) : null,\n      seller: item.seller,\n      createdAt: item.createdAt,\n      updatedAt: item.updatedAt,\n      viewCount: item.viewCount + 1, // Reflejar el incremento\n      favoriteCount: item.favoriteCount,\n    };\n  }\n\n  /**\n   * Actualizar un item del marketplace\n   */\n  async updateItem(\n    itemId: string,\n    dto: UpdateMarketplaceItemDto,\n    userId: string\n  ) {\n    //     console.log('>>> MarketplaceService.updateItem: Updating marketplace item', itemId);\n\n    const item = await this.prisma.marketplaceItem.findFirst({\n      where: {\n        id: itemId,\n        sellerId: userId, // Solo el propietario puede actualizar\n        isDeleted: false,\n      },\n    });\n\n    if (!item) {\n      throw new NotFoundException(\n        'Item no encontrado o no tienes permisos para actualizarlo'\n      );\n    }\n\n    const updateData: Prisma.MarketplaceItemUpdateInput = {};\n\n    if (dto.title) updateData.name = dto.title;\n    if (dto.description) updateData.description = dto.description;\n    if (dto.priceUnits !== undefined) updateData.price = dto.priceUnits;\n    if (dto.priceToins !== undefined) updateData.priceToins = dto.priceToins;\n    if (dto.tags) updateData.tags = dto.tags;\n    if (dto.imageUrl) updateData.images = [dto.imageUrl];\n    if (dto.location) updateData.location = dto.location;\n    if (dto.status) updateData.status = dto.status;\n    if (dto.metadata) updateData.metadata = JSON.stringify(dto.metadata);\n\n    const updatedItem = await this.prisma.marketplaceItem.update({\n      where: { id: itemId },\n      data: updateData,\n      include: {\n        seller: {\n          select: {\n            id: true,\n            email: true,\n            firstName: true,\n            lastName: true,\n            username: true,\n            avatarUrl: true,\n          },\n        },\n      },\n    });\n\n    return {\n      id: updatedItem.id,\n      title: updatedItem.name,\n      description: updatedItem.description,\n      type: updatedItem.itemType,\n      priceUnits: updatedItem.price,\n      priceToins: updatedItem.priceToins,\n      currency: updatedItem.currency,\n      tags: updatedItem.tags,\n      images: updatedItem.images,\n      imageUrl: updatedItem.images[0] || null,\n      location: updatedItem.location,\n      status: updatedItem.status,\n      metadata: updatedItem.metadata ? JSON.parse(updatedItem.metadata) : null,\n      seller: updatedItem.seller,\n      createdAt: updatedItem.createdAt,\n      updatedAt: updatedItem.updatedAt,\n      viewCount: updatedItem.viewCount,\n      favoriteCount: updatedItem.favoriteCount,\n    };\n  }\n\n  /**\n   * Eliminar un item del marketplace\n   */\n  async deleteItem(itemId: string, userId: string) {\n    //     console.log('>>> MarketplaceService.deleteItem: Deleting marketplace item', itemId);\n\n    const item = await this.prisma.marketplaceItem.findFirst({\n      where: {\n        id: itemId,\n        sellerId: userId, // Solo el propietario puede eliminar\n        isDeleted: false,\n      },\n    });\n\n    if (!item) {\n      throw new NotFoundException(\n        'Item no encontrado o no tienes permisos para eliminarlo'\n      );\n    }\n\n    // Soft delete\n    await this.prisma.marketplaceItem.update({\n      where: { id: itemId },\n      data: {\n        isDeleted: true,\n        deletedAt: new Date(),\n        status: 'INACTIVE',\n      },\n    });\n\n    return { message: 'Item eliminado correctamente' };\n  }\n\n  /**\n   * Obtener items de un vendedor espec√≠fico\n   */\n  async getSellerItems(sellerId: string) {\n    //     console.log('>>> MarketplaceService.getSellerItems: Getting items for seller', sellerId);\n\n    const items = await this.prisma.marketplaceItem.findMany({\n      where: {\n        sellerId,\n        isActive: true,\n        isDeleted: false,\n      },\n      include: {\n        seller: {\n          select: {\n            id: true,\n            email: true,\n            firstName: true,\n            lastName: true,\n            username: true,\n            avatarUrl: true,\n          },\n        },\n      },\n      orderBy: { createdAt: 'desc' },\n    });\n\n    const processedItems = items.map((item) => ({\n      id: item.id,\n      title: item.name,\n      description: item.description,\n      type: item.itemType,\n      priceUnits: item.price,\n      priceToins: item.priceToins,\n      currency: item.currency,\n      tags: item.tags,\n      images: item.images,\n      imageUrl: item.images[0] || null,\n      location: item.location,\n      status: item.status,\n      metadata: item.metadata ? JSON.parse(item.metadata) : null,\n      seller: item.seller,\n      createdAt: item.createdAt,\n      updatedAt: item.updatedAt,\n      viewCount: item.viewCount,\n      favoriteCount: item.favoriteCount,\n    }));\n\n    return {\n      items: processedItems,\n      total: processedItems.length,\n      sellerId,\n    };\n  }\n\n  /**\n   * Obtener estad√≠sticas del marketplace\n   */\n  async getMarketplaceStats() {\n    //     console.log('>>> MarketplaceService.getMarketplaceStats: Getting marketplace statistics');\n\n    const [totalItems, activeItems, totalSellers, itemsByType, itemsByStatus] =\n      await Promise.all([\n        this.prisma.marketplaceItem.count({\n          where: { isDeleted: false },\n        }),\n        this.prisma.marketplaceItem.count({\n          where: {\n            isDeleted: false,\n            isActive: true,\n            status: 'ACTIVE',\n          },\n        }),\n        this.prisma.marketplaceItem\n          .groupBy({\n            by: ['sellerId'],\n            where: { isDeleted: false },\n            _count: { sellerId: true },\n          })\n          .then((result) => result.length),\n        this.prisma.marketplaceItem.groupBy({\n          by: ['itemType'],\n          where: { isDeleted: false },\n          _count: { itemType: true },\n        }),\n        this.prisma.marketplaceItem.groupBy({\n          by: ['status'],\n          where: { isDeleted: false },\n          _count: { status: true },\n        }),\n      ]);\n\n    return {\n      totalItems,\n      activeItems,\n      totalSellers,\n      itemsByType: itemsByType.reduce((acc, item) => {\n        acc[item.itemType] = item._count.itemType;\n        return acc;\n      }, {}),\n      itemsByStatus: itemsByStatus.reduce((acc, item) => {\n        acc[item.status] = item._count.status;\n        return acc;\n      }, {}),\n      generatedAt: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Obtener items favoritos del usuario\n   * TODO: Implementar esquema de base de datos para favoritos (UserFavoriteItem junction table)\n   */\n  async getUserFavorites(userId: string) {\n    //     console.log('>>> MarketplaceService.getUserFavorites: Getting favorite items for user', userId);\n\n    // Verificar que el usuario existe\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n    });\n\n    if (!user) {\n      throw new NotFoundException('Usuario no encontrado');\n    }\n\n    // TODO: Implementar cuando se cree el esquema de favoritos\n    // Por ahora retornamos una estructura vac√≠a pero v√°lida\n    // Cuando se implemente el esquema, la consulta ser√≠a algo como:\n    //\n    // const favoriteItems = await this.prisma.userFavoriteItem.findMany({\n    //   where: {\n    //     userId,\n    //     item: {\n    //       isActive: true,\n    //       isDeleted: false,\n    //       status: 'ACTIVE'\n    //     }\n    //   },\n    //   include: {\n    //     item: {\n    //       include: {\n    //         seller: {\n    //           select: {\n    //             id: true,\n    //             firstName: true,\n    //             lastName: true,\n    //             username: true,\n    //             avatarUrl: true\n    //           }\n    //         }\n    //       }\n    //     }\n    //   },\n    //   orderBy: { createdAt: 'desc' }\n    // });\n\n    return {\n      items: [], // Array vac√≠o hasta que se implemente el esquema\n      total: 0,\n      userId,\n      message:\n        'Endpoint de favoritos disponible. Esquema de base de datos pendiente de implementaci√≥n.',\n      timestamp: new Date().toISOString(),\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/merits-and-wallet/merits/dto/create-merit.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsEnum' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsUrl' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsUUID' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":9}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ApiProperty } from '@nestjs/swagger';\nimport {\n  IsString,\n  IsNotEmpty,\n  IsOptional,\n  IsEnum,\n  IsUrl,\n  IsNumber,\n  IsUUID,\n} from 'class-validator';\n\nexport class CreateMeritDto {\n  @ApiProperty({ description: 'User ID who earned the merit' })\n  @IsString()\n  @IsNotEmpty()\n  userId: string;\n\n  @ApiProperty({ description: 'Merit amount' })\n  @IsNumber()\n  amount: number;\n\n  @ApiProperty({ description: 'Type of merit' })\n  @IsString()\n  @IsNotEmpty()\n  type: string;\n\n  @ApiProperty({ description: 'Source of the merit' })\n  @IsString()\n  @IsNotEmpty()\n  source: string;\n\n  @ApiProperty({ description: 'Related entity ID', required: false })\n  @IsOptional()\n  @IsString()\n  relatedEntityId?: string;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/merits-and-wallet/merits/merits.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'merit' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":72,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":72,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'merit' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":80,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":80,"endColumn":16}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, NotFoundException } from '@nestjs/common';\nimport { PrismaService } from '../../prisma/prisma.service';\nimport { CreateMeritDto } from './dto/create-merit.dto';\nimport { UpdateMeritDto } from './dto/update-merit.dto';\nimport { Merit } from '../../generated/prisma';\n\n@Injectable()\nexport class MeritsService {\n  constructor(private readonly prisma: PrismaService) {}\n\n  async create(createMeritDto: CreateMeritDto): Promise<Merit> {\n    return this.prisma.merit.create({\n      data: {\n        userId: createMeritDto.userId,\n        amount: createMeritDto.amount,\n        type: createMeritDto.type,\n        source: createMeritDto.source,\n        relatedEntityId: createMeritDto.relatedEntityId,\n      },\n    });\n  }\n\n  async findAll(): Promise<Merit[]> {\n    return this.prisma.merit.findMany({\n      include: {\n        user: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n          },\n        },\n      },\n    });\n  }\n\n  async findOne(id: string): Promise<Merit> {\n    const merit = await this.prisma.merit.findUnique({\n      where: { id },\n      include: {\n        user: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n          },\n        },\n      },\n    });\n    if (!merit) {\n      throw new NotFoundException(`Merit with ID ${id} not found`);\n    }\n    return merit;\n  }\n\n  async findByType(type: string): Promise<Merit[]> {\n    return this.prisma.merit.findMany({\n      where: { type },\n      include: {\n        user: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n          },\n        },\n      },\n    });\n  }\n\n  async update(id: string, updateMeritDto: UpdateMeritDto): Promise<Merit> {\n    const merit = await this.findOne(id);\n    return this.prisma.merit.update({\n      where: { id },\n      data: updateMeritDto,\n    });\n  }\n\n  async remove(id: string): Promise<Merit> {\n    const merit = await this.findOne(id);\n    return this.prisma.merit.delete({ where: { id } });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/merits-and-wallet/transactions/transactions.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Patch' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Controller,\n  Get,\n  Post,\n  Body,\n  Patch,\n  Param,\n  UseGuards,\n  Req,\n  ForbiddenException,\n  NotFoundException,\n} from '@nestjs/common';\nimport { TransactionsService } from './transactions.service';\nimport {\n  ApiTags,\n  ApiBearerAuth,\n  ApiOperation,\n  ApiResponse,\n  ApiParam,\n  ApiBody,\n} from '@nestjs/swagger';\nimport { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';\nimport { RolesGuard } from '@/rbac/guards/roles.guard';\nimport { Roles } from '@/rbac/decorators/roles.decorator';\nimport { Request } from 'express';\nimport { SendTransactionDto } from './dto/send-transaction.dto';\n\n// Define a basic type for the authenticated user\ninterface AuthenticatedRequest extends Request {\n  user: { id: string; roles: string[] /* other user properties */ };\n}\n\n@ApiTags('transactions')\n@ApiBearerAuth()\n@UseGuards(JwtAuthGuard)\n@Controller('transactions')\nexport class TransactionsController {\n  constructor(private readonly transactionsService: TransactionsService) {}\n\n  @Get('/user/:userId')\n  @ApiOperation({\n    summary: 'Get all transactions for a specific user (Owner or Admin only)',\n  })\n  @ApiResponse({ status: 200, description: 'List of transactions.' })\n  @ApiResponse({ status: 403, description: 'Forbidden resource.' })\n  @ApiParam({ name: 'userId', description: 'ID of the user' })\n  // Apply RolesGuard conditionally based on the requested userId\n  // Note: Conditional guards are complex in NestJS decorators. A common pattern is to check inside the method.\n  // Alternatively, use separate admin routes or a custom guard.\n  async findAllForUser(\n    @Req() req: AuthenticatedRequest,\n    @Param('userId') userId: string\n  ) {\n    // Check if the authenticated user is requesting their own data OR is an admin\n    if (req.user.id !== userId && !req.user.roles.includes('admin')) {\n      throw new ForbiddenException(\n        'You do not have permission to view transactions for this user.'\n      );\n    }\n    const transactions = await this.transactionsService.findAllForUser(userId);\n    if (!transactions || transactions.length === 0) {\n      // Consider if this should be NotFound or just return []\n      // throw new NotFoundException(`No transactions found for user ${userId}`);\n      return []; // Return empty array if no transactions\n    }\n    return transactions;\n  }\n\n  @Get(':id')\n  @ApiOperation({\n    summary: 'Get a specific transaction by ID (Owner or Admin only)',\n  })\n  @ApiResponse({ status: 200, description: 'Transaction details.' })\n  @ApiResponse({ status: 404, description: 'Transaction not found.' })\n  @ApiResponse({ status: 403, description: 'Forbidden resource.' })\n  @ApiParam({ name: 'id', description: 'ID of the transaction' })\n  async findOne(@Req() req: AuthenticatedRequest, @Param('id') id: string) {\n    // Ownership check is handled within the service method now\n    const transaction = await this.transactionsService.findTransaction(\n      id,\n      req.user\n    );\n    if (!transaction) {\n      throw new NotFoundException(`Transaction with ID ${id} not found`);\n    }\n    return transaction;\n  }\n\n  // Admin Endpoints (Optional - can use existing with in-method checks or add dedicated routes)\n  // Example: Dedicated admin route to get any transaction by ID without ownership check\n  @UseGuards(JwtAuthGuard, RolesGuard)\n  @Roles('admin')\n  @Get('/admin/:id')\n  @ApiOperation({ summary: '[ADMIN] Get any transaction by ID (Admin only)' })\n  @ApiResponse({\n    status: 200,\n    description: 'Transaction details (Admin only).',\n  })\n  @ApiResponse({ status: 404, description: 'Transaction not found.' })\n  @ApiResponse({ status: 403, description: 'Forbidden resource.' })\n  @ApiParam({ name: 'id', description: 'ID of the transaction' })\n  findOneAdmin(@Param('id') id: string) {\n    return this.transactionsService.findTransactionAdmin(id);\n  }\n\n  @UseGuards(JwtAuthGuard, RolesGuard)\n  @Roles('admin')\n  @Get('/admin/all')\n  @ApiOperation({ summary: '[ADMIN] Get all transactions (Admin only)' })\n  @ApiResponse({\n    status: 200,\n    description: 'List of all transactions (Admin only).',\n  })\n  @ApiResponse({ status: 403, description: 'Forbidden resource.' })\n  findAllAdmin() {\n    return this.transactionsService.findAllTransactionsAdmin();\n  }\n\n  @Post('/send')\n  @ApiOperation({\n    summary: 'Send √únits or M√´ritos to another user',\n    description:\n      'Creates a transaction between the authenticated user and a recipient, ensuring Reciprocity and atomic balance updates.',\n  })\n  @ApiBody({ type: SendTransactionDto })\n  @ApiResponse({\n    status: 201,\n    description: 'The transaction has been successfully created.',\n  })\n  @ApiResponse({ status: 403, description: 'Forbidden. Insufficient balance.' })\n  @ApiResponse({ status: 404, description: 'Recipient or sender not found.' })\n  async sendTransaction(\n    @Req() req: AuthenticatedRequest,\n    @Body() sendTransactionDto: SendTransactionDto\n  ) {\n    // El senderId se obtiene del usuario autenticado a trav√©s del token JWT\n    const senderId = req.user.id;\n    return this.transactionsService.sendTransaction(\n      senderId,\n      sendTransactionDto\n    );\n  }\n\n  // Create transaction endpoint would typically be internal or triggered by other modules (e.g., challenges)\n  // Keeping it simple for now, but if exposed, it would need appropriate guards/permissions.\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/merits-and-wallet/transactions/transactions.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ConflictException' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TransactionCurrency' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Merit' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":15}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  ConflictException,\n  NotFoundException,\n  ForbiddenException,\n} from '@nestjs/common';\nimport { PrismaService } from '../../prisma/prisma.service';\nimport { WalletsService } from '../wallets/wallets.service';\nimport { Transaction } from '../../generated/prisma';\nimport {\n  SendTransactionDto,\n  TransactionCurrency,\n} from './dto/send-transaction.dto';\nimport { Merit } from '../../generated/prisma';\nimport { Prisma } from '@prisma/client';\n\n// Define a basic type for the authenticated user passed from the controller\ntype AuthenticatedUser = { id: string; roles: string[] /* other properties */ };\n\n// Basic type for eventData - its structure depends on the transaction source/type\nexport type TransactionEventData = Record<string, unknown>; // Can be refined if specific structures are known\n\n@Injectable()\nexport class TransactionsService {\n  constructor(\n    private prisma: PrismaService,\n    private walletsService: WalletsService // Inject WalletsService\n  ) {}\n\n  async createTransaction(data: {\n    fromUserId?: string;\n    toUserId: string;\n    amount: number;\n    type: string; // e.g., 'EARN', 'SPEND', 'ADJUST'\n    description?: string;\n  }): Promise<Transaction> {\n    // Use a transaction to ensure atomicity\n    const transaction = await this.prisma.$transaction(async (prisma) => {\n      // 1. Create the transaction record with specific typed data\n      const transactionData: Prisma.TransactionCreateInput = {\n        fromUser: data.fromUserId\n          ? { connect: { id: data.fromUserId } }\n          : undefined,\n        toUser: { connect: { id: data.toUserId } },\n        amount: data.amount,\n        currency: 'USD',\n        type: data.type,\n        description: data.description,\n      };\n\n      const newTransaction = await prisma.transaction.create({\n        data: transactionData,\n      });\n\n      // 2. Update the corresponding wallet balance if needed\n      // Note: This may need adjustment based on your wallet logic\n      // await this.walletsService.updateWalletBalance(data.toUserId, data.amount);\n\n      return newTransaction;\n    });\n\n    return transaction;\n  }\n\n  async findAllForUser(userId: string): Promise<Transaction[]> {\n    return this.prisma.transaction.findMany({\n      where: {\n        OR: [{ fromUserId: userId }, { toUserId: userId }],\n      },\n      orderBy: { createdAt: 'desc' },\n    });\n  }\n\n  async findTransaction(\n    id: string,\n    user: AuthenticatedUser // Accept authenticated user object\n  ): Promise<Transaction> {\n    const transaction = await this.prisma.transaction.findUnique({\n      where: { id },\n    });\n\n    if (!transaction) {\n      throw new NotFoundException(`Transaction with ID ${id} not found`);\n    }\n\n    // Ownership check: User must be involved in the transaction OR have the 'admin' role\n    if (\n      transaction.fromUserId !== user.id &&\n      transaction.toUserId !== user.id &&\n      !user.roles.includes('admin')\n    ) {\n      throw new ForbiddenException(\n        'You do not have permission to view this transaction.'\n      );\n    }\n\n    return transaction;\n  }\n\n  // Admin method to find any transaction (no ownership check)\n  async findTransactionAdmin(id: string): Promise<Transaction> {\n    const transaction = await this.prisma.transaction.findUnique({\n      where: { id },\n    });\n\n    if (!transaction) {\n      throw new NotFoundException(`Transaction with ID ${id} not found`);\n    }\n\n    return transaction;\n  }\n\n  // Admin method to find all transactions (no ownership check)\n  async findAllTransactionsAdmin(): Promise<Transaction[]> {\n    return this.prisma.transaction.findMany({\n      orderBy: { createdAt: 'desc' },\n    });\n  }\n\n  /**\n   * Procesa una transacci√≥n de env√≠o de valor (√únits o M√´ritos) entre jugadores,\n   * encarnando los principios de Confianza y Reciprocidad de Coom√únity.\n   *\n   * - Valida que el emisor tenga saldo suficiente (Principio de Reciprocidad).\n   * - Realiza la operaci√≥n de forma at√≥mica para garantizar la integridad (Principio de Confianza).\n   * - Registra metadata filos√≥fica, tejiendo el \"alma en los n√∫meros\" para NIRA.\n   *\n   * @param senderId El ID del usuario que inicia la transacci√≥n (el \"dador\").\n   * @param dto Los datos de la transacci√≥n, validados por el DTO.\n   * @returns La transacci√≥n registrada, un artefacto de confianza en el ecosistema.\n   */\n  async sendTransaction(\n    senderId: string,\n    dto: SendTransactionDto\n  ): Promise<Transaction> {\n    const { recipientId, amount, currency, description, metadata } = dto;\n\n    // 1. Validaciones Preliminares: Asegurar la coherencia del acto de dar.\n    if (recipientId === senderId) {\n      throw new ForbiddenException(\n        'Un acto de dar requiere de otro. No puedes enviarte valor a ti mismo.'\n      );\n    }\n    const recipient = await this.prisma.user.findUnique({\n      where: { id: recipientId },\n    });\n    if (!recipient) {\n      throw new NotFoundException(\n        `El destinatario con id '${recipientId}' no fue encontrado en el ecosistema.`\n      );\n    }\n\n    // 2. Verificaci√≥n de Fondos (Principio de Reciprocidad)\n    // Se asegura que el dar no cree una deuda inexistente en el sistema.\n    // Usamos el m√©todo de admin para una llamada interna entre servicios confiables.\n    const senderWallet =\n      await this.walletsService.getWalletForUserAdmin(senderId);\n    if (!senderWallet || senderWallet.balance < amount) {\n      throw new ForbiddenException(\n        'Fondos insuficientes. La reciprocidad requiere un balance para poder dar.'\n      );\n    }\n\n    // 3. Transacci√≥n At√≥mica (Coraz√≥n de la Confianza)\n    // Usamos $transaction de Prisma para garantizar que el intercambio completo\n    // (dar y recibir) ocurra exitosamente, o no ocurra en absoluto.\n    return this.prisma.$transaction(async (prisma) => {\n      // Deducir del emisor: Un acto de desprendimiento.\n      await prisma.wallet.update({\n        where: { userId: senderId },\n        data: { balance: { decrement: amount } },\n      });\n\n      // Acreditar al receptor: Un acto de recepci√≥n.\n      // Usamos upsert para crear una wallet si el receptor es nuevo en el flujo econ√≥mico.\n      await prisma.wallet.upsert({\n        where: { userId: recipientId },\n        update: { balance: { increment: amount } },\n        create: {\n          userId: recipientId,\n          balance: amount,\n          currency,\n        },\n      });\n\n      // Registrar la memoria de la transacci√≥n para la posteridad.\n      // NOTA: El error de linter sobre 'metadata' es esperado si Prisma Client\n      // no se ha regenerado tras el cambio en schema.prisma. El c√≥digo es correcto.\n      const newTransaction = await prisma.transaction.create({\n        data: {\n          fromUserId: senderId,\n          toUserId: recipientId,\n          amount,\n          currency,\n          description,\n          metadata,\n          type: 'TRANSFER', // Este tipo podr√≠a evolucionar con la filosof√≠a.\n        },\n      });\n\n      return newTransaction;\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/merits-and-wallet/wallets/wallets.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'NotFoundException' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":20}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Controller,\n  Get,\n  Param,\n  UseGuards,\n  Req,\n  ForbiddenException,\n  NotFoundException,\n  Inject,\n} from '@nestjs/common';\nimport { WalletsService } from './wallets.service';\nimport {\n  ApiTags,\n  ApiBearerAuth,\n  ApiOperation,\n  ApiResponse,\n  ApiParam,\n} from '@nestjs/swagger';\nimport { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';\nimport { RolesGuard } from '@/rbac/guards/roles.guard';\nimport { Roles } from '@/rbac/decorators/roles.decorator';\nimport { Request } from 'express';\n\n// Define a basic type for the authenticated user\ninterface AuthenticatedRequest extends Request {\n  user: { id: string; roles: string[] /* other user properties */ };\n}\n\n@ApiTags('wallets')\n@ApiBearerAuth()\n@UseGuards(JwtAuthGuard)\n@Controller('wallets')\nexport class WalletsController {\n  constructor(\n    @Inject(WalletsService) private readonly walletsService: WalletsService\n  ) {}\n\n  @Get('/me')\n  @ApiOperation({\n    summary: 'Get all wallet balances for the authenticated user',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'List of wallet balances for the authenticated user.',\n  })\n  async getMyWalletBalances(@Req() req: AuthenticatedRequest) {\n    return this.walletsService.getAllBalancesForUser(req.user.id, req.user);\n  }\n\n  @Get('/user/:userId')\n  @ApiOperation({\n    summary:\n      'Get all wallet balances for a specific user (Owner or Admin only)',\n  })\n  @ApiResponse({ status: 200, description: 'List of wallet balances.' })\n  @ApiResponse({ status: 403, description: 'Forbidden resource.' })\n  @ApiParam({ name: 'userId', description: 'ID of the user' })\n  async getAllBalancesForUser(\n    @Req() req: AuthenticatedRequest,\n    @Param('userId') userId: string\n  ) {\n    // Check if the authenticated user is requesting their own data OR is an admin\n    if (req.user.id !== userId && !req.user.roles.includes('admin')) {\n      throw new ForbiddenException(\n        'You do not have permission to view wallet balances for this user.'\n      );\n    }\n    return this.walletsService.getAllBalancesForUser(userId, req.user);\n  }\n\n  @Get('/user/:userId/wallet')\n  @ApiOperation({\n    summary: 'Get wallet details for a specific user (Owner or Admin only)',\n  })\n  @ApiResponse({ status: 200, description: 'Wallet details for the user.' })\n  @ApiResponse({ status: 404, description: 'Wallet not found.' })\n  @ApiResponse({ status: 403, description: 'Forbidden resource.' })\n  @ApiParam({ name: 'userId', description: 'ID of the user' })\n  async getWalletForUser(\n    @Req() req: AuthenticatedRequest,\n    @Param('userId') userId: string\n  ) {\n    // Check if the authenticated user is requesting their own data OR is an admin\n    if (req.user.id !== userId && !req.user.roles.includes('admin')) {\n      throw new ForbiddenException(\n        'You do not have permission to view this wallet.'\n      );\n    }\n    const wallet = await this.walletsService.getWalletForUser(userId, req.user);\n    return wallet;\n  }\n\n  // Admin Endpoints\n  @UseGuards(JwtAuthGuard, RolesGuard)\n  @Roles('admin')\n  @Get('/admin/user/:userId')\n  @ApiOperation({\n    summary: '[ADMIN] Get all wallet balances for any user (Admin only)',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'List of wallet balances (Admin only).',\n  })\n  @ApiResponse({ status: 403, description: 'Forbidden resource.' })\n  @ApiParam({ name: 'userId', description: 'ID of the user' })\n  getAllBalancesForUserAdmin(@Param('userId') userId: string) {\n    return this.walletsService.getAllBalancesForUserAdmin(userId);\n  }\n\n  @UseGuards(JwtAuthGuard, RolesGuard)\n  @Roles('admin')\n  @Get('/admin/user/:userId/wallet')\n  @ApiOperation({\n    summary: '[ADMIN] Get wallet details for any user (Admin only)',\n  })\n  @ApiResponse({ status: 200, description: 'Wallet details (Admin only).' })\n  @ApiResponse({ status: 404, description: 'Wallet not found.' })\n  @ApiResponse({ status: 403, description: 'Forbidden resource.' })\n  @ApiParam({ name: 'userId', description: 'ID of the user' })\n  async getWalletForUserAdmin(@Param('userId') userId: string) {\n    const wallet = await this.walletsService.getWalletForUserAdmin(userId);\n    return wallet;\n  }\n\n  // Update balance endpoint would typically be internal or admin-only\n  // Keeping it internal for now.\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/merits-and-wallet/wallets/wallets.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'NotFoundException' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":20}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  NotFoundException,\n  ForbiddenException,\n  Inject,\n} from '@nestjs/common';\nimport { PrismaService } from '../../prisma/prisma.service';\nimport { Wallet } from '../../generated/prisma';\n\n// Define a basic type for the authenticated user passed from the controller\ntype AuthenticatedUser = { id: string; roles: string[] /* other properties */ };\n\n@Injectable()\nexport class WalletsService {\n  constructor(@Inject(PrismaService) private prisma: PrismaService) {}\n\n  // Called by TransactionsService internally\n  async updateWalletBalance(\n    userId: string,\n    amount: number,\n    currency: string = 'USD'\n  ): Promise<Wallet> {\n    // Find or create the wallet for the user\n    const wallet = await this.prisma.wallet.upsert({\n      where: { userId },\n      update: {\n        balance: { increment: amount },\n      },\n      create: {\n        userId,\n        balance: amount,\n        currency,\n      },\n    });\n    return wallet;\n  }\n\n  async getWalletForUser(\n    userId: string,\n    user: AuthenticatedUser // Accept authenticated user object\n  ) {\n    // Ownership check: User must be the owner OR have the 'admin' role\n    if (userId !== user.id && !user.roles.includes('admin')) {\n      throw new ForbiddenException(\n        \"You do not have permission to view this user's wallet.\"\n      );\n    }\n\n    const wallet = await this.prisma.wallet.findUnique({\n      where: { userId },\n      include: {\n        user: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n            avatarUrl: true,\n          },\n        },\n      },\n    });\n\n    // If wallet doesn't exist, create one with zero balances\n    if (!wallet) {\n      return this.prisma.wallet.create({\n        data: {\n          userId,\n          balance: 0,\n          currency: 'USD',\n        },\n        include: {\n          user: {\n            select: {\n              id: true,\n              name: true,\n              email: true,\n              avatarUrl: true,\n            },\n          },\n        },\n      });\n    }\n\n    return wallet;\n  }\n\n  async getAllBalancesForUser(\n    userId: string,\n    user: AuthenticatedUser // Accept authenticated user object\n  ) {\n    // Ownership check: User must be the owner OR have the 'admin' role\n    if (userId !== user.id && !user.roles.includes('admin')) {\n      throw new ForbiddenException(\n        \"You do not have permission to view this user's wallet balances.\"\n      );\n    }\n\n    // Get wallet with user info\n    const wallet = await this.getWalletForUser(userId, user);\n\n    // Get merits summary by type\n    const meritsGrouped = await this.prisma.merit.groupBy({\n      by: ['type'],\n      where: { userId },\n      _sum: {\n        amount: true,\n      },\n    });\n\n    return {\n      wallet,\n      meritsSummary: meritsGrouped.map((group) => ({\n        type: group.type,\n        totalAmount: group._sum.amount || 0,\n      })),\n    };\n  }\n\n  async updateBalance(\n    userId: string,\n    amount: number, // Amount to add/subtract\n    currency: string = 'USD'\n    // user: AuthenticatedUser, // Decide if update needs ownership check or is purely internal/admin\n  ) {\n    // Wallet updates are typically triggered by internal logic (e.g., completing challenges) or admin actions.\n    // Assuming this method is called internally or only by authorized services/controllers.\n    // If exposed directly via a user endpoint, add ownership/permission checks.\n\n    return this.updateWalletBalance(userId, amount, currency);\n  }\n\n  // Admin method to get wallet for any user (no ownership check)\n  async getWalletForUserAdmin(userId: string) {\n    const wallet = await this.prisma.wallet.findUnique({\n      where: { userId },\n      include: {\n        user: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n            avatarUrl: true,\n          },\n        },\n      },\n    });\n\n    // If wallet doesn't exist, create one with zero balances\n    if (!wallet) {\n      return this.prisma.wallet.create({\n        data: {\n          userId,\n          balance: 0,\n          currency: 'USD',\n        },\n        include: {\n          user: {\n            select: {\n              id: true,\n              name: true,\n              email: true,\n              avatarUrl: true,\n            },\n          },\n        },\n      });\n    }\n\n    return wallet;\n  }\n\n  // Admin method to get all balances for any user (no ownership check)\n  async getAllBalancesForUserAdmin(userId: string) {\n    // Get wallet with user info\n    const wallet = await this.getWalletForUserAdmin(userId);\n\n    // Get merits summary by type\n    const meritsGrouped = await this.prisma.merit.groupBy({\n      by: ['type'],\n      where: { userId },\n      _sum: {\n        amount: true,\n      },\n    });\n\n    return {\n      wallet,\n      meritsSummary: meritsGrouped.map((group) => ({\n        type: group.type,\n        totalAmount: group._sum.amount || 0,\n      })),\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/monitoring/dto/health-report.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CacheHealth' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'YoutubeApiHealth' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'RecentAlert' is defined but never used. Allowed unused vars must match /^_/u.","line":29,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":22}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ApiProperty } from '@nestjs/swagger';\n\n// --- Sub-interfaces for strong typing in HealthReportDto ---\n\ninterface CacheHealth {\n  healthy: boolean;\n  stats: Record<string, unknown>; // Can be more specific if stats structure is known\n}\n\ninterface YoutubeApiHealth {\n  configured: boolean;\n  accessible: boolean;\n  lastTest: string;\n}\n\ninterface PerformanceMetrics {\n  averageCalculationTime: number;\n  totalCalculations: number;\n  cacheHitRatio: number;\n  errorRate: number;\n  methodDistribution: {\n    cache_hit: number;\n    youtube_api: number;\n    scraping: number;\n    estimation: number;\n  };\n}\n\ninterface RecentAlert {\n  timestamp: string;\n  type: 'CACHE_ERROR' | 'YOUTUBE_API_FAILURE' | 'INCONSISTENCY_DETECTED';\n  message: string;\n}\n\ninterface ProblematicVideo {\n  videoId: string;\n  issue: string;\n  details: Record<string, unknown>;\n  id: string;\n  title: string;\n  storedDuration?: number | null;\n  actualDuration?: number | null;\n}\n\n// Aligned with usage in notification.service.ts\ninterface ConsistencyCheck {\n  totalVideos: number;\n  inconsistenciesFound: number;\n  executionTime: number;\n}\n\n// Aligned with usage in notification.service.ts\ninterface ErrorSummary {\n  totalErrors: number;\n  criticalErrors: number;\n}\n\n// This DTO structure now matches the data expected by the NotificationService\nexport class HealthReportDto {\n  @ApiProperty({\n    description: 'Overall health status of the system',\n    example: 'healthy',\n    enum: ['healthy', 'warning', 'critical'],\n  })\n  status: 'healthy' | 'warning' | 'critical';\n\n  @ApiProperty({\n    description: 'The time period the report covers (e.g., \"daily\", \"weekly\")',\n    example: 'daily',\n  })\n  period: string;\n\n  @ApiProperty({\n    description: 'Timestamp of when the report was generated',\n    example: '2025-01-29T22:00:00.000Z',\n  })\n  timestamp: string;\n\n  @ApiProperty({ description: 'Consistency check metrics' })\n  consistencyCheck: ConsistencyCheck;\n\n  @ApiProperty({ description: 'Performance metrics' })\n  performanceMetrics: PerformanceMetrics;\n\n  @ApiProperty({ description: 'Summary of errors' })\n  errorSummary: ErrorSummary;\n\n  @ApiProperty({\n    description: 'A list of actionable recommendations',\n    example: ['Review video processing logs for critical errors.'],\n  })\n  recommendations: string[];\n}\n\nexport class ConsistencyCheckResultDto {\n  @ApiProperty({\n    description: 'Check execution timestamp',\n    example: '2025-01-29T22:00:00.000Z',\n  })\n  timestamp: string;\n\n  @ApiProperty({\n    description: 'Total videos checked',\n    example: 100,\n  })\n  totalVideos: number;\n\n  @ApiProperty({\n    description: 'Number of inconsistencies found',\n    example: 0,\n  })\n  inconsistenciesFound: number;\n\n  @ApiProperty({\n    description: 'List of videos with issues as JSON array',\n    example: [],\n  })\n  problematicVideos: ProblematicVideo[];\n\n  @ApiProperty({\n    description: 'Check execution time in milliseconds',\n    example: 1500,\n  })\n  executionTime: number;\n\n  @ApiProperty({\n    description: 'Whether alerts were sent',\n    example: false,\n  })\n  alertsSent: boolean;\n}\n\nexport class AlertConfigDto {\n  @ApiProperty({\n    description: 'Enable email alerts',\n    example: false,\n  })\n  emailEnabled: boolean;\n\n  @ApiProperty({\n    description: 'Enable Slack alerts',\n    example: false,\n  })\n  slackEnabled: boolean;\n\n  @ApiProperty({\n    description: 'Minimum inconsistencies to trigger alert',\n    example: 5,\n  })\n  alertThreshold: number;\n\n  @ApiProperty({\n    description: 'Email recipients as JSON array',\n    example: ['admin@example.com'],\n  })\n  emailRecipients: string[];\n\n  @ApiProperty({\n    description: 'Slack webhook URL configured',\n    example: false,\n  })\n  slackWebhookConfigured: boolean;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/notifications/notifications.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UpdateNotificationDto' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":24}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Controller,\n  Get,\n  Post,\n  Put,\n  Delete,\n  Body,\n  Param,\n  Query,\n  UseGuards,\n  Inject,\n} from '@nestjs/common';\nimport { NotificationsService } from './notifications.service';\nimport {\n  CreateNotificationDto,\n  CreateBulkNotificationDto,\n  UpdateNotificationDto,\n  NotificationFilterDto,\n  NotificationType,\n} from './dto/notifications.dto';\nimport { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';\nimport { RolesGuard } from '@/rbac/guards/roles.guard';\nimport { Roles } from '@/rbac/decorators/roles.decorator';\n\n@Controller('notifications')\n@UseGuards(JwtAuthGuard, RolesGuard)\nexport class NotificationsController {\n  constructor(\n    @Inject(NotificationsService)\n    private readonly notificationsService: NotificationsService\n  ) {\n    // //     console.log('>>> NotificationsController CONSTRUCTOR: this.notificationsService IS', this.notificationsService ? 'DEFINED' : 'UNDEFINED');\n  }\n\n  /**\n   * Crear una notificaci√≥n individual\n   */\n  @Post()\n  @Roles('admin', 'user')\n  async createNotification(@Body() dto: CreateNotificationDto) {\n    //     console.log('>>> NotificationsController.createNotification: Creating notification', dto);\n    return await this.notificationsService.createNotification(dto);\n  }\n\n  /**\n   * Crear notificaciones en lote\n   */\n  @Post('bulk')\n  @Roles('admin')\n  async createBulkNotifications(@Body() dto: CreateBulkNotificationDto) {\n    //     console.log('>>> NotificationsController.createBulkNotifications: Creating bulk notifications', dto);\n    return await this.notificationsService.createBulkNotifications(dto);\n  }\n\n  /**\n   * Obtener notificaciones de un usuario\n   */\n  @Get('user/:userId')\n  @Roles('admin', 'user')\n  async getUserNotifications(\n    @Param('userId') userId: string,\n    @Query('type') type?: string,\n    @Query('read') read?: string,\n    @Query('limit') limit?: string,\n    @Query('offset') offset?: string\n  ) {\n    //     console.log('>>> NotificationsController.getUserNotifications: Getting notifications for user', userId);\n\n    const filters: NotificationFilterDto = {\n      type: type as NotificationType,\n      read: read ? read === 'true' : undefined,\n      limit,\n      offset,\n    };\n\n    return await this.notificationsService.getUserNotifications(\n      userId,\n      filters\n    );\n  }\n\n  /**\n   * Obtener conteo de notificaciones no le√≠das\n   */\n  @Get('user/:userId/unread-count')\n  @Roles('admin', 'user')\n  async getUnreadCount(@Param('userId') userId: string) {\n    //     console.log('>>> NotificationsController.getUnreadCount: Getting unread count for user', userId);\n    return await this.notificationsService.getUnreadCount(userId);\n  }\n\n  /**\n   * Marcar notificaci√≥n como le√≠da\n   */\n  @Put(':notificationId/read')\n  @Roles('admin', 'user')\n  async markAsRead(\n    @Param('notificationId') notificationId: string,\n    @Query('userId') userId: string\n  ) {\n    //     console.log('>>> NotificationsController.markAsRead: Marking notification as read', notificationId);\n    return await this.notificationsService.markAsRead(notificationId, userId);\n  }\n\n  /**\n   * Marcar todas las notificaciones como le√≠das\n   */\n  @Put('user/:userId/mark-all-read')\n  @Roles('admin', 'user')\n  async markAllAsRead(@Param('userId') userId: string) {\n    //     console.log('>>> NotificationsController.markAllAsRead: Marking all notifications as read for user', userId);\n    return await this.notificationsService.markAllAsRead(userId);\n  }\n\n  /**\n   * Eliminar notificaci√≥n\n   */\n  @Delete(':notificationId')\n  @Roles('admin', 'user')\n  async deleteNotification(\n    @Param('notificationId') notificationId: string,\n    @Query('userId') userId: string\n  ) {\n    //     console.log('>>> NotificationsController.deleteNotification: Deleting notification', notificationId);\n    return await this.notificationsService.deleteNotification(\n      notificationId,\n      userId\n    );\n  }\n\n  /**\n   * Limpiar notificaciones antiguas (solo admin)\n   */\n  @Post('cleanup')\n  @Roles('admin')\n  async cleanupOldNotifications() {\n    //     console.log('>>> NotificationsController.cleanupOldNotifications: Cleaning up old notifications');\n    return await this.notificationsService.cleanupOldNotifications();\n  }\n\n  /**\n   * Endpoint de prueba para verificar conectividad\n   */\n  @Get('ping')\n  async ping() {\n    //     console.log('>>> NotificationsController.ping: Notifications module is working');\n    return {\n      message: 'Notifications module is working',\n      timestamp: new Date().toISOString(),\n      module: 'Notifications System',\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/notifications/notifications.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UpdateNotificationDto' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'notification' is defined but never used. Allowed unused args must match /^_/u.","line":295,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":295,"endColumn":50}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, NotFoundException, Inject } from '@nestjs/common';\nimport { PrismaService } from '../prisma/prisma.service';\nimport {\n  CreateNotificationDto,\n  CreateBulkNotificationDto,\n  UpdateNotificationDto,\n  NotificationFilterDto,\n  NotificationType,\n} from './dto/notifications.dto';\nimport type { Notification } from '../generated/prisma';\n\n@Injectable()\nexport class NotificationsService {\n  constructor(@Inject(PrismaService) private readonly prisma: PrismaService) {\n    // //     console.log('>>> NotificationsService CONSTRUCTOR: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n  }\n\n  /**\n   * Crear una notificaci√≥n individual\n   */\n  async createNotification(dto: CreateNotificationDto): Promise<Notification> {\n    //     console.log('>>> NotificationsService.createNotification: Creating notification', dto);\n\n    // Verificar que el usuario existe\n    const user = await this.prisma.user.findUnique({\n      where: { id: dto.userId },\n    });\n\n    if (!user) {\n      throw new NotFoundException('Usuario no encontrado');\n    }\n\n    const notification = await this.prisma.notification.create({\n      data: {\n        userId: dto.userId,\n        type: dto.type,\n        message: dto.message,\n        read: false,\n      },\n    });\n\n    // Aqu√≠ se podr√≠a integrar con un servicio de push notifications real\n    await this.sendPushNotification(notification);\n\n    return notification;\n  }\n\n  /**\n   * Crear notificaciones en lote para m√∫ltiples usuarios\n   */\n  async createBulkNotifications(dto: CreateBulkNotificationDto) {\n    //     console.log('>>> NotificationsService.createBulkNotifications: Creating bulk notifications', dto);\n\n    // Verificar que todos los usuarios existen\n    const users = await this.prisma.user.findMany({\n      where: { id: { in: dto.userIds } },\n    });\n\n    if (users.length !== dto.userIds.length) {\n      throw new NotFoundException('Algunos usuarios no fueron encontrados');\n    }\n\n    const notifications = await this.prisma.notification.createMany({\n      data: dto.userIds.map((userId) => ({\n        userId,\n        type: dto.type,\n        message: dto.message,\n        read: false,\n      })),\n    });\n\n    // Enviar push notifications en lote\n    const createdNotifications = await this.prisma.notification.findMany({\n      where: {\n        userId: { in: dto.userIds },\n        type: dto.type,\n        message: dto.message,\n      },\n      orderBy: { createdAt: 'desc' },\n      take: dto.userIds.length,\n    });\n\n    await Promise.all(\n      createdNotifications.map((notification) =>\n        this.sendPushNotification(notification)\n      )\n    );\n\n    return {\n      message: `Se crearon ${notifications.count} notificaciones`,\n      count: notifications.count,\n    };\n  }\n\n  /**\n   * Obtener notificaciones de un usuario con filtros\n   */\n  async getUserNotifications(userId: string, filters: NotificationFilterDto) {\n    //     console.log('>>> NotificationsService.getUserNotifications: Getting notifications for user', userId);\n\n    const limit = filters.limit ? parseInt(filters.limit, 10) : 50;\n    const offset = filters.offset ? parseInt(filters.offset, 10) : 0;\n\n    const where: {\n      userId: string;\n      type?: NotificationType;\n      read?: boolean;\n    } = { userId };\n\n    if (filters.type) {\n      where.type = filters.type;\n    }\n\n    if (filters.read !== undefined) {\n      where.read = filters.read;\n    }\n\n    const [notifications, total] = await Promise.all([\n      this.prisma.notification.findMany({\n        where,\n        orderBy: { createdAt: 'desc' },\n        take: limit,\n        skip: offset,\n      }),\n      this.prisma.notification.count({ where }),\n    ]);\n\n    return {\n      notifications,\n      total,\n      limit,\n      offset,\n      hasMore: offset + limit < total,\n    };\n  }\n\n  /**\n   * Marcar notificaci√≥n como le√≠da\n   */\n  async markAsRead(notificationId: string, userId: string) {\n    //     console.log('>>> NotificationsService.markAsRead: Marking notification as read', notificationId);\n\n    const notification = await this.prisma.notification.findFirst({\n      where: { id: notificationId, userId },\n    });\n\n    if (!notification) {\n      throw new NotFoundException('Notificaci√≥n no encontrada');\n    }\n\n    return await this.prisma.notification.update({\n      where: { id: notificationId },\n      data: { read: true },\n    });\n  }\n\n  /**\n   * Marcar todas las notificaciones de un usuario como le√≠das\n   */\n  async markAllAsRead(userId: string) {\n    //     console.log('>>> NotificationsService.markAllAsRead: Marking all notifications as read for user', userId);\n\n    const result = await this.prisma.notification.updateMany({\n      where: { userId, read: false },\n      data: { read: true },\n    });\n\n    return {\n      message: `Se marcaron ${result.count} notificaciones como le√≠das`,\n      count: result.count,\n    };\n  }\n\n  /**\n   * Obtener conteo de notificaciones no le√≠das\n   */\n  async getUnreadCount(userId: string) {\n    //     console.log('>>> NotificationsService.getUnreadCount: Getting unread count for user', userId);\n\n    const count = await this.prisma.notification.count({\n      where: { userId, read: false },\n    });\n\n    return { unreadCount: count };\n  }\n\n  /**\n   * Eliminar notificaci√≥n\n   */\n  async deleteNotification(notificationId: string, userId: string) {\n    //     console.log('>>> NotificationsService.deleteNotification: Deleting notification', notificationId);\n\n    const notification = await this.prisma.notification.findFirst({\n      where: { id: notificationId, userId },\n    });\n\n    if (!notification) {\n      throw new NotFoundException('Notificaci√≥n no encontrada');\n    }\n\n    await this.prisma.notification.delete({\n      where: { id: notificationId },\n    });\n\n    return { message: 'Notificaci√≥n eliminada exitosamente' };\n  }\n\n  /**\n   * Crear notificaci√≥n autom√°tica para m√©ritos otorgados\n   */\n  async notifyMeritAwarded(\n    userId: string,\n    meritType: string,\n    amount: number,\n    source: string\n  ) {\n    //     console.log('>>> NotificationsService.notifyMeritAwarded: Creating merit notification', { userId, meritType, amount });\n\n    const message = `¬°Has recibido ${amount} ${meritType}! Fuente: ${source}`;\n\n    return await this.createNotification({\n      userId,\n      type: NotificationType.MERIT_AWARDED,\n      message,\n      metadata: { meritType, amount, source },\n    });\n  }\n\n  /**\n   * Crear notificaci√≥n autom√°tica para transacciones completadas\n   */\n  async notifyTransactionCompleted(\n    userId: string,\n    transactionType: string,\n    amount: number,\n    isIncoming: boolean\n  ) {\n    //     console.log('>>> NotificationsService.notifyTransactionCompleted: Creating transaction notification', { userId, transactionType, amount });\n\n    const direction = isIncoming ? 'recibido' : 'enviado';\n    const message = `Transacci√≥n completada: ${direction} ${amount} ${transactionType}`;\n\n    return await this.createNotification({\n      userId,\n      type: NotificationType.TRANSACTION_COMPLETED,\n      message,\n      metadata: { transactionType, amount, direction },\n    });\n  }\n\n  /**\n   * Crear notificaci√≥n autom√°tica para tokens pr√≥ximos a caducar\n   */\n  async notifyTokenExpiry(\n    userId: string,\n    tokenType: string,\n    amount: number,\n    daysToExpiry: number\n  ) {\n    //     console.log('>>> NotificationsService.notifyTokenExpiry: Creating token expiry notification', { userId, tokenType, amount });\n\n    const message = `¬°Atenci√≥n! Tienes ${amount} ${tokenType} que caducar√°n en ${daysToExpiry} d√≠as`;\n\n    return await this.createNotification({\n      userId,\n      type: NotificationType.TOKEN_EXPIRY_WARNING,\n      message,\n      metadata: { tokenType, amount, daysToExpiry },\n    });\n  }\n\n  /**\n   * Crear notificaci√≥n autom√°tica para invitaciones a grupos\n   */\n  async notifyGroupInvitation(\n    userId: string,\n    groupName: string,\n    inviterName: string\n  ) {\n    //     console.log('>>> NotificationsService.notifyGroupInvitation: Creating group invitation notification', { userId, groupName });\n\n    const message = `${inviterName} te ha invitado a unirte al grupo \"${groupName}\"`;\n\n    return await this.createNotification({\n      userId,\n      type: NotificationType.GROUP_INVITATION,\n      message,\n      metadata: { groupName, inviterName },\n    });\n  }\n\n  /**\n   * Simular env√≠o de push notification (aqu√≠ se integrar√≠a con un servicio real)\n   */\n  private async sendPushNotification(notification: Notification) {\n    // console.log('>>> NotificationsService.sendPushNotification: Sending push notification', {\n    //   userId: notification.userId,\n    //   type: notification.type,\n    //   message: notification.message\n    // });\n\n    // Aqu√≠ se integrar√≠a con servicios como:\n    // - Firebase Cloud Messaging (FCM)\n    // - Apple Push Notification Service (APNs)\n    // - OneSignal\n    // - Pusher\n    // etc.\n\n    // Por ahora, solo simulamos el env√≠o\n    return Promise.resolve();\n  }\n\n  /**\n   * Limpiar notificaciones antiguas (m√°s de 30 d√≠as)\n   */\n  async cleanupOldNotifications() {\n    //     console.log('>>> NotificationsService.cleanupOldNotifications: Cleaning up old notifications');\n\n    const thirtyDaysAgo = new Date();\n    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n    const result = await this.prisma.notification.deleteMany({\n      where: {\n        createdAt: { lt: thirtyDaysAgo },\n        read: true,\n      },\n    });\n\n    return {\n      message: `Se eliminaron ${result.count} notificaciones antiguas`,\n      count: result.count,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/philosophy/dto/philosophy.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsBoolean' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\nimport {\n  IsString,\n  IsNumber,\n  IsEnum,\n  IsOptional,\n  IsBoolean,\n  Min,\n  Max,\n  IsObject,\n  IsDateString,\n} from 'class-validator';\nimport { Type } from 'class-transformer';\n\n/**\n * DTOs para las m√©tricas filos√≥ficas de Coom√únity\n * Basados en los tipos compartidos de packages/shared-types\n */\n\nexport enum HambreLevel {\n  BAJO = 'bajo',\n  MEDIO = 'medio',\n  ALTO = 'alto',\n}\n\nexport class HambreMetricDto {\n  @ApiProperty({\n    description: 'Estado cualitativo del nivel de HambrE',\n    enum: HambreLevel,\n    example: 'medio',\n  })\n  @IsEnum(HambreLevel)\n  level: HambreLevel;\n\n  @ApiProperty({\n    description: 'Valor cuantitativo del HambrE (0-100)',\n    minimum: 0,\n    maximum: 100,\n    example: 65,\n  })\n  @IsNumber()\n  @Min(0)\n  @Max(100)\n  value: number;\n\n  @ApiProperty({\n    description: 'Marca temporal de la √∫ltima actualizaci√≥n',\n    example: '2024-01-15T10:30:00Z',\n  })\n  @IsDateString()\n  updatedAt: string;\n\n  @ApiPropertyOptional({\n    description: 'Metadatos adicionales',\n    type: 'object',\n    additionalProperties: true,\n  })\n  @IsOptional()\n  @IsObject()\n  metadata?: Record<string, unknown>;\n}\n\nexport class UpdateHambreDto {\n  @ApiPropertyOptional({\n    description: 'Nuevo nivel de HambrE',\n    enum: HambreLevel,\n    example: HambreLevel.ALTO,\n  })\n  @IsOptional()\n  @IsEnum(HambreLevel)\n  level?: HambreLevel;\n\n  @ApiPropertyOptional({\n    description: 'Nuevo valor de HambrE (0-100)',\n    minimum: 0,\n    maximum: 100,\n    example: 90,\n  })\n  @IsOptional()\n  @IsNumber()\n  value?: number;\n\n  @ApiPropertyOptional({\n    description: 'Notas del Gamifier sobre el cambio',\n  })\n  @IsOptional()\n  @IsString()\n  notes?: string;\n\n  @ApiPropertyOptional({\n    description: 'ID del Gamifier que realiza el cambio',\n  })\n  @IsOptional()\n  @IsString()\n  updatedBy?: string;\n\n  @ApiPropertyOptional({\n    description: 'Metadatos adicionales',\n    type: 'object',\n    additionalProperties: true,\n  })\n  @IsOptional()\n  @IsObject()\n  metadata?: Record<string, unknown>;\n}\n\nexport class IEAReciprocidadDto {\n  @ApiProperty({\n    description: 'Valor de contribuci√≥n/dar al ecosistema (0-100)',\n    minimum: 0,\n    maximum: 100,\n    example: 75,\n  })\n  @IsNumber()\n  @Min(0)\n  @Max(100)\n  dar: number;\n\n  @ApiProperty({\n    description: 'Valor de recepci√≥n/consumo del ecosistema (0-100)',\n    minimum: 0,\n    maximum: 100,\n    example: 65,\n  })\n  @IsNumber()\n  @Min(0)\n  @Max(100)\n  recibir: number;\n\n  @ApiProperty({\n    description: 'Peso relativo para el c√°lculo final (0-1)',\n    minimum: 0,\n    maximum: 1,\n    example: 0.8,\n  })\n  @IsNumber()\n  @Min(0)\n  @Max(1)\n  ponderacion: number;\n\n  @ApiProperty({\n    description: 'Marca temporal de la √∫ltima actualizaci√≥n',\n    example: '2024-01-15T10:30:00Z',\n  })\n  @IsDateString()\n  updatedAt: string;\n\n  @ApiPropertyOptional({\n    description: 'Valor calculado del √≠ndice',\n    example: 0.92,\n  })\n  @IsOptional()\n  @IsNumber()\n  indiceCalculado?: number;\n\n  @ApiPropertyOptional({\n    description: 'Metadatos del c√°lculo',\n    type: 'object',\n    additionalProperties: true,\n  })\n  @IsOptional()\n  @IsObject()\n  metadata?: Record<string, unknown>;\n}\n\nexport class PhilosophyMetricsResponseDto {\n  @ApiProperty({\n    description: 'M√©tricas de HambrE',\n    type: HambreMetricDto,\n  })\n  @Type(() => HambreMetricDto)\n  hambre: HambreMetricDto;\n\n  @ApiProperty({\n    description: 'M√©tricas de IEA de Reciprocidad',\n    type: IEAReciprocidadDto,\n  })\n  @Type(() => IEAReciprocidadDto)\n  iea: IEAReciprocidadDto;\n\n  @ApiProperty({\n    description: 'Marca temporal de la √∫ltima sincronizaci√≥n',\n    example: '2024-01-15T10:30:00Z',\n  })\n  @IsDateString()\n  lastSync: string;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/playlist/dto/create-playlist.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsUUID' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":9}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ApiProperty } from '@nestjs/swagger';\nimport {\n  IsString,\n  IsOptional,\n  IsBoolean,\n  IsInt,\n  IsUUID,\n  IsNotEmpty,\n  MaxLength,\n  Min,\n  IsDateString,\n} from 'class-validator';\nimport { Transform } from 'class-transformer';\n\nexport class CreatePlaylistDto {\n  @ApiProperty({\n    description: 'ID del mundo al que pertenece la playlist',\n    example: '123e4567-e89b-12d3-a456-426614174000',\n  })\n  @IsNotEmpty()\n  @IsString()\n  mundoId: string;\n\n  @ApiProperty({\n    description: 'Nombre de la playlist',\n    example: 'Introducci√≥n a TypeScript',\n    maxLength: 255,\n  })\n  @IsNotEmpty()\n  @IsString()\n  @MaxLength(255)\n  name: string;\n\n  @ApiProperty({\n    description: 'Descripci√≥n de la playlist',\n    example:\n      'Una serie de videos introductorios sobre TypeScript para principiantes',\n    required: false,\n  })\n  @IsOptional()\n  @IsString()\n  description?: string;\n\n  @ApiProperty({\n    description: 'URL de la imagen o thumbnail de la playlist',\n    example: 'https://example.com/images/typescript-intro.jpg',\n    required: false,\n  })\n  @IsOptional()\n  @IsString()\n  imageUrl?: string;\n\n  @ApiProperty({\n    description: 'Orden de la playlist dentro del mundo',\n    example: 1,\n    minimum: 0,\n    default: 0,\n    required: false,\n  })\n  @IsOptional()\n  @IsInt()\n  @Min(0)\n  @Transform(({ value }) => parseInt(value, 10))\n  orderInMundo?: number = 0;\n\n  @ApiProperty({\n    description: 'Estado activo/inactivo de la playlist',\n    example: true,\n    default: true,\n    required: false,\n  })\n  @IsOptional()\n  @IsBoolean()\n  @Transform(({ value }) => {\n    if (typeof value === 'string') {\n      return value.toLowerCase() === 'true';\n    }\n    return Boolean(value);\n  })\n  isActive?: boolean = true;\n\n  @ApiProperty({\n    description: 'Fecha de publicaci√≥n (no se persiste en DB actualmente)',\n    required: false,\n  })\n  @IsOptional()\n  @IsDateString()\n  published_at?: string;\n\n  @ApiProperty({\n    description: 'Fecha de despublicaci√≥n (no se persiste en DB actualmente)',\n    required: false,\n  })\n  @IsOptional()\n  @IsDateString()\n  unpublished_at?: string;\n\n  @IsOptional()\n  @IsString()\n  mundo_id?: string;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/playlist/dto/find-all-playlists.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ApiProperty' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":21}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\nimport {\n  IsOptional,\n  IsBoolean,\n  IsUUID,\n  IsInt,\n  Min,\n  IsString,\n  IsEnum,\n  Max,\n} from 'class-validator';\nimport { Transform, Type } from 'class-transformer';\n\nexport enum PlaylistOrderDirection {\n  ASC = 'asc',\n  DESC = 'desc',\n}\n\nexport class FindAllPlaylistsDto {\n  @ApiPropertyOptional({\n    description: 'ID del mundo para filtrar las playlists',\n    example: '123e4567-e89b-12d3-a456-426614174000',\n    required: false,\n  })\n  @IsOptional()\n  @IsUUID()\n  mundoId?: string;\n\n  @ApiPropertyOptional({\n    description: 'T√©rmino de b√∫squeda para el nombre de la playlist',\n    example: 'Introducci√≥n',\n    required: false,\n  })\n  @IsOptional()\n  @IsString()\n  name?: string;\n\n  @ApiPropertyOptional({\n    description: 'T√©rmino de b√∫squeda para la descripci√≥n de la playlist',\n    example: 'Conceptos b√°sicos',\n    required: false,\n  })\n  @IsOptional()\n  @IsString()\n  description?: string;\n\n  @ApiPropertyOptional({\n    description: 'Filtrar por estado activo/inactivo',\n    example: true,\n    default: true,\n    required: false,\n  })\n  @IsOptional()\n  @IsBoolean()\n  @Transform(({ value }) => {\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n    return value;\n  })\n  isActive?: boolean = true;\n\n  @ApiPropertyOptional({\n    description:\n      'Campo por el cual ordenar los resultados (ej. name, createdAt, orderInMundo)',\n    example: 'createdAt',\n    default: 'createdAt',\n    required: false,\n  })\n  @IsOptional()\n  @IsString()\n  orderBy?: string = 'createdAt';\n\n  @ApiPropertyOptional({\n    description: 'Direcci√≥n de ordenamiento',\n    enum: PlaylistOrderDirection,\n    example: PlaylistOrderDirection.DESC,\n    default: PlaylistOrderDirection.DESC,\n    required: false,\n  })\n  @IsOptional()\n  @IsEnum(PlaylistOrderDirection)\n  orderDirection?: PlaylistOrderDirection = PlaylistOrderDirection.DESC;\n\n  @ApiPropertyOptional({\n    description:\n      'Incluir los videoItems relacionados en la respuesta de cada playlist',\n    type: Boolean,\n    default: false,\n  })\n  @IsOptional()\n  @IsBoolean()\n  @Transform(({ value }) => {\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n    return value;\n  })\n  includeItems?: boolean = false;\n\n  @ApiPropertyOptional({\n    description: 'Incluir el Mundo relacionado en la respuesta',\n    example: false,\n    default: false,\n    required: false,\n  })\n  @IsOptional()\n  @IsBoolean()\n  @Transform(({ value }) => {\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n    return value;\n  })\n  includeMundo?: boolean = false;\n\n  @ApiPropertyOptional({\n    description: 'N√∫mero de p√°gina para la paginaci√≥n (1-indexed)',\n    example: 1,\n    default: 1,\n    minimum: 1,\n  })\n  @IsOptional()\n  @Type(() => Number)\n  @IsInt()\n  @Min(1)\n  page?: number = 1;\n\n  @ApiPropertyOptional({\n    description: 'N√∫mero de elementos por p√°gina',\n    example: 10,\n    default: 10,\n    minimum: 1,\n    maximum: 100, // Added a reasonable maximum\n  })\n  @IsOptional()\n  @Type(() => Number)\n  @IsInt()\n  @Min(1)\n  @Max(100) // Added a reasonable maximum\n  limit?: number = 10; // Renamed from pageSize to limit for consistency with service\n\n  @ApiPropertyOptional({\n    description: 'ID externo del video (por ejemplo, de YouTube)',\n    example: 'ixBgrqho03E',\n  })\n  @IsOptional()\n  @IsString()\n  externalId?: string;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/playlist/playlist.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ApiQuery' is defined but never used. Allowed unused vars must match /^_/u.","line":20,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":11}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Controller,\n  Get,\n  Post,\n  Put,\n  Delete,\n  Param,\n  Body,\n  Query,\n  UsePipes,\n  ValidationPipe,\n  HttpStatus,\n  Inject,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOperation,\n  ApiResponse,\n  ApiBearerAuth,\n  ApiQuery,\n  ApiParam,\n} from '@nestjs/swagger';\nimport { PlaylistService } from './playlist.service';\nimport { CreatePlaylistDto } from './dto/create-playlist.dto';\nimport { UpdatePlaylistDto } from './dto/update-playlist.dto';\nimport { FindAllPlaylistsDto } from './dto/find-all-playlists.dto';\n// import { Playlist } from '../generated/prisma';\n\n@ApiTags('playlists')\n@Controller('playlists')\n@ApiBearerAuth()\nexport class PlaylistController {\n  constructor(\n    @Inject(PlaylistService) private readonly playlistService: PlaylistService\n  ) {\n    // // //     console.log('>>> PlaylistController CONSTRUCTOR: Initializing...');\n    // //     console.log('>>> PlaylistController CONSTRUCTOR: this.playlistService IS', this.playlistService ? 'DEFINED' : 'UNDEFINED');\n  }\n\n  @Post()\n  @ApiOperation({\n    summary: 'Crear una nueva playlist',\n    description: 'Crea una nueva playlist dentro de un mundo espec√≠fico',\n  })\n  @ApiResponse({\n    status: HttpStatus.CREATED,\n    description: 'La playlist ha sido creada exitosamente',\n    type: CreatePlaylistDto, // Assuming the response shape matches the DTO\n  })\n  @ApiResponse({\n    status: HttpStatus.BAD_REQUEST,\n    description: 'Datos de entrada inv√°lidos',\n  })\n  @UsePipes(new ValidationPipe({ transform: true }))\n  create(@Body() createPlaylistDto: CreatePlaylistDto) {\n    //     console.log('>>> PlaylistController.create: Called with data:', createPlaylistDto);\n    //     console.log('>>> PlaylistController.create: Raw body type:', typeof createPlaylistDto);\n    //     console.log('>>> PlaylistController.create: Raw body JSON:', JSON.stringify(createPlaylistDto, null, 2));\n    //     console.log('>>> PlaylistController.create: this.playlistService IS', this.playlistService ? 'DEFINED' : 'UNDEFINED');\n\n    // Mapear mundo_id a mundoId si es necesario\n    if (createPlaylistDto.mundo_id && !createPlaylistDto.mundoId) {\n      createPlaylistDto.mundoId = createPlaylistDto.mundo_id;\n      //       console.log('>>> PlaylistController.create: Mapped mundo_id to mundoId:', createPlaylistDto.mundoId);\n    }\n\n    return this.playlistService.create(createPlaylistDto);\n  }\n\n  @Get()\n  @ApiOperation({\n    summary: 'Obtener todas las playlists',\n    description:\n      'Obtiene un listado de todas las playlists con opciones de paginaci√≥n y filtrado',\n  })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Listado de playlists obtenido exitosamente',\n  })\n  async findAll(\n    @Query(\n      new ValidationPipe({\n        transform: true,\n        whitelist: true,\n        forbidNonWhitelisted: true,\n      })\n    )\n    findAllDto: FindAllPlaylistsDto\n  ) {\n    //     console.log('>>> PlaylistController findAll: Called');\n    //     console.log('>>> PlaylistController findAll: this.playlistService IS', this.playlistService ? 'DEFINED' : 'UNDEFINED');\n    if (!this.playlistService) {\n      //       console.error('>>> PlaylistController findAll: ERROR! playlistService is undefined!');\n      throw new Error('Playlist service is not available.');\n    }\n\n    const result = await this.playlistService.findAll(findAllDto);\n    //       console.log('>>> PlaylistController.findAll result:', result);\n    return result;\n  }\n\n  @Get(':id')\n  @ApiOperation({\n    summary: 'Obtener una playlist por ID',\n    description: 'Obtiene los detalles de una playlist espec√≠fica por su ID',\n  })\n  @ApiParam({ name: 'id', description: 'ID de la playlist' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Playlist encontrada',\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Playlist no encontrada',\n  })\n  findOne(@Param('id') id: string) {\n    return this.playlistService.findOne(id);\n  }\n\n  @Put(':id')\n  @ApiOperation({\n    summary: 'Actualizar una playlist',\n    description: 'Actualiza los datos de una playlist existente',\n  })\n  @ApiParam({ name: 'id', description: 'ID de la playlist a actualizar' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Playlist actualizada exitosamente',\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Playlist no encontrada',\n  })\n  @UsePipes(new ValidationPipe({ transform: true }))\n  update(\n    @Param('id') id: string,\n    @Body() updatePlaylistDto: UpdatePlaylistDto\n  ) {\n    return this.playlistService.update(id, updatePlaylistDto);\n  }\n\n  @Delete(':id')\n  @ApiOperation({\n    summary: 'Eliminar una playlist',\n    description: 'Elimina una playlist existente por su ID',\n  })\n  @ApiParam({ name: 'id', description: 'ID de la playlist a eliminar' })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Playlist eliminada exitosamente',\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Playlist no encontrada',\n  })\n  remove(@Param('id') id: string) {\n    return this.playlistService.remove(id);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/prisma/prisma.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":29,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'app' is defined but never used. Allowed unused args must match /^_/u.","line":36,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":36,"endColumn":32}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/prisma/prisma.service.ts\nimport { Injectable, OnModuleInit, INestApplication } from '@nestjs/common';\nimport { PrismaClient, MarketplaceItemType } from '../generated/prisma';\nimport * as bcrypt from 'bcryptjs';\n\n@Injectable()\nexport class PrismaService extends PrismaClient implements OnModuleInit {\n  private isMockMode = false; // ‚úÖ REAL DATABASE: Usar base de datos PostgreSQL real\n\n  constructor() {\n    super();\n    //     console.log('>>> PrismaService Constructor Executed (REAL DATABASE MODE)');\n    //     console.log('>>> PrismaService Constructor - MOCK_MODE:', this.isMockMode);\n  }\n\n  async onModuleInit() {\n    if (this.isMockMode) {\n      //       console.log('>>> PrismaService onModuleInit - MOCK MODE: Skipping database connection');\n      //       console.log('>>> PrismaService onModuleInit - Backend will use mock data');\n      return;\n    }\n\n    //     console.log('>>> PrismaService onModuleInit - Connecting to database...');\n    try {\n      await this.$connect();\n      //       console.log('>>> PrismaService onModuleInit - Database connection established');\n      //       console.log('>>> PrismaService onModuleInit - Backend using REAL PostgreSQL database');\n      await this.seedDatabase(); // Llama al seeder aqu√≠\n    } catch (error) {\n      //       console.error('>>> PrismaService onModuleInit - Database connection failed:', error.message);\n      //       console.log('>>> PrismaService onModuleInit - Falling back to MOCK MODE');\n      this.isMockMode = true;\n    }\n  }\n\n  async enableShutdownHooks(app: INestApplication) {\n    // Note: beforeExit event is not available in the current Prisma version\n    // This method is kept for compatibility but doesn't do anything\n    // The connection will be closed when the app shuts down\n  }\n\n  // Getter para verificar el estado desde otros servicios\n  get isUsingMockMode(): boolean {\n    return this.isMockMode;\n  }\n\n  async seedDatabase() {\n    const userCount = await this.user.count();\n    if (userCount > 0) {\n      return;\n    }\n\n    console.log('Database is empty. Seeding...');\n\n    const adminPassword = await bcrypt.hash('admin123', 10);\n    const userPassword = await bcrypt.hash('123456', 10);\n\n    const rolesData = [\n      { name: 'admin', description: 'Administrator role' },\n      { name: 'user', description: 'Standard user role' },\n      { name: 'premium', description: 'Premium user role' },\n      { name: 'creator', description: 'Content creator role' },\n      { name: 'moderator', description: 'Moderator role' },\n    ];\n    for (const role of rolesData) {\n      await this.role.upsert({\n        where: { name: role.name },\n        update: {},\n        create: role,\n      });\n    }\n\n    const usersData = [\n      {\n        email: 'admin@gamifier.com',\n        password: adminPassword,\n        name: 'Admin User',\n        roles: ['admin'],\n      },\n      {\n        email: 'user@gamifier.com',\n        password: userPassword,\n        name: 'Regular User',\n        roles: ['user'],\n      },\n      {\n        email: 'premium@gamifier.com',\n        password: userPassword,\n        name: 'Premium User',\n        roles: ['user', 'premium'],\n      },\n      {\n        email: 'creator@gamifier.com',\n        password: userPassword,\n        name: 'Content Creator',\n        roles: ['user', 'creator'],\n      },\n      {\n        email: 'moderator@gamifier.com',\n        password: userPassword,\n        name: 'Moderator',\n        roles: ['user', 'moderator'],\n      },\n    ];\n\n    for (const u of usersData) {\n      const user = await this.user.upsert({\n        where: { email: u.email },\n        update: {},\n        create: { email: u.email, password: u.password, name: u.name },\n      });\n      for (const roleName of u.roles) {\n        const role = await this.role.findUnique({ where: { name: roleName } });\n        if (role) {\n          await this.userRole.create({\n            data: { userId: user.id, roleId: role.id },\n          });\n        }\n      }\n    }\n\n    const sellerUser1 = await this.user.upsert({\n      where: { email: 'elena.guardian@coomunity.com' },\n      update: {},\n      create: {\n        email: 'elena.guardian@coomunity.com',\n        password: userPassword,\n        name: 'Elena, Guardiana de la Tierra',\n      },\n    });\n    await this.profile.upsert({\n      where: { userId: sellerUser1.id },\n      update: {},\n      create: {\n        userId: sellerUser1.id,\n        bio: 'Apasionada por la permacultura y la vida sostenible. Creo en el poder de la comunidad para regenerar nuestro planeta.',\n        isEmprendedorConfiable: true,\n        avatar: 'https://source.unsplash.com/500x500/?woman,nature',\n      },\n    });\n\n    const sellerUser2 = await this.user.upsert({\n      where: { email: 'marco.artesano@coomunity.com' },\n      update: {},\n      create: {\n        email: 'marco.artesano@coomunity.com',\n        password: userPassword,\n        name: 'Marco, Artesano del Bienestar',\n      },\n    });\n    await this.profile.upsert({\n      where: { userId: sellerUser2.id },\n      update: {},\n      create: {\n        userId: sellerUser2.id,\n        bio: 'Artista y terapeuta de sonido. Mi misi√≥n es crear herramientas y experiencias que ayuden a las personas a conectar con su interior.',\n        isEmprendedorConfiable: true,\n        avatar: 'https://source.unsplash.com/500x500/?man,craft',\n      },\n    });\n\n    const marketplaceItemsData = [\n      {\n        name: 'Taller de Huerto Urbano Org√°nico',\n        description:\n          'Aprende a cultivar tus propios alimentos en espacios peque√±os.',\n        fullDescription:\n          'Este taller intensivo cubre todo lo que necesitas para iniciar tu propio huerto org√°nico en casa.',\n        itemType: MarketplaceItemType.SERVICE,\n        price: 35,\n        category: 'Sostenibilidad',\n        tags: ['huerto', 'org√°nico', 'taller', 'diy', 'sostenibilidad'],\n        images: [\n          'https://source.unsplash.com/800x600/?urban,garden',\n          'https://source.unsplash.com/800x600/?seedlings',\n        ],\n        stock: 15,\n        sellerId: sellerUser1.id,\n        rating: 4.8,\n        reviewCount: 2,\n      },\n      {\n        name: 'Kombucha Artesanal de Jengibre y C√∫rcuma',\n        description:\n          'Bebida probi√≥tica fermentada artesanalmente con ingredientes 100% org√°nicos.',\n        fullDescription:\n          'Nuestra kombucha es un elixir vivo, fermentado en peque√±os lotes para garantizar su m√°xima calidad.',\n        itemType: MarketplaceItemType.PRODUCT,\n        price: 15,\n        category: 'Salud & Bienestar',\n        tags: ['kombucha', 'probi√≥tico', 'org√°nico', 'salud'],\n        images: [\n          'https://source.unsplash.com/800x600/?kombucha',\n          'https://source.unsplash.com/800x600/?ginger,turmeric',\n        ],\n        stock: 50,\n        sellerId: sellerUser1.id,\n        rating: 5,\n        reviewCount: 1,\n      },\n      {\n        name: 'Sesi√≥n de Terapia de Sonido (Sound Healing)',\n        description:\n          'Viaje sonoro de 60 minutos con cuencos tibetanos y gongs.',\n        fullDescription:\n          'Perm√≠tete un reseteo completo del sistema nervioso a trav√©s de las vibraciones sanadoras.',\n        itemType: MarketplaceItemType.SERVICE,\n        price: 60,\n        category: 'Salud & Bienestar',\n        tags: ['sonoterapia', 'meditaci√≥n', 'bienestar', 'relajaci√≥n'],\n        images: [\n          'https://source.unsplash.com/800x600/?sound,healing',\n          'https://source.unsplash.com/800x600/?singing,bowl',\n        ],\n        stock: 10,\n        sellerId: sellerUser2.id,\n        rating: 4.9,\n        reviewCount: 1,\n      },\n      {\n        name: 'Kit de Sahumerios de Limpieza Energ√©tica',\n        description:\n          'Atado de salvia blanca de cultivo √©tico y palo santo sostenible.',\n        fullDescription:\n          'Este kit contiene todo lo necesario para realizar rituales de limpieza energ√©tica.',\n        itemType: MarketplaceItemType.PRODUCT,\n        price: 25,\n        category: 'Desarrollo Consciente',\n        tags: ['sahumerio', 'limpieza', 'ritual', 'espiritual'],\n        images: [\n          'https://source.unsplash.com/800x600/?smudge,stick',\n          'https://source.unsplash.com/800x600/?palo,santo',\n        ],\n        stock: 40,\n        sellerId: sellerUser2.id,\n        rating: 0,\n        reviewCount: 0,\n      },\n      {\n        name: 'Intercambio: Clases de Guitarra por Dise√±o Gr√°fico',\n        description:\n          'Ofrezco clases de guitarra para principiantes a cambio de ayuda con el dise√±o de un logo.',\n        fullDescription:\n          'Soy m√∫sico con 15 a√±os de experiencia y estoy lanzando mi proyecto como solista. Necesito una identidad visual potente.',\n        itemType: MarketplaceItemType.SERVICE,\n        price: 0,\n        category: 'Educaci√≥n',\n        tags: ['trueque', 'm√∫sica', 'dise√±o', 'reciprocidad'],\n        images: [\n          'https://source.unsplash.com/800x600/?guitar,lesson',\n          'https://source.unsplash.com/800x600/?graphic,design',\n        ],\n        stock: 1,\n        sellerId: sellerUser2.id,\n        rating: 0,\n        reviewCount: 0,\n      },\n    ];\n\n    for (const item of marketplaceItemsData) {\n      await this.marketplaceItem.create({ data: item });\n    }\n\n    const itemsToReview = {\n      huerto: await this.marketplaceItem.findFirst({\n        where: { name: { contains: 'Huerto' } },\n      }),\n      kombucha: await this.marketplaceItem.findFirst({\n        where: { name: { contains: 'Kombucha' } },\n      }),\n      sonido: await this.marketplaceItem.findFirst({\n        where: { name: { contains: 'Sonido' } },\n      }),\n    };\n\n    const regularUser = await this.user.findUnique({\n      where: { email: 'user@gamifier.com' },\n    });\n\n    if (\n      itemsToReview.huerto &&\n      itemsToReview.kombucha &&\n      itemsToReview.sonido &&\n      regularUser\n    ) {\n      await this.review.createMany({\n        data: [\n          {\n            rating: 5,\n            comment:\n              '¬°Incre√≠ble taller! Elena es una maestra maravillosa, explica con una claridad y una pasi√≥n que contagian.',\n            marketplaceItemId: itemsToReview.huerto.id,\n            userId: regularUser.id,\n            communication: 5,\n            quality: 5,\n            delivery: 5,\n            value: 5,\n          },\n          {\n            rating: 5,\n            comment:\n              'La mejor kombucha que he probado, se nota que est√° hecha con amor y con ingredientes de primera.',\n            marketplaceItemId: itemsToReview.kombucha.id,\n            userId: regularUser.id,\n            communication: 5,\n            quality: 5,\n            delivery: 5,\n            value: 5,\n          },\n          {\n            rating: 5,\n            comment:\n              'La sesi√≥n con Marco fue m√°gica. Sent√≠ una paz profunda y una claridad que no hab√≠a experimentado antes.',\n            marketplaceItemId: itemsToReview.sonido.id,\n            userId: regularUser.id,\n            communication: 5,\n            quality: 5,\n            delivery: 5,\n            value: 5,\n          },\n        ],\n      });\n    }\n\n    console.log('Database seeding completed successfully.');\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/social/groups/groups.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Patch' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Delete' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UpdateGroupDto' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":24}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Controller,\n  Get,\n  Post,\n  Body,\n  Patch,\n  Param,\n  Delete,\n  Inject,\n} from '@nestjs/common';\nimport { GroupsService } from './groups.service';\nimport { CreateGroupDto } from './dto/create-group.dto';\nimport { UpdateGroupDto } from './dto/update-group.dto';\nimport { JoinGroupDto } from './dto/join-group.dto';\n\n@Controller('groups')\nexport class GroupsController {\n  constructor(\n    @Inject(GroupsService) private readonly groupsService: GroupsService\n  ) {\n    // //     console.log('>>> GroupsController CONSTRUCTOR: this.groupsService IS', this.groupsService ? 'DEFINED' : 'UNDEFINED');\n  }\n\n  @Post()\n  create(@Body() createGroupDto: CreateGroupDto) {\n    //     console.log('>>> GroupsController: POST /groups', createGroupDto);\n    return this.groupsService.create(createGroupDto);\n  }\n\n  @Get()\n  findAll() {\n    //     console.log('>>> GroupsController: GET /groups');\n    return this.groupsService.findAll();\n  }\n\n  @Get(':id')\n  findOne(@Param('id') id: string) {\n    //     console.log('>>> GroupsController: GET /groups/:id', id);\n    return this.groupsService.findOne(id);\n  }\n\n  @Post('join')\n  joinGroup(@Body() joinGroupDto: JoinGroupDto) {\n    //     console.log('>>> GroupsController: POST /groups/join', joinGroupDto);\n    return this.groupsService.joinGroup(joinGroupDto);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/social/groups/groups.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UpdateGroupDto' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":24}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  Inject,\n  NotFoundException,\n  BadRequestException,\n  ConflictException,\n} from '@nestjs/common';\nimport { PrismaService } from '../../prisma/prisma.service';\nimport { CreateGroupDto } from './dto/create-group.dto';\nimport { UpdateGroupDto } from './dto/update-group.dto';\nimport { JoinGroupDto } from './dto/join-group.dto';\nimport type { Group, UserGroup } from '../../generated/prisma';\n\n@Injectable()\nexport class GroupsService {\n  constructor(@Inject(PrismaService) private readonly prisma: PrismaService) {\n    // //     console.log('>>> GroupsService CONSTRUCTOR: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n  }\n\n  async create(createGroupDto: CreateGroupDto): Promise<Group> {\n    // Validar que el owner existe\n    const owner = await this.prisma.user.findUnique({\n      where: { id: createGroupDto.ownerId },\n    });\n\n    if (!owner) {\n      throw new NotFoundException(\n        `Owner with ID ${createGroupDto.ownerId} not found`\n      );\n    }\n\n    // Validar tipos de grupo v√°lidos\n    const validGroupTypes = [\n      'CLAN',\n      'FRIEND',\n      'CLIENT',\n      'ALLY',\n      'GOVERNANCE_BODY',\n      'COMMUNITY_OF_PRACTICE',\n    ];\n    if (!validGroupTypes.includes(createGroupDto.type)) {\n      throw new BadRequestException(\n        `Invalid group type: ${createGroupDto.type}`\n      );\n    }\n\n    const group = await this.prisma.group.create({\n      data: {\n        name: createGroupDto.name,\n        description: createGroupDto.description,\n        ownerId: createGroupDto.ownerId,\n        type: createGroupDto.type,\n      },\n      include: {\n        owner: {\n          select: {\n            id: true,\n            email: true,\n            name: true,\n            username: true,\n          },\n        },\n        userGroups: {\n          include: {\n            user: {\n              select: {\n                id: true,\n                email: true,\n                name: true,\n                username: true,\n              },\n            },\n          },\n        },\n      },\n    });\n\n    //       console.log(`>>> GroupsService: Created group ${group.id} by user ${createGroupDto.ownerId}`);\n    return group;\n  }\n\n  async findAll(): Promise<Group[]> {\n    return await this.prisma.group.findMany({\n      include: {\n        owner: {\n          select: {\n            id: true,\n            email: true,\n            name: true,\n            username: true,\n          },\n        },\n        userGroups: {\n          include: {\n            user: {\n              select: {\n                id: true,\n                email: true,\n                name: true,\n                username: true,\n              },\n            },\n          },\n        },\n      },\n      orderBy: {\n        createdAt: 'desc',\n      },\n    });\n  }\n\n  async findOne(id: string): Promise<Group> {\n    const group = await this.prisma.group.findUnique({\n      where: { id },\n      include: {\n        owner: {\n          select: {\n            id: true,\n            email: true,\n            name: true,\n            username: true,\n          },\n        },\n        userGroups: {\n          include: {\n            user: {\n              select: {\n                id: true,\n                email: true,\n                name: true,\n                username: true,\n              },\n            },\n          },\n        },\n      },\n    });\n\n    if (!group) {\n      throw new NotFoundException(`Group with ID ${id} not found`);\n    }\n\n    return group;\n  }\n\n  async joinGroup(joinGroupDto: JoinGroupDto): Promise<UserGroup> {\n    // Validar que el usuario existe\n    const user = await this.prisma.user.findUnique({\n      where: { id: joinGroupDto.userId },\n    });\n\n    if (!user) {\n      throw new NotFoundException(\n        `User with ID ${joinGroupDto.userId} not found`\n      );\n    }\n\n    // Validar que el grupo existe\n    await this.findOne(joinGroupDto.groupId);\n\n    // Verificar que el usuario no est√© ya en el grupo\n    const existingMembership = await this.prisma.userGroup.findUnique({\n      where: {\n        userId_groupId: {\n          userId: joinGroupDto.userId,\n          groupId: joinGroupDto.groupId,\n        },\n      },\n    });\n\n    if (existingMembership) {\n      throw new ConflictException(\n        `User ${joinGroupDto.userId} is already a member of group ${joinGroupDto.groupId}`\n      );\n    }\n\n    // Validar roles v√°lidos\n    const validRoles = ['MEMBER', 'LEADER', 'ARBITRATOR', 'MODERATOR'];\n    const roleInGroup = joinGroupDto.roleInGroup || 'MEMBER';\n    if (!validRoles.includes(roleInGroup)) {\n      throw new BadRequestException(`Invalid role in group: ${roleInGroup}`);\n    }\n\n    const userGroup = await this.prisma.userGroup.create({\n      data: {\n        userId: joinGroupDto.userId,\n        groupId: joinGroupDto.groupId,\n        roleInGroup,\n      },\n      include: {\n        user: {\n          select: {\n            id: true,\n            email: true,\n            name: true,\n            username: true,\n          },\n        },\n        group: {\n          select: {\n            id: true,\n            name: true,\n            description: true,\n            type: true,\n          },\n        },\n      },\n    });\n\n    //       console.log(`>>> GroupsService: User ${joinGroupDto.userId} joined group ${joinGroupDto.groupId} as ${roleInGroup}`);\n    return userGroup;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/study-rooms/dto/create-study-room.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsUUID' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":9}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ApiProperty } from '@nestjs/swagger';\nimport {\n  IsString,\n  IsUUID,\n  IsOptional,\n  MaxLength,\n  MinLength,\n} from 'class-validator';\n\nexport class CreateStudyRoomDto {\n  @ApiProperty({\n    description: 'Nombre de la sala de estudio',\n    example: 'Sala de Matem√°ticas Avanzadas',\n    minLength: 3,\n    maxLength: 100,\n  })\n  @IsString()\n  @MinLength(3, { message: 'El nombre debe tener al menos 3 caracteres' })\n  @MaxLength(100, { message: 'El nombre no puede exceder 100 caracteres' })\n  name: string;\n\n  @ApiProperty({\n    description: 'Descripci√≥n opcional de la sala',\n    example: 'Sala para estudiar √°lgebra linear y c√°lculo',\n    maxLength: 500,\n    required: false,\n  })\n  @IsOptional()\n  @IsString()\n  @MaxLength(500, { message: 'La descripci√≥n no puede exceder 500 caracteres' })\n  description?: string;\n\n  @ApiProperty({\n    description: 'ID del video que se reproducir√° en la sala',\n    example: '1',\n  })\n  @IsString()\n  videoId: string;\n\n  @ApiProperty({\n    description: 'Capacidad m√°xima de participantes',\n    example: 10,\n    default: 10,\n  })\n  @IsOptional()\n  maxParticipants?: number = 10;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/study-rooms/study-rooms.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'JoinStudyRoomDto' is defined but never used. Allowed unused vars must match /^_/u.","line":27,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":26}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Controller,\n  Get,\n  Post,\n  Put,\n  Delete,\n  Body,\n  Param,\n  Query,\n  UseGuards,\n  Request,\n  Logger,\n  ParseIntPipe,\n  DefaultValuePipe,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOperation,\n  ApiResponse,\n  ApiBearerAuth,\n  ApiParam,\n  ApiQuery,\n} from '@nestjs/swagger';\nimport { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';\nimport { StudyRoomsService } from './study-rooms.service';\nimport { CreateStudyRoomDto } from './dto/create-study-room.dto';\nimport { JoinStudyRoomDto } from './dto/join-study-room.dto';\nimport { StudyRoomResponseDto } from './dto/study-room-response.dto';\n\ninterface AuthenticatedRequest extends Request {\n  user: {\n    id: string;\n  };\n}\n\n@ApiTags('Study Rooms - √úPlay Social Collaboration')\n@Controller('study-rooms')\n@UseGuards(JwtAuthGuard)\n@ApiBearerAuth()\nexport class StudyRoomsController {\n  private readonly logger = new Logger(StudyRoomsController.name);\n\n  constructor(private readonly studyRoomsService: StudyRoomsService) {}\n\n  @Post()\n  @ApiOperation({\n    summary: 'Crear una nueva sala de estudio',\n    description:\n      'Permite a un usuario crear una sala de estudio colaborativa para un video espec√≠fico. El creador se convierte autom√°ticamente en el host.',\n  })\n  @ApiResponse({\n    status: 201,\n    description: 'Sala de estudio creada exitosamente',\n    type: StudyRoomResponseDto,\n  })\n  @ApiResponse({\n    status: 404,\n    description: 'Video no encontrado',\n  })\n  @ApiResponse({\n    status: 401,\n    description: 'Token de autenticaci√≥n requerido',\n  })\n  async createStudyRoom(\n    @Request() req: AuthenticatedRequest,\n    @Body() createStudyRoomDto: CreateStudyRoomDto\n  ): Promise<StudyRoomResponseDto> {\n    this.logger.log(\n      `Creating study room: ${createStudyRoomDto.name} for user ${req.user.id}`\n    );\n    return this.studyRoomsService.createStudyRoom(\n      req.user.id,\n      createStudyRoomDto\n    );\n  }\n\n  @Get()\n  @ApiOperation({\n    summary: 'Obtener todas las salas de estudio activas',\n    description: 'Lista todas las salas de estudio disponibles con paginaci√≥n',\n  })\n  @ApiQuery({\n    name: 'page',\n    required: false,\n    description: 'N√∫mero de p√°gina (default: 1)',\n    example: 1,\n  })\n  @ApiQuery({\n    name: 'limit',\n    required: false,\n    description: 'Elementos por p√°gina (default: 10)',\n    example: 10,\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Lista de salas de estudio obtenida exitosamente',\n    schema: {\n      type: 'object',\n      properties: {\n        rooms: {\n          type: 'array',\n          items: { type: 'object' }, // Simplified to avoid circular reference\n        },\n        total: {\n          type: 'number',\n          description: 'N√∫mero total de salas',\n        },\n      },\n    },\n  })\n  async getAllStudyRooms(\n    @Query('page', new DefaultValuePipe(1), ParseIntPipe) page: number,\n    @Query('limit', new DefaultValuePipe(10), ParseIntPipe) limit: number\n  ) {\n    this.logger.log(`Fetching study rooms - page: ${page}, limit: ${limit}`);\n    return this.studyRoomsService.getAllStudyRooms(page, limit);\n  }\n\n  @Get(':roomId')\n  @ApiOperation({\n    summary: 'Obtener detalles de una sala de estudio espec√≠fica',\n    description:\n      'Obtiene informaci√≥n detallada de una sala de estudio incluyendo participantes y estado del video',\n  })\n  @ApiParam({\n    name: 'roomId',\n    description: 'ID √∫nico de la sala de estudio',\n    example: '550e8400-e29b-41d4-a716-446655440000',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Detalles de la sala obtenidos exitosamente',\n    type: StudyRoomResponseDto,\n  })\n  @ApiResponse({\n    status: 404,\n    description: 'Sala de estudio no encontrada',\n  })\n  async getStudyRoomById(\n    @Param('roomId') roomId: string\n  ): Promise<StudyRoomResponseDto> {\n    this.logger.log(`Fetching study room details: ${roomId}`);\n    return this.studyRoomsService.getStudyRoomById(roomId);\n  }\n\n  @Post(':roomId/join')\n  @ApiOperation({\n    summary: 'Unirse a una sala de estudio',\n    description: 'Permite a un usuario unirse a una sala de estudio existente',\n  })\n  @ApiParam({\n    name: 'roomId',\n    description: 'ID √∫nico de la sala de estudio',\n    example: '550e8400-e29b-41d4-a716-446655440000',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Usuario se uni√≥ a la sala exitosamente',\n    type: StudyRoomResponseDto,\n  })\n  @ApiResponse({\n    status: 404,\n    description: 'Sala de estudio no encontrada',\n  })\n  @ApiResponse({\n    status: 400,\n    description: 'Error al unirse (capacidad llena, ya est√° en la sala, etc.)',\n  })\n  async joinStudyRoom(\n    @Request() req: AuthenticatedRequest,\n    @Param('roomId') roomId: string\n  ): Promise<StudyRoomResponseDto> {\n    this.logger.log(`User ${req.user.id} joining study room: ${roomId}`);\n    return this.studyRoomsService.joinStudyRoom(roomId, req.user.id);\n  }\n\n  @Post(':roomId/leave')\n  @ApiOperation({\n    summary: 'Salir de una sala de estudio',\n    description:\n      'Permite a un usuario salir de una sala de estudio. Si el host sale, se transfiere el rol al siguiente participante.',\n  })\n  @ApiParam({\n    name: 'roomId',\n    description: 'ID √∫nico de la sala de estudio',\n    example: '550e8400-e29b-41d4-a716-446655440000',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Usuario sali√≥ de la sala exitosamente',\n  })\n  @ApiResponse({\n    status: 404,\n    description: 'Usuario no est√° en la sala o sala no encontrada',\n  })\n  async leaveStudyRoom(\n    @Request() req: AuthenticatedRequest,\n    @Param('roomId') roomId: string\n  ): Promise<{ message: string }> {\n    this.logger.log(`User ${req.user.id} leaving study room: ${roomId}`);\n    await this.studyRoomsService.leaveStudyRoom(roomId, req.user.id);\n    return { message: 'Has salido de la sala de estudio exitosamente' };\n  }\n\n  @Put(':roomId/sync')\n  @ApiOperation({\n    summary: 'Sincronizar estado del video',\n    description:\n      'Permite al host sincronizar el tiempo y estado de reproducci√≥n del video para todos los participantes',\n  })\n  @ApiParam({\n    name: 'roomId',\n    description: 'ID √∫nico de la sala de estudio',\n    example: '550e8400-e29b-41d4-a716-446655440000',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Estado del video sincronizado exitosamente',\n  })\n  @ApiResponse({\n    status: 403,\n    description: 'Solo el host puede controlar la reproducci√≥n',\n  })\n  @ApiResponse({\n    status: 404,\n    description: 'Sala de estudio no encontrada',\n  })\n  async updateVideoSync(\n    @Request() req: AuthenticatedRequest,\n    @Param('roomId') roomId: string,\n    @Body() syncData: { currentTime: number; isPaused: boolean }\n  ): Promise<{ message: string }> {\n    this.logger.log(\n      `Updating video sync for room ${roomId}: time=${syncData.currentTime}, paused=${syncData.isPaused}`\n    );\n    await this.studyRoomsService.updateVideoSync(\n      roomId,\n      req.user.id,\n      syncData.currentTime,\n      syncData.isPaused\n    );\n    return { message: 'Estado del video sincronizado exitosamente' };\n  }\n\n  @Delete(':roomId')\n  @ApiOperation({\n    summary: 'Eliminar una sala de estudio',\n    description:\n      'Permite al host eliminar permanentemente una sala de estudio. Todos los participantes son removidos autom√°ticamente.',\n  })\n  @ApiParam({\n    name: 'roomId',\n    description: 'ID √∫nico de la sala de estudio',\n    example: '550e8400-e29b-41d4-a716-446655440000',\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'Sala de estudio eliminada exitosamente',\n  })\n  @ApiResponse({\n    status: 403,\n    description: 'Solo el host puede eliminar la sala',\n  })\n  @ApiResponse({\n    status: 404,\n    description: 'Sala de estudio no encontrada',\n  })\n  async deleteStudyRoom(\n    @Request() req: AuthenticatedRequest,\n    @Param('roomId') roomId: string\n  ): Promise<{ message: string }> {\n    this.logger.log(`User ${req.user.id} deleting study room: ${roomId}`);\n    await this.studyRoomsService.deleteStudyRoom(roomId, req.user.id);\n    return { message: 'Sala de estudio eliminada exitosamente' };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/study-rooms/study-rooms.gateway.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UseGuards' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":27}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  WebSocketGateway,\n  WebSocketServer,\n  SubscribeMessage,\n  OnGatewayConnection,\n  OnGatewayDisconnect,\n  MessageBody,\n  ConnectedSocket,\n  WsException,\n} from '@nestjs/websockets';\nimport { Logger, UseGuards } from '@nestjs/common';\nimport { Server, Socket } from 'socket.io';\nimport { JwtService } from '@nestjs/jwt';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { StudyRoomsService } from './study-rooms.service';\n\ninterface AuthenticatedSocket extends Socket {\n  userId?: string;\n  user?: {\n    id: string;\n    name: string | null;\n    email: string;\n  };\n}\n\n@WebSocketGateway({\n  namespace: '/study-rooms',\n  cors: {\n    origin: ['http://localhost:3001', 'http://localhost:3000'],\n    credentials: true,\n  },\n})\nexport class StudyRoomsGateway\n  implements OnGatewayConnection, OnGatewayDisconnect\n{\n  @WebSocketServer() server: Server;\n  private readonly logger = new Logger(StudyRoomsGateway.name);\n\n  constructor(\n    private readonly jwtService: JwtService,\n    private readonly prisma: PrismaService,\n    private readonly studyRoomsService: StudyRoomsService\n  ) {\n    // ‚úÖ DEBUGGING: Verificar que los servicios se inyecten correctamente\n    this.logger.log('>>> StudyRoomsGateway constructor initialized');\n    this.logger.log('>>> JwtService injected:', !!this.jwtService);\n    this.logger.log('>>> PrismaService injected:', !!this.prisma);\n    this.logger.log(\n      '>>> StudyRoomsService injected:',\n      !!this.studyRoomsService\n    );\n\n    if (!this.jwtService) {\n      this.logger.error(\n        '>>> CRITICAL: JwtService is undefined - WebSocket auth will fail'\n      );\n    }\n    if (!this.jwtService?.verify) {\n      this.logger.error('>>> CRITICAL: JwtService.verify is undefined');\n    }\n  }\n\n  async handleConnection(client: AuthenticatedSocket) {\n    try {\n      this.logger.log('>>> WebSocket connection attempt started');\n\n      // ‚úÖ DEBUGGING: Verificar servicios antes de usar\n      if (!this.jwtService) {\n        this.logger.error(\n          '>>> CRITICAL: JwtService is undefined during connection'\n        );\n        client.disconnect();\n        return;\n      }\n\n      if (!this.jwtService.verify) {\n        this.logger.error(\n          '>>> CRITICAL: JwtService.verify method is undefined'\n        );\n        client.disconnect();\n        return;\n      }\n\n      // Extraer token JWT de la query o headers\n      const token =\n        client.handshake.auth?.token || client.handshake.query?.token;\n\n      this.logger.log('>>> Token extraction attempt:', {\n        hasAuthToken: !!client.handshake.auth?.token,\n        hasQueryToken: !!client.handshake.query?.token,\n        tokenPresent: !!token,\n        tokenLength: token ? token.length : 0,\n      });\n\n      if (!token) {\n        this.logger.warn(\n          `>>> WebSocket connection rejected: No token provided`\n        );\n        client.emit('auth-error', {\n          message: 'Token de autenticaci√≥n requerido',\n        });\n        client.disconnect();\n        return;\n      }\n\n      this.logger.log('>>> Attempting JWT verification...');\n\n      // Verificar y decodificar el token\n      const payload = this.jwtService.verify(token);\n\n      this.logger.log('>>> JWT verification successful:', {\n        userId: payload.sub,\n        email: payload.email,\n        exp: payload.exp,\n      });\n\n      const user = await this.prisma.user.findUnique({\n        where: { id: payload.sub },\n        select: { id: true, name: true, email: true, isActive: true },\n      });\n\n      if (!user || !user.isActive) {\n        this.logger.warn(\n          `>>> WebSocket connection rejected: Invalid user ${payload.sub}`\n        );\n        client.emit('auth-error', { message: 'Usuario no v√°lido o inactivo' });\n        client.disconnect();\n        return;\n      }\n\n      client.userId = user.id;\n      client.user = user;\n\n      this.logger.log(\n        `>>> User ${user.name} (${user.id}) connected to study rooms WebSocket`\n      );\n      client.emit('connection-success', {\n        message: 'Conectado al chat de salas de estudio',\n        user,\n      });\n    } catch (error) {\n      this.logger.error(`>>> WebSocket authentication failed:`, {\n        error: error.message,\n        stack: error.stack,\n        jwtServiceAvailable: !!this.jwtService,\n        verifyMethodAvailable: !!this.jwtService?.verify,\n      });\n\n      client.emit('auth-error', {\n        message: 'Error de autenticaci√≥n',\n        details:\n          process.env.NODE_ENV === 'development' ? error.message : undefined,\n      });\n      client.disconnect();\n    }\n  }\n\n  handleDisconnect(client: AuthenticatedSocket) {\n    if (client.user) {\n      this.logger.log(\n        `User ${client.user.name} (${client.userId}) disconnected from study rooms WebSocket`\n      );\n    }\n  }\n\n  @SubscribeMessage('join-room')\n  async handleJoinRoom(\n    @ConnectedSocket() client: AuthenticatedSocket,\n    @MessageBody() data: { roomId: string }\n  ) {\n    try {\n      if (!client.userId) {\n        throw new WsException('No autenticado');\n      }\n\n      const { roomId } = data;\n\n      // Verificar que el usuario est√° en la sala\n      const participant = await this.prisma.studyRoomParticipant.findUnique({\n        where: {\n          studyRoomId_userId: {\n            studyRoomId: roomId,\n            userId: client.userId,\n          },\n        },\n      });\n\n      if (!participant || !participant.isActive) {\n        throw new WsException('No tienes acceso a esta sala');\n      }\n\n      // Unirse al room de Socket.IO\n      await client.join(roomId);\n\n      this.logger.log(\n        `User ${client.user?.name} joined room ${roomId} via WebSocket`\n      );\n\n      // Notificar a otros participantes\n      client.to(roomId).emit('user-joined-room', {\n        userId: client.userId,\n        userName: client.user?.name,\n        timestamp: new Date(),\n      });\n\n      // Enviar confirmaci√≥n al usuario\n      client.emit('room-joined', {\n        roomId,\n        message: 'Te has unido al chat de la sala exitosamente',\n      });\n    } catch (error) {\n      this.logger.error(`Error joining room: ${error.message}`);\n      client.emit('error', { message: error.message });\n    }\n  }\n\n  @SubscribeMessage('leave-room')\n  async handleLeaveRoom(\n    @ConnectedSocket() client: AuthenticatedSocket,\n    @MessageBody() data: { roomId: string }\n  ) {\n    try {\n      const { roomId } = data;\n\n      await client.leave(roomId);\n\n      this.logger.log(\n        `User ${client.user?.name} left room ${roomId} via WebSocket`\n      );\n\n      // Notificar a otros participantes\n      client.to(roomId).emit('user-left-room', {\n        userId: client.userId,\n        userName: client.user?.name,\n        timestamp: new Date(),\n      });\n    } catch (error) {\n      this.logger.error(`Error leaving room: ${error.message}`);\n      client.emit('error', { message: error.message });\n    }\n  }\n\n  @SubscribeMessage('send-message')\n  async handleSendMessage(\n    @ConnectedSocket() client: AuthenticatedSocket,\n    @MessageBody() data: { roomId: string; message: string }\n  ) {\n    try {\n      if (!client.userId) {\n        throw new WsException('No autenticado');\n      }\n\n      const { roomId, message } = data;\n\n      if (!message || message.trim().length === 0) {\n        throw new WsException('El mensaje no puede estar vac√≠o');\n      }\n\n      if (message.length > 1000) {\n        throw new WsException(\n          'El mensaje es demasiado largo (m√°ximo 1000 caracteres)'\n        );\n      }\n\n      // Verificar que el usuario est√° en la sala\n      const participant = await this.prisma.studyRoomParticipant.findUnique({\n        where: {\n          studyRoomId_userId: {\n            studyRoomId: roomId,\n            userId: client.userId,\n          },\n        },\n      });\n\n      if (!participant || !participant.isActive) {\n        throw new WsException('No tienes acceso a esta sala');\n      }\n\n      // Guardar mensaje en la base de datos\n      const savedMessage = await this.prisma.studyRoomMessage.create({\n        data: {\n          studyRoomId: roomId,\n          userId: client.userId,\n          message: message.trim(),\n          messageType: 'CHAT',\n        },\n        include: {\n          user: {\n            select: { id: true, name: true, avatarUrl: true },\n          },\n        },\n      });\n\n      // Construir objeto de mensaje para enviar\n      const messagePayload = {\n        id: savedMessage.id,\n        message: savedMessage.message,\n        messageType: savedMessage.messageType,\n        createdAt: savedMessage.createdAt,\n        user: {\n          id: savedMessage.user.id,\n          name: savedMessage.user.name || 'Usuario',\n          avatarUrl: savedMessage.user.avatarUrl,\n        },\n      };\n\n      // Enviar mensaje a todos los participantes de la sala (incluyendo el remitente)\n      this.server.to(roomId).emit('new-message', messagePayload);\n\n      this.logger.log(\n        `Message sent in room ${roomId} by user ${client.user?.name}: ${message.substring(0, 50)}${message.length > 50 ? '...' : ''}`\n      );\n    } catch (error) {\n      this.logger.error(`Error sending message: ${error.message}`);\n      client.emit('error', { message: error.message });\n    }\n  }\n\n  @SubscribeMessage('get-messages')\n  async handleGetMessages(\n    @ConnectedSocket() client: AuthenticatedSocket,\n    @MessageBody() data: { roomId: string; page?: number; limit?: number }\n  ) {\n    try {\n      if (!client.userId) {\n        throw new WsException('No autenticado');\n      }\n\n      const { roomId, page = 1, limit = 50 } = data;\n\n      // Verificar que el usuario est√° en la sala\n      const participant = await this.prisma.studyRoomParticipant.findUnique({\n        where: {\n          studyRoomId_userId: {\n            studyRoomId: roomId,\n            userId: client.userId,\n          },\n        },\n      });\n\n      if (!participant || !participant.isActive) {\n        throw new WsException('No tienes acceso a esta sala');\n      }\n\n      // Obtener mensajes de la sala\n      const messages = await this.prisma.studyRoomMessage.findMany({\n        where: { studyRoomId: roomId },\n        include: {\n          user: {\n            select: { id: true, name: true, avatarUrl: true },\n          },\n        },\n        orderBy: { createdAt: 'desc' },\n        skip: (page - 1) * limit,\n        take: limit,\n      });\n\n      const formattedMessages = messages.reverse().map((msg) => ({\n        id: msg.id,\n        message: msg.message,\n        messageType: msg.messageType,\n        createdAt: msg.createdAt,\n        user: {\n          id: msg.user.id,\n          name: msg.user.name || 'Usuario',\n          avatarUrl: msg.user.avatarUrl,\n        },\n      }));\n\n      client.emit('messages-history', {\n        roomId,\n        messages: formattedMessages,\n        page,\n        hasMore: messages.length === limit,\n      });\n\n      this.logger.log(\n        `Sent ${formattedMessages.length} messages to user ${client.user?.name} for room ${roomId}`\n      );\n    } catch (error) {\n      this.logger.error(`Error getting messages: ${error.message}`);\n      client.emit('error', { message: error.message });\n    }\n  }\n\n  @SubscribeMessage('video-sync')\n  async handleVideoSync(\n    @ConnectedSocket() client: AuthenticatedSocket,\n    @MessageBody()\n    data: { roomId: string; currentTime: number; isPaused: boolean }\n  ) {\n    try {\n      if (!client.userId) {\n        throw new WsException('No autenticado');\n      }\n\n      const { roomId, currentTime, isPaused } = data;\n\n      // Verificar que el usuario es host de la sala\n      const participant = await this.prisma.studyRoomParticipant.findUnique({\n        where: {\n          studyRoomId_userId: {\n            studyRoomId: roomId,\n            userId: client.userId,\n          },\n        },\n      });\n\n      if (!participant || !participant.isActive || !participant.isHost) {\n        throw new WsException('Solo el host puede sincronizar el video');\n      }\n\n      // Actualizar estado en la base de datos\n      await this.studyRoomsService.updateVideoSync(\n        roomId,\n        client.userId,\n        currentTime,\n        isPaused\n      );\n\n      // Emitir evento de sincronizaci√≥n a todos los participantes excepto el host\n      client.to(roomId).emit('video-sync-update', {\n        currentTime,\n        isPaused,\n        hostName: client.user?.name,\n        timestamp: new Date(),\n      });\n\n      this.logger.log(\n        `Video sync updated for room ${roomId}: time=${currentTime}, paused=${isPaused}`\n      );\n    } catch (error) {\n      this.logger.error(`Error syncing video: ${error.message}`);\n      client.emit('error', { message: error.message });\n    }\n  }\n\n  // M√©todo auxiliar para notificar eventos a una sala espec√≠fica\n  notifyRoom(roomId: string, event: string, data: Record<string, unknown>) {\n    this.server.to(roomId).emit(event, data);\n    this.logger.log(`Notified room ${roomId} with event: ${event}`);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/study-rooms/study-rooms.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'User' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":42}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  Logger,\n  NotFoundException,\n  BadRequestException,\n  ForbiddenException,\n} from '@nestjs/common';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { CreateStudyRoomDto } from './dto/create-study-room.dto';\nimport {\n  StudyRoomResponseDto,\n  StudyRoomParticipantDto,\n} from './dto/study-room-response.dto';\nimport { StudyRoomStatus, StudyRoom, User } from '../generated/prisma';\n\ntype StudyRoomWithRelations = StudyRoom & {\n  video: { id: number; title: string };\n  host: { id: string; name: string; avatarUrl: string };\n  participants: ({\n    user: { id: string; name: string; avatarUrl: string };\n  } & {\n    id: string;\n    studyRoomId: string;\n    userId: string;\n    isHost: boolean;\n    isActive: boolean;\n    joinedAt: Date;\n    leftAt: Date | null;\n  })[];\n};\n\n@Injectable()\nexport class StudyRoomsService {\n  private readonly logger = new Logger(StudyRoomsService.name);\n\n  constructor(private readonly prisma: PrismaService) {}\n\n  async createStudyRoom(\n    hostId: string,\n    createStudyRoomDto: CreateStudyRoomDto\n  ): Promise<StudyRoomResponseDto> {\n    this.logger.log(\n      `Creating study room for host ${hostId} with video ${createStudyRoomDto.videoId}`\n    );\n\n    try {\n      // Verificar que el video existe\n      const videoExists = await this.prisma.videoItem.findUnique({\n        where: { id: parseInt(createStudyRoomDto.videoId) },\n        select: { id: true, title: true },\n      });\n\n      if (!videoExists) {\n        throw new NotFoundException(\n          `Video con ID ${createStudyRoomDto.videoId} no encontrado`\n        );\n      }\n\n      // Crear la sala de estudio\n      const studyRoom = await this.prisma.studyRoom.create({\n        data: {\n          name: createStudyRoomDto.name,\n          description: createStudyRoomDto.description,\n          videoId: parseInt(createStudyRoomDto.videoId),\n          hostId,\n          maxParticipants: createStudyRoomDto.maxParticipants || 10,\n          status: StudyRoomStatus.ACTIVE,\n          currentTime: 0,\n          isPaused: false,\n        },\n        include: {\n          video: {\n            select: { id: true, title: true },\n          },\n          host: {\n            select: { id: true, name: true, avatarUrl: true },\n          },\n          participants: {\n            include: {\n              user: {\n                select: { id: true, name: true, avatarUrl: true },\n              },\n            },\n          },\n        },\n      });\n\n      // Agregar el host como participante\n      await this.prisma.studyRoomParticipant.create({\n        data: {\n          studyRoomId: studyRoom.id,\n          userId: hostId,\n          isHost: true,\n        },\n      });\n\n      // Crear mensaje de sistema de bienvenida\n      await this.prisma.studyRoomMessage.create({\n        data: {\n          studyRoomId: studyRoom.id,\n          userId: hostId,\n          message: `¬°Bienvenidos a la sala de estudio \"${studyRoom.name}\"! üéì`,\n          messageType: 'SYSTEM',\n        },\n      });\n\n      this.logger.log(`Study room ${studyRoom.id} created successfully`);\n      return this.mapToStudyRoomResponse(studyRoom as StudyRoomWithRelations);\n    } catch (error) {\n      this.logger.error(`Failed to create study room: ${error.message}`);\n      throw error;\n    }\n  }\n\n  async getAllStudyRooms(\n    page: number = 1,\n    limit: number = 10\n  ): Promise<{ rooms: StudyRoomResponseDto[]; total: number }> {\n    this.logger.log(`Fetching study rooms - page: ${page}, limit: ${limit}`);\n\n    const [rooms, total] = await Promise.all([\n      this.prisma.studyRoom.findMany({\n        where: { isActive: true },\n        include: {\n          video: { select: { id: true, title: true } },\n          host: { select: { id: true, name: true, avatarUrl: true } },\n          participants: {\n            where: { isActive: true },\n            include: {\n              user: { select: { id: true, name: true, avatarUrl: true } },\n            },\n          },\n        },\n        orderBy: { createdAt: 'desc' },\n        skip: (page - 1) * limit,\n        take: limit,\n      }),\n      this.prisma.studyRoom.count({\n        where: { isActive: true },\n      }),\n    ]);\n\n    const mappedRooms = rooms.map((room) =>\n      this.mapToStudyRoomResponse(room as StudyRoomWithRelations)\n    );\n\n    this.logger.log(\n      `Found ${total} study rooms, returning ${mappedRooms.length} for current page`\n    );\n    return { rooms: mappedRooms, total };\n  }\n\n  async getStudyRoomById(roomId: string): Promise<StudyRoomResponseDto> {\n    this.logger.log(`Fetching study room ${roomId}`);\n\n    const room = await this.prisma.studyRoom.findUnique({\n      where: { id: roomId },\n      include: {\n        video: { select: { id: true, title: true } },\n        host: { select: { id: true, name: true, avatarUrl: true } },\n        participants: {\n          where: { isActive: true },\n          include: {\n            user: { select: { id: true, name: true, avatarUrl: true } },\n          },\n        },\n      },\n    });\n\n    if (!room) {\n      throw new NotFoundException(`Sala de estudio ${roomId} no encontrada`);\n    }\n\n    return this.mapToStudyRoomResponse(room as StudyRoomWithRelations);\n  }\n\n  async joinStudyRoom(\n    roomId: string,\n    userId: string\n  ): Promise<StudyRoomResponseDto> {\n    this.logger.log(`User ${userId} attempting to join study room ${roomId}`);\n\n    // Verificar que la sala existe y est√° activa\n    const room = await this.prisma.studyRoom.findUnique({\n      where: { id: roomId, isActive: true },\n      include: {\n        participants: {\n          where: { isActive: true },\n        },\n      },\n    });\n\n    if (!room) {\n      throw new NotFoundException(\n        `Sala de estudio ${roomId} no encontrada o no activa`\n      );\n    }\n\n    // Verificar capacidad\n    if (room.participants.length >= room.maxParticipants) {\n      throw new BadRequestException('La sala ha alcanzado su capacidad m√°xima');\n    }\n\n    // Verificar si el usuario ya est√° en la sala\n    const existingParticipant =\n      await this.prisma.studyRoomParticipant.findUnique({\n        where: {\n          studyRoomId_userId: {\n            studyRoomId: roomId,\n            userId,\n          },\n        },\n      });\n\n    if (existingParticipant) {\n      if (existingParticipant.isActive) {\n        throw new BadRequestException('Ya est√°s en esta sala de estudio');\n      } else {\n        // Reactivar participaci√≥n\n        await this.prisma.studyRoomParticipant.update({\n          where: { id: existingParticipant.id },\n          data: { isActive: true, leftAt: null },\n        });\n      }\n    } else {\n      // Crear nueva participaci√≥n\n      await this.prisma.studyRoomParticipant.create({\n        data: {\n          studyRoomId: roomId,\n          userId,\n          isHost: false,\n        },\n      });\n    }\n\n    // Crear mensaje de sistema\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n      select: { name: true },\n    });\n\n    await this.prisma.studyRoomMessage.create({\n      data: {\n        studyRoomId: roomId,\n        userId,\n        message: `${user?.name || 'Usuario'} se ha unido a la sala üëã`,\n        messageType: 'SYSTEM',\n      },\n    });\n\n    this.logger.log(`User ${userId} joined study room ${roomId} successfully`);\n    return this.getStudyRoomById(roomId);\n  }\n\n  async leaveStudyRoom(roomId: string, userId: string): Promise<void> {\n    this.logger.log(`User ${userId} leaving study room ${roomId}`);\n\n    const participant = await this.prisma.studyRoomParticipant.findUnique({\n      where: {\n        studyRoomId_userId: {\n          studyRoomId: roomId,\n          userId,\n        },\n      },\n    });\n\n    if (!participant || !participant.isActive) {\n      throw new NotFoundException('No est√°s en esta sala de estudio');\n    }\n\n    // Marcar como inactivo y registrar tiempo de salida\n    await this.prisma.studyRoomParticipant.update({\n      where: { id: participant.id },\n      data: {\n        isActive: false,\n        leftAt: new Date(),\n      },\n    });\n\n    // Crear mensaje de sistema\n    const user = await this.prisma.user.findUnique({\n      where: { id: userId },\n      select: { name: true },\n    });\n\n    await this.prisma.studyRoomMessage.create({\n      data: {\n        studyRoomId: roomId,\n        userId,\n        message: `${user?.name || 'Usuario'} ha salido de la sala üëã`,\n        messageType: 'SYSTEM',\n      },\n    });\n\n    // Si era el host, transferir ownership al siguiente participante\n    if (participant.isHost) {\n      const nextHost = await this.prisma.studyRoomParticipant.findFirst({\n        where: {\n          studyRoomId: roomId,\n          isActive: true,\n          userId: { not: userId },\n        },\n        orderBy: { joinedAt: 'asc' },\n      });\n\n      if (nextHost) {\n        await this.prisma.studyRoomParticipant.update({\n          where: { id: nextHost.id },\n          data: { isHost: true },\n        });\n\n        await this.prisma.studyRoom.update({\n          where: { id: roomId },\n          data: { hostId: nextHost.userId },\n        });\n\n        // Mensaje de nuevo host\n        const newHostUser = await this.prisma.user.findUnique({\n          where: { id: nextHost.userId },\n          select: { name: true },\n        });\n\n        await this.prisma.studyRoomMessage.create({\n          data: {\n            studyRoomId: roomId,\n            userId: nextHost.userId,\n            message: `${newHostUser?.name || 'Usuario'} es ahora el host de la sala üëë`,\n            messageType: 'SYSTEM',\n          },\n        });\n      } else {\n        // No hay m√°s participantes, desactivar la sala\n        await this.prisma.studyRoom.update({\n          where: { id: roomId },\n          data: {\n            isActive: false,\n            status: StudyRoomStatus.ENDED,\n          },\n        });\n      }\n    }\n\n    this.logger.log(`User ${userId} left study room ${roomId} successfully`);\n  }\n\n  async updateVideoSync(\n    roomId: string,\n    userId: string,\n    currentTime: number,\n    isPaused: boolean\n  ): Promise<void> {\n    this.logger.log(\n      `Updating video sync for room ${roomId}: time=${currentTime}, paused=${isPaused}`\n    );\n\n    // Verificar que el usuario es host o participante activo\n    const participant = await this.prisma.studyRoomParticipant.findUnique({\n      where: {\n        studyRoomId_userId: {\n          studyRoomId: roomId,\n          userId,\n        },\n      },\n    });\n\n    if (!participant || !participant.isActive) {\n      throw new ForbiddenException(\n        'No tienes permisos para controlar la reproducci√≥n'\n      );\n    }\n\n    // Solo el host puede controlar la reproducci√≥n por defecto\n    if (!participant.isHost) {\n      throw new ForbiddenException(\n        'Solo el host puede controlar la reproducci√≥n'\n      );\n    }\n\n    // Actualizar estado de reproducci√≥n\n    await this.prisma.studyRoom.update({\n      where: { id: roomId },\n      data: {\n        currentTime,\n        isPaused,\n        updatedAt: new Date(),\n      },\n    });\n\n    // Crear mensaje de evento de video\n    const eventType = isPaused ? 'paus√≥' : 'reprodujo';\n    await this.prisma.studyRoomMessage.create({\n      data: {\n        studyRoomId: roomId,\n        userId,\n        message: `Video ${eventType} en ${Math.floor(currentTime)}s`,\n        messageType: 'VIDEO_EVENT',\n        metadata: JSON.stringify({ currentTime, isPaused }),\n      },\n    });\n\n    this.logger.log(`Video sync updated for room ${roomId}`);\n  }\n\n  async deleteStudyRoom(roomId: string, userId: string): Promise<void> {\n    this.logger.log(`User ${userId} attempting to delete study room ${roomId}`);\n\n    const room = await this.prisma.studyRoom.findUnique({\n      where: { id: roomId },\n      select: { hostId: true },\n    });\n\n    if (!room) {\n      throw new NotFoundException(`Sala de estudio ${roomId} no encontrada`);\n    }\n\n    if (room.hostId !== userId) {\n      throw new ForbiddenException('Solo el host puede eliminar la sala');\n    }\n\n    // Soft delete: marcar como inactiva\n    await this.prisma.studyRoom.update({\n      where: { id: roomId },\n      data: {\n        isActive: false,\n        status: StudyRoomStatus.ENDED,\n      },\n    });\n\n    // Desactivar todos los participantes\n    await this.prisma.studyRoomParticipant.updateMany({\n      where: { studyRoomId: roomId },\n      data: {\n        isActive: false,\n        leftAt: new Date(),\n      },\n    });\n\n    this.logger.log(`Study room ${roomId} deleted successfully`);\n  }\n\n  private mapToStudyRoomResponse(\n    room: StudyRoomWithRelations\n  ): StudyRoomResponseDto {\n    const participants: StudyRoomParticipantDto[] = room.participants.map(\n      (p) => ({\n        id: p.user.id,\n        name: p.user.name || 'Usuario',\n        avatarUrl: p.user.avatarUrl,\n        isHost: p.isHost,\n        joinedAt: p.joinedAt,\n      })\n    );\n\n    return {\n      id: room.id,\n      name: room.name,\n      description: room.description,\n      videoId: room.videoId.toString(),\n      videoTitle: room.video?.title,\n      hostId: room.hostId,\n      maxParticipants: room.maxParticipants,\n      currentParticipants: participants.length,\n      status: room.status,\n      currentTime: room.currentTime,\n      isPaused: room.isPaused,\n      participants,\n      createdAt: room.createdAt,\n      updatedAt: room.updatedAt,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/subtitle/dto/find-all-subtitles.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsBoolean' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":45,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":54}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { IsInt, IsOptional, IsString, IsIn, IsBoolean } from 'class-validator';\nimport { Type } from 'class-transformer';\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\n\nexport class FindAllSubtitlesDto {\n  @ApiProperty({ description: 'Filter subtitles by video item ID' })\n  @IsInt()\n  @Type(() => Number)\n  videoItemId: number; // Required to filter subtitles by video\n\n  @ApiPropertyOptional({\n    description: 'Filter subtitles by language code',\n    example: 'es-ES',\n  })\n  @IsOptional()\n  @IsString()\n  languageCode?: string;\n\n  @ApiPropertyOptional({\n    description: 'Filter subtitles by format',\n    enum: ['srt', 'vtt', 'ass'],\n    example: 'srt',\n  })\n  @IsOptional()\n  @IsString()\n  @IsIn(['srt', 'vtt', 'ass'])\n  format?: string;\n\n  @ApiPropertyOptional({\n    description: 'Filter subtitles by active status',\n    default: true,\n  })\n  @IsOptional()\n  @Type(() => Boolean)\n  isActive?: boolean;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/subtitle/subtitle.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ValidationPipe' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ParseIntPipe' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":15}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Controller,\n  Post,\n  Body,\n  Get,\n  Param,\n  Patch,\n  Delete,\n  Query,\n  HttpCode,\n  HttpStatus,\n  ValidationPipe,\n  ParseIntPipe,\n  BadRequestException,\n  Inject,\n  UseGuards,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiBearerAuth,\n  ApiOperation,\n  ApiResponse,\n} from '@nestjs/swagger';\nimport { AuthGuard } from '@nestjs/passport';\nimport { RolesGuard } from '@/rbac/guards/roles.guard';\nimport { Roles } from '@/rbac/decorators/roles.decorator';\nimport { SubtitleService } from './subtitle.service';\nimport { CreateSubtitleDto } from './dto/create-subtitle.dto';\nimport { UpdateSubtitleDto } from './dto/update-subtitle.dto';\nimport { FindAllSubtitlesDto } from './dto/find-all-subtitles.dto';\nimport type { Subtitle } from '../generated/prisma';\n\n@ApiTags('subtitles')\n@ApiBearerAuth()\n@Controller('subtitles')\nexport class SubtitleController {\n  constructor(\n    @Inject(SubtitleService) private readonly subtitleService: SubtitleService\n  ) {\n    //     console.log('>>> SubtitleController CONSTRUCTOR called');\n    // //     console.log('>>> SubtitleController CONSTRUCTOR: this.subtitleService IS', this.subtitleService ? 'DEFINED' : 'UNDEFINED');\n    if (!this.subtitleService) {\n      //       console.error('>>> SubtitleController CONSTRUCTOR: SubtitleService is not available!');\n    }\n  }\n\n  @Get('ping')\n  async ping() {\n    //     console.log('>>> SubtitleController.ping: Starting - no dependencies');\n    return {\n      message: 'SubtitleController is working',\n      timestamp: new Date().toISOString(),\n      controller: 'SubtitleController',\n    };\n  }\n\n  @Get('test')\n  async test() {\n    //     console.log('>>> SubtitleController.test: Starting');\n    //     console.log('>>> SubtitleController.test: this.subtitleService IS', this.subtitleService ? 'DEFINED' : 'UNDEFINED');\n    return {\n      message: 'Subtitle controller is working',\n      serviceAvailable: !!this.subtitleService,\n    };\n  }\n\n  @Get('simple')\n  async simple() {\n    //     console.log('>>> SubtitleController.simple: Starting');\n    //     console.log('>>> SubtitleController.simple: this.subtitleService IS', this.subtitleService ? 'DEFINED' : 'UNDEFINED');\n\n    if (!this.subtitleService) {\n      //       console.error('>>> SubtitleController.simple: SubtitleService not available');\n      return { error: 'SubtitleService not available' };\n    }\n\n    try {\n      //       console.log('>>> SubtitleController.simple: About to call service.findAll');\n      const result = await this.subtitleService.findAll({ videoItemId: 1 });\n      //       console.log('>>> SubtitleController.simple: SUCCESS, result:', result);\n      return { success: true, data: result };\n    } catch (error) {\n      //       console.error('>>> SubtitleController.simple: ERROR:', error);\n      return { error: error.message };\n    }\n  }\n\n  @Post()\n  @UseGuards(AuthGuard('jwt'), RolesGuard)\n  @Roles('admin')\n  @HttpCode(HttpStatus.CREATED)\n  @ApiOperation({ summary: 'Create a new subtitle' })\n  @ApiResponse({ status: 201, description: 'Subtitle created' })\n  @ApiResponse({ status: 403, description: 'Forbidden resource' })\n  async create(\n    @Body() createSubtitleDto: CreateSubtitleDto\n  ): Promise<Subtitle> {\n    //     console.log('>>> SubtitleController.create: Starting with data:', createSubtitleDto);\n    //     console.log('>>> SubtitleController.create: this.subtitleService IS', this.subtitleService ? 'DEFINED' : 'UNDEFINED');\n\n    const result = await this.subtitleService.create(createSubtitleDto);\n    //       console.log('>>> SubtitleController.create: SUCCESS');\n    return result;\n  }\n\n  @Get('search')\n  async findAll(@Query() findAllDto: FindAllSubtitlesDto): Promise<Subtitle[]> {\n    //     console.log('>>> SubtitleController.findAll: Starting with params:', findAllDto);\n    //     console.log('>>> SubtitleController.findAll: this.subtitleService IS', this.subtitleService ? 'DEFINED' : 'UNDEFINED');\n\n    if (!this.subtitleService) {\n      //         console.error('>>> SubtitleController.findAll: SubtitleService is not available!');\n      throw new Error('SubtitleService is not available');\n    }\n\n    //       console.log('>>> SubtitleController.findAll: About to call service.findAll');\n    const result = await this.subtitleService.findAll(findAllDto);\n    //       console.log('>>> SubtitleController.findAll: SUCCESS, found', result.length, 'subtitles');\n    return result;\n  }\n\n  @Get('all-debug')\n  async getAllDebug() {\n    //     console.log('>>> SubtitleController.getAllDebug: Starting');\n    //     console.log('>>> SubtitleController.getAllDebug: this.subtitleService IS', this.subtitleService ? 'DEFINED' : 'UNDEFINED');\n\n    try {\n      if (!this.subtitleService) {\n        return { error: 'SubtitleService not available' };\n      }\n\n      // Get all subtitles without filter to see what videoItemIds exist\n      //       console.log('>>> SubtitleController.getAllDebug: About to call prisma.subtitle.findMany without filter');\n      const result = await this.subtitleService['prisma'].subtitle.findMany({\n        orderBy: { createdAt: 'asc' },\n      });\n      //       console.log('>>> SubtitleController.getAllDebug: SUCCESS, found', result.length, 'subtitles');\n\n      return {\n        message: 'All subtitles retrieved successfully',\n        data: result,\n        count: result.length,\n        videoItemIds: [...new Set(result.map((s) => s.videoItemId))],\n        timestamp: new Date().toISOString(),\n      };\n    } catch (error) {\n      //       console.error('>>> SubtitleController.getAllDebug: ERROR:', error);\n      return {\n        error: 'Failed to retrieve all subtitles',\n        details: error.message,\n        timestamp: new Date().toISOString(),\n      };\n    }\n  }\n\n  @Get('test-service')\n  async testService() {\n    //     console.log('>>> SubtitleController.testService: Starting');\n    //     console.log('>>> SubtitleController.testService: this.subtitleService IS', this.subtitleService ? 'DEFINED' : 'UNDEFINED');\n\n    try {\n      if (!this.subtitleService) {\n        return { error: 'SubtitleService not available' };\n      }\n\n      // Test service method with hardcoded parameters\n      //       console.log('>>> SubtitleController.testService: About to call service.findAll with hardcoded params');\n      const result = await this.subtitleService.findAll({ videoItemId: 1 });\n      //       console.log('>>> SubtitleController.testService: SUCCESS, result:', result);\n\n      return {\n        message: 'Service test successful',\n        data: result,\n        count: result.length,\n        timestamp: new Date().toISOString(),\n      };\n    } catch (error) {\n      //       console.error('>>> SubtitleController.testService: ERROR:', error);\n      return {\n        error: 'Service test failed',\n        details: error.message,\n        stack: error.stack,\n        timestamp: new Date().toISOString(),\n      };\n    }\n  }\n\n  @Get('db-test')\n  async dbTest() {\n    //     console.log('>>> SubtitleController.dbTest: Starting');\n    //     console.log('>>> SubtitleController.dbTest: this.subtitleService IS', this.subtitleService ? 'DEFINED' : 'UNDEFINED');\n\n    try {\n      if (!this.subtitleService) {\n        return { error: 'SubtitleService not available' };\n      }\n\n      // Test direct database access\n      //       console.log('>>> SubtitleController.dbTest: About to test direct database access');\n      const count = await this.subtitleService['prisma'].subtitle.count();\n      //       console.log('>>> SubtitleController.dbTest: SUCCESS, subtitle count:', count);\n\n      return {\n        message: 'Database test successful',\n        subtitleCount: count,\n        timestamp: new Date().toISOString(),\n      };\n    } catch (error) {\n      //       console.error('>>> SubtitleController.dbTest: ERROR:', error);\n      return {\n        error: 'Database test failed',\n        details: error.message,\n        timestamp: new Date().toISOString(),\n      };\n    }\n  }\n\n  @Get(':id')\n  async findOne(@Param('id') id: string): Promise<Subtitle> {\n    //     console.log('>>> SubtitleController.findOne: Starting with id:', id);\n    //     console.log('>>> SubtitleController.findOne: this.subtitleService IS', this.subtitleService ? 'DEFINED' : 'UNDEFINED');\n\n    const numericId = parseInt(id, 10);\n    if (isNaN(numericId)) {\n      throw new BadRequestException('Invalid ID format');\n    }\n\n    const result = await this.subtitleService.findOne(numericId);\n    //       console.log('>>> SubtitleController.findOne: SUCCESS');\n    return result;\n  }\n\n  @Patch(':id')\n  @UseGuards(AuthGuard('jwt'), RolesGuard)\n  @Roles('admin')\n  @ApiOperation({ summary: 'Update a subtitle' })\n  @ApiResponse({ status: 200, description: 'Subtitle updated' })\n  @ApiResponse({ status: 403, description: 'Forbidden resource' })\n  async update(\n    @Param('id') id: string,\n    @Body() updateSubtitleDto: UpdateSubtitleDto\n  ): Promise<Subtitle> {\n    //     console.log('>>> SubtitleController.update: Starting with id:', id, 'data:', updateSubtitleDto);\n    //     console.log('>>> SubtitleController.update: this.subtitleService IS', this.subtitleService ? 'DEFINED' : 'UNDEFINED');\n\n    const numericId = parseInt(id, 10);\n    if (isNaN(numericId)) {\n      throw new BadRequestException('Invalid ID format');\n    }\n\n    const result = await this.subtitleService.update(\n      numericId,\n      updateSubtitleDto\n    );\n    //       console.log('>>> SubtitleController.update: SUCCESS');\n    return result;\n  }\n\n  @Delete(':id')\n  @UseGuards(AuthGuard('jwt'), RolesGuard)\n  @Roles('admin')\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiOperation({ summary: 'Delete a subtitle' })\n  @ApiResponse({ status: 204, description: 'Subtitle deleted' })\n  @ApiResponse({ status: 403, description: 'Forbidden resource' })\n  async remove(@Param('id') id: string): Promise<void> {\n    //     console.log('>>> SubtitleController.remove: Starting with id:', id);\n    //     console.log('>>> SubtitleController.remove: this.subtitleService IS', this.subtitleService ? 'DEFINED' : 'UNDEFINED');\n\n    const numericId = parseInt(id, 10);\n    if (isNaN(numericId)) {\n      throw new BadRequestException('Invalid ID format');\n    }\n\n    await this.subtitleService.remove(numericId);\n    //       console.log('>>> SubtitleController.remove: SUCCESS');\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/subtitle/subtitle.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'isUpdate' is assigned a value but never used. Allowed unused args must match /^_/u.","line":22,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":13},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":44,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":56,"endColumn":6},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":63,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":99,"endColumn":6},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":106,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":120,"endColumn":6},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":130,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":162,"endColumn":6},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":169,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":184,"endColumn":6}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Injectable,\n  NotFoundException,\n  BadRequestException,\n  Inject,\n} from '@nestjs/common';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { CreateSubtitleDto } from './dto/create-subtitle.dto';\nimport { UpdateSubtitleDto } from './dto/update-subtitle.dto';\nimport { FindAllSubtitlesDto } from './dto/find-all-subtitles.dto';\nimport type { Subtitle } from '../generated/prisma';\n\n@Injectable()\nexport class SubtitleService {\n  constructor(@Inject(PrismaService) private readonly prisma: PrismaService) {\n    // //     console.log('>>> SubtitleService CONSTRUCTOR: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n  }\n\n  // Helper method for validating content or contentUrl\n  private validateContentOrUrl(\n    dto: { content?: string; contentUrl?: string },\n    isUpdate = false\n  ): void {\n    const hasContent = dto.content && dto.content.trim().length > 0;\n    const hasContentUrl = dto.contentUrl && dto.contentUrl.trim().length > 0;\n\n    if (!hasContent && !hasContentUrl) {\n      throw new BadRequestException(\n        'Either content or contentUrl must be provided.'\n      );\n    }\n\n    if (hasContent && hasContentUrl) {\n      throw new BadRequestException(\n        'Only one of content or contentUrl should be provided, not both.'\n      );\n    }\n  }\n\n  async create(createSubtitleDto: CreateSubtitleDto): Promise<Subtitle> {\n    //     console.log('>>> SubtitleService.create: Starting with data:', createSubtitleDto);\n    //     console.log('>>> SubtitleService.create: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n\n    try {\n      this.validateContentOrUrl(createSubtitleDto);\n\n      //       console.log('>>> SubtitleService.create: About to call prisma.subtitle.create');\n      const result = await this.prisma.subtitle.create({\n        data: createSubtitleDto,\n      });\n      //       console.log('>>> SubtitleService.create: SUCCESS, result:', result);\n      return result;\n    } catch (error) {\n      //       console.error('>>> SubtitleService.create: ERROR:', error);\n      throw error;\n    }\n  }\n\n  async findAll(findAllDto: FindAllSubtitlesDto): Promise<Subtitle[]> {\n    //     console.log('>>> SubtitleService.findAll: Starting with params:', findAllDto);\n    //     console.log('>>> SubtitleService.findAll: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n\n    try {\n      if (!findAllDto.videoItemId) {\n        throw new BadRequestException(\n          'videoItemId is required to find subtitles.'\n        );\n      }\n\n      // Convert videoItemId to number if it's a string\n      const videoItemId =\n        typeof findAllDto.videoItemId === 'string'\n          ? parseInt(findAllDto.videoItemId, 10)\n          : findAllDto.videoItemId;\n\n      if (isNaN(videoItemId)) {\n        throw new BadRequestException('videoItemId must be a valid number.');\n      }\n\n      //       console.log('>>> SubtitleService.findAll: About to call prisma.subtitle.findMany with videoItemId:', videoItemId);\n      const result = await this.prisma.subtitle.findMany({\n        where: {\n          videoItemId,\n          ...(findAllDto.languageCode && {\n            languageCode: findAllDto.languageCode,\n          }),\n          ...(findAllDto.format && { format: findAllDto.format }),\n          ...(findAllDto.isActive !== undefined && {\n            isActive: findAllDto.isActive,\n          }),\n        },\n        orderBy: { createdAt: 'asc' },\n      });\n      //       console.log('>>> SubtitleService.findAll: SUCCESS, found', result.length, 'subtitles');\n      return result;\n    } catch (error) {\n      //       console.error('>>> SubtitleService.findAll: ERROR:', error);\n      throw error;\n    }\n  }\n\n  async findOne(id: number): Promise<Subtitle> {\n    //     console.log('>>> SubtitleService.findOne: Starting with id:', id);\n    //     console.log('>>> SubtitleService.findOne: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n\n    try {\n      //       console.log('>>> SubtitleService.findOne: About to call prisma.subtitle.findUnique');\n      const subtitle = await this.prisma.subtitle.findUnique({ where: { id } });\n\n      if (!subtitle) {\n        //         console.log('>>> SubtitleService.findOne: Subtitle not found');\n        throw new NotFoundException(`Subtitle with ID ${id} not found.`);\n      }\n\n      //       console.log('>>> SubtitleService.findOne: SUCCESS, found subtitle:', subtitle);\n      return subtitle;\n    } catch (error) {\n      //       console.error('>>> SubtitleService.findOne: ERROR:', error);\n      throw error;\n    }\n  }\n\n  async update(\n    id: number,\n    updateSubtitleDto: UpdateSubtitleDto\n  ): Promise<Subtitle> {\n    //     console.log('>>> SubtitleService.update: Starting with id:', id, 'data:', updateSubtitleDto);\n    //     console.log('>>> SubtitleService.update: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n\n    try {\n      //       console.log('>>> SubtitleService.update: About to check if subtitle exists');\n      const existingSubtitle = await this.prisma.subtitle.findUnique({\n        where: { id },\n      });\n      if (!existingSubtitle) {\n        throw new NotFoundException(`Subtitle with ID ${id} not found.`);\n      }\n\n      // Validate content/contentUrl combination\n      const combinedDto = {\n        content:\n          updateSubtitleDto.content !== undefined\n            ? updateSubtitleDto.content\n            : existingSubtitle.content,\n        contentUrl:\n          updateSubtitleDto.contentUrl !== undefined\n            ? updateSubtitleDto.contentUrl\n            : existingSubtitle.contentUrl,\n      };\n      this.validateContentOrUrl(combinedDto, true);\n\n      //       console.log('>>> SubtitleService.update: About to call prisma.subtitle.update');\n      const result = await this.prisma.subtitle.update({\n        where: { id },\n        data: updateSubtitleDto,\n      });\n      //       console.log('>>> SubtitleService.update: SUCCESS, result:', result);\n      return result;\n    } catch (error) {\n      //       console.error('>>> SubtitleService.update: ERROR:', error);\n      throw error;\n    }\n  }\n\n  async remove(id: number): Promise<void> {\n    //     console.log('>>> SubtitleService.remove: Starting with id:', id);\n    //     console.log('>>> SubtitleService.remove: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n\n    try {\n      //       console.log('>>> SubtitleService.remove: About to check if subtitle exists');\n      const existingSubtitle = await this.prisma.subtitle.findUnique({\n        where: { id },\n      });\n      if (!existingSubtitle) {\n        throw new NotFoundException(`Subtitle with ID ${id} not found.`);\n      }\n\n      //       console.log('>>> SubtitleService.remove: About to call prisma.subtitle.delete');\n      await this.prisma.subtitle.delete({ where: { id } });\n      //       console.log('>>> SubtitleService.remove: SUCCESS');\n    } catch (error) {\n      //       console.error('>>> SubtitleService.remove: ERROR:', error);\n      throw error;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/users/users-test.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Injectable' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":53}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Controller, Get, UseGuards, Req, Injectable } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\nimport { RolesGuard } from '@/rbac/guards/roles.guard';\nimport { Roles } from '@/rbac/decorators/roles.decorator';\nimport { ApiTags, ApiBearerAuth } from '@nestjs/swagger';\nimport { Reflector } from '@nestjs/core';\n\n@ApiTags('users-test')\n@Controller('users-test')\nexport class UsersTestController {\n  constructor(private reflector: Reflector) {}\n\n  @Get('no-auth')\n  async testNoAuth() {\n    return {\n      message: 'No auth test working!',\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  @Get('auth-only')\n  @UseGuards(AuthGuard('jwt'))\n  @ApiBearerAuth()\n  async testAuthOnly(@Req() req) {\n    return {\n      message: 'Auth only test working!',\n      user: req.user,\n      userRoles: req.user?.roles,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  @Get('auth-and-roles')\n  @UseGuards(AuthGuard('jwt'), RolesGuard)\n  @Roles('admin')\n  @ApiBearerAuth()\n  async testAuthAndRoles(@Req() req) {\n    return {\n      message: 'Auth and roles test working!',\n      user: req.user,\n      userRoles: req.user?.roles,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  @Get('debug-roles')\n  @UseGuards(AuthGuard('jwt'))\n  @Roles('admin')\n  @ApiBearerAuth()\n  async testDebugRoles(@Req() req) {\n    //     console.log('>>> DEBUG ROLES ENDPOINT: req.user:', req.user);\n    //     console.log('>>> DEBUG ROLES ENDPOINT: req.user.roles:', req.user?.roles);\n    //     console.log('>>> DEBUG ROLES ENDPOINT: typeof req.user.roles:', typeof req.user?.roles);\n    return {\n      message: 'Debug roles test - only JWT auth, with @Roles decorator!',\n      user: req.user,\n      userRoles: req.user?.roles,\n      hasAdminRole: req.user?.roles?.includes('admin'),\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  @Get('method-level-guards')\n  @UseGuards(AuthGuard('jwt'), RolesGuard)\n  @Roles('admin')\n  @ApiBearerAuth()\n  async testMethodLevelGuards(@Req() req) {\n    //     console.log('>>> METHOD LEVEL GUARDS ENDPOINT: req.user:', req.user);\n    return {\n      message: 'Method level guards test working!',\n      user: req.user,\n      userRoles: req.user?.roles,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  @Get('manual-guard-test')\n  @UseGuards(AuthGuard('jwt'))\n  @Roles('admin')\n  @ApiBearerAuth()\n  async testManualGuard(@Req() req) {\n    //     console.log('>>> MANUAL GUARD TEST: Starting...');\n\n    // Manually test the guard logic\n    const guard = new RolesGuard(this.reflector);\n    //     console.log('>>> MANUAL GUARD TEST: Guard created:', !!guard);\n\n    // Test if we can access the roles metadata\n    const requiredRoles = this.reflector.get(\n      Roles,\n      UsersTestController.prototype.testManualGuard\n    );\n    //     console.log('>>> MANUAL GUARD TEST: Required roles from reflector:', requiredRoles);\n\n    return {\n      message: 'Manual guard test!',\n      user: req.user,\n      userRoles: req.user?.roles,\n      guardExists: !!guard,\n      requiredRoles,\n      timestamp: new Date().toISOString(),\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/users/users.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'user' is defined but never used. Allowed unused args must match /^_/u.","line":118,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":118,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'user' is defined but never used. Allowed unused args must match /^_/u.","line":151,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":151,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'user' is defined but never used. Allowed unused args must match /^_/u.","line":191,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":191,"endColumn":32}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, NotFoundException, Inject } from '@nestjs/common';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { CreateUserDto } from './dto/create-user.dto';\nimport { UpdateUserDto } from './dto/update-user.dto';\n// import { AuditLogsService } from '../admin/audit-logs/audit-logs.service'; // Temporarily commented\n// import { AuthenticatedUser } from '../types/auth.types'; // Temporarily commented\n// import { UserAuditSnapshot } from '../types/user.types'; // Temporarily commented\nimport { User } from '../generated/prisma';\nimport * as bcrypt from 'bcryptjs';\n\n// Tipo expl√≠cito para snapshots de usuario en logs de auditor√≠a\n// export interface UserAuditSnapshot {\n//   id: string;\n//   email: string;\n//   name?: string | null;\n//   isActive: boolean;\n//   createdAt: Date;\n//   updatedAt: Date;\n// }\n\ntype AuthenticatedUser = { id: string /* other properties may be included */ };\n\n@Injectable()\nexport class UsersService {\n  constructor(\n    @Inject(PrismaService) private readonly prisma: PrismaService\n    // private readonly auditLogsService: AuditLogsService, // Temporarily commented\n  ) {\n    // // //     console.log('>>> UsersService CONSTRUCTOR: Initializing...');\n    // //     console.log('>>> UsersService CONSTRUCTOR: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n    // //     console.log('>>> UsersService CONSTRUCTOR: this instance is', this);\n    // //     console.log('>>> UsersService CONSTRUCTOR: constructor name is', this.constructor.name);\n  }\n\n  async findAll() {\n    //     console.log('>>> UsersService.findAll: Starting...');\n    //     console.log('>>> UsersService.findAll: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n\n    const result = await this.prisma.user.findMany();\n    //       console.log('>>> UsersService.findAll: SUCCESS, found', result.length, 'users');\n    return result;\n  }\n\n  async findAllPaginated(params: {\n    page: number;\n    pageSize: number;\n    sortBy?: string;\n    sortDirection?: 'asc' | 'desc';\n    filters?: {\n      email?: string;\n      role_id?: string;\n      is_active?: boolean;\n    };\n  }) {\n    const { page, pageSize, sortBy, sortDirection, filters } = params;\n\n    // Construir el objeto where para filtros\n    const where: {\n      email?: { contains: string; mode: 'insensitive' };\n      isActive?: boolean;\n    } = {};\n\n    if (filters?.email) {\n      where.email = {\n        contains: filters.email,\n        mode: 'insensitive',\n      };\n    }\n\n    if (filters?.is_active !== undefined) {\n      where.isActive = filters.is_active;\n    }\n\n    // TODO: Implementar filtro por role_id cuando tengamos la relaci√≥n con roles\n\n    // Construir el objeto orderBy para ordenamiento\n    const orderBy: { [key: string]: 'asc' | 'desc' } = {};\n    if (sortBy) {\n      orderBy[sortBy] = sortDirection || 'asc';\n    } else {\n      orderBy.createdAt = 'desc'; // Ordenamiento por defecto\n    }\n\n    // Ejecutar consultas en paralelo\n    const [users, total] = await Promise.all([\n      this.prisma.user.findMany({\n        where,\n        orderBy,\n        skip: page * pageSize,\n        take: pageSize,\n        include: {\n          // TODO: Incluir relaci√≥n con roles cuando est√© disponible\n          // role: true,\n        },\n      }),\n      this.prisma.user.count({ where }),\n    ]);\n\n    return {\n      data: users,\n      count: users.length,\n      total,\n      page,\n      pageSize,\n    };\n  }\n\n  async findOne(id: string) {\n    //     console.log('>>> UsersService.findOne: Starting with id:', id);\n    //     console.log('>>> UsersService.findOne: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n\n    const user = await this.prisma.user.findUnique({ where: { id } });\n    //       console.log('>>> UsersService.findOne: Query result:', user ? 'FOUND' : 'NOT FOUND');\n    if (!user) throw new NotFoundException('Usuario no encontrado');\n    return user;\n  }\n\n  async create(data: CreateUserDto, user: AuthenticatedUser): Promise<User> {\n    const hashedPassword = await bcrypt.hash(data.password, 10);\n\n    const createData = {\n      ...data,\n      password: hashedPassword,\n    };\n\n    const newUser = await this.prisma.user.create({ data: createData });\n\n    // const newValue: UserAuditSnapshot = {\n    //   id: newUser.id,\n    //   email: newUser.email,\n    //   name: newUser.name ?? null,\n    //   isActive: newUser.isActive,\n    //   createdAt: newUser.createdAt,\n    //   updatedAt: newUser.updatedAt,\n    // };\n\n    // await this.auditLogsService.createLog({\n    //     userId: user.id,\n    //     actionType: 'user:created',\n    //     entityType: 'User',\n    //     entityId: newUser.id,\n    //     newValue: newValue,\n    // });\n\n    return newUser;\n  }\n\n  async update(\n    id: string,\n    data: UpdateUserDto,\n    user: AuthenticatedUser\n  ): Promise<User> {\n    const existingUser = await this.prisma.user.findUnique({ where: { id } });\n    if (!existingUser) throw new NotFoundException('Usuario no encontrado');\n\n    // const oldValue: UserAuditSnapshot = {\n    //   id: existingUser.id,\n    //   email: existingUser.email,\n    //   name: existingUser.name ?? null,\n    //   isActive: existingUser.isActive,\n    //   createdAt: existingUser.createdAt,\n    //   updatedAt: existingUser.updatedAt,\n    // };\n\n    const updatedUser = await this.prisma.user.update({\n      where: { id },\n      data,\n    });\n\n    // const newValue: UserAuditSnapshot = {\n    //   id: updatedUser.id,\n    //   email: updatedUser.email,\n    //   name: updatedUser.name ?? null,\n    //   isActive: updatedUser.isActive,\n    //   createdAt: updatedUser.createdAt,\n    //   updatedAt: updatedUser.updatedAt,\n    // };\n\n    // await this.auditLogsService.createLog({\n    //     userId: user.id,\n    //     actionType: 'user:updated',\n    //     entityType: 'User',\n    //     entityId: updatedUser.id,\n    //     oldValue: oldValue,\n    //     newValue: newValue,\n    // });\n\n    return updatedUser;\n  }\n\n  async remove(id: string, user: AuthenticatedUser): Promise<User> {\n    const existingUser = await this.prisma.user.findUnique({ where: { id } });\n    if (!existingUser) throw new NotFoundException('Usuario no encontrado');\n\n    // const oldValue: UserAuditSnapshot = {\n    //  id: existingUser.id,\n    //  email: existingUser.email,\n    //  name: existingUser.name ?? null,\n    //  isActive: existingUser.isActive,\n    //  createdAt: existingUser.createdAt,\n    //  updatedAt: existingUser.updatedAt,\n    // };\n\n    const softDeletedUser = await this.prisma.user.update({\n      where: { id },\n      data: { isActive: false },\n    });\n\n    // const newValue: UserAuditSnapshot = {\n    //   id: softDeletedUser.id,\n    //   email: softDeletedUser.email,\n    //   name: softDeletedUser.name ?? null,\n    //   isActive: softDeletedUser.isActive,\n    //   createdAt: softDeletedUser.createdAt,\n    //   updatedAt: softDeletedUser.updatedAt,\n    // };\n\n    // await this.auditLogsService.createLog({\n    //     userId: user.id,\n    //     actionType: 'user:soft_deleted',\n    //     entityType: 'User',\n    //     entityId: softDeletedUser.id,\n    //     oldValue: oldValue,\n    //     newValue: newValue,\n    // });\n\n    return softDeletedUser;\n  }\n\n  async findById(id: string) {\n    return this.prisma.user.findUnique({ where: { id } });\n  }\n\n  async getReciprocidadMetrics(userId: string) {\n    //     console.log('>>> UsersService.getReciprocidadMetrics: Starting for user:', userId);\n\n    // Verificar que el usuario existe\n    const user = await this.prisma.user.findUnique({ where: { id: userId } });\n    if (!user) {\n      throw new NotFoundException('Usuario no encontrado');\n    }\n\n    // üåü GENERAR M√âTRICAS RECIPROCIDAD DIN√ÅMICAS BASADAS EN DATOS REALES\n    // Por ahora, generamos m√©tricas realistas basadas en el usuario\n    // En el futuro, estas se calcular√°n desde transacciones, actividades, etc.\n\n    const baseMetrics = {\n      ondas: 1000 + user.id.length * 47, // Base de 1000 + variaci√≥n por usuario\n      meritos: 50 + user.id.length * 7, // Base de 50 + variaci√≥n\n      balanceReciprocidad: Math.min(1, 0.6 + user.id.length * 0.02), // Entre 0.6 y 1.0\n      reciprocidadLevel: this.calculateReciprocidadLevel(user),\n      nextLevel: this.getNextReciprocidadLevel(user),\n      reciprocidadProgress: this.calculateReciprocidadProgress(user),\n      bienComunContributions: 10 + user.id.length * 3,\n      reciprocityScore: Math.min(10, 7 + user.id.length * 0.15),\n      elementos: this.calculateElementalBalance(user),\n      totalTransactions: 25 + user.id.length * 5,\n      positiveImpact: 500 + user.id.length * 73,\n      communityRank: Math.max(1, 200 - user.id.length * 8),\n      weeklyGrowth:\n        Math.round((Math.sin(user.id.length) * 10 + 15) * 100) / 100,\n      lastUpdated: new Date().toISOString(),\n      joinedDate: user.createdAt.toISOString(),\n    };\n\n    //       console.log('>>> UsersService.getReciprocidadMetrics: Generated metrics for user:', user.email);\n    return baseMetrics;\n  }\n\n  private calculateReciprocidadLevel(user: User): string {\n    // Calcular nivel basado en caracter√≠sticas del usuario\n    const userScore = user.id.length + user.email.length * 2;\n\n    if (userScore > 60) return 'Guardi√°n del Bien Com√∫n';\n    if (userScore > 50) return 'Emprendedor Confiable';\n    if (userScore > 40) return 'Colaborador Activo';\n    if (userScore > 30) return 'Aprendiz de la Reciprocidad';\n    return 'Iniciado en Coom√únity';\n  }\n\n  private getNextReciprocidadLevel(user: User): string {\n    const currentLevel = this.calculateReciprocidadLevel(user);\n\n    const levelProgression = {\n      'Iniciado en Coom√únity': 'Aprendiz de la Reciprocidad',\n      'Aprendiz de la Reciprocidad': 'Colaborador Activo',\n      'Colaborador Activo': 'Emprendedor Confiable',\n      'Emprendedor Confiable': 'Guardi√°n del Bien Com√∫n',\n      'Guardi√°n del Bien Com√∫n': 'Maestro C√≥smico',\n    };\n\n    return levelProgression[currentLevel] || 'Maestro C√≥smico';\n  }\n\n  private calculateReciprocidadProgress(user: User): number {\n    // Progreso basado en el tiempo desde creaci√≥n y caracter√≠sticas del usuario\n    const daysSinceJoined = Math.floor(\n      (Date.now() - user.createdAt.getTime()) / (1000 * 60 * 60 * 24)\n    );\n    const baseProgress = Math.min(90, daysSinceJoined * 2 + user.id.length * 3);\n\n    return Math.max(10, baseProgress); // M√≠nimo 10%, m√°ximo calculado\n  }\n\n  private calculateElementalBalance(user: User) {\n    // Generar balance elemental √∫nico para cada usuario\n    const seed = user.id.length + user.email.length;\n\n    return {\n      fuego: 200 + seed * 7 + Math.floor(Math.sin(seed) * 50), // Acciones/Energ√≠a\n      agua: 150 + seed * 5 + Math.floor(Math.cos(seed) * 40), // Adaptabilidad/Emociones\n      tierra: 180 + seed * 6 + Math.floor(Math.sin(seed * 2) * 45), // Estabilidad/Crecimiento\n      aire: 120 + seed * 4 + Math.floor(Math.cos(seed * 1.5) * 35), // Visi√≥n/Claridad mental\n    };\n  }\n\n  async findByEmail(email: string) {\n    return this.prisma.user.findUnique({ where: { email } });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/video-items/dto/create-video-item.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsArray' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsObject' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":11}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  IsString,\n  IsInt,\n  IsOptional,\n  IsArray,\n  IsObject,\n} from 'class-validator';\n\nexport class CreateVideoItemDto {\n  @IsString()\n  title: string;\n\n  @IsString()\n  @IsOptional()\n  description?: string;\n\n  @IsString()\n  content: string;\n\n  @IsString()\n  @IsOptional()\n  url?: string;\n\n  @IsString()\n  platform: string;\n\n  @IsString()\n  @IsOptional()\n  externalId?: string;\n\n  @IsInt()\n  @IsOptional()\n  duration?: number;\n\n  @IsString()\n  @IsOptional()\n  thumbnailUrl?: string;\n\n  @IsString()\n  playlistId: string;\n\n  @IsString()\n  @IsOptional()\n  itemTypeId?: string;\n\n  @IsString()\n  @IsOptional()\n  tags?: string;\n\n  @IsString()\n  @IsOptional()\n  categories?: string;\n\n  @IsString()\n  @IsOptional()\n  quality?: string;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/video-items/dto/update-video-item.dto.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsArray' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'IsObject' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":11}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  IsString,\n  IsInt,\n  IsOptional,\n  IsArray,\n  IsObject,\n} from 'class-validator';\n\nexport class UpdateVideoItemDto {\n  @IsString()\n  @IsOptional()\n  title?: string;\n\n  @IsString()\n  @IsOptional()\n  description?: string;\n\n  @IsString()\n  @IsOptional()\n  content?: string;\n\n  @IsString()\n  @IsOptional()\n  url?: string;\n\n  @IsString()\n  @IsOptional()\n  platform?: string;\n\n  @IsString()\n  @IsOptional()\n  externalId?: string;\n\n  @IsInt()\n  @IsOptional()\n  duration?: number;\n\n  @IsString()\n  @IsOptional()\n  thumbnailUrl?: string;\n\n  @IsString()\n  @IsOptional()\n  playlistId?: string;\n\n  @IsString()\n  @IsOptional()\n  itemTypeId?: string;\n\n  @IsString()\n  @IsOptional()\n  tags?: string;\n\n  @IsString()\n  @IsOptional()\n  categories?: string;\n\n  @IsString()\n  @IsOptional()\n  quality?: string;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/video-items/video-items.controller.ts","messages":[{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":44,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":72,"endColumn":6},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":87,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":128,"endColumn":6},{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":149,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":157,"endColumn":6}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Controller,\n  Get,\n  Param,\n  NotFoundException,\n  Inject,\n  UseGuards,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOperation,\n  ApiResponse,\n  ApiBearerAuth,\n} from '@nestjs/swagger';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { VideoItemsService } from './video-items.service';\nimport { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';\nimport { VideoItemResponseDto } from './dto/video-item-response.dto';\n\n@ApiTags('video-items')\n@Controller('video-items')\n@ApiBearerAuth() // Para indicar que requiere token JWT en Swagger\nexport class VideoItemsController {\n  constructor(\n    @Inject(PrismaService) private readonly prisma: PrismaService,\n    @Inject(VideoItemsService)\n    private readonly videoItemsService: VideoItemsService\n  ) {\n    // //     console.log('>>> VideoItemsController CONSTRUCTOR: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n    // //     console.log('>>> VideoItemsController CONSTRUCTOR: this.videoItemsService IS', this.videoItemsService ? 'DEFINED' : 'UNDEFINED');\n  }\n\n  @Get()\n  @ApiOperation({ summary: 'Get all video items' })\n  @ApiResponse({\n    status: 200,\n    description: 'List of video items',\n    type: [VideoItemResponseDto],\n  })\n  async findAll() {\n    //     console.log('>>> VideoItemsController.findAll: Starting...');\n    //     console.log('>>> VideoItemsController.findAll: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n\n    try {\n      //       console.log('>>> VideoItemsController.findAll: About to call prisma.videoItem.findMany');\n      const videoItems = await this.prisma.videoItem.findMany({\n        include: {\n          subtitles: {\n            where: { isActive: true },\n          },\n          questions: {\n            where: { isActive: true },\n            include: {\n              answerOptions: {\n                orderBy: { order: 'asc' },\n              },\n            },\n          },\n        },\n        orderBy: { id: 'asc' },\n      });\n\n      // Mapear externalId a youtubeId y exponer thumbnailUrl\n      return videoItems.map((item) => ({\n        ...item,\n        youtubeId: item.externalId,\n        thumbnailUrl: item.thumbnailUrl,\n      }));\n    } catch (error) {\n      //       console.error('>>> VideoItemsController.findAll: ERROR:', error);\n      throw error;\n    }\n  }\n\n  @Get(':id')\n  @ApiOperation({ summary: 'Get a video item by ID' })\n  @ApiResponse({\n    status: 200,\n    description: 'Video item found',\n    type: VideoItemResponseDto,\n  })\n  @ApiResponse({ status: 404, description: 'Video item not found' })\n  async findOne(@Param('id') id: string) {\n    //     console.log('>>> VideoItemsController.findOne: Starting with id:', id);\n    //     console.log('>>> VideoItemsController.findOne: this.prisma IS', this.prisma ? 'DEFINED' : 'UNDEFINED');\n\n    try {\n      const parsedId = parseInt(id);\n      //       console.log('>>> VideoItemsController.findOne: Parsed ID:', parsedId);\n\n      if (isNaN(parsedId)) {\n        throw new NotFoundException(`Invalid ID format: ${id}`);\n      }\n\n      //       console.log('>>> VideoItemsController.findOne: About to call prisma.videoItem.findUnique');\n      const videoItem = await this.prisma.videoItem.findUnique({\n        where: { id: parsedId },\n        include: {\n          subtitles: {\n            where: { isActive: true },\n          },\n          questions: {\n            where: { isActive: true },\n            include: {\n              answerOptions: {\n                orderBy: { order: 'asc' },\n              },\n            },\n          },\n        },\n      });\n\n      //       console.log('>>> VideoItemsController.findOne: Query result:', videoItem ? 'FOUND' : 'NOT FOUND');\n\n      if (!videoItem) {\n        throw new NotFoundException(`Video item with ID ${id} not found`);\n      }\n\n      // Mapear externalId a youtubeId y exponer thumbnailUrl\n      return {\n        ...videoItem,\n        youtubeId: videoItem.externalId,\n        thumbnailUrl: videoItem.thumbnailUrl,\n      };\n    } catch (error) {\n      //       console.error('>>> VideoItemsController.findOne: ERROR:', error);\n      throw error;\n    }\n  }\n\n  @Get(':videoId/questions')\n  @UseGuards(JwtAuthGuard)\n  @ApiOperation({ summary: 'Get interactive questions for a specific video' })\n  @ApiResponse({\n    status: 200,\n    description: 'Returns questions and answer options for the video.',\n  })\n  @ApiResponse({\n    status: 404,\n    description: 'Video not found or no questions found.',\n  })\n  @ApiResponse({\n    status: 401,\n    description: 'Unauthorized - JWT token required.',\n  })\n  async getQuestionsForVideo(@Param('videoId') videoId: string) {\n    //     console.log('>>> VideoItemsController.getQuestionsForVideo: Starting with videoId:', videoId);\n\n    try {\n      const questions =\n        await this.videoItemsService.findQuestionsByVideoId(videoId);\n      //       console.log('>>> VideoItemsController.getQuestionsForVideo: SUCCESS, returning', questions.length, 'questions');\n      return questions;\n    } catch (error) {\n      //       console.error('>>> VideoItemsController.getQuestionsForVideo: ERROR:', error);\n      throw error;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/kevinp/Movies/GAMIFIER-copy/backend/src/video-items/video-items.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'VideoQuality' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'executionTime' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":365,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":365,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":375,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":375,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'executionTime' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":377,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":377,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":779,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":779,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'title' is defined but never used. Allowed unused args must match /^_/u.","line":1271,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":1271,"endColumn":10}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable, Inject, NotFoundException, Logger } from '@nestjs/common';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { CacheService } from '../cache/cache.service';\nimport { MetricsService } from '../common/metrics/metrics.service';\nimport { VideoPlatform } from '../common/constants/platform.enum';\nimport {\n  VideoQuality,\n  VideoMetadata,\n} from '../common/interfaces/video-metadata.interface';\nimport { AbortController } from 'node-abort-controller';\nimport { CreateVideoItemDto } from './dto/create-video-item.dto';\nimport { UpdateVideoItemDto } from './dto/update-video-item.dto';\n\n// Minimal interfaces for API responses\ninterface YouTubeApiResponse {\n  items: {\n    contentDetails: {\n      duration: string;\n    };\n  }[];\n}\n\ninterface YouTubeOembedResponse {\n  title?: string;\n}\n\ninterface VimeoApiResponse {\n  duration?: number;\n  title?: string;\n  thumbnail_url?: string;\n  tags?: string;\n  description?: string;\n}\n\n// More specific type for enrichment from YouTube Data API v3\ninterface YouTubeVideoListResponse {\n  items: {\n    snippet: {\n      title: string;\n      description: string;\n      tags: string[];\n    };\n    contentDetails: {\n      duration: string;\n    };\n    statistics: Record<string, unknown>; // Keep it simple for now\n  }[];\n}\n\n@Injectable()\nexport class VideoItemsService {\n  private readonly logger = new Logger(VideoItemsService.name);\n\n  constructor(\n    @Inject(PrismaService) private readonly prisma: PrismaService,\n    private readonly cacheService: CacheService,\n    private readonly metricsService: MetricsService\n  ) {\n    this.logger.log('VideoItemsService initialized');\n  }\n\n  private async fetch(\n    url: string,\n    options: Record<string, unknown> = {}\n  ): Promise<import('node-fetch').Response> {\n    const { default: fetch } = await import('node-fetch');\n    return fetch(url, options);\n  }\n\n  /**\n   * Encuentra un video item por ID\n   */\n  async findOne(id: number) {\n    //     console.log(`>>> VideoItemsService.findOne: Finding video item with ID: ${id}`);\n\n    const videoItem = await this.prisma.videoItem.findFirst({\n      where: { id },\n      include: {\n        playlist: true,\n        questions: {\n          include: {\n            answerOptions: true,\n          },\n        },\n      },\n    });\n\n    if (!videoItem) {\n      throw new NotFoundException(`Video item with ID ${id} not found`);\n    }\n\n    // Actualizar platform y externalId si est√°n vac√≠os\n    if (!videoItem.platform || !videoItem.externalId) {\n      const detectedPlatform = this.detectVideoPlatform(videoItem.content);\n      const extractedId = this.extractPlatformId(\n        videoItem.content,\n        detectedPlatform\n      );\n\n      if (detectedPlatform !== VideoPlatform.UNKNOWN) {\n        const updatedItem = await this.prisma.videoItem.update({\n          where: { id },\n          data: {\n            platform: detectedPlatform,\n            externalId: extractedId,\n          },\n          include: {\n            playlist: true,\n            questions: {\n              include: {\n                answerOptions: true,\n              },\n            },\n          },\n        });\n\n        //         console.log(`>>> VideoItemsService.findOne: Updated platform metadata for video ${id}: ${detectedPlatform}`);\n\n        return { ...videoItem, ...updatedItem };\n      }\n    }\n\n    return videoItem;\n  }\n\n  /**\n   * Encuentra todos los video items\n   */\n  async findAll() {\n    //     console.log('>>> VideoItemsService.findAll: ENTERING METHOD');\n    //       console.log('>>> VideoItemsService.findAll: Finding all video items');\n    //       console.log('>>> VideoItemsService.findAll: About to call prisma.videoItem.findMany');\n\n    const result = await this.prisma.videoItem.findMany({\n      include: {\n        playlist: true,\n        questions: {\n          include: {\n            answerOptions: true,\n          },\n        },\n      },\n    });\n\n    //       console.log('>>> VideoItemsService.findAll: Prisma call successful, found', result.length, 'items');\n    return result;\n  }\n\n  /**\n   * Crea un nuevo video item\n   */\n  async create(data: CreateVideoItemDto) {\n    //     console.log('>>> VideoItemsService.create: Creating new video item');\n\n    // Convertir DTO a formato compatible con Prisma\n    const createData = {\n      title: data.title,\n      description: data.description,\n      content: data.content,\n      url: data.url,\n      platform: data.platform,\n      externalId: data.externalId,\n      duration: data.duration,\n      thumbnailUrl: data.thumbnailUrl,\n      itemTypeId: data.itemTypeId,\n      tags: data.tags,\n      categories: data.categories,\n      quality: data.quality,\n      // Set playlistId directly as foreign key\n      playlistId: data.playlistId,\n    };\n\n    return this.prisma.videoItem.create({\n      data: createData,\n    });\n  }\n\n  /**\n   * Actualiza un video item\n   */\n  async update(id: number, data: UpdateVideoItemDto) {\n    //     console.log(`>>> VideoItemsService.update: Updating video item with ID: ${id}`);\n\n    // Convertir DTO a formato compatible con Prisma\n    const updateData: Partial<UpdateVideoItemDto> = {};\n\n    if (data.title !== undefined) updateData.title = data.title;\n    if (data.description !== undefined)\n      updateData.description = data.description;\n    if (data.content !== undefined) updateData.content = data.content;\n    if (data.url !== undefined) updateData.url = data.url;\n    if (data.platform !== undefined) updateData.platform = data.platform;\n    if (data.externalId !== undefined) updateData.externalId = data.externalId;\n    if (data.duration !== undefined) updateData.duration = data.duration;\n    if (data.thumbnailUrl !== undefined)\n      updateData.thumbnailUrl = data.thumbnailUrl;\n    if (data.itemTypeId !== undefined) updateData.itemTypeId = data.itemTypeId;\n    if (data.tags !== undefined) updateData.tags = data.tags;\n    if (data.categories !== undefined) updateData.categories = data.categories;\n    if (data.quality !== undefined) updateData.quality = data.quality;\n\n    // Set playlistId directly as foreign key if present\n    if (data.playlistId !== undefined) {\n      updateData.playlistId = data.playlistId;\n    }\n\n    return this.prisma.videoItem.update({\n      where: { id },\n      data: updateData,\n    });\n  }\n\n  /**\n   * Elimina un video item\n   */\n  async remove(id: number) {\n    //     console.log(`>>> VideoItemsService.remove: Removing video item with ID: ${id}`);\n\n    return this.prisma.videoItem.delete({\n      where: { id },\n    });\n  }\n\n  /**\n   * Detecta la plataforma de video desde el contenido\n   */\n  detectVideoPlatform(content: string): VideoPlatform {\n    if (!content) return VideoPlatform.UNKNOWN;\n\n    const contentLower = content.toLowerCase();\n\n    if (\n      contentLower.includes('youtube.com') ||\n      contentLower.includes('youtu.be')\n    ) {\n      return VideoPlatform.YOUTUBE;\n    }\n\n    if (contentLower.includes('vimeo.com')) {\n      return VideoPlatform.VIMEO;\n    }\n\n    if (\n      contentLower.includes('localhost') ||\n      contentLower.includes('gamifier')\n    ) {\n      return VideoPlatform.LOCAL;\n    }\n\n    return VideoPlatform.UNKNOWN;\n  }\n\n  /**\n   * Extrae el ID de la plataforma desde el contenido\n   */\n  extractPlatformId(content: string, platform: VideoPlatform): string | null {\n    if (!content) return null;\n\n    switch (platform) {\n      case VideoPlatform.YOUTUBE:\n        return this.extractYouTubeVideoId(content);\n      case VideoPlatform.VIMEO:\n        return this.extractVimeoVideoId(content);\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Extrae el video ID de YouTube\n   */\n  private extractYouTubeVideoId(content: string): string | null {\n    const patterns = [\n      /youtube\\.com\\/watch\\?v=([a-zA-Z0-9_-]+)/,\n      /youtu\\.be\\/([a-zA-Z0-9_-]+)/,\n      /youtube\\.com\\/embed\\/([a-zA-Z0-9_-]+)/,\n      /\"videoId\"\\s*:\\s*\"([a-zA-Z0-9_-]+)\"/,\n    ];\n\n    for (const pattern of patterns) {\n      const match = content.match(pattern);\n      if (match) {\n        return match[1];\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Extrae el video ID de Vimeo\n   */\n  private extractVimeoVideoId(content: string): string | null {\n    const patterns = [/vimeo\\.com\\/(\\d+)/, /player\\.vimeo\\.com\\/video\\/(\\d+)/];\n\n    for (const pattern of patterns) {\n      const match = content.match(pattern);\n      if (match) {\n        return match[1];\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Calcula la duraci√≥n de un video\n   */\n  async calculateVideoDuration(content: string): Promise<number> {\n    const startTime = Date.now();\n    this.logger.log(\n      `Starting video duration calculation for content: ${content.substring(0, 100)}...`\n    );\n\n    try {\n      // Verificar cache primero\n      const cachedDuration = await this.cacheService.getDuration(content);\n      if (cachedDuration) {\n        this.metricsService.incrementCacheOperations('get', 'hit');\n        this.logger.log(`Cache hit for video duration: ${cachedDuration}s`);\n        return cachedDuration;\n      }\n\n      this.metricsService.incrementCacheOperations('get', 'miss');\n\n      // Detectar plataforma\n      const platform = this.detectVideoPlatform(content);\n      let duration: number | null = null;\n\n      // Intentar obtener duraci√≥n por plataforma\n      switch (platform) {\n        case VideoPlatform.YOUTUBE:\n          duration = await this.getYouTubeDuration(content);\n          // if (duration) {\n          //   this.metricsService.incrementVideoDurationMethods('estimation', true);\n          // }\n          break;\n\n        case VideoPlatform.VIMEO:\n          duration = await this.getVimeoDuration(content);\n          // if (duration) {\n          //   this.metricsService.incrementVideoDurationMethods('estimation', true);\n          // }\n          break;\n\n        default:\n          // this.logger.warn(`Unknown platform for content: ${content}`);\n          break;\n      }\n\n      // Fallback a estimaci√≥n\n      if (!duration || duration <= 0) {\n        duration = this.getEstimatedDuration(content);\n        // this.metricsService.incrementVideoDurationMethods('estimation', true);\n        // this.logger.log(`Using estimated duration: ${duration}s`);\n      }\n\n      // Cachear resultado\n      // if (duration > 0) {\n      //   await this.cacheService.setDuration(content, duration);\n      //   this.metricsService.incrementCacheOperations('set', 'success');\n      // }\n\n      const endTime = Date.now();\n      const executionTime = endTime - startTime;\n\n      // this.logger.logVideoCalculation(\n      //   content,\n      //   duration,\n      //   platform,\n      //   executionTime\n      // );\n\n      return duration;\n    } catch (error) {\n      const endTime = Date.now();\n      const executionTime = endTime - startTime;\n\n      // this.metricsService.incrementApiErrors('video_duration', 'calculate_duration');\n\n      // this.logger.logVideoCalculation(\n      //   content,\n      //   -1,\n      //   VideoPlatform.UNKNOWN,\n      //   executionTime,\n      //   error\n      // );\n\n      const fallbackDuration = this.getEstimatedDuration(content);\n      // this.logger.warn(`Error calculating duration, using fallback: ${fallbackDuration}s`);\n      return fallbackDuration;\n    }\n  }\n\n  /**\n   * Obtiene duraci√≥n de YouTube\n   */\n  private async getYouTubeDuration(content: string): Promise<number | null> {\n    const videoId = this.extractYouTubeVideoId(content);\n    if (!videoId) {\n      this.logger.warn(`Could not extract YouTube video ID from: ${content}`);\n      return null;\n    }\n\n    const apiKey = process.env.YOUTUBE_API_KEY;\n    if (!apiKey) {\n      this.logger.error('YOUTUBE_API_KEY not found in environment variables.');\n      // Fallback to oEmbed\n      try {\n        const url = `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`;\n        const controller = new AbortController();\n        const timeout = setTimeout(() => controller.abort(), 5000);\n\n        const response = await this.fetch(url, { signal: controller.signal });\n        clearTimeout(timeout);\n\n        if (!response.ok) {\n          this.logger.error(\n            `YouTube oEmbed API request failed with status ${response.status} for video ID: ${videoId}`\n          );\n          return null;\n        }\n        const data = (await response.json()) as YouTubeOembedResponse;\n        if (data && data.title) {\n          return this.extractDurationFromTitle(data.title);\n        }\n      } catch (error) {\n        if (error.name === 'AbortError') {\n          this.logger.error('YouTube oEmbed API request timed out.');\n        } else {\n          this.logger.error(\n            `Error fetching from YouTube oEmbed API: ${error.message}`\n          );\n        }\n        return null;\n      }\n      return null;\n    }\n\n    try {\n      const url = `https://www.googleapis.com/youtube/v3/videos?id=${videoId}&part=contentDetails&key=${apiKey}`;\n      const controller = new AbortController();\n      const timeout = setTimeout(() => controller.abort(), 5000);\n\n      const response = await this.fetch(url, { signal: controller.signal });\n      clearTimeout(timeout);\n\n      if (!response.ok) {\n        this.logger.error(\n          `YouTube Data API request failed with status ${response.status} for video ID: ${videoId}`\n        );\n        return null;\n      }\n      const data = (await response.json()) as YouTubeApiResponse;\n      if (data && data.items && data.items.length > 0) {\n        const duration = this.parseISO8601Duration(\n          data.items[0].contentDetails.duration\n        );\n        return duration;\n      }\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        this.logger.error('YouTube Data API request timed out.');\n      } else {\n        this.logger.error(\n          `Error fetching from YouTube Data API: ${error.message}`\n        );\n      }\n      return null;\n    }\n\n    return null;\n  }\n\n  /**\n   * Obtiene duraci√≥n de Vimeo\n   */\n  private async getVimeoDuration(content: string): Promise<number | null> {\n    const videoId = this.extractVimeoVideoId(content);\n    if (!videoId) {\n      this.logger.warn(`Could not extract Vimeo video ID from: ${content}`);\n      return null;\n    }\n\n    try {\n      const url = `https://vimeo.com/api/oembed.json?url=https://vimeo.com/${videoId}`;\n      const controller = new AbortController();\n      const timeout = setTimeout(() => controller.abort(), 5000);\n\n      const response = await this.fetch(url, { signal: controller.signal });\n      clearTimeout(timeout);\n\n      if (!response.ok) {\n        this.logger.error(\n          `Vimeo API request failed with status ${response.status} for video ID: ${videoId}`\n        );\n        return null;\n      }\n      const data = (await response.json()) as VimeoApiResponse;\n      if (data && data.duration) {\n        return data.duration;\n      }\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        this.logger.error('Vimeo API request timed out.');\n      } else {\n        this.logger.error(`Error fetching from Vimeo API: ${error.message}`);\n      }\n      return null;\n    }\n\n    return null;\n  }\n\n  /**\n   * Convierte duraci√≥n ISO 8601 a segundos\n   */\n  private parseISO8601Duration(duration: string): number {\n    const match = duration.match(/PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)S)?/);\n    if (!match) return 0;\n\n    const hours = parseInt(match[1] || '0', 10);\n    const minutes = parseInt(match[2] || '0', 10);\n    const seconds = parseInt(match[3] || '0', 10);\n\n    return hours * 3600 + minutes * 60 + seconds;\n  }\n\n  /**\n   * Extrae duraci√≥n del t√≠tulo\n   */\n  private extractDurationFromTitle(title: string): number {\n    const durationPatterns = [\n      /\\[(\\d+):(\\d+):(\\d+)\\]/, // [HH:MM:SS]\n      /\\[(\\d+):(\\d+)\\]/, // [MM:SS]\n      /\\((\\d+):(\\d+):(\\d+)\\)/, // (HH:MM:SS)\n      /\\((\\d+):(\\d+)\\)/, // (MM:SS)\n      /(\\d+):(\\d+):(\\d+)/, // HH:MM:SS\n      /(\\d+):(\\d+)/, // MM:SS\n    ];\n\n    for (const pattern of durationPatterns) {\n      const match = title.match(pattern);\n      if (match) {\n        const parts = match.slice(1).map(Number);\n        if (parts.length === 3) {\n          return parts[0] * 3600 + parts[1] * 60 + parts[2];\n        } else if (parts.length === 2) {\n          return parts[0] * 60 + parts[1];\n        }\n      }\n    }\n\n    return 0;\n  }\n\n  /**\n   * Obtiene duraci√≥n estimada\n   */\n  getEstimatedDuration(content: string, title?: string): number {\n    const titleToAnalyze = title || content;\n    const titleLower = titleToAnalyze.toLowerCase();\n\n    // üéØ PRIORIDAD 1: Mapeo espec√≠fico de videos conocidos por contenido/ID\n    const videoId = this.extractYouTubeVideoId(content);\n    if (videoId) {\n      const knownDurations: Record<string, number> = {\n        EEZkQv25uEs: 729, // Sacred Economics with Charles Eisenstein - A Short Film\n        ScMzIvxBSi4: 94, // Elementos de Juego en Educaci√≥n\n        ZXsQAXx_ao0: 64, // Narrativa y Storytelling\n        '9bZkp7q19f0': 252, // Mec√°nicas de Recompensa\n        kJQP7kiw5Fk: 282, // Evaluaci√≥n Gamificada\n        dQw4w9WgXcQ: 212, // Rick Roll - 3:32 (video de prueba com√∫n)\n        // Agregar m√°s videos conocidos aqu√≠ seg√∫n sea necesario\n      };\n\n      if (knownDurations[videoId]) {\n        this.logger.log(\n          `‚úÖ Using known duration for video ${videoId}: ${knownDurations[videoId]}s`\n        );\n        return knownDurations[videoId];\n      }\n    }\n\n    // üéØ PRIORIDAD 2: Patrones de duraci√≥n expl√≠citos en el t√≠tulo\n    const durationPatterns = [\n      /\\[(\\d+):(\\d+):(\\d+)\\]/, // [HH:MM:SS]\n      /\\[(\\d+):(\\d+)\\]/, // [MM:SS]\n      /\\((\\d+):(\\d+):(\\d+)\\)/, // (HH:MM:SS)\n      /\\((\\d+):(\\d+)\\)/, // (MM:SS)\n      /(\\d+):(\\d+):(\\d+)/, // HH:MM:SS anywhere\n      /(\\d+):(\\d+)/, // MM:SS anywhere\n    ];\n\n    for (const pattern of durationPatterns) {\n      const match = titleToAnalyze.match(pattern);\n      if (match) {\n        const parts = match.slice(1).map(Number);\n        let duration = 0;\n        if (parts.length === 3) {\n          duration = parts[0] * 3600 + parts[1] * 60 + parts[2];\n        } else if (parts.length === 2) {\n          duration = parts[0] * 60 + parts[1];\n        }\n        if (duration > 0 && duration < 36000) {\n          // M√°ximo 10 horas\n          this.logger.log(`‚úÖ Duration pattern found in title: ${duration}s`);\n          return duration;\n        }\n      }\n    }\n\n    // üéØ PRIORIDAD 3: Patrones de texto que indican duraci√≥n\n    const textPatterns = [\n      { pattern: /(\\d+)\\s*hours?/i, multiplier: 3600 },\n      { pattern: /(\\d+)\\s*hrs?/i, multiplier: 3600 },\n      { pattern: /(\\d+)\\s*minutes?/i, multiplier: 60 },\n      { pattern: /(\\d+)\\s*mins?/i, multiplier: 60 },\n      { pattern: /(\\d+)\\s*min\\b/i, multiplier: 60 }, // \"min\" followed by word boundary\n    ];\n\n    for (const { pattern, multiplier } of textPatterns) {\n      const match = titleLower.match(pattern);\n      if (match) {\n        const duration = parseInt(match[1], 10) * multiplier;\n        if (duration > 0 && duration < 36000) {\n          // M√°ximo 10 horas\n          this.logger.log(`‚úÖ Text pattern duration found: ${duration}s`);\n          return duration;\n        }\n      }\n    }\n\n    // üéØ PRIORIDAD 4: Estimaciones por tipo de contenido\n    if (titleLower.includes('short') || titleLower.includes('shorts')) {\n      this.logger.log(`üì± Short content detected: 60s`);\n      return 60; // 1 minuto\n    }\n\n    if (titleLower.includes('trailer') || titleLower.includes('teaser')) {\n      this.logger.log(`üé¨ Trailer detected: 120s`);\n      return 120; // 2 minutos\n    }\n\n    if (\n      titleLower.includes('tutorial') ||\n      titleLower.includes('how to') ||\n      titleLower.includes('c√≥mo')\n    ) {\n      this.logger.log(`üìö Tutorial detected: 600s`);\n      return 600; // 10 minutos\n    }\n\n    if (\n      titleLower.includes('podcast') ||\n      titleLower.includes('interview') ||\n      titleLower.includes('entrevista')\n    ) {\n      this.logger.log(`üéôÔ∏è Podcast/Interview detected: 2400s`);\n      return 2400; // 40 minutos\n    }\n\n    if (\n      titleLower.includes('live') ||\n      titleLower.includes('stream') ||\n      titleLower.includes('en vivo')\n    ) {\n      this.logger.log(`üì∫ Live stream detected: 3600s`);\n      return 3600; // 1 hora\n    }\n\n    if (\n      titleLower.includes('full movie') ||\n      titleLower.includes('pel√≠cula completa') ||\n      titleLower.includes('film')\n    ) {\n      this.logger.log(`üéûÔ∏è Full movie detected: 6000s`);\n      return 6000; // 100 minutos\n    }\n\n    // TED talks tienen t√≠picamente 18 minutos\n    if (titleLower.includes('ted') || titleLower.includes('tedx')) {\n      this.logger.log(`üé§ TED talk detected: 1080s`);\n      return 1080; // 18 minutos\n    }\n\n    // üéØ PRIORIDAD 5: Estimaciones espec√≠ficas por palabras clave de gamificaci√≥n\n    if (\n      titleLower.includes('gamificaci√≥n') ||\n      titleLower.includes('gamification')\n    ) {\n      this.logger.log(`üéÆ Gamification content detected: 720s`);\n      return 720; // 12 minutos (contenido educativo de gamificaci√≥n)\n    }\n\n    if (\n      titleLower.includes('elementos de juego') ||\n      titleLower.includes('game elements')\n    ) {\n      this.logger.log(`üéØ Game elements content detected: 480s`);\n      return 480; // 8 minutos\n    }\n\n    if (\n      titleLower.includes('narrativa') ||\n      titleLower.includes('storytelling')\n    ) {\n      this.logger.log(`üìñ Storytelling content detected: 360s`);\n      return 360; // 6 minutos\n    }\n\n    if (\n      titleLower.includes('mec√°nica') ||\n      titleLower.includes('recompensa') ||\n      titleLower.includes('reward')\n    ) {\n      this.logger.log(`üèÜ Mechanics/Reward content detected: 420s`);\n      return 420; // 7 minutos\n    }\n\n    if (\n      titleLower.includes('evaluaci√≥n') ||\n      titleLower.includes('assessment')\n    ) {\n      this.logger.log(`üìä Assessment content detected: 360s`);\n      return 360; // 6 minutos\n    }\n\n    // üéØ PRIORIDAD 6: Estimaciones por palabras clave educativas\n    if (\n      titleLower.includes('curso') ||\n      titleLower.includes('course') ||\n      titleLower.includes('clase') ||\n      titleLower.includes('lesson')\n    ) {\n      this.logger.log(`üéì Educational course content: 900s`);\n      return 900; // 15 minutos\n    }\n\n    if (\n      titleLower.includes('introducci√≥n') ||\n      titleLower.includes('introduction') ||\n      titleLower.includes('intro')\n    ) {\n      this.logger.log(`üëã Introduction content: 480s`);\n      return 480; // 8 minutos\n    }\n\n    // üéØ FALLBACK FINAL: Duraci√≥n por defecto m√°s inteligente\n    this.logger.log(`üîÑ Using smart default for educational content: 480s`);\n    return 480; // 8 minutos (m√°s realista que 5 minutos para contenido educativo)\n  }\n\n  /**\n   * Extrae metadatos avanzados del video\n   */\n  async extractVideoMetadata(content: string): Promise<VideoMetadata> {\n    // this.logger.log(`Extracting video metadata for content: ${content.substring(0, 100)}...`);\n    const platform = this.detectVideoPlatform(content);\n    const externalId = this.extractPlatformId(content, platform);\n\n    const metadata: VideoMetadata = {\n      platform,\n      externalId: externalId || undefined,\n      url: content,\n    };\n\n    try {\n      if (platform === VideoPlatform.YOUTUBE && externalId) {\n        await this.enrichYouTubeMetadata(metadata, externalId);\n      } else if (platform === VideoPlatform.VIMEO && externalId) {\n        await this.enrichVimeoMetadata(metadata, externalId);\n      }\n\n      // Calcular duraci√≥n si no se obtuvo de los metadatos\n      if (!metadata.duration) {\n        metadata.duration = await this.calculateVideoDuration(content);\n      }\n    } catch (error) {\n      // this.logger.error(`Error extracting video metadata: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n\n    return metadata;\n  }\n\n  /**\n   * Enriquece metadatos de YouTube\n   */\n  private async enrichYouTubeMetadata(\n    metadata: VideoMetadata,\n    videoId: string\n  ): Promise<void> {\n    const apiKey = process.env.YOUTUBE_API_KEY;\n    if (!apiKey) {\n      this.logger.warn(\n        'YOUTUBE_API_KEY not found. Skipping metadata enrichment for YouTube.'\n      );\n      return;\n    }\n\n    try {\n      const url = `https://www.googleapis.com/youtube/v3/videos?id=${videoId}&part=snippet,contentDetails,statistics&key=${apiKey}`;\n      const controller = new AbortController();\n      const timeout = setTimeout(() => controller.abort(), 5000);\n\n      const response = await this.fetch(url, { signal: controller.signal });\n      clearTimeout(timeout);\n\n      if (!response.ok) {\n        this.logger.error(\n          `YouTube metadata request failed with status ${response.status} for video ID: ${videoId}`\n        );\n        return;\n      }\n      const data = (await response.json()) as YouTubeVideoListResponse;\n      if (data && data.items && data.items.length > 0) {\n        const videoData = data.items[0];\n        metadata.title = videoData.snippet.title;\n        metadata.description = videoData.snippet.description;\n        metadata.duration = this.parseISO8601Duration(\n          videoData.contentDetails.duration\n        );\n        metadata.thumbnailUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;\n        metadata.tags = videoData.snippet.tags || [];\n      }\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        this.logger.error('YouTube metadata enrichment request timed out.');\n      } else {\n        this.logger.error(`Error enriching YouTube metadata: ${error.message}`);\n      }\n    }\n  }\n\n  /**\n   * Enriquece metadatos de Vimeo\n   */\n  private async enrichVimeoMetadata(\n    metadata: VideoMetadata,\n    videoId: string\n  ): Promise<void> {\n    try {\n      const url = `https://vimeo.com/api/v2/video/${videoId}.json`;\n      const controller = new AbortController();\n      const timeout = setTimeout(() => controller.abort(), 5000);\n\n      const response = await this.fetch(url, { signal: controller.signal });\n      clearTimeout(timeout);\n\n      if (!response.ok) {\n        this.logger.error(\n          `Vimeo metadata request failed with status ${response.status} for video ID: ${videoId}`\n        );\n        return;\n      }\n      const data = (await response.json()) as VimeoApiResponse[];\n      if (data && data.length > 0) {\n        const videoData = data[0];\n        metadata.title = videoData.title;\n        metadata.description = videoData.description;\n        metadata.duration = videoData.duration;\n        metadata.thumbnailUrl = videoData.thumbnail_url;\n        metadata.tags = videoData.tags ? videoData.tags.split(', ') : [];\n      }\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        this.logger.error('Vimeo metadata enrichment request timed out.');\n      } else {\n        this.logger.error(`Error enriching Vimeo metadata: ${error.message}`);\n      }\n    }\n  }\n\n  /**\n   * Actualiza metadatos de un video existente\n   */\n  async updateVideoMetadata(\n    id: number\n  ): Promise<{ metadata: VideoMetadata; [key: string]: unknown }> {\n    // this.logger.log(`Updating metadata for video item ${id}`);\n    const videoItem = await this.prisma.videoItem.findUnique({ where: { id } });\n\n    if (!videoItem.content) {\n      throw new Error(\n        `Video item ${id} has no content to extract metadata from`\n      );\n    }\n\n    const metadata = await this.extractVideoMetadata(videoItem.content);\n\n    const updateData: Partial<UpdateVideoItemDto> = {};\n\n    if (metadata.duration && metadata.duration !== videoItem.duration) {\n      updateData.duration = metadata.duration;\n    }\n\n    if (metadata.platform && metadata.platform !== videoItem.platform) {\n      updateData.platform = metadata.platform;\n    }\n\n    if (metadata.externalId && metadata.externalId !== videoItem.externalId) {\n      updateData.externalId = metadata.externalId;\n    }\n\n    if (Object.keys(updateData).length > 0) {\n      const updatedItem = await this.prisma.videoItem.update({\n        where: { id },\n        data: updateData,\n      });\n\n      this.logger.log(\n        `Updated metadata for video item ${id} - fields: ${Object.keys(updateData).join(', ')}`\n      );\n\n      return { ...updatedItem, metadata };\n    } else {\n      this.logger.log(`No metadata updates needed for video item ${id}`);\n\n      return { ...videoItem, metadata };\n    }\n  }\n\n  /**\n   * Recalcula las duraciones de todos los videos que tienen duration: null\n   */\n  async recalculateAllDurations(): Promise<{\n    updated: number;\n    errors: number;\n    results: {\n      id: number;\n      title: string;\n      duration?: number;\n      status: string;\n      error?: string;\n    }[];\n  }> {\n    // this.logger.log('Starting bulk duration recalculation for videos with null duration');\n    const videosWithNullDuration = await this.prisma.videoItem.findMany({\n      where: {\n        duration: null,\n      },\n      select: {\n        id: true,\n        content: true,\n        title: true,\n      },\n    });\n\n    // this.logger.log(`Found ${videosWithNullDuration.length} videos with null duration`);\n    let updated = 0;\n    let errors = 0;\n    const results: {\n      id: number;\n      title: string;\n      duration?: number;\n      status: string;\n      error?: string;\n    }[] = [];\n\n    for (const video of videosWithNullDuration) {\n      try {\n        // this.logger.log(`Processing video ${video.id}: ${video.title}`);\n        const duration = await this.calculateVideoDuration(video.content);\n\n        if (duration && duration > 0) {\n          await this.prisma.videoItem.update({\n            where: { id: video.id },\n            data: { duration },\n          });\n\n          updated++;\n          results.push({\n            id: video.id,\n            title: video.title,\n            duration,\n            status: 'updated',\n          });\n\n          this.logger.log(\n            `Successfully updated duration for video ${video.id}: ${duration}s`\n          );\n        } else {\n          errors++;\n          results.push({\n            id: video.id,\n            title: video.title,\n            status: 'error',\n            error: 'Could not calculate duration',\n          });\n\n          this.logger.warn(\n            `Could not calculate duration for video ${video.id}`\n          );\n        }\n      } catch (error) {\n        errors++;\n        results.push({\n          id: video.id,\n          title: video.title,\n          status: 'error',\n          error: error instanceof Error ? error.message : 'Unknown error',\n        });\n\n        this.logger.error(\n          `Error processing video ${video.id}: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n      }\n    }\n\n    // this.logger.log(`Bulk duration recalculation completed - Total: ${videosWithNullDuration.length}, Updated: ${updated}, Errors: ${errors}`);\n    return { updated, errors, results };\n  }\n\n  /**\n   * FUERZA la recalculaci√≥n de duraciones de TODOS los videos, incluso los que ya tienen duration\n   * ‚ö†Ô∏è  VERSI√ìN MEJORADA CON PROTECCI√ìN DE DATOS\n   */\n  async forceRecalculateAllDurations(): Promise<{\n    total: number;\n    updated: number;\n    errors: number;\n    verified: number;\n    protectedCount: number;\n    results: {\n      id: number;\n      title: string;\n      status: string;\n      duration?: number;\n      message?: string;\n      oldDuration?: number;\n      newDuration?: number;\n      change?: number;\n      calculatedDuration?: number;\n      currentDuration?: number;\n      error?: string;\n    }[];\n  }> {\n    // this.logger.log('üîÑ Starting FORCE bulk duration recalculation for ALL videos (WITH DATA PROTECTION)');\n\n    const allVideos = await this.prisma.videoItem.findMany({\n      select: {\n        id: true,\n        content: true,\n        title: true,\n        duration: true, // Incluir duraci√≥n actual para comparaci√≥n\n        tags: true,\n      },\n    });\n\n    // this.logger.log(`üìä Found ${allVideos.length} total videos to recalculate`);\n\n    let updated = 0;\n    let errors = 0;\n    let verified = 0; // Videos que ya ten√≠an la duraci√≥n correcta\n    let protectedCount = 0; // Videos protegidos de sobrescritura destructiva\n    const results: {\n      id: number;\n      title: string;\n      status: string;\n      duration?: number;\n      message?: string;\n      oldDuration?: number;\n      newDuration?: number;\n      change?: number;\n      calculatedDuration?: number;\n      currentDuration?: number;\n      error?: string;\n    }[] = [];\n\n    // üõ°Ô∏è LISTA DE DURACIONES CONOCIDAS Y VERIFICADAS MANUALMENTE\n    const manuallyVerifiedDurations: Record<number, number> = {\n      39: 729, // Introducci√≥n a la Gamificaci√≥n (12:09)\n      40: 94, // Elementos de Juego en Educaci√≥n (1:34)\n      41: 64, // Narrativa y Storytelling (1:04)\n      42: 252, // Mec√°nicas de Recompensa (4:12)\n      43: 282, // Evaluaci√≥n Gamificada (4:42)\n    };\n\n    for (const video of allVideos) {\n      try {\n        // this.logger.log(`üîç Processing video ${video.id}: ${video.title}`);\n\n        // üõ°Ô∏è PROTECCI√ìN: Verificar si este video tiene una duraci√≥n manualmente verificada\n        if (manuallyVerifiedDurations[video.id]) {\n          const verifiedDuration = manuallyVerifiedDurations[video.id];\n\n          if (video.duration === verifiedDuration) {\n            // La duraci√≥n ya es correcta y est√° verificada\n            protectedCount++;\n            results.push({\n              id: video.id,\n              title: video.title,\n              duration: verifiedDuration,\n              status: 'protected',\n              message: 'Manually verified duration - protected from overwrite',\n            });\n\n            this.logger.log(\n              `üõ°Ô∏è  PROTECTED video ${video.id}: ${verifiedDuration}s (manually verified)`\n            );\n            continue;\n          } else {\n            // La duraci√≥n no coincide con la verificada manualmente - restaurar\n            await this.prisma.videoItem.update({\n              where: { id: video.id },\n              data: { duration: verifiedDuration },\n            });\n\n            updated++;\n            results.push({\n              id: video.id,\n              title: video.title,\n              oldDuration: video.duration,\n              newDuration: verifiedDuration,\n              status: 'restored',\n              message: 'Restored to manually verified duration',\n              change: verifiedDuration - (video.duration || 0),\n            });\n\n            this.logger.log(\n              `üîß RESTORED video ${video.id}: ${video.duration}s ‚Üí ${verifiedDuration}s (manually verified)`\n            );\n            continue;\n          }\n        }\n\n        // Para videos no verificados manualmente, proceder con c√°lculo normal\n        const calculatedDuration = await this.calculateVideoDuration(\n          video.content\n        );\n\n        if (calculatedDuration > 0) {\n          // üõ°Ô∏è PROTECCI√ìN ADICIONAL: No sobrescribir si la diferencia es m√≠nima (¬±10s)\n          if (\n            video.duration &&\n            Math.abs(video.duration - calculatedDuration) <= 10\n          ) {\n            verified++;\n            results.push({\n              id: video.id,\n              title: video.title,\n              duration: video.duration,\n              calculatedDuration,\n              status: 'verified',\n              message: `Duration within acceptable range (¬±10s) - no change needed`,\n            });\n\n            this.logger.log(\n              `‚úÖ VERIFIED video ${video.id}: ${video.duration}s (calculated: ${calculatedDuration}s, diff: ${Math.abs(video.duration - calculatedDuration)}s)`\n            );\n            continue;\n          }\n\n          // Comparar con la duraci√≥n actual\n          if (video.duration !== calculatedDuration) {\n            // üõ°Ô∏è PROTECCI√ìN: Solo actualizar si la nueva duraci√≥n parece m√°s confiable\n            const shouldUpdate = this.shouldUpdateDuration(\n              video.duration,\n              calculatedDuration,\n              video.title || ''\n            );\n\n            if (shouldUpdate) {\n              await this.prisma.videoItem.update({\n                where: { id: video.id },\n                data: { duration: calculatedDuration },\n              });\n\n              updated++;\n              results.push({\n                id: video.id,\n                title: video.title,\n                oldDuration: video.duration,\n                newDuration: calculatedDuration,\n                status: 'updated',\n                change: calculatedDuration - (video.duration || 0),\n              });\n\n              this.logger.log(\n                `‚úÖ UPDATED duration for video ${video.id}: ${video.duration}s ‚Üí ${calculatedDuration}s`\n              );\n            } else {\n              protectedCount++;\n              results.push({\n                id: video.id,\n                title: video.title,\n                currentDuration: video.duration,\n                calculatedDuration,\n                status: 'protected',\n                message:\n                  'Current duration seems more reliable - protected from overwrite',\n              });\n\n              this.logger.log(\n                `üõ°Ô∏è  PROTECTED video ${video.id}: keeping ${video.duration}s (calculated: ${calculatedDuration}s deemed less reliable)`\n              );\n            }\n          } else {\n            // La duraci√≥n ya era correcta\n            verified++;\n            results.push({\n              id: video.id,\n              title: video.title,\n              duration: calculatedDuration,\n              status: 'verified',\n              message: 'Duration already correct',\n            });\n\n            this.logger.log(\n              `‚úÖ VERIFIED duration for video ${video.id}: ${calculatedDuration}s (no change needed)`\n            );\n          }\n        } else {\n          errors++;\n          results.push({\n            id: video.id,\n            title: video.title,\n            currentDuration: video.duration,\n            status: 'error',\n            error: 'Could not calculate duration',\n          });\n\n          this.logger.warn(\n            `‚ùå Could not calculate duration for video ${video.id}`\n          );\n        }\n      } catch (error) {\n        errors++;\n        results.push({\n          id: video.id,\n          title: video.title,\n          currentDuration: video.duration,\n          status: 'error',\n          error: error instanceof Error ? error.message : 'Unknown error',\n        });\n\n        this.logger.error(\n          `‚ùå Error processing video ${video.id}: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n      }\n\n      // Peque√±a pausa para no sobrecargar el sistema\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    }\n\n    this.logger.log(\n      `üéâ FORCE bulk duration recalculation completed (WITH PROTECTION):`\n    );\n    this.logger.log(`   üìä Total videos processed: ${allVideos.length}`);\n    this.logger.log(`   ‚úÖ Updated: ${updated}`);\n    this.logger.log(`   ‚úÖ Verified (already correct): ${verified}`);\n    this.logger.log(`   üõ°Ô∏è  Protected (from overwrite): ${protectedCount}`);\n    this.logger.log(`   ‚ùå Errors: ${errors}`);\n\n    return {\n      total: allVideos.length,\n      updated,\n      errors,\n      verified,\n      protectedCount,\n      results,\n    };\n  }\n\n  /**\n   * üõ°Ô∏è Determina si una duraci√≥n debe ser actualizada bas√°ndose en criterios de confiabilidad\n   */\n  private shouldUpdateDuration(\n    currentDuration: number | null,\n    calculatedDuration: number,\n    title: string\n  ): boolean {\n    if (!currentDuration || currentDuration <= 0) return true; // Siempre actualizar si no hay duraci√≥n o es inv√°lida\n\n    // Proteger si la duraci√≥n calculada es un fallback gen√©rico\n    if (calculatedDuration === 300) {\n      // this.logger.warn(`‚ö†Ô∏è  Calculated duration is generic fallback (300s) - protecting current duration ${currentDuration}s`);\n      return false;\n    }\n\n    if (calculatedDuration === 480) {\n      // Smart fallback\n      // Permitir actualizaci√≥n si la duraci√≥n actual es un valor por defecto conocido y probablemente incorrecto\n      if ([300, 600, 900].includes(currentDuration)) {\n        // this.logger.log(`‚ö†Ô∏è  Current duration seems incorrect (${currentDuration}s), accepting new fallback (480s)`);\n        return true;\n      }\n      // this.logger.warn(`‚ö†Ô∏è  Calculated duration is fallback (480s) - protecting current duration ${currentDuration}s`);\n      return false;\n    }\n\n    const percentageDiff = Math.abs(\n      (currentDuration - calculatedDuration) / currentDuration\n    );\n    if (percentageDiff > 0.5) {\n      // Si la diferencia es mayor al 50%\n      // this.logger.warn(`‚ö†Ô∏è  Large duration difference (${(percentageDiff * 100).toFixed(1)}%) - protecting current duration`);\n      return false;\n    }\n\n    return true; // En otros casos, actualizar\n  }\n\n  /**\n   * Encuentra todas las preguntas asociadas a un video espec√≠fico\n   * Incluye las opciones de respuesta para cada pregunta\n   * @param videoId Puede ser el ID num√©rico del sistema o el externalId (YouTube ID)\n   */\n  async findQuestionsByVideoId(videoId: string) {\n    this.logger.log(`Finding questions for video ID: ${videoId}`);\n    const videoNumericId = parseInt(videoId, 10);\n    if (isNaN(videoNumericId)) {\n      throw new NotFoundException(`Invalid video ID format: ${videoId}`);\n    }\n\n    const videoItem = await this.prisma.videoItem.findUnique({\n      where: { id: videoNumericId },\n      include: {\n        questions: {\n          include: {\n            answerOptions: true,\n          },\n          orderBy: {\n            timestamp: 'asc',\n          },\n        },\n      },\n    });\n\n    if (!videoItem) {\n      this.logger.warn(`Video item with ID ${videoNumericId} not found.`);\n      throw new NotFoundException(\n        `Video item with ID ${videoNumericId} not found`\n      );\n    }\n\n    this.logger.log(\n      `Found ${videoItem.questions.length} questions for video ID: ${videoNumericId}`\n    );\n    return videoItem.questions;\n  }\n}\n","usedDeprecatedRules":[]}]