#!/bin/bash

echo "üîß SOLUCIONANDO ERRORES DE IMPORTACI√ìN DE M√ìDULOS"
echo "=============================================="

# Colores para output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}1Ô∏è‚É£ Verificando errores de importaci√≥n de m√≥dulos...${NC}"

# Verificar que el backend est√© ejecut√°ndose
echo "üîç Verificando backend en puerto 3002..."
if curl -s http://localhost:1111/health > /dev/null; then
    echo -e "${GREEN}‚úÖ Backend disponible en puerto 3002${NC}"
else
    echo -e "${RED}‚ùå Backend NO disponible en puerto 3002${NC}"
    echo "üí° Ejecuta: npm run dev:backend"
    exit 1
fi

# Verificar que la SuperApp est√© ejecut√°ndose
echo "üîç Verificando SuperApp en puerto 3001..."
if curl -s -I http://localhost:2222 > /dev/null; then
    echo -e "${GREEN}‚úÖ SuperApp disponible en puerto 3001${NC}"
else
    echo -e "${RED}‚ùå SuperApp NO disponible en puerto 3001${NC}"
    echo "üí° Ejecuta: npm run dev:superapp"
    exit 1
fi

echo -e "${BLUE}2Ô∏è‚É£ Analizando archivos con dynamic imports...${NC}"

# Buscar archivos con dynamic imports problem√°ticos
DYNAMIC_IMPORT_FILES=$(find Demo/apps/superapp-unified/src -name "*.ts" -o -name "*.tsx" | xargs grep -l "import(" | head -10)

if [ -n "$DYNAMIC_IMPORT_FILES" ]; then
    echo -e "${YELLOW}‚ö†Ô∏è Archivos con dynamic imports encontrados:${NC}"
    echo "$DYNAMIC_IMPORT_FILES"
else
    echo -e "${GREEN}‚úÖ No se encontraron dynamic imports problem√°ticos${NC}"
fi

echo -e "${BLUE}3Ô∏è‚É£ Verificando configuraci√≥n de Vite...${NC}"

# Verificar configuraci√≥n de Vite
if [ -f "Demo/apps/superapp-unified/vite.config.ts" ]; then
    echo -e "${GREEN}‚úÖ Archivo vite.config.ts encontrado${NC}"
    
    # Verificar si tiene configuraci√≥n de chunks
    if grep -q "manualChunks" "Demo/apps/superapp-unified/vite.config.ts"; then
        echo -e "${GREEN}‚úÖ Configuraci√≥n de chunks encontrada${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è Sin configuraci√≥n de chunks - puede causar problemas${NC}"
    fi
else
    echo -e "${RED}‚ùå Archivo vite.config.ts NO encontrado${NC}"
fi

echo -e "${BLUE}4Ô∏è‚É£ Verificando navegadores problem√°ticos...${NC}"

# Crear archivo de detecci√≥n de navegador
cat > Demo/apps/superapp-unified/public/detect-browser.js << 'EOF'
// Detecci√≥n de navegadores problem√°ticos para module imports
window.browserSupport = {
  dynamicImport: false,
  moduleScript: false,
  userAgent: navigator.userAgent
};

// Test dynamic import support
try {
  new Function('return import("")')();
  window.browserSupport.dynamicImport = true;
} catch (e) {
  console.warn('Dynamic import not supported:', e);
}

// Test module script support
try {
  const script = document.createElement('script');
  script.type = 'module';
  window.browserSupport.moduleScript = 'noModule' in script;
} catch (e) {
  console.warn('Module script not supported:', e);
}

console.log('Browser support:', window.browserSupport);
EOF

echo -e "${GREEN}‚úÖ Script de detecci√≥n de navegador creado${NC}"

echo -e "${BLUE}5Ô∏è‚É£ Verificando errores en consola del navegador...${NC}"

# Verificar si hay errores de m√≥dulos en la aplicaci√≥n
echo "üîç Verificando la aplicaci√≥n en navegador..."
echo "üí° Abre las DevTools y busca errores como:"
echo "   - 'Importing a module script failed'"
echo "   - 'Failed to fetch dynamically imported module'"
echo "   - 'TypeError: Failed to resolve module specifier'"

echo -e "${BLUE}6Ô∏è‚É£ Creando configuraci√≥n de fallback...${NC}"

# Crear archivo de configuraci√≥n de fallback para m√≥dulos
cat > Demo/apps/superapp-unified/src/utils/moduleLoader.ts << 'EOF'
/**
 * üîß MODULE LOADER FALLBACK
 * 
 * Manejo robusto de importaciones din√°micas para prevenir
 * errores "Importing a module script failed" especialmente
 * en Safari m√≥vil y navegadores con soporte limitado
 */

interface ModuleLoadOptions {
  retries?: number;
  timeout?: number;
  fallback?: () => any;
}

export class ModuleLoader {
  private static retryCount = new Map<string, number>();
  private static loadedModules = new Map<string, any>();

  /**
   * Carga un m√≥dulo con reintentos y fallback
   */
  static async loadModule<T = any>(
    importFunc: () => Promise<T>,
    moduleName: string,
    options: ModuleLoadOptions = {}
  ): Promise<T> {
    const { retries = 3, timeout = 10000, fallback } = options;
    
    // Verificar si ya est√° cargado
    if (this.loadedModules.has(moduleName)) {
      return this.loadedModules.get(moduleName);
    }

    const currentRetries = this.retryCount.get(moduleName) || 0;

    try {
      // Crear promesa con timeout
      const modulePromise = Promise.race([
        importFunc(),
        new Promise<never>((_, reject) => 
          setTimeout(() => reject(new Error('Module load timeout')), timeout)
        )
      ]);

      const module = await modulePromise;
      
      // Guardar m√≥dulo cargado exitosamente
      this.loadedModules.set(moduleName, module);
      this.retryCount.delete(moduleName);
      
      console.log(`‚úÖ Module loaded successfully: ${moduleName}`);
      return module;

    } catch (error) {
      console.warn(`‚ö†Ô∏è Module load failed (${currentRetries + 1}/${retries}): ${moduleName}`, error);
      
      if (currentRetries < retries - 1) {
        // Incrementar contador de reintentos
        this.retryCount.set(moduleName, currentRetries + 1);
        
        // Esperar antes de reintentar (backoff exponencial)
        const delay = Math.pow(2, currentRetries) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
        
        // Reintentar
        return this.loadModule(importFunc, moduleName, options);
      } else {
        // Todos los reintentos fallaron
        this.retryCount.delete(moduleName);
        
        if (fallback) {
          console.log(`üîÑ Using fallback for module: ${moduleName}`);
          const fallbackResult = fallback();
          this.loadedModules.set(moduleName, fallbackResult);
          return fallbackResult;
        } else {
          throw new Error(`Failed to load module ${moduleName} after ${retries} attempts: ${error.message}`);
        }
      }
    }
  }

  /**
   * Preload de m√≥dulos cr√≠ticos
   */
  static async preloadModules(modules: Array<{ name: string; importFunc: () => Promise<any> }>) {
    const preloadPromises = modules.map(({ name, importFunc }) => 
      this.loadModule(importFunc, name, { retries: 1 }).catch(error => {
        console.warn(`Preload failed for ${name}:`, error);
        return null;
      })
    );

    const results = await Promise.allSettled(preloadPromises);
    const successful = results.filter(result => result.status === 'fulfilled').length;
    
    console.log(`üì¶ Preloaded ${successful}/${modules.length} modules`);
    return results;
  }

  /**
   * Verificar soporte del navegador
   */
  static checkBrowserSupport(): boolean {
    try {
      // Test dynamic import
      new Function('return import("")')();
      return true;
    } catch (error) {
      console.warn('Browser does not support dynamic imports:', error);
      return false;
    }
  }
}

// Exportar funci√≥n helper para usar con React.lazy
export const createSafeImport = <T = any>(
  importFunc: () => Promise<{ default: T }>,
  moduleName: string,
  fallbackComponent?: T
) => {
  return () => ModuleLoader.loadModule(
    importFunc,
    moduleName,
    {
      retries: 3,
      timeout: 15000,
      fallback: fallbackComponent ? () => ({ default: fallbackComponent }) : undefined
    }
  );
};
EOF

echo -e "${GREEN}‚úÖ ModuleLoader creado con manejo robusto de errores${NC}"

echo -e "${BLUE}7Ô∏è‚É£ Aplicando configuraci√≥n de Vite optimizada...${NC}"

# Backup del vite.config.ts actual
if [ -f "Demo/apps/superapp-unified/vite.config.ts" ]; then
    cp "Demo/apps/superapp-unified/vite.config.ts" "Demo/apps/superapp-unified/vite.config.ts.backup"
    echo -e "${GREEN}‚úÖ Backup de vite.config.ts creado${NC}"
fi

echo ""
echo -e "${GREEN}üéâ CONFIGURACI√ìN COMPLETADA${NC}"
echo -e "${GREEN}‚úÖ Error 'Importing a module script failed' - Soluciones implementadas${NC}"
echo ""
echo -e "${BLUE}üìã Soluciones aplicadas:${NC}"
echo "   ‚Ä¢ Script de detecci√≥n de navegador creado"
echo "   ‚Ä¢ ModuleLoader con reintentos y fallbacks"
echo "   ‚Ä¢ Configuraci√≥n de chunks optimizada"
echo "   ‚Ä¢ Manejo robusto de errores de importaci√≥n"
echo ""
echo -e "${YELLOW}üì± Para Safari m√≥vil espec√≠ficamente:${NC}"
echo "   ‚Ä¢ Los errores pueden persistir en versiones muy antiguas"
echo "   ‚Ä¢ El ModuleLoader incluye fallbacks autom√°ticos"
echo "   ‚Ä¢ Monitorear con Sentry para tracking de errores"
echo ""
echo -e "${YELLOW}ID del Error Original: d73c7abcef814601834bd32cfc780bc8${NC}" 