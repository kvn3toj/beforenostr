// üîß Utility Tool Template - Coom√únity Pattern
// üéØ INTENT: {{TOOL_INTENT}}
// üåü VALUES: {{TOOL_VALUES}}
// ‚ö° CONSTRAINTS: {{TOOL_CONSTRAINTS}}

import * as fs from 'fs/promises';
import * as path from 'path';

export interface UtilityConfig {
  projectRoot: string;
  verbose: boolean;
  dryRun: boolean;
}

export interface PhilosophyCheck {
  hasIntent: boolean;
  hasValues: boolean;
  hasConstraints: boolean;
  alignmentScore: number;
}

export class {{TOOL_CLASS_NAME}} {
  private config: UtilityConfig;

  constructor(config: UtilityConfig) {
    this.config = config;
  }

  /**
   * Execute the tool's main functionality
   */
  public async execute(...args: any[]): Promise<any> {
    if (this.config.verbose) {
      console.log(`üõ†Ô∏è Executing {{TOOL_NAME}} with args:`, args);
    }

    if (this.config.dryRun) {
      console.log('üîÑ Dry run mode - no changes will be made');
      return this.simulateExecution(args);
    }

    return this.performExecution(args);
  }

  /**
   * Check philosophy alignment of files/code
   */
  public async checkPhilosophyAlignment(filePath: string): Promise<PhilosophyCheck> {
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      
      const hasIntent = /üéØ\s*INTENT:/i.test(content);
      const hasValues = /üåü\s*VALUES:/i.test(content);
      const hasConstraints = /‚ö°\s*CONSTRAINTS:/i.test(content);
      
      const score = [hasIntent, hasValues, hasConstraints].filter(Boolean).length / 3;
      
      return {
        hasIntent,
        hasValues,
        hasConstraints,
        alignmentScore: score
      };
    } catch (error) {
      throw new Error(`Failed to check philosophy alignment: ${error.message}`);
    }
  }

  /**
   * Generate documentation for the tool
   */
  public async generateDocs(): Promise<string> {
    const docTemplate = `# {{TOOL_NAME}} Documentation

## üéØ Intent
{{TOOL_INTENT}}

## üåü Values
{{TOOL_VALUES}}

## ‚ö° Constraints
{{TOOL_CONSTRAINTS}}

## Usage

\`\`\`typescript
import { {{TOOL_CLASS_NAME}} } from './{{TOOL_NAME}}';

const tool = new {{TOOL_CLASS_NAME}}({
  projectRoot: process.cwd(),
  verbose: true,
  dryRun: false
});

await tool.execute();
\`\`\`

## Philosophy Alignment

This tool follows the Coom√únity Intent + Values + Constraints pattern:

- **Transparencia**: Clear documentation and verbose logging
- **Bien Com√∫n**: Shared utility for team benefit
- **Reciprocidad**: Contributes to collective development efficiency
- **Metan√∂ia**: Transforms development workflow

Generated by Tool Maker System
`;

    return docTemplate;
  }

  private async simulateExecution(args: any[]): Promise<any> {
    // Simulate the execution without making changes
    return {
      simulation: true,
      args,
      estimatedChanges: 'Mock changes that would be made'
    };
  }

  private async performExecution(args: any[]): Promise<any> {
    // Implement actual execution logic
    return {
      success: true,
      args,
      changes: 'Actual changes made'
    };
  }
}

// Export factory function
export const create{{TOOL_CLASS_NAME}} = (config: Partial<UtilityConfig> = {}) => {
  const defaultConfig: UtilityConfig = {
    projectRoot: process.cwd(),
    verbose: false,
    dryRun: false,
    ...config
  };
  
  return new {{TOOL_CLASS_NAME}}(defaultConfig);
};
